declare module "@typescene/core/App/Activity/Activation" {
import { Component, Page } from "@typescene/core/UI";
import { Activity } from "@typescene/core/App/Activity/Activity";
/** Encapsulates a command to start an activity; should be extended into unique classes that `Activity` classes can be mapped to using `mapActivation`, and which can be mapped to routes using `mapRoute`; the latter will enable saving parts of a path (URL) to properties on the activation object */
export abstract class Activation {
    /** Returns a new activation object for the given route path (must start with `/` or `#/`), or undefined if none of the currently mapped routes match */
    static route(path: string): Activation | undefined;
    /** Create a new activation object, which can be used (with a derived class) to start an activity based on the Activation class type, and stored property values; copies all properties from the given object, if any */
    constructor(properties?: object);
    /** Returns a promise for an activity instance, or for undefined if no `Activity` class is mapped to this activation type; this method is injected by `mapActivation`, but can also be overridden directly to customize the behavior of creating activities for activation objects (e.g. testing for valid IDs, or lazy loading) */
    getActivityAsync(): PromiseLike<Activity | undefined>;
    /** Returns the full path that will route to this activation object (or the path that this object was actually created for, using `mapRoute`), or undefined if no route has been mapped to this activation class or if one of the route parameters is missing */
    getPath(): string | undefined;
    /** Activation object property */
    [p: string]: any;
}
/** *Class decorator*, maps the decorated `Activation` (sub) class OR `Activity` class OR `Component` (ui module) class to the given route (e.g `dashboard`, `/users/:userID/post/:postID` or `#/docs/*docName`); if a name is provided, it can be used at the start of sub routes, using `&name/sub/route` (without leading hash/slash chars); multiple routes can be added per class; if the decorated class is an `Activity` class, a unique `Activation` sub class is generated automatically, and if the decorated class is a UI `Component` or `Page` class, a unique `Activity` class is also generated [decorator] */
export function mapRoute(route: string, name?: string): (target: typeof Activity | typeof Activation | (new (activity: Activity) => Component | Page)) => void;
/** *Class decorator*, maps the decorated `Activity` class to given `Activation` type, so that routed (path/URL) and manual activations (using an activation object) lead to the instantiation of the decorated `Activity` [decorator] */
export function mapActivation(activationType: typeof Activation): (target: typeof Activity & {
    getInstance(activation: Activation): Activity;
}) => void;

}

declare module "@typescene/core/App/Activity/Activity" {
import Async, { Signal } from "@typescene/core/Async";
import { Activation } from "@typescene/core/App/Activity/Activation";
import { ActivityTransition } from "@typescene/core/App/Activity/ActivityStack";
/** Activity base class, represents a UI activity; to be extended by application code, and registered using an activation decorator (i.e. `mapActivation` or `mapRoute`); can be linked to a view class to be displayed by decorating the view (`UI.Component` or `UI.Page` class using `mapViewActivity`) */
export class Activity extends Async.ObservableObject {
    /** Get an instance of this activity class, can be overridden to alter behavior when e.g. pushing a parent activity by class; by default simply constructs the instance without parameters */
    static getInstance(activation?: Activation | object): Activity;
    /** Create an activity instance, using given activation object if any; if the activation object is the result of a route mapping, it contains all routing parameters as string properties; otherwise the activation object may contain any type of data that can be used to initialize the new activity, and replace it with a new instance (following `Application.reactivate`) */
    constructor(activation?: Activation | object);
    /** Method that is called asynchronously after this activity is created; override this method to perform any initialization that must be completed before the activity is started; if this method returns a promise, it must be fulfilled _before_ the activity can be pushed to the foreground */
    protected onCreateAsync(): PromiseLike<any> | undefined | void;
    /** Globally unique activity identifier */
    readonly uid: string;
    /** Activation object that was supplied to the constructor when this activity was instantiated (or an activation object that contains all properties of the object that was supplied, if any) */
    readonly activation: Activation;
    /** Display title of this activity (observable) */
    title: string | undefined;
    /** Object that contains options for this activity (observable, never null or undefined) */
    options: Activity.ActivityOptions;
    /** Signal that is emitted before this activity is pushed to foreground, if any handler throws an error then the activity is not activated */
    readonly Starting: Signal.Emittable<ActivityTransition>;
    /** Signal that is emitted after this activity is pushed to foreground (note that `.Resumed` will also always be emitted) */
    readonly Started: Signal.Emittable<ActivityTransition>;
    /** Signal that is emitted before another activity is pushed to foreground, if any handler throws an error then the activity is not suspended */
    readonly Suspending: Signal.Emittable<ActivityTransition>;
    /** Signal that is emitted after this activity is no longer in foreground */
    readonly Suspended: Signal.Emittable<ActivityTransition>;
    /** Signal that is emitted before this activity is put back in foreground, if any handler throws an error then the previous activity is not suspended */
    readonly Resuming: Signal.Emittable<ActivityTransition>;
    /** Signal that is emitted after this activity is in foreground (emitted after `.Resuming`, or after `.Starting` together with `.Started`) */
    readonly Resumed: Signal.Emittable<ActivityTransition>;
    /** Signal that is emitted after this activity is removed from history, and will not be resumed anymore */
    readonly Deactivated: Signal.Emittable<ActivityTransition>;
}
export namespace Activity {
    /** Options for an activity that determine its behavior in the activity stack */
    interface ActivityOptions {
        /** Required parent activity, if any; the activity stack will ensure that the required activity (or an instance of given class) exists in its history stack when activating this activity, or insert it before pushing this activity */
        parentActivity?: Activity | typeof Activity;
        /** Set to true to require this activity to be in the foreground, or move up to it, when used as a parent activity; i.e. when starting or resuming a child activity, all activities on top of the hub activity are suspended and replaced with the child activity; can be used to prevent buildup of activities on the history stack and therefore possible memory leaks */
        isHubActivity?: boolean;
        /** Set to true to allow only one copy of an activity on the stack; i.e. when attempting to push an instance that is already on the stack, the stack is transitioned _up_ to the existing instance instead; use with a singleton activity to implement e.g. an application home activity */
        isRootActivity?: boolean;
        /** Set to true to mark this activity as a background activity; i.e. it should not be started directly, and it should be skipped when navigating back in history (enforced by `Application`, not `ActivityStack` itself, to allow background activities in the foreground temporarily, and to enable skipping past a first background activity on the stack by exiting the application) */
        isBackgroundActivity?: boolean;
        /** Set to true to mark this activity as a foreground-only activity; i.e. it will be removed automatically before another activity is started (in replace mode, the new activity replaces the activity on the stack before the transient activity); can be used for e.g. modal dialogs, drawers, and messages */
        isTransient?: boolean;
    }
}
/** Represents an activity that should be created only once and re-used if required (overrides .getInstance static method); abstract class, to be overridden */
export abstract class SingletonActivity extends Activity {
    /** Get the instance of this activity class, constructs the instance without parameters once and returns this instance every time */
    static getInstance(activation?: Activation | object): any;
    /** Create a new activity; can be used only once */
    constructor(activation?: Activation | object);
    private static _instance?;
    private static _instanceIndex?;
}
/** Represents a singleton activity that may only exist in the background (i.e. it should not be started directly, and it should be skipped when navigating back in history, enforced by `Application`), created only once and re-used if required (overrides .getInstance static method); abstract class, needs to be overridden */
export abstract class SupportActivity extends SingletonActivity {
    constructor(activation?: Activation | object);
}
/** Represents a singleton activity that is both a root activity (i.e. may exist only once on the activity stack, starting/replacing the activity again transitions the stack up to the existing activity instead), and a hub activity (i.e. starting any activity that specifies this activity as its parent activity, transitions the stack up to the hub activity first, suspending all other activities that used to be in the foreground), created only once and re-used if required (overrides .getInstance static method); abstract class, to be overridden */
export abstract class RootActivity extends SingletonActivity {
    constructor(activation?: Activation | object);
}
/** *Class decorator*, associates a parent activity class with the decorated `Activity` class: whenever an activity instance of the class decorated with this decorator is started, an instance of the given parent activity class must already exist on the stack, or a (new) instance will be started in advance [decorator] */
export function mapParentActivity(parentActivityClass: typeof Activity): (target: typeof Activity) => void;

}

declare module "@typescene/core/App/Activity/ActivityStack" {
import { Signal } from "@typescene/core/Async";
import { Activity } from "@typescene/core/App/Activity/Activity";
/** Represents a stack of activated activities (like browser history) */
export class ActivityStack {
    /** Add an activity to the foreground asynchronously, does nothing if given activity was already in the foreground; returns Promise that resolves to the completed transition */
    pushAsync(activity: Activity): PromiseLike<ActivityTransition>;
    /** Replace the current activity asynchronously (throws error if none), or remove current activity if given activity was already directly below current activity in the activity stack; returns Promise that resolves to the completed transition */
    replaceAsync(activity: Activity): PromiseLike<ActivityTransition>;
    /** Remove the current foreground activity (go back) asynchronously, returns Promise that resolves to the completed transition */
    popAsync(): PromiseLike<ActivityTransition>;
    /** Remove the current foreground activity (go back) asynchronously if and only if it is the given activity, returns Promise that resolves to the completed transition, if any */
    popAsync(activity: Activity): PromiseLike<ActivityTransition | undefined>;
    /** Remove foreground activities until given activity or activity of given type is in the foreground; returns Promise that resolves to activity, or undefined if there was no matching activity on the stack */
    upAsync(activityOrClass: Activity | typeof Activity): PromiseLike<Activity | undefined>;
    /** Reload state using given history ID, if possible (i.e. not yet deactivated relevant activities in the meantime); returns a promise that resolves when the state has been reached */
    restoreHistoryStateAsync(historyID: string): PromiseLike<void>;
    /** Get an ID that represents the current state, for use with `.restoreHistoryStateAsync` */
    getHistoryState(): string;
    /** Get the activity closest to the foreground of the given type, if any (excluding foreground activity itself, and before given activity in second parameter, if any) */
    getParent<T>(ActivityClass: typeof Activity & {
        new (...args: any[]): T;
    }, before?: Activity): T | undefined;
    /** Returns true if the stack contains given activity */
    contains(activity: Activity): boolean;
    /** The current foreground activity (top of stack, if any; observable) */
    readonly top: Activity | undefined;
    /** The number of activities on the stack (observable) */
    readonly length: number;
    /** The title of the topmost activity that has a title defined (observable) */
    readonly title: string | undefined;
    /** Create an activity cursor that starts at the top of this stack, and can move back on the stack and to parent activities; if the `activity` property is undefined, the cursor has reached the end; note that any changes to the stack while the cursor is in use may yield unexpected results */
    getCursor(): ActivityStack.Cursor;
    /** Signal that is emitted when a transition occurs (after Starting/Resuming/Suspending but before Started/Resumed) */
    readonly Transition: Signal.Emittable<ActivityTransition>;
    /** Helper method to find parent activity/ies for given activity; returns an array of activities to be pushed (including activity itself) */
    private _findParents(activity, excludeTop?);
    /** Helper method to move up to existing root activity, or hub parent activity if needed */
    private _upToHubOrRoot(activity);
    /** Helper method to remove a transient activity if needed */
    private _popTransient();
    /** Helper method for sending signals and creating promise */
    private _processTransition(to, op);
    private _idx;
    private _stack;
    private _ids;
    private _transitionP;
}
export namespace ActivityStack {
    interface Cursor {
        /** The activity stack that this cursor was created on */
        readonly activityStack: ActivityStack;
        /** The current activity; if this is undefined, the cursor has moved past the end (bottom) of the stack */
        readonly activity?: Activity;
        /** Move down the stack to the previous activity; returns this */
        goBack(): this;
        /** Move down the stack to the current activity's parent activity, if any; if there is no parent activity, the cursor will move past the end and stop; returns this */
        goParent(): this;
        /** Copy this cursor to another instance that can move independently */
        clone(): Cursor;
    }
}
/** Represents a transition from one foreground activity to another */
export interface ActivityTransition {
    /** Unique ID for this transition */
    id: string;
    /** The activity stack that is transitioning */
    activityStack: ActivityStack;
    /** The activity that is currently in the foreground, if any */
    from: Activity;
    /** The new foreground activity, if any */
    to: Activity;
    /** The stack operation being performed: push, replace, or pop */
    op: ActivityTransition.Operation;
    /** The previous transition that is part of the same operation (pop/push/pop/up) */
    previous: ActivityTransition;
}
export namespace ActivityTransition {
    /** Operation type that triggered a transition */
    enum Operation {
        /** Push operation */
        Push = 0,
        /** Replace operation */
        Replace = 1,
        /** Pop operation */
        Pop = 2,
    }
}

}

declare module "@typescene/core/App/Activity" {
export * from "@typescene/core/App/Activity/Activation";
export * from "@typescene/core/App/Activity/Activity";
export * from "@typescene/core/App/Activity/ActivityStack";

}

declare module "@typescene/core/App/Application" {
import Async, { Signal } from "@typescene/core/Async";
import { Activation, Activity, ActivityTransition, ActivityStack } from "@typescene/core/App/Activity";
import { CultureService } from "@typescene/core/App/Culture";
/** Encapsulates the application as a singleton object */
export class Application extends Async.ObservableObject {
    /** The current (and only) Application instance, when created */
    static current: Application;
    /** Promise that resolves to the application instance after it has been created */
    static ready: PromiseLike<Application>;
    private static _resolve_ready;
    /** Create the application instance (either from a derived class or from the Application class itself); can be called only once */
    constructor(title?: string);
    /** The application name to be displayed in the title bar (observed), overridden by the title of the current activity/ies, if any */
    title: string;
    /** The currently active i18n culture service (`CultureService` instance), referred to by ID `culture`; to activate another culture, use `addServiceAlias` to alias another culture to the `culture` identifier; changes will be reflected in this property asynchronously, and will also be reflected in the UI flow direction (`ltr` or `rtl`) and translations using `UI.tl` */
    readonly culture: CultureService;
    /** Signal that is emitted when no activity is found for a location */
    readonly PageNotFound: Signal.Emittable<string>;
    /** Signal that is emitted when all activities have been dropped and none have been started */
    readonly NoActivity: Signal.VoidEmittable;
    /** Activity stack instance */
    activities: ActivityStack;
    /** Returns the activity that is currently in the foreground (observable) */
    getTopActivity(): Activity | undefined;
    /** Start given activity as foreground activity (push/replace, same as calling `.activities.push/replace(...)` directly), or start activity using given resource path or string (`#/...` or `/...`, or relative path as `#./...`, `#../...`, `./...` or `../...`); if `navigateIfNotFound` is not false, then the browser/app will navigate to the new location if no matching activity is found (automatic for external URLs), otherwise invokes onPageNotFound handler; note that activities transition asynchronously and any updates will not be reflected until a few milliseconds after calling this method */
    startActivityAsync(activatable: Activity | typeof Activity | Activation | string, replace?: boolean, navigateIfNotFound?: boolean): PromiseLike<ActivityTransition | undefined>;
    /** Go back in activity history; either to previous activity or to activity of given class; returns promise that resolves to the new foreground activity, or undefined if activity was not found; the NoActivity signal is emitted if all activities have been dropped and there is no current activity anymore */
    dropActivityAsync(ActivityClass?: typeof Activity): PromiseLike<Activity | undefined>;
    /** Returns true if the given path matches or is a prefix of the currently active path (e.g. `#/items` is considered active if the current path is `#/items/123` or `#/items`) */
    isActive(path: string): boolean;
    /** Returns true if the current activity or one of its parent activities is an instance of the given activity class */
    isActive(activityClass: typeof Activity): boolean;
    /** Returns true if the given activity matches the current activity or one of its parent activities */
    isActive(activity: Activity): boolean;
    /** Remove the activity that is currently in the foreground, and reinstantiate a new activity using the `Activation` object that was used to instantiate the current activity; this also re-displays the view, if any; also increments the `.activationIndex` property; returns a promise that is fulfilled after the activity has been started */
    reactivate(): PromiseLike<ActivityTransition | undefined>;
    /** Counter that is incremented every time `.reactivate` is called */
    readonly activationIndex: number | undefined;
    /** Returns a normalized version of given path/URL, i.e. either `/...` or `#/...`, or undefined if given path/URL cannot be normalized; relative paths are also supported (e.g. `../foo` or `#../foo`) */
    protected normalizePath(path?: string): string | undefined;
    /** Returns the (browser/app) platform's current URI as a string, if available */
    protected getCurrentUrl(): string;
    /** Directs the (browser/app) platform to given URL, e.g. a full URL to navigate away from the current application */
    protected navigateToUrl(url: string): void;
    /** Activation counter */
    private _activationIndex?;
}
/** Alias for `Application#startActivityAsync` on the current `Application` instance; if there is no current instance, this function waits for an Application instance to be created first */
export function startActivityAsync(activityOrPath: Activity | typeof Activity | Activation | string, replace?: boolean, navigateIfNotFound?: boolean): PromiseLike<ActivityTransition | undefined>;
/** Get the activity closest to the foreground of given type, if any */
export function findActivity<T>(ActivityClass: typeof Activity & {
    new (...args: any[]): T;
}): T | undefined;

}

declare module "@typescene/core/App/Culture/CultureService" {
import { Service } from "@typescene/core/App/Service";
/** Base culture service (mapped on `culture-neutral` and `culture` initially); to be overridden with a language and region specific culture service, mapped as `culture-xx-YY/zz`, and aliased as `culture` using `addServiceAlias` to set as the current culture */
export class CultureService extends Service {
    /** The name of this culture, defaults to "none" but should be set to _languagecode-countrycode/regioncode_ and/or shorter forms such as _languagecode-countrycode_ and _languagecode_ */
    readonly name: string;
    /** Text flow direction for this culture's language, either `ltr` or `rtl`, or undefined (platform default) */
    readonly textFlowDirection?: "ltr" | "rtl";
    /** Translate given text (may include placeholders and prefixes used by `UI.tl`) */
    translateText(text: string): string;
    /** Pluralize text based on given number and substitution form(s); defaults to English singular/plural rules without automatic pluralization (i.e. both singular and plural forms need to be specified in the placeholder) */
    pluralizeText(n: number, forms: string[]): string;
    /** Returns given number formatted using culture specific rules, and using given precision (i.e. fixed number of decimals to display e.g. `2.00`, and/or rounding at given number of decimals, default 8, to avoid binary-to-decimal rounding errors such as `1.99999999`...); default implementation uses decimal point (`.`) and no thousands separators, but may revert to scientific notation for numbers with more than 20 digits (platform default) */
    formatNumber(n: number | string, fixedDecimals?: number, roundDecimals?: number): string;
    /** Returns given number formatted as a currency, with given currency symbol and fixed number of decimals; defaults to "$", non-breaking space, and number with 2 fixed decimals; specific culture implementations should override defaults but still accept the same arguments */
    formatCurrency(n: number | string, currencySymbol?: string, fixedDecimals?: number): string;
    /** Returns given number formatted as a percentage, with given percentage symbol and fixed number of decimals; defaults to number without fixed decimals and "%" character; specific culture implementations should override defaults but still accept the same arguments */
    formatPercentage(n: number | string, percSymbol?: string, fixedDecimals?: number): string;
    /** Collection of date/time formatters specific to this culture, used by `.formatDateTime`; defaults to a mostly international English format; replacement algorithm requires inclusion of all lengths of possible placeholders (including e.g. `yyy` and `%`) */
    protected readonly dateTimeFormatters: CultureService.DateTimeFormatters;
    /** Returns given date/time formatted using given format string (e.g. `dd/MMM/yyyy HH:mm`) using the following default placeholders, which may be (re-) defined by the culture service (defaults to `%dd %t`):
     * * `%d`: short date, e.g. 20/1/17,
     * * `%dd`: medium date, e.g. 20 Jan 2017
     * * `%ddd`: long date, e.g. 20 January 2017
     * * `%dddd`: full date, e.g. Friday, 20 January 2017
     * * `%t`: time, e.g. 2:20 PM
     * * `%tt`: time with seconds, e.g. 2:20:00 PM
     * * `%T`: 24-hour time, e.g. 14:20
     * * `%TT`: 24-hour time with seconds, e.g. 14:20:00
     * * `d`: date 0-31,
     * * `dd`: date 00-31,
     * * `ddd`: abbreviated weekday name,
     * * `dddd`: full weekday name,
     * * `h`: hours 0-12,
     * * `hh`: hours 00-12,
     * * `H`: hours 0-23,
     * * `HH`: hours 00-23,
     * * `m`: minutes 0-59,
     * * `mm`: minutes 00-59,
     * * `M`: month 0-12,
     * * `MM`: month 00-12,
     * * `MMM`: abbreviated month name,
     * * `MMMM`: full month name,
     * * `s`: seconds 0-59,
     * * `ss`: seconds 00-59,
     * * `t`: a/p,
     * * `tt`: AM/PM,
     * * `y`: year 0-99,
     * * `yy`: year 00-99,
     * * `yyyy`: year 0000-9999,
     * * `/`: date separator,
     * * `:`: time separator
     */
    formatDateTime(d: Date, format?: string): string;
}
export namespace CultureService {
    /** Collection of date/time formatter function, indexed by placeholder name (e.g. `M`, `MM`, `MMM`), which return the relevant string representation of a given date argument */
    interface DateTimeFormatters {
        /** Returns the relevant string representation of given date */
        [s: string]: (this: DateTimeFormatters, d: Date, s: CultureService) => string;
    }
}

}

declare module "@typescene/core/App/Culture/Observer" {
import { Signal } from "@typescene/core/Async";
import { CultureService } from "@typescene/core/App/Culture/CultureService";
/** Signal that is emitted when the global i18n culture changes (through `CultureService`) */
export const CultureChanged: Signal.Emittable<CultureService>;

}

declare module "@typescene/core/App/Culture" {
export * from "@typescene/core/App/Culture/CultureService";
export * from "@typescene/core/App/Culture/Observer";

}

declare module "@typescene/core/App/Service/Service" {
import Async from "@typescene/core/Async";
/** Service base class, to be extended to represent a service of which a singleton instance can be injected as a property of any other class (e.g. a view or activity class, or another service); service classes must be registered by ID, using the `mapService` decorator */
export class Service extends Async.ObservableObject {
    /** Get the singleton instance of this service class, can be overridden; by default returns a single instance, constructed without parameters only when needed, and never dereferenced */
    static getInstance(): any;
    /** Singleton constructor; do not use directly, use `getInstance` instead */
    constructor();
}
/** *Class decorator*, registers the decorated `Service` class using given UpperCamelCase ID(s), so that injected properties (see `injectService`) decorated with a matching service ID automatically contain a reference to a singleton instance of the decorated `Service` [decorator] */
export function mapService(...id: string[]): (target: typeof Service) => void;
/** Add an alias for the given service by ID, so that the aliased service *also* becomes available using the given alias; the aliased service does not need to have been mapped yet */
export function addServiceAlias(newId: string, serviceId: string): void;
/** *Property decorator*, injects an instance of the `Service` class that is registered with the same ID as the name of the decorated propety (lowerCamelCase is converted to UpperCamelCase) into this property as and when it becomes available [decorator] */
export function injectService(target: object, propertyKey: string): void;
/** *Property decorator*, injects an instance of the `Service` class that is registered with given ID (must be UpperCamelCase) into this property as and when it becomes available [decorator] */
export function injectService(id: string): PropertyDecorator;

}

declare module "@typescene/core/App/Service" {
export * from "@typescene/core/App/Service/Service";

}

declare module "@typescene/core/App/View/Layout/App" {
import { Component, Container, DrawerContainer, ComponentFactory } from "@typescene/core/UI";
import { VerticalLayout, ScrollableLayout } from "@typescene/core/App/View/Layout/Single";
declare const AppBarLayout_base: typeof Container & ComponentFactory<Container>;
/** Represents the top header row of an application page, contains only one Row instance; all content passed into the initializer is automatically added to this row, not the container itself */
export class AppBarLayout extends AppBarLayout_base {
    appendChild(child: Component): this;
}
/** Represents a full-page application layout that contains a header app bar fragment and a footer container fragment */
export class AppViewLayout extends VerticalLayout {
    /** Layout fragment for the application bar at the top of the screen, contains only one Row instance; all content passed into the initializer is automatically added to this row, not the container itself */
    static Header: typeof AppBarLayout;
    /** Layout fragment for the application container's fixed footer */
    static Footer: typeof VerticalLayout.Footer;
}
/** Represents a full-page application layout that contains a header app bar fragment and a footer container fragment, as well as a scrollable navigation sidebar; the sidebar is automatically collapsed while `.sidebarCollapsed` is set (defaults to true on small screens, observable) but is also wrapped in a drawer container in the `.drawer` property, which can be opened using its `openAsync()` method (e.g. from a click handler on a button available in the `.AppBar` fragment) */
export class HubViewLayout extends AppViewLayout {
    /** Layout fragment for the application bar at the top of the screen, contains only one Row instance; all content passed into the initializer is automatically added to this row, not the container itself */
    static Header: typeof AppViewLayout.Header;
    /** Layout fragment for the application container's fixed footer */
    static Footer: typeof AppViewLayout.Footer;
    /** Layout fragment for sidebar content */
    static Sidebar: typeof ScrollableLayout;
    /** Create a view instance and initialize the sidebar/drawer combination */
    constructor();
    /** True if the sidebar should be hidden, normally only on small screens but can be overridden by defining a getter for this property (observed, readonly) */
    readonly sidebarCollapsed: boolean;
    /** Drawer compononent containing only the sidebar, for small viewports */
    readonly drawer: DrawerContainer;
    private readonly _drawerIsOpen;
}

}

declare module "@typescene/core/App/View/Layout/Base" {
import Async from "@typescene/core/Async";
import { Component, LayoutContainer, DialogContainer } from "@typescene/core/UI";
/** Represents a container layout, can be extended to define container-based layouts and their associated layout fragments (using `layoutFragment` on static properties) */
export class BaseLayout extends LayoutContainer {
    /** Dummy property for duck typing of layout classes */
    static readonly isLayoutClass: true;
    /** Create a new instance of this layout view */
    constructor();
    /** Observable object that contains all fragments that have been added using `.appendChild(...)` or through a component factory (i.e. static `.with(...)` method), indexed by ID */
    readonly fragments: {
        [name: string]: Component | undefined;
    } & Async.ObservableObject;
    /** Add a child component to this component, or store a view fragment in the `.fragments` object; returns this */
    appendChild(child?: Component): this;
    /** Set given observable property of this component to given named fragment (observed property of `.fragments` object), with optional transformation function (run inside the observable context, for e.g. conditional assignment) */
    bindFragment(propertyName: keyof this, fragmentName: string, transform?: (fragment: Component | undefined) => Component | undefined): void;
}
/** Represents a dialog layout, can be extended to define dialog container-based layouts and their associated layout fragments (using `layoutFragment` on static properties) */
export class BaseDialogLayout extends DialogContainer {
    /** Dummy property for duck typing of layout classes */
    static readonly isLayoutClass: true;
    /** Create a new instance of this layout view */
    constructor();
    /** Observable object that contains all fragments that have been added using `.appendChild(...)` or through a component factory (i.e. static `.with(...)` method), indexed by ID */
    readonly fragments: {
        [name: string]: Component | undefined;
    } & Async.ObservableObject;
    /** Add a child component to this component, or store a view fragment in the `.fragments` object; returns this */
    appendChild(child?: Component): this;
    /** Set given observable property of this component to given named fragment (observed property of `.fragments` object), with optional transformation function (run inside the observable context, for e.g. conditional assignment) */
    bindFragment(propertyName: keyof this, fragmentName: string, transform?: (fragment: Component | undefined) => any): void;
}

}

declare module "@typescene/core/App/View/Layout/Single" {
import { Container, ComponentFactory } from "@typescene/core/UI";
import { BaseLayout } from "@typescene/core/App/View/Layout/Base";
declare const VerticalLayout_base: typeof BaseLayout & ComponentFactory<BaseLayout>;
/** Represents a strictly vertical layout that contains a header container fragment and a footer container fragment; all other content will be added to the main content area */
export class VerticalLayout extends VerticalLayout_base {
    /** Layout fragment for the container's fixed header */
    static Header: typeof Container;
    /** Layout fragment for the container's fixed footer */
    static Footer: typeof Container;
}
declare const ScrollableLayout_base: typeof VerticalLayout & ComponentFactory<VerticalLayout>;
/** Represents a strictly vertical layout that contains a header container fragment and a footer container fragment, all other content will be added to the _scrollable_ main content container */
export class ScrollableLayout extends ScrollableLayout_base {
    /** Layout fragment for the scrollable container's fixed header */
    static Header: typeof VerticalLayout.Header;
    /** Layout fragment for the scrollable container's fixed footer */
    static Footer: typeof VerticalLayout.Footer;
}

}

declare module "@typescene/core/App/View/Layout" {
export * from "@typescene/core/App/View/Layout/Base";
export * from "@typescene/core/App/View/Layout/Single";
export * from "@typescene/core/App/View/Layout/App";

}

declare module "@typescene/core/App/View/MessageBox" {
import { BaseDialogLayout } from "@typescene/core/App/View/Layout";
import { ComponentFactory, Row, Button, TextLabelFactory } from "@typescene/core/UI";
/** Modal dialog layout view used by `showMessageBox` that contains a title row fragment and a button row fragment, and all messages as separate rows in the main content area */
export class MessageBoxLayout extends BaseDialogLayout {
    /** Layout fragment for the message box title row, used by `showMessageBox` as the header of message box dialogs that contain a title; can be used to apply global style overrides */
    static readonly TitleRow: typeof Row & ComponentFactory<Row>;
    /** Layout fragment for the message box button row, used by `showMessageBox` as a footer row on message box dialogs; can be used to apply global style overrides */
    static readonly ButtonRow: typeof Row & ComponentFactory<Row>;
    /** Message row component factory (NOT a fragment), used by `showMessageBox` to construct the _first_ message row; can be used to apply global style overrides */
    static readonly FirstMessageRow: typeof Row & ComponentFactory<Row>;
    /** Message row component factory (NOT a fragment), used by `showMessageBox` to construct the all message rows _other than the first row_; can be used to apply global style overrides */
    static readonly MessageRow: typeof Row & ComponentFactory<Row>;
    /** Label used for the default "Dismiss" button when the arguments to `showMessageBox` do not include a single button; can be changed but must be a `UI.TextLabelFactory` (i.e. result of `UI.tl`) */
    static DISMISS_LABEL: TextLabelFactory;
    /** Create a new message box (without content); use `showMessageBox` function instead, to initialize and display a message box with a title, message, and predefined buttons */
    constructor();
}
/** Show a modal message dialog box with given message(s) and a "Dismiss" button; returns a promise that is fulfilled when the dialog is closed */
export function showMessageBox(message: string | TextLabelFactory | Array<string | TextLabelFactory>): PromiseLike<number | undefined>;
/** Show a modal message dialog box with given title and message(s) and a "Dismiss" button; returns a promise that is fulfilled when the dialog is closed */
export function showMessageBox(title: string | TextLabelFactory, message: string | TextLabelFactory | Array<string | TextLabelFactory>): PromiseLike<number | undefined>;
/** Show a modal message dialog box with given message(s) and buttons (as result(s) of `Button.with(...)`); returns a promise that resolves to the index of the button that was clicked, or undefined if the dialog was dismissed otherwise (e.g. ESC key) */
export function showMessageBox(message: string | TextLabelFactory | Array<string | TextLabelFactory>, ...buttons: ComponentFactory<Button>[]): PromiseLike<number | undefined>;
/** Show a modal message dialog box with given title, message(s), and buttons (as result(s) of `Button.with(...)`); returns a promise that resolves to the index of the button that was clicked, or undefined if the dialog was dismissed otherwise (e.g. ESC key) */
export function showMessageBox(title: string | TextLabelFactory, message: string | TextLabelFactory | Array<string | TextLabelFactory>, ...buttons: ComponentFactory<Button>[]): PromiseLike<number | undefined>;

}

declare module "@typescene/core/App/View/ViewLayout" {
import { Component } from "@typescene/core/UI";
/** Base interface for layout view classes, implemented by typeof `Blank`, `BlankDialog`, and all derived classes */
export interface LayoutClass {
    /** [implementation] */
    new (...args: any[]): Component & {
        fragments: any;
    };
    /** [implementation] */
    isLayoutClass: boolean;
}
/** Returns true if given component is a layout fragment, i.e. an instantiation of a component class (or factory) that is referenced using the `layoutFragment` decorator on a layout view class */
export function isLayoutFragment(component: Component): boolean;
/** Returns true if given component can be used as a layout fragment on given layout view, i.e. the component is an instantiation of a component class (or factory) that is referenced using the `layoutFragment` decorator on given layout view class */
export function isLayoutFragment(component: Component, layout: Component): boolean;
/** *Property decorator*, defines the UI Component class (or factory) referenced by the decorated static property as a layout fragment, for use with layout views (i.e. classes defined on `Layout` namespace and derived classes), such that instances of the referenced component class are added to the `fragments` object on layout view instances [decorator] */
export function layoutFragment(target: LayoutClass, id: string): void;

}

declare module "@typescene/core/App/View/ViewMapping" {
import { Component, Page } from "@typescene/core/UI";
import { Activity } from "@typescene/core/App/Activity";
/** *Class decorator*, maps the decorated view class to an `Activity` class; the view class should be a UI `Component` or `Page` class with a constructor that has a single matching activity argument, possibly a view layout or fragment class that derives from the types in the `Layout` namespace; if the view class is a fragment, it is automatically added to the (parent) activity's matching view; re-uses view instances when possible, but views are dereferenced within given timeout when no longer in use (in ms, defaults to 2s, set to 0 to disable) [decorator] */
export function mapViewActivity<ActivityT extends Activity>(activityClass: {
    new (...args: any[]): ActivityT;
}, dereferenceTimeout?: number): (target: new (activity: ActivityT) => Component | Page) => void;

}

declare module "@typescene/core/App/View" {
export * from "@typescene/core/App/View/Layout";
export * from "@typescene/core/App/View/ViewLayout";
export * from "@typescene/core/App/View/ViewMapping";
export * from "@typescene/core/App/View/MessageBox";

}

declare module "@typescene/core/App" {
export * from "@typescene/core/App/Activity";
export * from "@typescene/core/App/View";
export * from "@typescene/core/App/Service";
export * from "@typescene/core/App/Application";
export * from "@typescene/core/App/Culture";

}

declare module "@typescene/core/App" {
export * from "@typescene/core/App/index";
import * as App from "@typescene/core/App/index";
export default App;

}

declare module "@typescene/core/Async/Defer" {
/** Execute given function only when idle, with given arguments (array or `arguments` object) if any */
export function defer(f: (...args: any[]) => void, args?: any[] | IArguments): void;
/** Run a batch of deferred functions; returns true if there are still more deferred functions in the queue, or false if there are none or if already running; set argument to true to run _all_ deferred functions that are currently in the queue (but not those that get added after the call to `runYield`) */
export function runYield(yieldAll?: boolean): boolean;

}

declare module "@typescene/core/Async/Inject" {
/** _Property decorator_, makes a property observable on every instance, with a read-only value shared across all instances taken from an (earlier OR later) call to `inject`, *until* the property is directly assigned to [requires ES5+ target] [decorator] */
export function injectable(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** Set given injectable observable properties (decorated with `injectable`) on *all* instances of given class and derived classes to the given values, except for instances where the property has been overwritten directly; may be called multiple times even with the same properties to redefine their injected value; returns an object that contains the previous injected values (for e.g. overriding an injected function that calls into the previously injected function; when injecting into a derived class, these properties use accessors to return latest overridden injected values on base class(es) dynamically) */
export function inject<SpecT extends {
    [name: string]: any;
}>(targetClass: Function, spec: SpecT): SpecT;

}

declare module "@typescene/core/Async/Observable" {
import { Promise } from "@typescene/core/Async/Promise";
import { Signal } from "@typescene/core/Async/Signal";
import { ObservableObject } from "@typescene/core/Async/ObservableObject";
import { ObservableArray } from "@typescene/core/Async/ObservableArray";
/** Represents an observable value (with the value itself in `.value`) */
export class ObservableValue<T> {
    /** Returns true if currently running in a subscribed-to observable context (i.e. evaluating an observable value, recording dependencies on other observable values being accessed from this context) */
    static isObserving(): boolean;
    /** Encapsulate given value as an ObservableValue */
    static fromValue<T>(value: T): ObservableValue<T>;
    /** Encapsulate given promised value as an ObservableValue; the observed value will start out as `undefined` but then changes to the `Promise` result when resolved; or if promise was rejected, hangs on to the error and throws it when retrieving the observable value */
    static fromPromise<T>(valuePromise: PromiseLike<T>): ObservableValue<T>;
    /** Connect to given `Signal`, and create a read-only observable value that always contains the last emitted signal value (initially undefined; the value is only set after the next time the signal is emitted) */
    static fromSignal<T>(signal: Signal.Emittable<T>): ObservableValue<T>;
    /** Create a new (single) observed value using optional getter and setter functions; note that getters *should* be pure functions without side effects, creating or setting other observables from the getter will result in an error; getter is not called immediately but only when being subscribed to or when obtaining the value itself (from `.value`) */
    constructor(getter?: () => T, setter?: (value: T) => void);
    /** Set a getter function for the observable value, which should return a current value, or another ObservableValue instance, or set `.value` directly; note that getters *should* be pure functions without side effects, creating or setting other observables from the getter will result in an error; the getter is only invoked (asynchronously) if a value had been set previously and needs to be updated; reading `.value` from the getter results in the value previously set, no recursion occurs; returns this */
    getter(f: () => T): this;
    /** Set a setter function for the observable value; setting `.value` directly from the setter results in changing the underlying observable value (which can also be read by the getter, or the setter itself), no recursion occurs; returns this */
    setter(f: (value: T) => void): this;
    /** Observable value, (re-) evaluated only if necessary; when set to an `ObservableValue` instance, this property returns that instance's value, until this property is set to another value (except if the `ObservableValue` has a setter, which is called first); plain Array values are turned into `ObservableArray` instances, and plain Object instances into `ObservableObject` instances --- unless `.shallow` is set to true */
    value: T | undefined;
    /** Returns .value (observable if used within an observable getter) */
    valueOf(): T | undefined;
    /** Returns .value as a string (observable if used within an observable getter) */
    toString(): string;
    /** Returns last value set, does not re-evaluate and/or add dependency */
    getLastValue(): T | undefined;
    /** Transform this observable value using given function, into a new ObservableValue instance; note that the transformation function is not necessarily invoked after each value change, if the new observable is not subscribed to and/or multiple changes occur (asynchronously) before the transformation is evaluated; observables used by the given function itself are not automatically subscribed to (wrap given function in observe(...) to observe dependencies as well) */
    map<U>(callback: (value: T) => U): ObservableValue<U>;
    /** Start listening for changes to this observable value and all of its dependencies asynchronously; returns this */
    subscribe(): this;
    /** Start listening for changes to this observable value and all of its dependencies asynchronously, and schedule given function for every new value (including the current value, or undefined if none has been set); returns this */
    subscribe(callback: (value: T) => any): this;
    /** Start listening for changes to this observable value and all of its dependencies asynchronously, and return a promise for the next (different) value of the observable; does _not_ force evaluation of the current value (i.e. getters are not called); stops subscribing immediately after the promise is resolved */
    next(): Promise<T>;
    /** True if this observable value is currently subscribed to, either directly or from dependent observables */
    readonly subscribed: boolean;
    /** True if this observable value is writable (not only a getter defined) */
    readonly writable: boolean;
    /** Set to true to stop this observablue value instance from converting arrays and objects to observables, and reading values from observable value instances */
    shallow?: boolean;
    /** Clear value and remove getter/setter functions, unsubscribe from dependencies */
    clear(): void;
    /** Manually invoke the getter function synchronously, if any; can be used only if not currently evaluating another observable value (otherwise, wrap in a call to `unobserved`); calling this method is normally not necessary, and should only be used if external factors outside of observables change in such a way that the result of the getter function changes; if so, then subsequent retrieval of `.value` results in the new value, and dependent observable values are scheduled to update automatically (asynchronously) */
    update(): void;
}
/** Create a (single) observable that holds the return value of the given function, re-evaluated (when subscribed to) whenever one of the observable values used in the getter function change, *or* (also when not subscribed to) when `ObservableValue#value` is read after one of the observables used in the getter function (may have) changed its value; note that getters *should* be pure functions without side effects, creating or setting other observables from the getter will result in an error */
export function observe<T>(f: () => T): ObservableValue<T>;
/** Encapsulate given promise as an observable value that is set when the promise resolves; if the promise is already resolved, the observable value is set to the promise's value immediately; if or when the promise is rejected, the error is stored and will be thrown when trying to obtain the observable value */
export function observe<T>(promise: PromiseLike<T>): ObservableValue<T>;
/** Returns a new ObservableArray with elements copied from given array; (same as `ObservableArray.fromArray`; does not observe values of a given `ObservableArray`, see `observeArray` instead) */
export function observe<T>(obj: Array<T>): ObservableArray<T>;
/** Returns a new ObservableObject with properties copied from given object; (same as new ObservableObject(...) but with a strongly typed return value) */
export function observe<T extends object>(obj: T): T & ObservableObject;
/** Invoke given function without recording dependencies on currently evaluating observable values; passes on the `this` value given to this function, returns the function's return value */
export function unobserved<T>(f: ((...args: any[]) => T), ...args: any[]): T;

}

declare module "@typescene/core/Async/ObservableArray" {
import { ObservableValue } from "@typescene/core/Async/Observable";
/** Encapsulates `Array` with observable properties; the result works exactly like a regular array, but setting elements outside the bounds of the array (>= length) does NOT work: length must be set first */
export class ObservableArray<T> {
    /** Create an `ObservableArray` out of a regular Array */
    static fromArray<T>(array: Array<T>): ObservableArray<T>;
    /** Create an `ObservableArray` that takes array elements from the array in given `ObservableValue`, or the value itself as a single element if it is not an array, or an empty array if the value is null or undefined; changes in array elements and/or observable values are reflected asynchronously; use the `lazy` argument to defer initialization of array elements until the `.length` property is accessed */
    static fromObservableValue<T>(observableValue: ObservableValue<T[] | T | undefined>, lazy?: boolean): ObservableArray<T>;
    /** Create a new empty `ObservableArray` instance */
    constructor();
    /** Create a read-only `ObservableArray` with each value of the original array mapped to the result of the given getter function; observable values used in the map function are not observed (like `ObservableValue#map`); the getter is called for combinations of value and index (i.e. deleting a value in the middle of the source array will trigger changes for all elements after it; if the index is not important then use `.mapAsyncValues` instead); the resulting array length changes along with the original array length; use the `lazy` argument to defer initialization of array elements until the `.length` property is accessed */
    mapAsync<U>(callback: (value: T, index: number, array: T[]) => (ObservableValue<U> | U), thisArg?: any, lazy?: boolean): ObservableArray<U>;
    /** Create a read-only ObservableArray with each value of the original array mapped to the result of the given function; observable values used in the map function are not observed (like ObservableValue map method); the resulting array length changes along with the original array length; this method is slightly more expensive than mapAsync for larger arrays, especially in non-ES6 environments, but is overall more efficient because it avoids unnecessary callbacks when subscribed to; use the `lazy` argument to defer initialization of array elements until the `.length` property is accessed */
    mapAsyncValues<U>(callback: (value: T) => (ObservableValue<U> | U), thisArg?: any, lazy?: boolean): ObservableArray<U>;
    /** Create a read-only observable array that contains all values from the original array and all nested (observable) arrays, optionally removing gaps (i.e. undefined or null elements); the resulting array and its length _always_ change asynchronously with the contents of the original array, even if not subscribed to a value or the length property; use the `lazy` argument to defer initialization of array elements until the `.length` property is accessed */
    flattenAsync(removeGaps?: boolean, lazy?: boolean): ObservableArray<T>;
    /** Represent observable arrays as regular JSON arrays */
    toJSON(): T[];
}
/** Type definition to declare Array methods mixin */
export interface ObservableArray<T> extends Array<T> {
}
/** Returns an ObservableArray instance based on the result of given function: if the returned value is an array, then all elements are copied to the result; if the returned value is an observable array, all elements are proxied; if the returned value is not an array, the result contains this value as a single element; if the returned value is null or undefined, the result will be an empty array; changes in values/elements are reflected asynchronously */
export function observeArray<T>(f: () => (T[] | T | undefined)): ObservableArray<T>;

}

declare module "@typescene/core/Async/ObservableObject" {
import { Signal } from "@typescene/core/Async/Signal";
import { ObservableValue } from "@typescene/core/Async/Observable";
/** Represents an object with (some) observable members; may be extended into a derived class, or use `makeObjectObservable` function to mix into any object [requires ES5+ target] */
export class ObservableObject {
    /** Create an object with (some) observable members */
    constructor();
    /** Returns true if property with given name is observable */
    hasObservableProperty(name: string | number): boolean;
    /** Add an observable property with given name and value; any existing (observable) properties with this name are removed first */
    addObservableProperty(name: string | number, value: any): void;
    /** Signal that is emitted when any property changes (but does not subscribe to any properties, i.e. only changes to properties already subscribed to, and properties with plain values [not getters] will trigger this signal) */
    readonly PropertyChange: Signal.Emittable<string>;
}
/** Returns a new `ObservableObject` with properties copied from given object; `ObservableValue` instances are referenced directly (including getter and setter), Array properties are turned into `ObservableArray` instances, and plain Object instances into `ObservableObject` instances; also seals the new instance if the object parameter was sealed, and freezes it if the object parameter was frozen*/
export function makeObjectObservable<T extends object>(obj: T): T & ObservableObject;
/** Make the property with given name observable; use given observable value instance, if any, otherwise use a new observable value instance that holds the current property value and/or uses the current property getter and setter [requires ES5+ target] */
export function makePropertyObservable(obj: object, member: string | number, instance?: ObservableValue<any>): void;
/** Delete the property with given name and clear its observable value */
export function deleteObservableProperty(obj: object, member: string | number): void;
/** Returns true if property with given name is defined and is observable */
export function isObservableProperty(obj: object, member: string | number): boolean;
/** _Method/accessor decorator_, wraps a method or getter (but not setter) in an `unobserved` call, so that any observable values read by this method (or functions invoked synchronously from within this method) are not marked as dependencies of any currently evaluating observable values [requires ES5+ target] [decorator] */
export function unobservable(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Read-only-accessor decorator_, wraps a getter (without setter) in an `unobserved` call, so that any observable values read by the accessor (or functions invoked synchronously from within the accessor) are not marked as dependencies of any currently evaluating observable values; defines a read-only property using the result of the accessor call, after the first time it was invoked for each instance [requires ES5+ target] [decorator] */
export function unobservable_memoize_get(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance [requires ES5+ target] [decorator] */
export function observable(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance and converts values to strings when read (empty string for null/undefined/NaN) [requires ES5+ target] [decorator] */
export function observable_string(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance and converts values to numbers using Number(...) when read [requires ES5+ target] [decorator] */
export function observable_number(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance, as a shallow observable value (i.e. does not read values from observable values assigned to this property; and does not convert arrays to observable arrays nor objects to observable objects) [requires ES5+ target] [decorator] */
export function observable_shallow(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that undefined/null values cannot be set (also throws TypeError) [requires ES5+ target] [decorator] */
export function observable_not_null(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that only instances of Object can be set, which are sealed automatically [requires ES5+ target] [decorator] */
export function observable_seal(target: Object, key: string, descriptor?: PropertyDescriptor): any;
/** _Property/accessor decorator_, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that only instances of Object can be set, which are frozen automatically [requires ES5+ target] [decorator] */
export function observable_freeze(target: Object, key: string, descriptor?: PropertyDescriptor): any;

}

declare module "@typescene/core/Async/Promise" {
/** Represents a value to be resolved at any time in the future */
export class Promise<T> implements PromiseLike<T> {
    /** Delay the execution of a callback but return a promise for its result */
    static delay<T>(f: (...args: any[]) => T, ms: number, args?: any[]): Promise<T>;
    /** Return a promise that will be resolved after a delay */
    static sleep<T>(ms: number, value?: T): Promise<T>;
    /** Defer the execution of a callback but return a promise for its result */
    static defer<T>(f: (...args: any[]) => T, args?: any[]): Promise<T>;
    /** Executes given callback, providing it with a Node.js-style (err, result) => {...} handler that immediately resolves or rejects the resulting promise when called; (use as e.g. `Promise.fn(f => fs.readFile('/etc/passwd', f)).then(...))` */
    static fn<T>(callback: (f: (err: any, result: T) => void) => void): Promise<T>;
    /** Return a resolved promise */
    static resolve<T>(value: T): Promise<T>;
    /** Return a rejected promise */
    static reject(error: Error): Promise<{}>;
    /** Return a promise that is fulfilled when all given promises are fulfilled and is immediately rejected when one of the promises is rejected */
    static all<ValueT>(promises: PromiseLike<ValueT>[]): Promise<ValueT[]>;
    /** Return a promise that is resolved or rejected exactly like the first of the given promises that is resolved or rejected */
    static race<T>(promises: PromiseLike<T>[]): Promise<T>;
    /** Create a new Promise instance by running the given callback function, which is given callbacks to resolve and/or reject the promise; the promise is also rejected if the callback function throws an exception */
    constructor(executor?: (resolve: (value: PromiseLike<T> | T) => void, reject: (error: Error) => void) => void);
    /** Run one of the callbacks as soon as the promise is fulfilled or rejected */
    then<O>(onFulfilled?: (value: T) => (PromiseLike<O> | O), onRejected?: (error: Error) => (PromiseLike<O> | O)): Promise<O>;
    /** Run one of the callbacks as soon as the promise is fulfilled or rejected */
    then<O>(onFulfilled?: (value: T) => (PromiseLike<O> | O), onRejected?: (error: Error) => void): Promise<O>;
    /** Catch rejections and return a new promise */
    catch<O>(onRejected?: (error: Error) => (PromiseLike<O> | O)): Promise<O>;
    /** Catch rejections and return a new promise */
    catch<O>(onRejected?: (error: Error) => void): Promise<O>;
}
/** Return a promise that will be resolved after a delay */
export function sleep<PromiseT>(ms: number, value?: PromiseT): Promise<PromiseT>;

}

declare module "@typescene/core/Async/Signal" {
import { Promise } from "@typescene/core/Async/Promise";
import { ObservableValue } from "@typescene/core/Async";
/** Encapsulates a handler connected to a signal */
export interface SignalConnection {
    /** Disconnect the connected handler from this signal */
    disconnect(): void;
    /** True if connection has been disconnected */
    disconnected: boolean;
}
/** Encapsulates a signal that can be used to trigger one or more handlers asynchronously; do _not_ construct `Signal` classes directly, use the static `.create` method to create derived classes which can be instantiated and emitted */
export abstract class Signal<T> {
    /** Create a new emittable signal class with given payload type */
    static create(): Signal.VoidEmittable;
    static create<DataT>(): Signal.Emittable<DataT>;
    /** [implementation] Create a read-only observable value that contains the last emitted value (initially undefined, only contains a value after the first time this signal is emitted) */
    static observe(): ObservableValue<any>;
    /** [implementation] Add a handler */
    static connect(callback: any, target?: object): SignalConnection;
    /** [implementation] Add a one-time handler */
    static connectOnce(callback: any, target?: object): void;
    /** [implementation] Remove all handlers */
    static disconnectAll(): typeof Signal;
    /** [implementation] Returns true if this signal has any handlers */
    static isConnected(): boolean;
    /** Static method that is called synchronously when a first handler is connected (and when a new handler is connected after all had been disconnected); override this in a signal base class, e.g. to add a delayed initialization method */
    protected static onHandlerConnected?: () => void;
    /** Static method that is called synchronously when no more handlers are connected; override this in a signal base class, e.g. to add a delayed deallocation method */
    protected static onHandlersDisconnected?: () => void;
    /** Create a signal with given payload data, ready to be emitted */
    constructor(data: T);
    /** Invoke all handlers and capture promises of their return values in .results (unless argument is true); works only once; returns this */
    emit(noResults?: boolean): this;
    /** Invoke given callback(s) with return values of all handlers, or any exception that occurred during execution of all handlers; returns a Promise that resolves to the return value of the callback(s) itself */
    then<O>(onFulfilled?: (results: any[]) => O, onRejected?: (error: Error) => O): Promise<O>;
    /** Catch errors that occur during execution of all handlers; returns a Promise that resolves to the return value of the callback itself */
    catch<O>(onRejected?: (error: Error) => O): Promise<O>;
    /** Array of Promises that resolve to return values of all handlers */
    readonly results: Promise<any>[];
    /** The payload data for this signal instance */
    readonly data: T;
}
export namespace Signal {
    /** Type definition for a callable (emittable) signal *class*; matches the result of `.create` with the same type parameter */
    interface Emittable<T> {
        /** Instantiate a signal with given value, ready to be emitted */
        new (data: T): Signal<T>;
        /** Emit a signal with given value; does not instantiate this class unless there are actually handlers connected to it */
        (data: T): void;
        /** Add a handler to be invoked when this signal is emitted; returns an encapsulation of the connection with a disconnect method */
        connect(handler: (data: T) => any): SignalConnection;
        /** Add a handler to be invoked when this signal is emitted: a method with given name on given target object (resolved only when needed); returns an encapsulation of the connection with a disconnect method */
        connect(method: string, target: object): SignalConnection;
        /** Add a handler to be invoked the next time this signal is emitted */
        connectOnce(handler: (data: T) => any): void;
        /** Add a handler to be invoked the next time this signal is emitted: a method with given name on given target object (resolved only when needed) */
        connectOnce(method: string, target: object): void;
        /** Remove all handlers */
        disconnectAll(): this;
        /** Returns true if this signal has any handlers connected to it */
        isConnected(): boolean;
        /** Create a read-only observable value that contains the last emitted value (initially undefined, only contains a value after the first time this signal is emitted) */
        observe(): ObservableValue<T>;
    }
    /** Type definition for a callable (emittable) signal *class*; matches the result of `.create` without a type parameter */
    interface VoidEmittable {
        /** Instantiate a signal, ready to be emitted */
        new (): Signal<void>;
        /** Emit a signal; does not instantiate this class unless there are actually handlers connected to it */
        (): void;
        /** Add a handler to be invoked when this signal is emitted; returns an encapsulation of the connection with a disconnect method */
        connect(handler: () => any): SignalConnection;
        /** Add a handler to be invoked when this signal is emitted: a method with given name on given target object (resolved only when needed); returns an encapsulation of the connection with a disconnect method */
        connect(method: string, target: object): SignalConnection;
        /** Add a handler to be invoked the next time this signal is emitted */
        connectOnce(handler: () => any): void;
        /** Add a handler to be invoked the next time this signal is emitted: a method with given name on given target object (resolved only when needed) */
        connectOnce(method: string, target: object): void;
        /** Remove all handlers */
        disconnectAll(): this;
        /** Returns true if this signal has any handlers connected to it */
        isConnected(): boolean;
    }
}
/** Signal that is emitted for all exceptions that were unhandled during async execution; a custom handler may be added here, the default handler just logs a warning message to the console; to disable this behavior for specific errors, set error.message to a blank string */
export const UnhandledException: Signal.Emittable<Error>;

}

declare module "@typescene/core/Async" {
export * from "@typescene/core/Async/Defer";
export * from "@typescene/core/Async/Signal";
export * from "@typescene/core/Async/Promise";
export * from "@typescene/core/Async/Observable";
export * from "@typescene/core/Async/ObservableArray";
export * from "@typescene/core/Async/ObservableObject";
export * from "@typescene/core/Async/Inject";

}

declare module "@typescene/core/Async" {
export * from "@typescene/core/Async/index";
import * as Async from "@typescene/core/Async/index";
export default Async;

}

declare module "@typescene/core/UI/Animation" {
import { Component } from "@typescene/core/UI";
/** Represents a UI component animation */
export abstract class Animation {
    static enableAll(): void;
    static disableAll(): void;
    static readonly isEnabled: boolean;
    constructor(name: string);
    /** Unique ID (includes name and a unique number, generated by constructor) */
    readonly id: string;
    /** Name of the animation (not necessarily unique) */
    readonly name: string;
    /** Total duration in milliseconds of (the looping segment of) this animation, set by implementation */
    duration: number;
    /** Play the animation on given component */
    abstract play(component: Component): Animation.AnimationControl<Animation>;
    /** Play the animation once for the entire duration, and then stop it */
    playOnce(component: Component): Animation.AnimationControl<Animation>;
}
export namespace Animation {
    /** Represents the public interface for a playing animation */
    interface AnimationControl<AnimationT extends Animation> {
        /** Reference to the animation itself */
        animation: AnimationT;
        /** Stop playing the animation, clear its artifacts */
        stop(): void;
        /** Promise that resolves to the animation control itself, after the animation is over (duration has passed) */
        done: PromiseLike<AnimationControl<AnimationT>>;
    }
}

}

declare module "@typescene/core/UI/Binding" {
import Async from "@typescene/core/Async";
import { Component } from "@typescene/core/UI";
/** Represents a property binding, used with component factories to proxy values taken from the base component instance onto properties of its sub components */
export class Binding<ResultT> {
    /** Create a new binding based on the given property name/path (referring to the base component, on which .with or .initializeWith was called; resulting values can also be instances of ObservableValue or Promise), and optionally a transformation function, invoked each time the observed value changes (outside of any observable context, like `map` on `ObservableValue`, i.e. no further dependencies are recorded); if no path is specified, the name of the initializer property that contains this binding is used, if any */
    constructor(sourcePath?: string, getTransform?: (value: any, baseComponent: Component) => (ResultT | Async.ObservableValue<ResultT> | PromiseLike<ResultT>));
    /** Construct an ObservableValue that is bound to the value on given component (used by factory initializer to apply binding) */
    observeOn(component: Component, name?: string): Async.ObservableValue<ResultT>;
}
/** Represents a two-way binding (`Binding` that also includes a setter on the proxy property) */
export class TwoWayBinding<ResultT> extends Binding<ResultT> {
    /** Create a new two-way binding based on the given property name/path (see `new Binding`), and optionally a transformation function, invoked each time a new value is being set (outside of any observable context); if no path is specified, the name of the initializer property that contains this binding is used, if any */
    constructor(sourcePath?: string, getTransform?: (value: any, baseComponent: Component) => (ResultT | Async.ObservableValue<ResultT> | PromiseLike<ResultT>), setTransform?: (value: any, baseComponent: Component) => any);
    /** Make an ObservableValue that is bound to the value on given component (used by factory initializer to apply binding) */
    observeOn(component: Component, name?: string): Async.ObservableValue<ResultT>;
}
/** Represents an array property binding, used with component factories to proxy arrays taken from the base component instance onto array properties of its sub components; all arrays are _lazily bound_, i.e. elements remain undefined until their `length` property has been evaluated */
export class ArrayBinding<ItemT> extends Binding<ItemT[]> {
    /** Create a new binding based on the given property name/path, getter transformation function (see `Binding` constructor), and array element transformation function, to be passed to `mapAsync` or `mapAsyncValues` (if `uniqueValues` argument is true) */
    constructor(sourcePath?: string, getTransform?: (array: any, baseComponent: Component) => any, itemTransform?: (value: any, baseComponent: Component) => ItemT, uniqueValues?: boolean);
    /** Create a new binding based on the given property name/path, getter transformation function (see `Binding` constructor), and array element transformation function, to be passed to `mapAsync` or `mapAsyncValues` (if `uniqueValues` argument is true); if `flatten` argument is true, the element transformation function may return an array of results as well, to be flattened into the final result (with undefined/null values removed) */
    constructor(sourcePath?: string, getTransform?: (array: any, baseComponent: Component) => any, itemTransform?: (value: any, baseComponent: Component) => (ItemT | ItemT[]), uniqueValues?: boolean, flatten?: boolean);
    /** Make an ObservableValue that is bound to the value on given component (used by factory initializer to apply binding); wraps an observable array in an observable value; for better performance, use `.observeArrayOn(...)` directly (used by component factory initializer) */
    observeOn(component: Component, name?: string): Async.ObservableValue<ItemT[]>;
    /** Make an ObservableArray that is bound to the value on given component (used by factory initializer to apply binding); since accessing the bound value at time of binding may be premature, all array elements remain undefined _until_ the `length` property is accessed (e.g. from an observable context such as a component renderer) */
    observeArrayOn(component: Component, name?: string): Async.ObservableArray<ItemT>;
}
/** Create a new `Binding` for a property on the base component with the same name as the component initializer property
 * @see bind2
 */
export function bind(): Binding<any>;
/** Create a new `Binding` for given property name/path on the base component; for use in a component initializer */
export function bind(sourcePath: string): Binding<any>;
/** Create a new `Binding` for given property name/path on the base component, and transformation function; for use in a component initializer */
export function bind<T>(sourcePath: string, getTransform: (value: any) => T): Binding<T>;
/** Create a new `TwoWayBinding` for a property on the base component with the same name as the component initializer property */
export function bind2(): TwoWayBinding<any>;
/** Create a new `TwoWayBinding` for given property name/path on the base component; for use in a component initializer */
export function bind2(sourcePath: string): TwoWayBinding<any>;
/** Create a new `TwoWayBinding` for given property name/path on the base component, and transformation function(s); for use in a component initializer */
export function bind2<T>(sourcePath: string, getTransform: (value: any) => T, setTransform?: (value: any) => any): Binding<T>;
/** Create a new `ArrayBinding` for given property name/path on the base component, which should contain an array; the binding resolves to an observable array of instances of given `Component` class (with a constructor that takes one or two arguments: the original array element value, and optionally the base component reference); for use in a component initializer; uses `mapAsync` on the observable array by default: deleting a value in the middle of the array will trigger reinstantiation of all components after it; to use `mapAsyncValues` for better results with arrays of objects, set the `uniqueValues` argument to true; to create components asynchronously in batches, set the `batchSize` argument to a number; all arrays are _lazily bound_, i.e. elements remain undefined until their `length` property has been evaluated */
export function bindComponents<ComponentT extends Component>(sourcePath: string, componentClass: {
    new (value: any, baseComponent: Component): ComponentT;
}, uniqueValues?: boolean, batchSize?: number): ArrayBinding<Component>;

}

declare module "@typescene/core/UI/Components/Blocks/Block" {
import { Component } from "@typescene/core/UI/Components/Component";
import { Page } from "@typescene/core/UI/Page";
/** Block base class: full-width block component */
export class Block extends Component {
    /** Create a new empty block component */
    constructor();
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Block.Initializer) => this;
    /** Overlay position (observed); set to one of the `OverlayPosition` enum's values to take this block out of the top-down component flow, and position it relative to its _parent_ container (or to the screen, if displayed directly); note that this block will still move up/down along with the content of the parent container if its `scrollable` property is true */
    overlayPosition?: Block.OverlayPosition;
}
export namespace Block {
    /** Initializer for .with({...}) */
    interface Initializer extends Component.Initializer {
        /** Property initializer: overlay positioning option (to display block as an overlay within its parent container) */
        overlayPosition?: OverlayPosition;
        /** Property initializer: display options (for use when displayed directly on the page) */
        displayOptions?: Page.DisplayOptions;
    }
    /** Overlay positioning options */
    enum OverlayPosition {
        /** Top (full width) */
        Top = 0,
        /** Top left corner */
        TopLeft = 1,
        /** Top right corner */
        TopRight = 2,
        /** Top inside corner (left for default ltr mode) */
        TopStart = 3,
        /** Top outside corner (right for default ltr mode) */
        TopEnd = 4,
        /** Bottom (full width) */
        Bottom = 5,
        /** Bottom left corner */
        BottomLeft = 6,
        /** Bottom right corner */
        BottomRight = 7,
        /** Bottom inside corner (left for default ltr mode) */
        BottomStart = 8,
        /** Bottom outside corner (right for default ltr mode) */
        BottomEnd = 9,
    }
}

}

declare module "@typescene/core/UI/Components/Blocks/Card" {
import { Block } from "@typescene/core/UI/Components";
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory } from "@typescene/core/UI/Components/ComponentFactory";
/** Represents a card block containing a header, content, and a footer */
export class Card extends Block {
    /** Create a card block with given content, if any */
    constructor(content?: Block[]);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Card.Initializer) => this;
    /** Block to be displayed as a header, may be undefined (observed) */
    header?: Block;
    /** Block to be displayed as a footer, may be undefined (observed) */
    footer?: Block;
    /** Array of main content blocks, stacked top to bottom (observed) */
    content: Array<Block | undefined>;
    /** Append a block to this component */
    appendChild(block?: Block): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace Card {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: content blocks */
        content?: ComponentFactory.SpecList2;
        /** Property initializer: header block */
        header?: ComponentFactory.SpecEltOrList;
        /** Property initializer: footer block */
        footer?: ComponentFactory.SpecEltOrList;
    }
}

}

declare module "@typescene/core/UI/Components/Blocks/ContainerBlock" {
import { Container } from "@typescene/core/UI/Components";
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { Block } from "@typescene/core/UI/Components/Blocks/Block";
/** Represents a block with an embedded sub container within its margins/padding */
export class ContainerBlock<ContainerT extends Container> extends Block {
    /** Create a container block component with given container, if any */
    constructor(container?: ContainerT);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ContainerBlock.Initializer<ContainerT>) => this;
    /** Container element (created if not set, never undefined; observed) */
    container: ContainerT;
    /** Overall target height of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be "auto"); if a height has not been set explicitly, or is set to "auto", then the value is taken from the height of the container; for `LayoutContainer`, a value of "100%" is used if the container's height is also "auto" */
    height: string;
    /** Set the container for this component (overwrites existing value, if any); returns this */
    appendChild(c?: ContainerT): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace ContainerBlock {
    /** Initializer for .with({ ... }) */
    interface Initializer<ContainerT extends Container> extends Block.Initializer {
        /** Property initializer: container component or initializer */
        container?: UIValueOrAsync<ComponentFactory<Container> | Container> | ComponentFactory.SpecList2;
    }
}

}

declare module "@typescene/core/UI/Components/Blocks/Divider" {
import { UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { Block } from "@typescene/core/UI/Components/Blocks/Block";
/** Represents a divider block element (horizontal line placed between blocks) */
export class Divider extends Block {
    /** Create a new divider with given (optional) properties */
    constructor(color?: string, thickness?: string, margin?: string, insetStart?: string, insetEnd?: string);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Divider.Initializer) => this;
    /** Divider color (CSS value, platform default used if empty, observed) */
    color: string;
    /** Divider thickness (CSS value, platform default used if empty, observed) */
    thickness: string;
    /** Vertical whitespace around divider (CSS value, platform default used if empty, observed) */
    margin: string;
    /** Horizontal inset on the inside, i.e. left margin in left-to-right flow direction mode (CSS value, none if empty, observed) */
    insetStart: string;
    /** Horizontal inset on the outside, i.e. right margin in left-to-right flow direction mode (CSS value, none if empty, observed) */
    insetEnd: string;
}
export namespace Divider {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: line color (CSS color) */
        color?: UIValueOrAsync<string>;
        /** Property initializer: line weight (CSS length) */
        thickness?: UIValueOrAsync<string>;
        /** Property initializer: space around line (CSS length) */
        margin?: UIValueOrAsync<string>;
        /** Property initializer: inside inset (CSS length) */
        insetStart?: UIValueOrAsync<string>;
        /** Property initializer: outside inset (CSS length) */
        insetEnd?: UIValueOrAsync<string>;
    }
}

}

declare module "@typescene/core/UI/Components/Blocks/List" {
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { ComponentRenderer } from "@typescene/core/UI/Components/ComponentRenderer";
import { ComponentSignal, ComponentSignalHandler } from "@typescene/core/UI/Components/ComponentSignal";
import { Block } from "@typescene/core/UI/Components/Blocks/Block";
import { Divider } from "@typescene/core/UI/Components/Blocks/Divider";
/** Represents a list of blocks */
export class List<BlockT extends Block> extends Block {
    /** Create a list component with given items */
    constructor(items?: Array<BlockT | undefined>);
    /** Method that is called immediately after the renderer for this list is constructed; adds observers for item selection */
    protected beforeFirstRender(renderer: ComponentRenderer<this, any>): void;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: List.Initializer<BlockT>) => this;
    /** List content (observed) */
    items: Array<BlockT | undefined>;
    /** Current (last) selected item index (base 0), or -1 if no item is selected (observed) */
    selectedIndex: number;
    private _observableSelectedIndex?;
    /** Set to an initializer spec for the Divider component to insert a divider between each element (observed) */
    divider: Divider.Initializer;
    /** Set to a string value to have getFormValues add an ObservableArray with form values of list items */
    name: string;
    /** Deselect all items currently in this list */
    deselectAll(): void;
    /** Select given item (block), and immediately deselect others if `.selectionMode` is `ItemClick` or `ItemFocus`; does _not_ check if the item is included in `.items` at all for performance reasons */
    selectItem(item: BlockT | undefined): void;
    /** Append a block to this list */
    appendChild(block?: BlockT): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: any): any;
    /** Set all input values by element name */
    setFormValues(values: any): void;
    /** Signal emitted when the list selection changes, while displayed on screen */
    readonly SelectionChange: ComponentSignal.Emittable<List.ItemEvent<any>>;
    private _dividers;
}
export namespace List {
    /** Initializer for .with({ ... }) */
    interface Initializer<BlockT extends Block> extends Block.Initializer {
        /** Property initializer: list of items */
        items?: ComponentFactory.SpecList;
        /** Divider initializer spec */
        divider?: Divider.Initializer;
        /** Property initializer: (last) selected item index */
        selectedIndex?: UIValueOrAsync<number>;
        /** Property initializer: form values list name */
        name?: string;
        /** Signal initializer: method name or handler */
        SelectionChange?: string | ListSelectionHandler<BlockT>;
    }
    /** Data that is emitted after the item selection of a list component changes */
    interface ItemEvent<T extends Block> {
        /** The target item index */
        index: number;
        /** The target item */
        item?: T;
    }
    /** Signal that is emitted when a list selection event occurs */
    class SelectionSignal<T extends Block> extends ComponentSignal<ItemEvent<T>> {
    }
}
/** Constructor for a list selection event handler */
export class ListSelectionHandler<T extends Block> extends ComponentSignalHandler<List.ItemEvent<T>> {
}

}

declare module "@typescene/core/UI/Components/Blocks/NavList" {
import { Container } from "@typescene/core/UI/Components";
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { ComponentRenderer } from "@typescene/core/UI/Components/ComponentRenderer";
import { ComponentSignalHandler, ComponentSignal } from "@typescene/core/UI/Components/ComponentSignal";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
import { Block } from "@typescene/core/UI/Components/Blocks/Block";
/** Represents a list of tabs or links */
export class NavList extends Block {
    /** Create a navigation list component */
    constructor(navItems?: NavList.NavItem[], type?: NavList.Type, selectedIndex?: number);
    /** Method that is called immediately after the renderer for this component is constructed; adds observers for nav item selection */
    protected beforeFirstRender(renderer: ComponentRenderer<this, any>): void;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: NavList.Initializer) => this;
    /** Nav labels, icons, and badges (observed) */
    navItems: NavList.NavItem[];
    /** Space reserved for icons (rem units), if > 0 (observed) */
    remGutter: number;
    /** Index of selected nav item (base 0), or -1 if no selection (observed); does not automatically activate nav item targets; to do so, use the `.activate(...)` function instead */
    selectedIndex: number;
    private _observableSelectedIndex?;
    /** Key (string value) of selected item, if any (read-only, observable) */
    readonly selectedKey: string | undefined;
    /** Type of nav: tabs or pills, inline or stacked; default tabs (observed) */
    type: NavList.Type;
    /** Set to true to fill all horizontal space */
    justified: boolean;
    /** Select nav item by index or key, display associated container if any, and/or start associated activity if any; returns this */
    activate(selection: number | string): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
    /** Signal emitted when the selected nav item changes, while displayed on screen */
    readonly NavChange: ComponentSignal.Emittable<NavList.SelectionEvent>;
    /** Container block that contains the container for currently selected item, if any */
    private _containerBlock;
    /** Factory UID of the factory that created the current container, or undefined if container was not created using a factory */
    private _factoryUID?;
    /** Activation instance, with injected methods */
    private _activation;
}
export namespace NavList {
    /** Contains injectable methods for activating targets and querying activation state; instantiated by `NavList` */
    class Activation {
        /** Injectable method to activate given target (e.g. URL, or Activity instance or class); default ony handles URLs, `Application` instance injects more functionality here */
        activate(target: any): void;
        /** Injectable method that returns true (observable) if and when given target matches the current target, i.e. URL/path matches, or activity/class matches current activity or one of its parent activities; this method is called from within an observable context to be able to observe changes to target states */
        isActive(target: any): boolean;
    }
    /** Represents an item in a navigation list (tab or link) */
    interface NavItem {
        /** Text label */
        label?: string | TextLabelFactory;
        /** Icon (see `Label` component) */
        icon?: string;
        /** Badge text */
        badge?: string;
        /** Key (identifier string) of the item, used to populate `NavList/selectedKey` */
        key?: string;
        /** Container to be displayed below tabs/links when this item is selected */
        container?: Container | ComponentFactory<Container>;
        /** URL/path string, or (App module) `Activity` instance or `Activity` class that will be activated when this item is selected; also, the item will be automatically selected if/when its target is active (i.e. URL/path matches, or activity/class matches current activity or one of its parent activities) */
        target?: any;
    }
    /** NavList display type */
    enum Type {
        /** Display as a row of tabs */
        Tabs = 0,
        /** Display as a row of pills */
        Pills = 1,
        /** Display as a list of pills */
        StackedPills = 2,
    }
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: navlist items */
        navItems?: UIValueOrAsync<NavList.NavItem[]>;
        /** Property initializer: initial item index */
        selectedIndex?: UIValueOrAsync<number>;
        /** Initializer: activate item automatically, by index or key */
        activate?: number | string;
        /** Property initializer: nav display type */
        type?: UIValueOrAsync<NavList.Type>;
        /** Property initializer: true to fill all horizontal space */
        justified?: UIValueOrAsync<boolean>;
        /** Signal initializer: method name or handler */
        NavChange?: string | NavListSelectionHandler;
    }
    /** Data that is emitted when a navlist's selection changes */
    interface SelectionEvent {
        /** The new selection index */
        index: number;
        /** The new selection key, if any */
        key?: string;
        /** The container to be displayed, if any */
        container?: Container;
    }
    /** Signal that is emitted when a navlist's selection changes */
    class SelectionSignal extends ComponentSignal<SelectionEvent> {
    }
}
/** Constructor for a navlist selection event handler */
export class NavListSelectionHandler extends ComponentSignalHandler<NavList.SelectionEvent> {
}

}

declare module "@typescene/core/UI/Components/Blocks/Row" {
import { ControlElement } from "@typescene/core/UI/Components";
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { Block } from "@typescene/core/UI/Components/Blocks/Block";
/** Represents a row containing control elements placed horizontally */
export class Row extends Block {
    /** Create a row block with given content, if any */
    constructor(content?: ControlElement[]);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Row.Initializer) => this;
    /** Array of elements that go into this row (observed) */
    content: Array<ControlElement | undefined>;
    /** Spacing between elements (CSS value, platform default used if empty, observed) */
    spacing: string;
    /** Vertical spacing (margin) for this row (CSS value, value of `.spacing` used if empty, observed); not applicable if `.height` is set */
    verticalSpacing: string;
    /** Horizontal positioning of content within the outer boundaries of the row (observed), defaults to "start" if not defined */
    horzAlign?: "start" | "end" | "left" | "center" | "right";
    /** Append a control element to this row */
    appendChild(controlElement?: ControlElement): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace Row {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: list of control elements */
        content?: ComponentFactory.SpecList;
        /** Property initializer: spacing around controls */
        spacing?: UIValueOrAsync<string>;
        /** Property initializer: vertical spacing above and below controls */
        verticalSpacing?: UIValueOrAsync<string>;
    }
}
/** Represents a row containing control elements placed horizontally, with spacing set to `0` (no margin) */
export class CloseRow extends Row {
    spacing: string;
    verticalSpacing: string;
}
/** A row element with components aligned to the opposite side ("end" alignment, i.e. right-aligned for left-to-right languages) */
export class OppositeRow extends Row {
    /** Horizontal positioning of content within the outer boundaries of the row (observed), set to "end" for `OppositeRow` instances */
    horzAlign?: "start" | "end" | "left" | "center" | "right";
}
/** A row element with components aligned in the center */
export class CenterRow extends Row {
    /** Horizontal positioning of content within the outer boundaries of the row (observed), set to "center" for `CenterRow` instances */
    horzAlign?: "start" | "end" | "left" | "center" | "right";
}

}

declare module "@typescene/core/UI/Components/Blocks/Table" {
import Async from "@typescene/core/Async";
import { ControlElement } from "@typescene/core/UI/Components";
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory } from "@typescene/core/UI/Components/ComponentFactory";
import { Block } from "@typescene/core/UI/Components/Blocks/Block";
import { TableRow, TableHeader } from "@typescene/core/UI/Components/Blocks/TableRow";
/** Represents a table block component */
export class Table<TableRowT extends TableRow> extends Block {
    /** Create a table with given header and rows, if any */
    constructor(headerColumns?: Array<string | ControlElement | Block>, widths?: string[], rows?: TableRowT[] | Async.ObservableArray<TableRowT>);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Table.Initializer) => this;
    /** Header row; not rendered if undefined, or does not contain columns, OR if table itself has no rows (observed) */
    header?: TableHeader;
    /** List of rows; each row should have the same number of columns (observed) */
    rows: Array<TableRowT | undefined>;
    /** Set to a string value to have getFormValues add an ObservableArray with form values of table rows */
    name?: string;
    /** Append a row to this table */
    appendChild(tableRow?: TableRowT): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: any): any;
    /** Set all input values by element name */
    setFormValues(values: any): void;
}
export namespace Table {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: list of rows */
        rows: ComponentFactory.SpecList2TCol;
        /** Property initializer: header row */
        header?: ComponentFactory.SpecEltOrListTCol;
        /** Property initializer: form values list name */
        name?: string;
    }
}

}

declare module "@typescene/core/UI/Components/Blocks/TableRow" {
import { Style } from "@typescene/core/UI/Style";
import { ControlElement } from "@typescene/core/UI/Components";
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { Block } from "@typescene/core/UI/Components/Blocks/Block";
/** Represents a row within a `Table` component */
export class TableRow extends Block {
    /** Create a table row with given columns, if any */
    constructor(columns?: Array<string | ControlElement | Block>, widths?: string[], styles?: Array<Style | Style.StyleSet>);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: TableRow.Initializer) => this;
    /** Column content as strings, control elements, or blocks (observed) */
    columns: Array<string | ControlElement | Block | undefined>;
    /** Column widths for all columns (CSS values, observed) */
    widths: Array<string | undefined>;
    /** Additional styles for all columns (observed) */
    styles: Array<Style | Style.StyleSet | undefined>;
    /** Row index (base 0) the last time this row was rendered, or -1 (observable) */
    rowIndex: number;
    /** Append a table cell to this row */
    appendChild(cell?: string | ControlElement | Block): this;
    /** Returns an array of directly contained components */
    getChildren(): Component[];
}
export namespace TableRow {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Block.Initializer {
        /** Property initializer: content of all columns, as strings, control elements, or blocks */
        columns: ComponentFactory.SpecListTCol;
        /** Property initializer: widths of all columns */
        widths?: UIValueOrAsync<Array<string | undefined>>;
        /** Property initializer: additional styles for all columns */
        styles?: UIValueOrAsync<Array<Style | Style.StyleSet | undefined>>;
    }
}
/** A table header at the top of a table */
export class TableHeader extends TableRow {
    /** Automatic selection management mode: table header rows are not selectable */
    selectionMode: Component.SelectionMode;
    /** Automatic focus management mode: table header rows are not focusable */
    focusMode: Component.FocusMode;
}

}

declare module "@typescene/core/UI/Components/Blocks/TreeList" {
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory } from "@typescene/core/UI/Components/ComponentFactory";
import { ComponentRenderer } from "@typescene/core/UI/Components/ComponentRenderer";
import { ComponentSignal, ComponentSignalHandler } from "@typescene/core/UI/Components/ComponentSignal";
import { Block } from "@typescene/core/UI/Components/Blocks/Block";
/** Represents a hierarchical list of blocks */
export class TreeList<BlockT extends TreeList.BlockItem> extends Block {
    /** Create a tree list component with given items */
    constructor(items?: Array<BlockT | undefined>);
    /** Method that is called immediately after the renderer for this list is constructed; adds observers for item selection */
    protected beforeFirstRender(renderer: ComponentRenderer<this, any>): void;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: TreeList.Initializer<BlockT>) => this;
    /** Hierarchical list content (observed); items can use the `TreeList.BlockItem` interface to provide sub content, see e.g. `TreeListRow` */
    items: Array<BlockT | undefined>;
    /** Select given item (block), and immediately deselect others if `.selectionMode` is `ItemClick` or `ItemFocus`; does _not_ check if the item is included in `.items` at all for performance reasons */
    selectItem(item: BlockT | undefined): void;
    /** Key (string value) of selected item, if any (observable); see `TreeList.BlockItem/key`; if set to a string value, all items in the hierarchy will be checked for a matching key, and selected or deselected; for selected items, parent items will be expanded automatically; input focus will be removed from deselected items as well, but selected items are not focused automatically */
    selectedKey: string | undefined;
    /** Observable used by `selectedKey` setter to watch for changes to list items if key was not found yet; to be cleared when selection changes again */
    private _selectedKeySetter;
    /** Append a tree list block to this list */
    appendChild(block?: BlockT): this;
    /** Returns an array of directly contained components (observable); i.e. a flattened list of all _visible_ tree list items */
    getChildren(): Component[];
    /** Signal emitted when the list selection changes, while displayed on screen */
    readonly SelectionChange: ComponentSignal.Emittable<TreeList.ItemEvent<any>>;
    /** Signal emitted when a tree list item is collapsed, while displayed on screen */
    readonly ItemCollapsed: ComponentSignal.Emittable<TreeList.ItemEvent<any>>;
    /** Signal emitted when a tree list item is expanded, while displayed on screen */
    readonly ItemExpanded: ComponentSignal.Emittable<TreeList.ItemEvent<any>>;
    /** Flattened observable array, derived from `.items` property */
    private _flattened?;
}
export namespace TreeList {
    /** Initializer for .with({ ... }) */
    interface Initializer<BlockT extends Block> extends Block.Initializer {
        /** Property initializer: nested list of items */
        items?: ComponentFactory.SpecList;
        /** Signal initializer: method name or handler */
        SelectionChange?: string | TreeListSelectionHandler<BlockT>;
        /** Signal initializer: method name or handler */
        ItemCollapsed?: string | TreeListFoldHandler<BlockT>;
        /** Signal initializer: method name or handler */
        ItemExpanded?: string | TreeListFoldHandler<BlockT>;
    }
    /** Represents a `Block` component with optional properties that define the hierarchical structure used by `TreeList` */
    interface BlockItem extends Block {
        /** Optional key (identifier string) of the item, used to populate `TreeList/selectedKey` */
        key?: string;
        /** Optional flag, set to true to collapse the hierarchy below this item; this property should be observable to update rendered components asynchronously */
        collapsed?: boolean;
        /** Optional (observable) array containing tree list items to be displayed below this item; this property should be observable to update rendered components asynchronously */
        treeListItems?: Array<TreeList.BlockItem | undefined>;
    }
    /** Data that is emitted after the item selection of a tree list component changes, or when a tree list item is collapsed/expanded */
    interface ItemEvent<T extends TreeList.BlockItem> {
        /** The newly selected item */
        item?: T;
        /** The key (string value) of the newly selected item, if any */
        key?: string;
    }
    /** Signal that is emitted when a tree list selection event occurs */
    class SelectionSignal<T extends TreeList.BlockItem> extends ComponentSignal<ItemEvent<T>> {
    }
    /** Signal that is emitted when a tree list item is collapsed or expanded */
    class FoldSignal<T extends TreeList.BlockItem> extends ComponentSignal<ItemEvent<T>> {
    }
}
/** Constructor for a tree list selection event handler */
export class TreeListSelectionHandler<T extends TreeList.BlockItem> extends ComponentSignalHandler<TreeList.ItemEvent<T>> {
}
/** Constructor for a tree list fold (collapse/expand) event handler */
export class TreeListFoldHandler<T extends TreeList.BlockItem> extends ComponentSignalHandler<TreeList.ItemEvent<T>> {
}

}

declare module "@typescene/core/UI/Components/Blocks/TreeListRow" {
import { ArrayBinding } from "@typescene/core/UI/Binding";
import { Component, ControlElement, ComponentFactory } from "@typescene/core/UI/Components";
import { TreeList } from "@typescene/core/UI/Components/Blocks/TreeList";
import { CloseRow } from "@typescene/core/UI/Components/Blocks/Row";
/** Represents a tree list row, with an optional list of sub rows; implements the `TreeList.BlockItem` interface */
export class TreeListRow extends CloseRow implements TreeList.BlockItem {
    /** Create an _array_ of tree list row components from the given array of tree item data objects, with given icons and measurements */
    static arrayFromItems(itemData: TreeListRow.ItemData[], openIcon: string, closedIcon: string, remGutter?: number, height?: string): TreeListRow[];
    /** Create a new `ArrayBinding` for given property name/path on the base component, which should contain an array of unique tree item data objects; the binding resolves to an observable array of `TreeListRow` instances; for use in a component initializer; set the `batchSize` argument to a value greater than 0 to create rows in batches for faster initial rendering */
    static arrayFromBinding(sourcePath: string, openIcon: string, closedIcon: string, remGutter?: number, height?: string, batchSize?: number): ArrayBinding<Component>;
    /** Creates a new tree list row for given item data, with given open/closed icon names and measurements; set the `batchSize` argument to a value greater than 0 to create child rows in batches for faster initial rendering */
    constructor(itemData: TreeListRow.ItemData, openIcon: string, closedIcon: string, remGutter?: number, height?: string, batchSize?: number);
    /** Default height for new instances (CSS length, initially 1.75em) */
    static HEIGHT: string;
    /** Default gutter width for new instances (CSS length in rem units, initially 1.5) */
    static REM_GUTTER: number;
    /** Item data for this row (observed as a shallow reference, i.e. item data properties are not automatically observed, but the reference to the object itself is) */
    itemData: TreeListRow.ItemData;
    /** Item key for this row (read-only, taken directly from the `itemData` object; observable) */
    readonly key: string | undefined;
    /** Indent width, i.e. width of space before nested row content, and icon width (CSS length in rem units; observed) */
    remGutter: number;
    /** Name of the icon that is used in front of rows that have a `treeListItems` array and are not collapsed (see `Icon/icon` property on `Icon`; observed) */
    openIcon: string;
    /** Name of the icon that is used in front of rows that have a `treeListItems` array and are currently collapsed (see `Icon/icon` property on `Icon`; observed) */
    closedIcon: string;
    /** Reference to the `TreeListRow` instance that created this row, if any, i.e. the parent row in the visual hierarchy; this property is set automatically by a parent constructor, and by the static methods `arrayFromItems`, and `arrayFromBinding`; otherwise it _must_ be set before rendering */
    treeListRowParent?: TreeListRow;
    /** True if this row is collapsed (defaults to true; observable) */
    collapsed: boolean;
    /** List of rows displayed below this row in the hierarchical structure of a `TreeList` component; automatically generated based on `itemData` and its properties */
    readonly treeListItems: TreeListRow[];
    /** Tree list row content; automatically generated based on `itemData` and its properties */
    readonly content: ControlElement[];
    /** Generate the content factory initializer spec for this row (used as an observable getter) */
    private _getContentSpec();
    /** Generate the observable array that contains `TreeListRow` instances for child items */
    private _getTreeListItems(batchSize?);
    /** Cached indent position 1-n */
    private _indent;
    /** Cached content spec */
    private _contentSpec;
    /** Cached spacer instance */
    private _contentSpecSpacer;
    /** Cached toggle icon instance */
    private _contentSpecToggleIcon;
    /** Cached label instance */
    private _contentSpecLabel;
}
export namespace TreeListRow {
    /** Interface definition of the source data that can be used to construct a `TreeListRow` instance and its children; actual objects may contain more state information such as an instance of a linked (view) model, however either a `content` array or a `name` property is required */
    interface ItemData {
        /** Optional key (identifier string) of the item */
        key?: string;
        /** Row content to be displayed for this item, as a factory initializer spec: an array containing strings, `TextLabelFactory` instances, `Icon` instances or factories, etc */
        content?: ComponentFactory.SpecList;
        /** Item display name, displayed in a `WideLabel` component if `content` is undefined */
        name?: string;
        /** Name of the icon displayed at the start of the row (after the open/closed icon, if any) */
        icon?: string;
        /** (Observable) array of sub items to be displayed; child instances of `TreeListRow` are automatically created for these items upon initialization; if this property is undefined, the tree list row will be displayed as a leaf item; if this array is not observable, the list of sub items will not be updated automatically */
        items?: TreeListRow.ItemData[];
        /** True if the created tree list row should be automatically expanded to reveal sub items when rendered */
        autoExpand?: boolean;
    }
}

}

declare module "@typescene/core/UI/Components/Component" {
import Async from "@typescene/core/Async";
import { Animation } from "@typescene/core/UI/Animation";
import { Style } from "@typescene/core/UI/Style";
import { Page } from "@typescene/core/UI/Page";
import { ActionHandler, ComponentSignal, DragEvent, DragHandler, KeyHandler, KeyboardEvent, PointerEvent, PointerHandler } from "@typescene/core/UI/Components/ComponentSignal";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { ComponentRenderHandler, ComponentRenderer } from "@typescene/core/UI/Components/ComponentRenderer";
/** Component base class to represent every part of the user interface, to be extended by application code (e.g. as a sub class of `Container` or another component class) or constructed from derived component classes (e.g. `Button`) */
export abstract class Component extends Async.ObservableObject {
    /** Abstract constructor with any number of arguments */
    constructor(...args: any[]);
    /** Returns a component factory for this component type, with given (observable) property values and/or sub components; the result is an instance of `ComponentFactory`, a pre-initialized component constructor; this method is only available on component classes that provide a parameterless constructor */
    static with<ClassT extends typeof Component, T extends Component, InitializerT>(this: ClassT & {
        new (): {
            initializeWith(initializer: InitializerT): T;
        };
    }, properties: InitializerT, ...values: Array<ComponentFactory.SpecEltOrList | ((component: T, base: Component) => void)>): ClassT & ComponentFactory<T>;
    /** Returns a component factory for this component type, with given sub components; the result is an instance of `ComponentFactory`, a pre-initialized component constructor; this method is only available on component classes that provide a parameterless constructor */
    static with<ClassT extends typeof Component, T extends Component, InitializerT>(this: ClassT & {
        new (): {
            initializeWith(initializer: InitializerT): T;
        };
    }, ...values: Array<ComponentFactory.SpecEltOrList | ((component: T, base: Component) => void)>): ClassT & ComponentFactory<T>;
    /** __Invalid first argument__, use a valid initializer and/or component factories; returns a component factory for this component type, with given (observable) property values and/or sub components */
    static with<ClassT extends typeof Component, T extends Component, InitializerT>(this: ClassT & {
        new (): {
            initializeWith(initializer: InitializerT): T;
        };
    }, properties: InitializerT | {}, ...values: Array<ComponentFactory.SpecEltOrList | ((component: T, base: Component) => void)>): never;
    /** Initializes this instance with given properties, and with given base component to bind to; may be called more than once, may be overridden (as a function property, not method) to extend the initializer type and transform the initializer spec before calling the base method; returns this */
    initializeWith: (values: Component.Initializer, base?: Component) => this;
    /** Initialize this component, i.e. apply properties from component factories, if any; called automatically by the highest-level component factory constructor with the base component as argument (i.e. component on which `.with` was called), can be overridden to initialize other properties before those from the component factory (and invoke `super.initialize()` manually); returns true only if this component had not been initialized before */
    initialize(base?: Component): boolean;
    /** True if this component has been initialized (synchronous) */
    private _initialized?;
    /** Returns a new component signal class specific to this component, with optional signal base class which must derive from ComponentSignal; can be used to define custom signals in a component constructor or public property initializer (or memoized get-accessor for lazy initialization); sets static property `ComponentSignal.component` of the derived signal class to the component instance, as well as any other static properties given */
    protected createComponentSignal<DataT, SignalT extends {
        new (data: DataT): ComponentSignal<DataT>;
    } = typeof ComponentSignal>(base?: SignalT & (new (data: DataT) => ComponentSignal<DataT>), properties?: {}): ComponentSignal.Emittable<DataT>;
    /** Identifier string (optional), may be set by component factory constructor, and used with .getComponentById(...) */
    id: string;
    /** Globally unique component identifier */
    readonly uid: string;
    /** Add a child component to this component; only supported by components that actually contain other components (e.g. `Container`), throws an Error otherwise; returns this */
    appendChild(child?: Component): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
    /** Returns a list of currently selected directly contained components, in order of selection (observable) */
    getSelectedChildren(): Component[];
    /** Returns the last selected directly contained component (observable); evaluated asynchronously if automatic selection management mode is `ItemClick` or `ItemFocus`, otherwise evaluated synchronously from current selection status of child components */
    getLastSelectedChild(): Component | undefined;
    /** Returns the nearest matching child element with given ID, if any (observable) */
    getComponentById(id: string): Component | undefined;
    /** Returns the nearest matching child element with given ID _and_ that is an instance of given class, if any (observable) */
    getComponentById<C extends Component>(id: string, componentClass: typeof Component & {
        new (...p: any[]): C;
    }): C | undefined;
    /** Returns all (recursive) child components that are an instance of given class (observable) */
    getComponentsByType<C extends Component>(componentClass: {
        new (...p: any[]): C;
    }): C[];
    /** Returns true if given component is a child component of this component or any of its child components (observable, but triggers re-evaluation upon every change in child [sub] components) */
    contains(component: Component): boolean;
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: {}): any;
    /** Set all input values by element name */
    setFormValues(values: any): void;
    /** Animation(s) to be played during the lifetime of this component on screen; initially undefined */
    animations?: Component.Animations;
    /** Play given animation on this component; returns the animation control instance, which can be used to stop the animation manually; given callback is called asynchronously after the animation completes */
    animate<AnimationT extends Animation>(animation: AnimationT, continuous?: boolean, after?: () => void): Animation.AnimationControl<AnimationT>;
    /** Play animation on this component (from `.animations`, by identifier); if found, returns the animation control instance, which can be used to stop the animation manually; given callback is called asynchronously after the animation completes */
    animate(animation: string, continuous?: boolean, after?: () => void): Animation.AnimationControl<Animation> | undefined;
    /** Object with options to be used when displaying this block as a page component, initially undefined (observed) */
    displayOptions?: Page.DisplayOptions;
    /** Options for rendering this component (not observable); initially undefined */
    renderOptions?: ComponentRenderer.RenderOptions;
    /** Layout/text flow direction for switching between left-to-right and right-to-left languages; copied from parent to child components just before rendering */
    flowDirection?: "ltr" | "rtl";
    /** Primary renderer class for this component; injected globally on the component (sub) class, but can be overwritten by assigning to this property (observable) */
    protected Renderer: typeof ComponentRenderer;
    /** Wait for this component to be rendered and return a promise for its output (value of `.out`), unless the component is already rendered, in which case this method returns a resolved promise for the last rendered output; never forces the component to be rendered */
    getRenderedOutputAsync(): PromiseLike<ComponentRenderer.Output<this, any>>;
    /** Returns the last rendered output for this component, if any (value of `.out`); does not trigger a render */
    getLastRenderedOutput(): ComponentRenderer.Output<this, any> | undefined;
    /** Rendered output for this component (observable); retrieving this value triggers a render operation, if it was not already subscribed to, e.g. if the component is displayed on screen; the renderer is lazily constructed from the class reference injected into the `.Renderer` property */
    readonly out: ComponentRenderer.Output<this, any> | undefined;
    /** Render this component synchronously, always updating any existing rendered output; this method should _not_ be used unless changes may have occurred outside of the observable context, otherwise read the value from `.out`, include it on a `Page`, or use the `.display()` method where available */
    render(): ComponentRenderer.Output<this, any> | undefined;
    /** Signal emitted after updating DOM (render) */
    readonly Rendered: ComponentSignal.Emittable<ComponentRenderer.Output<this, any>>;
    /** Current renderer instance, created upon access */
    private readonly _renderer;
    /** Method that is called immediately after the renderer for this component is constructed; override this method (and invoke `super.beforeFirstRender`) to be able to call or inject renderer methods before this component is first rendered */
    protected beforeFirstRender(renderer: ComponentRenderer<this, any>): void;
    /** Helper method to watch and apply list focus mode on renderer instance */
    private _watchFocusMode(renderer);
    /** Helper method to watch and apply selection mode on renderer instance */
    private _watchSelectionMode(renderer);
    /** Helper method to observe selected child component(s), and deselect all except component selected latest; also overrides selection mode for components where this property is undefined; returns an observable for the single (last) selected component */
    private _observeSingleSelection(setSelectionMode);
    /** Observable value containing the last selected component, either computed or set asynchronously if automatic selection management mode is `ItemClick` or `ItemFocus` */
    private _lastSelectionAsync?;
    /** Add a new style override to this component class (and derived classes); does not have any effect on existing component instances, but changes to previously added style overrides are always observed; returns given style instance */
    static addStyleOverride(style: Style): Style;
    /** Read-only reference to an instance of `Style`, encapsulating CSS styles and classes for this component; for extensible component classes, do not override this property but use static method `.addStyleOverride(...)` instead */
    readonly style: Style;
    /** Returns the current dimensions for this component, in logical (CSS) pixel units; may return 0x0 if this component is not yet displayed on screen (i.e. use the `.Rendered` signal and/or a timeout to obtain accurate results) */
    getActualDimensions(): {
        width: number;
        height: number;
    };
    /** Overall target height of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be "auto") */
    height: string;
    /** Overall target width of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component width, may be "auto") */
    width: string;
    /** Set to a number between 0 and 1 to add a drop shadow to this component (shadow "depth" of 1 creates the illusion of a component lifted off the canvas the furthest, 0 means no shadow at all; observable, directly adds shadow effect to `.style`) */
    shadowEffect: number;
    /** Override the drop shadow "depth" value while mouse cursor is hovering over this component, with given number between 0 and 1 */
    addShadowEffectOnHover(d: number): void;
    /** Override the drop shadow "depth" value while this component or a child component has input focus, with given number between 0 and 1 */
    addShadowEffectOnFocus(d: number): void;
    /** Set to true to hide this component (observable, directly modifies hidden state of `.style` and plays show/hide animations) */
    hidden: boolean;
    private _hidden;
    /** Set to true to display this component in a selected state (observable, directly modifies selected state of `.style` and plays select/deselect animations) */
    selected: boolean;
    private _selected;
    /** Automatic selection management mode */
    selectionMode?: Component.SelectionMode;
    /** Last selection order number, assigned when selected */
    private _selectionOrder;
    /** Automatic focus management mode */
    focusMode?: Component.FocusMode;
    /** True if this component _or_ a child component has input focus, false otherwise; set to true to focus the component itself, if and when available (throws an exception if this component is unable to receive input focus); set to false to remove focus from this component */
    hasFocus: boolean;
    /** Connect Focus and Blur signal handlers to maintain `_liveFocus` and `hasFocus` */
    private _connectFocus();
    /** True if the mouse cursor is hovering over this component, false otherwise; evaluated lazily using `.MouseEnter` and `.MouseLeave`, value is `false` initially until first signal is emitted after this property has been read once */
    readonly hoverState: boolean;
    /** Platform focus state, set by Focus/Blur signal handlers */
    private _liveFocus;
    /** Platform hover state, set by MouseEnter/Leave signal handlers */
    private _liveHover?;
    /** Signal emitted when this component _or_ a child component is clicked, touched, or otherwise activated; captured from containers down to contained components, not consumed */
    readonly Click: ComponentSignal.Emittable<PointerEvent>;
    /** Signal emitted asynchronously after this component _or_ a child component is clicked, touched, or otherwise activated; propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly Clicked: ComponentSignal.Emittable<PointerEvent>;
    /** Signal emitted when this component _or_ a child component is double-clicked; captured from containers down to contained components, not consumed */
    readonly DoubleClick: ComponentSignal.Emittable<PointerEvent>;
    /** Signal emitted asynchronously after this component _or_ a child component is double-clicked; propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly DoubleClicked: ComponentSignal.Emittable<PointerEvent>;
    /** Signal emitted when a mouse button is pressed down, or a touch occurs, on this component _or_ a child component; captured from containers down to contained components, not consumed */
    readonly Press: ComponentSignal.Emittable<PointerEvent>;
    /** Signal emitted asynchronously after a mouse button is pressed down, or a touch occurs, on this component _or_ a child component; propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly Pressed: ComponentSignal.Emittable<PointerEvent>;
    /** Signal emitted when the cursor begins to hover over this component; captured from containers down to contained components, not consumed */
    readonly MouseEnter: ComponentSignal.Emittable<PointerEvent>;
    /** Signal emitted when the cursor has left this component; captured from containers down to contained components, not consumed */
    readonly MouseLeave: ComponentSignal.Emittable<PointerEvent>;
    /** Signal emitted when a context menu is requested for this component or a child component (usually by right-clicking); captured from containers down to contained components, not consumed */
    readonly MouseContextMenu: ComponentSignal.Emittable<PointerEvent>;
    /** Signal emitted when a key is pressed down (while this component _or_ a child component is focused); captured from containers down to contained components, not consumed */
    readonly KeyDown: ComponentSignal.Emittable<KeyboardEvent>;
    /** Signal emitted after a key is pressed (while this component _or_ a child component is focused); captured from containers down to contained components, not consumed */
    readonly KeyPress: ComponentSignal.Emittable<KeyboardEvent>;
    /** Signal emitted when this component _or_ a child component receives focus; captured from containers down to contained components, not consumed */
    readonly Focus: ComponentSignal.Emittable<any>;
    /** Signal emitted when this component _or_ a child component loses focus; captured from containers down to contained components, not consumed */
    readonly Blur: ComponentSignal.Emittable<any>;
    /** Signal emitted asynchronously after this component receives focus; propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly FocusGained: ComponentSignal.Emittable<any>;
    /** Signal emitted asynchronously after this component loses focus, and only if `.FocusGained` was emitted previously; propagates from child components to parents, not consumable */
    readonly FocusLost: ComponentSignal.Emittable<any>;
    /** Signal emitted when this component _or_ a child component commences a drag operation; captured from containers down to contained components, not consumed */
    readonly DragStart: ComponentSignal.Emittable<DragEvent>;
    /** Signal emitted when a drag operation begins to hover over this component; captured from containers down to contained components, not consumable */
    readonly DragEnter: ComponentSignal.Emittable<DragEvent>;
    /** Signal emitted when a drag operation has left this component; captured from containers down to contained components, not consumable */
    readonly DragLeave: ComponentSignal.Emittable<DragEvent>;
    /** Signal emitted when this element or a child element is the target of a drop after a drag operation; captured from containers down to contained components, not consumed */
    readonly DragDrop: ComponentSignal.Emittable<DragEvent>;
    /** Helper function to create a key event signal */
    private _makeKeyEvent(key);
    /** Signal emitted after the enter key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly EnterKeyPressed: ComponentSignal.Emittable<KeyboardEvent>;
    /** Signal emitted after the space bar is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly SpaceBarPressed: ComponentSignal.Emittable<KeyboardEvent>;
    /** Signal emitted after the backspace key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly BackspaceKeyPressed: ComponentSignal.Emittable<KeyboardEvent>;
    /** Signal emitted after the forward-delete key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly DeleteKeyPressed: ComponentSignal.Emittable<KeyboardEvent>;
    /** Signal emitted after the escape key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly EscapeKeyPressed: ComponentSignal.Emittable<KeyboardEvent>;
    /** Signal emitted after the left arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly ArrowLeftKeyPressed: ComponentSignal.Emittable<KeyboardEvent>;
    /** Signal emitted after the up arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly ArrowUpKeyPressed: ComponentSignal.Emittable<KeyboardEvent>;
    /** Signal emitted after the right arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly ArrowRightKeyPressed: ComponentSignal.Emittable<KeyboardEvent>;
    /** Signal emitted after the down arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */
    readonly ArrowDownKeyPressed: ComponentSignal.Emittable<KeyboardEvent>;
}
export namespace Component {
    /** Specification of which animations to play during the lifetime of a component on screen (can be extended for sub component types) */
    interface Animations {
        /** Played when component is displayed or added to a displayed parent component */
        appear?: Animation;
        /** Played when component is removed from the screen */
        disappear?: Animation;
        /** Played when component is shown (set `hidden` to false) */
        show?: Animation;
        /** Played when component is hidden (set `hidden` to true) */
        hide?: Animation;
        /** Played when component is selected (set `selected` to true) */
        select?: Animation;
        /** Played when component is deselected (set `selected` to false) */
        deselect?: Animation;
        [name: string]: Animation | undefined;
    }
    /** Options for automatic focus management */
    enum FocusMode {
        /** Unable to focus this component */
        None = 0,
        /** Click or touch to focus */
        Click = 1,
        /** Click, touch, or use keyboard (tab key) to focus */
        Auto = 2,
        /** Focus a child component on click, touch, or up/down arrow key press; child components with focus mode `None` are ignored */
        Items = 3,
    }
    /** Options for automatic selection management */
    enum SelectionMode {
        /** Unable to select this component */
        None = 0,
        /** Focus to select */
        Focus = 1,
        /** Click or touch, or use space bar (while focused) to select */
        Click = 2,
        /** Click or touch, or use space bar (while focused) to toggle selection */
        Toggle = 3,
        /** Select _one_ child component on click or touch; set selection mode of child components to `Click` if undefined */
        ItemClick = 4,
        /** Select _one_ child component on focus; set selection mode of child components to `Focus` if undefined; to be combined with focus mode `Items` for directional keyboard navigation */
        ItemFocus = 5,
        /** Toggle selection on child components on click or touch, or space bar (while focused): set selection mode of child components to `Toggle` if undefined */
        ItemToggle = 6,
    }
    /** Initializer for .with({ ... }) */
    interface Initializer {
        /** Identifier, used to add a component reference to the base component (on which .with(...) or .initializeWith(...) was called) as a property with given identifier */
        id?: string;
        /** Style initializer: object or `Style` instance */
        style?: UIValueOrAsync<Style | Style.StyleSet>;
        /** Property initializer: target height (CSS length) */
        height?: UIValueOrAsync<string>;
        /** Property initializer: target width (CSS length) */
        width?: UIValueOrAsync<string>;
        /** Property initializer: 0 (no shadow effect) - 1 (greatest effect) */
        shadowEffect?: UIValueOrAsync<number>;
        /** Shadow effect when hovered over: 0 (no shadow effect) - 1 (greatest effect) */
        shadowEffectOnHover?: number;
        /** Shadow effect when focused component or child: 0 (no shadow effect) - 1 (greatest effect) */
        shadowEffectOnFocus?: number;
        /** Property initializer: true if component should be hidden */
        hidden?: UIValueOrAsync<boolean>;
        /** Property initializer: true if component should be selected */
        selected?: UIValueOrAsync<boolean>;
        /** Property initializer: automatic selection management mode */
        selectionMode?: UIValueOrAsync<SelectionMode>;
        /** Property initializer: true if component should be focused for input */
        hasFocus?: UIValueOrAsync<boolean>;
        /** Property initializer: automatic focus management mode */
        focusMode?: UIValueOrAsync<FocusMode>;
        /** Animations list (not observable, will overwrite all existing ones) */
        animations?: Component.Animations;
        /** Options for rendering this component (not observable) */
        renderOptions?: ComponentRenderer.RenderOptions;
        /** Signal initializer: method name or handler */
        Rendered?: string | ComponentRenderHandler;
        /** Signal initializer: method name or handler */
        Click?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        Clicked?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        DoubleClick?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        DoubleClicked?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        Press?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        Pressed?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        MouseEnter?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        MouseLeave?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        MouseContextMenu?: string | PointerHandler;
        /** Signal initializer: method name or handler */
        KeyDown?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        KeyPress?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        Focus?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        Blur?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        FocusGained?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        FocusLost?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        DragStart?: string | DragHandler;
        /** Signal initializer: method name or handler */
        DragEnter?: string | DragHandler;
        /** Signal initializer: method name or handler */
        DragLeave?: string | DragHandler;
        /** Signal initializer: method name or handler */
        DragDrop?: string | DragHandler;
        /** Signal initializer: method name or handler */
        EnterKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        SpaceBarPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        BackspaceKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        DeleteKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        EscapeKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        ArrowLeftKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        ArrowUpKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        ArrowRightKeyPressed?: string | KeyHandler;
        /** Signal initializer: method name or handler */
        ArrowDownKeyPressed?: string | KeyHandler;
    }
}

}

declare module "@typescene/core/UI/Components/ComponentFactory" {
import Async from "@typescene/core/Async";
import { Binding } from "@typescene/core/UI/Binding";
import { Component } from "@typescene/core/UI/Components/Component";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
/** Type definition used by component initializers, that wraps a type as well as the same type within an observable value, promise, or binding */
export type UIValueOrAsync<T> = T | Async.ObservableValue<T> | PromiseLike<T> | Binding<any>;
/** Component factory class: constructor creates and initializes a Component */
export interface ComponentFactory<T extends Component> extends Function {
    /** Component class that this factory was created from */
    readonly FactoryComponent: {
        new (): T;
    };
    /** Unique factory identifier */
    readonly componentFactoryId: string;
    /** Flag used for duck typing classes created as component factories */
    readonly isComponentFactory: true;
    /** Flag that can be set to indicate that components created directly from this factory should _not_ be wrapped in other types of components before being appended as fragment child nodes (on classes that are decorated with `appendChildComponents` with argument `acceptFragments`) */
    isFragmentFactory?: true;
    /** Flag that is unset when this component factory is used from within another component factory (i.e. when created components are not base components); if true, the `Component#initialize` method is called by the constructor, otherwise by the containing component factory */
    isBaseComponent?: boolean;
    /** Override initializer properties that are currently encapsulated in this component factory, if any */
    override(values: any): void;
    /** Contruct the component with all properties contained in this factory */
    new (): T;
}
export namespace ComponentFactory {
    /** A factory initializer element (e.g. control element) */
    type SpecElt = UIValueOrAsync<ComponentFactory<Component> | TextLabelFactory | Component | typeof Component | undefined>;
    /** A factory initializer element (e.g. control element) or table content */
    type SpecEltTCol = UIValueOrAsync<ComponentFactory<Component> | TextLabelFactory | Component | typeof Component | string | number | undefined>;
    /** A list of factory initializer elements (e.g. row) */
    type SpecList = UIValueOrAsync<Array<SpecElt>>;
    /** A list of factory initializer elements (e.g. row) or table content */
    type SpecListTCol = UIValueOrAsync<Array<SpecEltTCol>>;
    /** A list of factory initializer elements, or a single element */
    type SpecEltOrList = UIValueOrAsync<SpecElt | Array<SpecElt>>;
    /** A list of factory initializer elements, or a single element; or table content */
    type SpecEltOrListTCol = UIValueOrAsync<SpecEltTCol | Array<SpecEltTCol>>;
    /** A list of (lists of) factory initializer elements */
    type SpecList2 = UIValueOrAsync<Array<SpecEltOrList>>;
    /** A list of (lists of) factory initializer elements or table content */
    type SpecList2TCol = UIValueOrAsync<Array<SpecEltOrListTCol>>;
    /** Choices for the level at which components in (array) properties are expected to be; used by factory to expand/wrap initializer property values before appending as child nodes on a component decorated with `appendChildComponents`, or storing them in a property decorated with `applyComponentsArray` or `applyComponentRef` */
    enum CLevel {
        Container = 0,
        Block = 1,
        ControlElement = 2,
        TableRow = 3,
        TableHeader = 4,
    }
    /** _Class decorator_ for a component class that expects child components (through `appendChild` method) of given type; the factory will then expand/wrap regular and observable objects, factories, classes, or components into the correct type; if `acceptFragments` is set, then components constructed from factories with the `isFragmentFactory` are passed in as-is; used on root component classes, should not need to be used in application code [decorator] */
    function appendChildComponents(type: ComponentFactory.CLevel, acceptFragments?: boolean): (target: typeof Component) => void;
    /** _Property decorator_ for a property where values from an initializer spec should be applied as an (observable) array of components of given type (e.g. `Block`, `ControlElement`, `TableRow`); the factory will then expand/wrap regular and observable arrays of objects, factories, classes, or components into the correct type [decorator] */
    function applyComponentsArray(type: ComponentFactory.CLevel): (target: Component, key: string) => void;
    /** _Property decorator_ for a property where values from an initializer spec should be applied as a reference to a component of given type (e.g. `Block`, `ControlElement`); the factory will then expand/wrap objects, factories, classes, and components into the correct type [decorator] */
    function applyComponentRef(type: ComponentFactory.CLevel): (target: Component, key: string) => void;
    /** _Property decorator_ for a property for which values from an initializer spec should be applied asynchronously (using an `Async.defer(...)` call), instead of being set directly [decorator] */
    function applyAsync(target: Component, key: string): void;
    /** _Method decorator_ for the method that should be called to apply the value of an initializer spec property with the given property name; the method should always accept values as well as instances of `Async.ObservableValue` [decorator] */
    function setterFor(initializerPropertyName: string): MethodDecorator;
}

}

declare module "@typescene/core/UI/Components/ComponentRenderer" {
import Async, { Signal } from "@typescene/core/Async";
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentSignalHandler } from "@typescene/core/UI/Components/ComponentSignal";
/** Class that contains the code necessary to render a component; to retrieve rendering output, Component methods only use the `.output` property, which is an ObservableValue instance that is populated using the (protected) `.render` method */
export abstract class ComponentRenderer<ComponentT extends Component, ElementT> {
    /** Create a new renderer instance for given component */
    constructor(component: ComponentT);
    /** The component that this renderer renders */
    readonly component: ComponentT;
    /** An observable value containing the rendered output, if any; used by the Component rendering methods to retrieve output; this property should *not* be overridden, override the protected `.render` method instead and/or use the `.watch` method to add partial rendering code */
    readonly output: Async.ObservableValue<ComponentRenderer.Output<ComponentT, ElementT> | undefined>;
    /** Signal that is emitted after updating `.output` (but not if undefined) and/or when the `updated` promise on the rendered output is resolved */
    readonly Rendered: Signal.Emittable<ComponentRenderer.Output<ComponentT, ElementT>>;
    /** Component renderer function; to be overridden, *must* be a pure function, based on the current `.component` and `.output` properties (otherwise *creating* or *setting* ObservableValue instances should be done within a function that is passed to `unobserved`) */
    protected render(): ComponentRenderer.Output<ComponentT, ElementT> | undefined;
    /** Add a method that will be called (synchronously and asynchronously) from a new observable context, after previously added methods, immediately *after* the `.render` method has run once, along with an optional method that will be called (synchronously, unobserved) with the result of the first method; i.e. observable values used in the first method will be subscribed to while the output is subscribed to, but changes to these values will never trigger re-rendering the entire component -- instead, the second function is invoked; useful for partially updating existing output using a subset of component properties; should be called _before_ rendering takes place */
    watch<T>(getter: (this: this) => T, map?: (this: this, value: T) => void): void;
}
export namespace ComponentRenderer {
    /** Encapsulates output for a rendered component; class type parameters indicate the type of component rendered, and the output type (e.g. HTMLElement) */
    class Output<ComponentT extends Component, ElementT> {
        /** Create a new instance for given component, with given element (should not be undefined) */
        constructor(component: ComponentT, element: ElementT, context?: any);
        /** The component that the output is generated for */
        readonly component: ComponentT;
        /** Reference to the actual output (e.g. DOM element) */
        readonly element: ElementT;
        /** Reference to an element that wraps around the output element, that should be included by the parent element instead (or undefined) */
        wrapper?: ElementT;
        /** Reference to a (sub) element that should be used to register event handlers, if different from main element (otherwise undefined) */
        liveElement?: ElementT;
        /** If defined, a promise that resolves the next time the content of the rendered output element is generated (drawn on screen _if_ the parent output element is also already on screen) */
        updated?: PromiseLike<any>;
        /** Flag that can be used for duck typing */
        isComponentOutput: true;
    }
    /** Options for rendering (child) components */
    interface RenderOptions {
        /** Set to true to force synchronous rendering for this component */
        synchronous?: boolean;
        /** Set to a value in milliseconds to animate _child component_ positioning for the given duration, if possible; only works with lists and tables, and may require synchronous rendering of child components (i.e. set `.synchronous` on list items) */
        animateListItems?: number;
    }
}
/** Constructor for a component render event handler */
export class ComponentRenderHandler extends ComponentSignalHandler<ComponentRenderer.Output<Component, any>> {
}
/** _Class decorator_, maps the decorated `ComponentRenderer` class to a `Component` class as its primary renderer; the renderer class constructor must have a single argument, being the component to be rendered; overrides previously mapped renderer entirely, to extend super class renderer functionality inject a class that extends the previous renderer class [decorator] */
export function mapComponentRenderer<ComponentT extends Component>(componentClass: typeof Component & {
    new (...args: any[]): ComponentT;
}): (target: new (component: ComponentT) => ComponentRenderer<ComponentT, any>) => void;

}

declare module "@typescene/core/UI/Components/ComponentSignal" {
import Async, { Signal } from "@typescene/core/Async";
import { Drag } from "@typescene/core/UI/Drag";
import { Component } from "@typescene/core/UI/Components/Component";
/** Signal that is emitted by a component instance as the result of a user action */
export class ComponentSignal<DataT> extends Async.Signal<DataT> {
    /** Component for which this signal will be emitted */
    static readonly component: Component;
}
export namespace ComponentSignal {
    /** Type definition for a callable (emittable) component signal class */
    interface Emittable<T> extends Signal.Emittable<T> {
        /** Emit a signal with given value, for the component this signal is attached to */
        (data?: T): void;
        /** Component for which this signal will be emitted */
        readonly component: Component;
    }
}
/** Abstract wrapper for a handler that can connect to signals derived from `ComponentSignal`; used for automatic type inference of signal handlers */
export interface ComponentSignalHandler<DataT> extends Function {
    /** Call the handler as a function */
    (data?: DataT): void;
    /** Add this EventHandler as a handler for given event signal */
    connectTo(signal: ComponentSignal.Emittable<DataT>): Async.SignalConnection;
    /** Always true, for duck typing wrapped handlers */
    isEventHandler: true;
}
/** [implementation] "Constructor" wrapper for a UI signal handler */
export abstract class ComponentSignalHandler<DataT> {
    constructor(f: (data: DataT) => void);
}
/** Interface definition of a platform agnostic keyboard event */
export interface KeyboardEvent {
    /** True if `alt` key is held down */
    altKey?: boolean;
    /** True if `ctrl` key is held down */
    ctrlKey?: boolean;
    /** True if `meta` key is held down */
    metaKey?: boolean;
    /** True if `shift` key is held down */
    shiftKey?: boolean;
    /** Key code, used with key up/down events */
    keyCode?: number;
    /** Character code (usually ASCII), used with key press events */
    which?: number;
    /** Stop the default action for this event from taking place */
    preventDefault?: () => void;
}
/** Interface definition of a platform agnostic mouse/pointer event */
export interface PointerEvent {
    /** True if `alt` key is held down */
    altKey?: boolean;
    /** True if `ctrl` key is held down */
    ctrlKey?: boolean;
    /** True if `meta` key is held down */
    metaKey?: boolean;
    /** True if `shift` key is held down */
    shiftKey?: boolean;
    /** Mouse button affected: 0 = primary, 2 = secondary */
    button?: number;
    /** Horizontal coordinate relative to the browser window */
    clientX?: number;
    /** Vertical coordinate relative to the browser window */
    clientY?: number;
    /** Stop the default action for this event from taking place */
    preventDefault?: () => void;
}
/** Interface definition of a drag event with payload */
export interface DragEvent {
    /** Event payload */
    detail: Drag.DragEventDetail;
}
/** Constructor for a component signal handler (no event data) */
export class ActionHandler extends ComponentSignalHandler<never> {
}
/** Signal that is emitted when a keyboard event occurs */
export class KeyEventSignal extends ComponentSignal<KeyboardEvent> {
}
/** Constructor for a keyboard event handler */
export class KeyHandler extends ComponentSignalHandler<KeyboardEvent> {
}
/** Signal that is emitted when a mouse/pointer event occurs */
export class PointerEventSignal extends ComponentSignal<PointerEvent> {
}
/** Constructor for a mouse/pointer event handler */
export class PointerHandler extends ComponentSignalHandler<PointerEvent> {
}
/** Signal that is emitted when a custom drag event occurs */
export class DragEventSignal extends ComponentSignal<DragEvent> {
}
/** Constructor for a drag event handler */
export class DragHandler extends ComponentSignalHandler<DragEvent> {
}

}

declare module "@typescene/core/UI/Components/Containers/Container" {
import { Page } from "@typescene/core/UI/Page";
import { Block, List, ComponentSignal } from "@typescene/core/UI/Components";
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
/** Represents a container with vertically stacked blocks */
export class Container extends Component {
    /** Create a container with given content, if any */
    constructor(content?: Block[]);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Container.Initializer) => this;
    /** Array of main content blocks, stacked top to bottom (observed) */
    content: Array<Block | undefined>;
    /** Vertical positioning of main content area within the outer boundaries of the container (observed), defaults to "top" if not defined */
    vertAlign?: "top" | "middle" | "bottom";
    /** Horizontal positioning of main content area within the outer boundaries of the container (observed), defaults to "center" if not defined; may lead to unexpected results if the contained blocks are of different widths */
    horzAlign?: "start" | "end" | "left" | "center" | "right";
    /** Max width of main content (observed); leave this blank to remove content width limitations */
    maxContentWidth: string;
    /** Set to true to make content within container scrollable; defaults to false (observed) */
    scrollable?: boolean;
    /** Flag that becomes true when the container content is scrolled all the way to the top (observable); scroll position is continuously monitored after this value is read once */
    readonly scrolledToTop: boolean | undefined;
    private _scrolledToTop?;
    /** Flag that becomes true when the container content is scrolled all the way to the bottom, or to the threshold defined by `.scrollBottomThreshold` (observable); scroll position is continuously monitored after this value is read once */
    readonly scrolledToBottom: boolean | undefined;
    private _scrolledToBottom?;
    /** Flag that becomes true when the container content is scrolled all the way to the left (observable); scroll position is continuously monitored after this value is read once */
    readonly scrolledToLeft: boolean | undefined;
    private _scrolledToLeft?;
    /** Flag that becomes true when the container content is scrolled all the way to the right (observable); scroll position is continuously monitored after this value is read once */
    readonly scrolledToRight: boolean | undefined;
    private _scrolledToRight?;
    /** Bottom scroll threshold in pixels away from the bottom of this container: when reached this position, the `.scrolledToBottom` property is set (observed, but does not directly influence current property values); can be used e.g. to trigger lazy loading of list items or trigger footer display */
    scrollBottomThreshold?: number;
    /** Top scroll threshold in pixels away from the top of this container: when reached this position, the `.scrolledToTop` property is set (observed, but does not directly influence current property values); can be used e.g. to trigger lazy loading of list items or trigger header display */
    scrollTopThreshold?: number;
    /** Signal emitted when the container content is scrolled up (i.e. content moves down relative to the viewable area of the container), only once on first scroll or after changing direction; scroll position is continuously monitored only after this signal is connected to */
    readonly ScrolledUp: ComponentSignal.Emittable<any>;
    /** Signal emitted when the container content is scrolled down (i.e. content moves up relative to the viewable area of the container), only once on first scroll or after changing direction; scroll position is continuously monitored only after this signal is connected to */
    readonly ScrolledDown: ComponentSignal.Emittable<any>;
    /** Object with options to be used when displaying this container as a page component, initially undefined (observed) */
    displayOptions?: Page.DisplayOptions;
    /** Returns true if this container contains a List component without items, optionally of given type (observable if used in getter); useful as a shortcut in a getter for .hidden on a "blank-slate" block */
    hasEmptyList(listComponentClass?: typeof List): boolean;
    /** Append a block to this container; returns this */
    appendChild(block?: Block): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
/** Represents a container with blocks that are laid out horizontally (just like text), automatically spanning multiple rows if necessary */
export class FlowContainer extends Container {
}
export namespace Container {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Component.Initializer {
        /** Property initializer: content blocks */
        content?: ComponentFactory.SpecList2;
        /** Property initializer: vertical positioning of main content area ("top", "middle", "bottom") */
        vertAlign?: UIValueOrAsync<string>;
        /** Property initializer: horizontal positioning of main content area ("start", "end", "left", "center", "right") */
        horzAlign?: UIValueOrAsync<string>;
        /** Property initializer: maximum content width */
        maxContentWidth?: UIValueOrAsync<string>;
        /** Property initializer: true for scrollable content area */
        scrollable?: UIValueOrAsync<boolean>;
        /** Property initializer: scroll-top threshold distance in pixels */
        scrollTopThreshold?: UIValueOrAsync<number>;
        /** Property initializer: scroll-bottom threshold distance in pixels */
        scrollBottomThreshold?: UIValueOrAsync<number>;
        /** Property initializer: display options (for use when displayed directly on the page) */
        displayOptions?: Page.DisplayOptions;
        /** Property initializer: true to focus first component on render */
        focusFirst?: UIValueOrAsync<boolean>;
    }
}

}

declare module "@typescene/core/UI/Components/Containers/DialogContainer" {
import { Animation } from "@typescene/core/UI/Animation";
import { Page } from "@typescene/core/UI/Page";
import { Block } from "@typescene/core/UI/Components";
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory } from "@typescene/core/UI/Components/ComponentFactory";
import { ActionHandler, ComponentSignal } from "@typescene/core/UI/Components/ComponentSignal";
import { Container } from "@typescene/core/UI/Components/Containers/Container";
import { TextButton } from "@typescene/core/UI/Components/Controls/Button";
/** Represents a modal dialog container */
export class DialogContainer extends Container {
    /** Create a new modal dialog with given content, if any */
    constructor(content?: Block[], width?: string);
    /** Default "appear" animation, added to every new DialogContainer instance by the constructor */
    static APPEAR_ANIMATION?: Animation;
    /** Default "disappear" animation, added to every new DialogContainer instance by the constructor */
    static DISAPPEAR_ANIMATION?: Animation;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: DialogContainer.Initializer) => this;
    /** Block to be displayed as a header, may be undefined (observed) */
    header?: Block;
    /** Block to be displayed as a footer, may be undefined (observed) */
    footer?: Block;
    /** Show the dialog on screen (in front of other components on the current page, if any), asynchronously after emitting the `.Opening` signal; returns a promise that is fulfilled after the dialog has been rendered */
    openAsync(): PromiseLike<void>;
    /** Remove the dialog from screen (does not emit or wait for `.Closing` signal, only emits `.Closed`); returns this */
    close(): this;
    /** Use given component as a drag handle for this dialog (and releases handle currently in use; defaults to .header) */
    setDragHandle(handle?: Component): void;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
    /** Object with options to be used when displaying this block as a page component (observed) */
    displayOptions: Page.DisplayOptions;
    /** Signal emitted by the `.open` method before displaying the dialog; if any handler throws an error then the dialog will not open */
    readonly Opening: ComponentSignal.Emittable<{}>;
    /** Signal emitted when user clicks outside dialog, presses esc or clicks DialogContainer.TopCloseButton; if any handler throws an error then the dialog will not close */
    readonly Closing: ComponentSignal.Emittable<{}>;
    /** Signal emitted when this dialog has been closed */
    readonly Closed: ComponentSignal.Emittable<{}>;
}
export namespace DialogContainer {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Container.Initializer {
        /** Property initializer: header block */
        header?: ComponentFactory.SpecEltOrList;
        /** Property initializer: footer block */
        footer?: ComponentFactory.SpecEltOrList;
        /** Signal initializer: method name or handler */
        Closing?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        Closed?: string | ActionHandler;
    }
    /** Predefined modal close button ("X") control, based on `TextButton` */
    class TopCloseButton extends TextButton {
        /** Create a modal close button ("X") control */
        constructor();
    }
}

}

declare module "@typescene/core/UI/Components/Containers/DrawerContainer" {
import { Animation } from "@typescene/core/UI/Animation";
import { Block } from "@typescene/core/UI/Components";
import { DialogContainer } from "@typescene/core/UI/Components/Containers/DialogContainer";
/** Represents a modal container displayed on the side of the screen */
export class DrawerContainer extends DialogContainer {
    /** Create a drawer component with given content, if any */
    constructor(content?: Block[], width?: string);
    /** Default "appear" animation, added to every new `DrawerContainer` instance by the constructor */
    static APPEAR_ANIMATION?: Animation;
    /** Default "disappear" animation, added to every new `DrawerContainer` instance by the constructor */
    static DISAPPEAR_ANIMATION?: Animation;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: DialogContainer.Initializer) => this;
}
/** Represents a modal container displayed on the right hand side of the screen (i.e. DrawerContainer with different alignment and animations) */
export class OppositeDrawerContainer extends DrawerContainer {
    /** Create a drawer component with given content, if any */
    constructor(content?: Block[], width?: string);
    /** Default "appear" animation, added to every new `OppositeDrawerContainer` instance by the constructor */
    static APPEAR_ANIMATION?: Animation;
    /** Default "disappear" animation, added to every new `OppositeDrawerContainer` instance by the constructor */
    static DISAPPEAR_ANIMATION?: Animation;
}

}

declare module "@typescene/core/UI/Components/Containers/LayoutContainer" {
import { Container } from "@typescene/core/UI/Components/Containers/Container";
import { ComponentFactory } from "@typescene/core/UI/Components/ComponentFactory";
import { Component } from "@typescene/core/UI/Components/Component";
/** Represents a container with sub containers on up to four sides, and a main area with vertically stacked blocks */
export class LayoutContainer extends Container {
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: LayoutContainer.Initializer) => this;
    /** Default inside gutter width, used when inside gutter container has no defined width (CSS value, initially 18rem) */
    static INSIDE_GUTTER_WIDTH: string;
    /** Default outside gutter width, used when outside gutter container has no defined width (CSS value, initially 22rem) */
    static OUTSIDE_GUTTER_WIDTH: string;
    /** Default header height, used when header container has no defined height (CSS value, initially 4rem) */
    static HEADER_HEIGHT: string;
    /** Default footer height, used when footer container has no defined height (CSS value, initially 2rem) */
    static FOOTER_HEIGHT: string;
    /** Header container, if any (observed) */
    header?: Container;
    /** Footer container, if any (observed) */
    footer?: Container;
    /** Inside gutter container, i.e. default on left side for left-to-right flow direction, if any (observed) */
    insideGutter?: Container;
    /** Outside gutter container, i.e. default on right side for left-to-right flow direction, if any (observed) */
    outsideGutter?: Container;
    /** Set to true to make content within container scrollable; defaults to true for `LayoutContainer` (observed) */
    scrollable?: boolean;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace LayoutContainer {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Container.Initializer {
        /** Property initializer: header container */
        header?: ComponentFactory.SpecEltOrList | null;
        /** Property initializer: footer container */
        footer?: ComponentFactory.SpecEltOrList | null;
        /** Property initializer: inside gutter container (i.e. on the left for default ltr mode) */
        insideGutter?: ComponentFactory.SpecEltOrList | null;
        /** Property initializer: outside gutter container (i.e. on the right for default ltr mode) */
        outsideGutter?: ComponentFactory.SpecEltOrList | null;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/BlockControl" {
import { Block } from "@typescene/core/UI/Components";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory } from "@typescene/core/UI/Components/ComponentFactory";
/** Represents a control element that contains a block */
export class BlockControl<BlockT extends Block> extends ControlElement {
    /** Create a new block control element containing the given block, if any */
    constructor(block?: BlockT);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: BlockControl.Initializer) => this;
    /** Block element, if any (observed) */
    block?: BlockT;
    /** Overall target width of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be "auto"); if a width has not been set explicitly, or is set to "auto", then the value is taken from the width of the container */
    width: string;
    /** Set the block for this component (overwrites existing value, if any); returns this */
    appendChild(c?: BlockT): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace BlockControl {
    /** initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: content block */
        block?: ComponentFactory.SpecEltOrList;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/Button" {
import { Style } from "@typescene/core/UI/Style";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { ComponentSignalHandler, ComponentSignal, PointerHandler } from "@typescene/core/UI/Components/ComponentSignal";
import { Menu } from "@typescene/core/UI/Menu";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
/** Represents a button control */
export class Button extends ControlElement {
    /** Create a button control element */
    constructor(label?: string | TextLabelFactory, icon?: string);
    /** Initialize a button control factory with given label and handler */
    static withLabel<T extends typeof Button>(this: T, label: UIValueOrAsync<string | TextLabelFactory>, clickedHandler?: string | PointerHandler): T & ComponentFactory<Button>;
    /** Initialize a button control factory with given icon and handler */
    static withIcon<T extends typeof Button>(this: T, icon: UIValueOrAsync<string>, clickedHandler?: string | PointerHandler): T & ComponentFactory<Button>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Button.Initializer) => this;
    /** Button label (observed) */
    label: string;
    /** Optional icon (see `Label#icon`; observed) */
    icon?: string;
    /** Optional icon to be appended after the label text (observed) */
    iconAfter?: string;
    /** Space reserved for icon (rem units), if > 0 (observed) */
    remGutter?: number;
    /** Optional badge text (see `Label#badge`; observed) */
    badge: string;
    /** Tooltip text (observed) */
    tooltipText: string;
    /** Disabled state (observed) */
    disabled: boolean;
    /** Set to true to enable Bootstrap style "primary" class */
    primary: boolean;
    /** Dropdown menu options to be displayed when this button is clicked (optional); defaults to undefined, set to array or ObservableArray to enable */
    dropdown?: Menu.Option[];
    /** URL/path string, or (App module) `Activity` instance or `Activity` class that will be activated when this button is clicked (optional) */
    target: any;
    /** Set to false to expand horizontally within row (observed) */
    shrinkwrap: boolean;
    /** Encapsulation of button element style (observed) */
    readonly style_button: Style;
    /** Signal emitted when a dropdown option has been selected */
    readonly DropdownClicked: ComponentSignal.Emittable<string | number>;
}
export namespace Button {
    /** Signal that is emitted when a dropdown item has been selected */
    class DropdownClickSignal extends ComponentSignal<string | number> {
    }
    /** Contains injectable method for activating targets; instantiated by `Button` */
    class Activation {
        /** Injectable method to activate given target (e.g. URL, or Activity instance or class); default ony handles URLs, `Application` instance injects more functionality here */
        activate(target: any): void;
    }
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: label text */
        label?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: icon (before label) */
        icon?: UIValueOrAsync<string>;
        /** Property initializer: icon (after label) */
        iconAfter?: UIValueOrAsync<string>;
        /** Property initializer: space reserved for icon (rem units) */
        remGutter?: UIValueOrAsync<number>;
        /** Property initializer: badge text */
        badge?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: true to disable the button */
        disabled?: UIValueOrAsync<boolean>;
        /** Property initializer: true to display as primary button */
        primary?: UIValueOrAsync<boolean>;
        /** Property initializer: dropdown items */
        dropdown?: UIValueOrAsync<Menu.Option[]>;
        /** Property initializer: target URL, or Activity instance/class */
        target?: any;
        /** Property initializer: button style */
        style_button?: UIValueOrAsync<Style | Style.StyleSet>;
        /** Signal initializer: method name or handler */
        DropdownClicked?: string | ButtonDropdownClickHandler;
    }
}
/** Constructor for a button dropdown click event handler */
export class ButtonDropdownClickHandler extends ComponentSignalHandler<string | number> {
}
/** Primary button control (shortcut for setting `.primary` on regular `Button` class) */
export class PrimaryButton extends Button {
    primary: boolean;
}
/** Button that switches between selected (active) and deselected (inactive) when clicked (shortcut for setting `toggleMode` on regular `Button` class) */
export class ToggleButton extends Button {
    constructor(label?: string | TextLabelFactory, icon?: string);
}
/** Link-styled button control ("btn-link" class) */
export class LinkButton extends Button {
}
/** Button control that is not decorated as a button */
export class TextButton extends Button {
}
/** Round button control (e.g. with an icon) */
export class RoundButton extends Button {
}

}

declare module "@typescene/core/UI/Components/Controls/ButtonGroup" {
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { ComponentRenderer } from "@typescene/core/UI/Components/ComponentRenderer";
import { Button } from "@typescene/core/UI/Components/Controls/Button";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
/** Represents a button group (toggle, tab, or toolbar) control */
export class ButtonGroup extends ControlElement {
    /** Create a button group element */
    constructor(buttons?: Button[]);
    /** Method that is called immediately after the renderer for this button group is constructed; adds observers for button activation */
    protected beforeFirstRender(renderer: ComponentRenderer<this, any>): void;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ButtonGroup.Initializer) => this;
    /** Buttons to be displayed as part of the button group, in order (observed) */
    buttons: Array<Button | undefined>;
    /** Set to true to show buttons from top to bottom (observed) */
    vertical: boolean;
    /** Set to false to expand horizontally within row (observed) */
    shrinkwrap: boolean;
    /** Currently selected button index (base 0) or -1 if no selection (observed) */
    selectedIndex: number;
    private _observableSelectedIndex?;
    /** Append a button to this group; returns this */
    appendChild(button?: Button): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace ButtonGroup {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: buttons to display */
        buttons?: ComponentFactory.SpecList;
        /** Property initializer: true to display buttons vertically */
        vertical?: UIValueOrAsync<boolean>;
        /** Property initializer: index of selected button (use with `.selectionMode` set to `ItemClick`) */
        selectedIndex?: UIValueOrAsync<number>;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/ContainerControl" {
import { Container } from "@typescene/core/UI/Components";
import { Component } from "@typescene/core/UI/Components/Component";
import { UIValueOrAsync, ComponentFactory } from "@typescene/core/UI/Components/ComponentFactory";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
/** Represents a control element that contains a container */
export class ContainerControl<ContainerT extends Container> extends ControlElement {
    /** Create a container control element that contains the given container, if any */
    constructor(container?: ContainerT);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ContainerControl.Initializer) => this;
    /** Container element (created if not set, never undefined; observed); if set to a container (other than LayoutContainer) with maxContentWidth other than auto, and this control's width is set to auto, this control will shrinkwrap to the same width as the container */
    container: ContainerT;
    /** Overall target height of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be "auto"); if a height has not been set explicitly, or is set to "auto", then the value is taken from the height of the container; for `LayoutContainer`, a value of "100%" is used if the container's height is also "auto" */
    height: string;
    /** Overall target width of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be "auto"); if a width has not been set explicitly, or is set to "auto", then the value is taken from the width of the container */
    width: string;
    /** Set the container for this component (overwrites existing value, if any); returns this */
    appendChild(c?: ContainerT): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace ContainerControl {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: wrapped container */
        container?: UIValueOrAsync<ComponentFactory<Container> | Container> | ComponentFactory.SpecList2;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/ControlElement" {
import { Component } from "@typescene/core/UI/Components/Component";
import { UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
/** UI control element base class */
export abstract class ControlElement extends Component {
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ControlElement.Initializer) => this;
    /** Width (CSS length), default "auto" (observed) */
    width: string;
    /** Set to true to shrink this element to use as little horizontal space as possible in a row; set to false to expand (observed) */
    shrinkwrap: boolean;
    /** Set to true to automatically break text across lines (observed) */
    wrapText: boolean;
}
export namespace ControlElement {
    /** Initializer for .with({ ... }) */
    interface Initializer extends Component.Initializer {
        /** Property initializer: target width of this component (CSS length) */
        width?: UIValueOrAsync<string>;
        /** Property initializer: true to occupy as little horizontal space as possible */
        shrinkwrap?: UIValueOrAsync<boolean>;
        /** Property initializer: true to focus this component */
        hasFocus?: UIValueOrAsync<boolean>;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/ControlStack" {
import { Component } from "@typescene/core/UI/Components/Component";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
/** Represents a stack control containing control elements with equal widths placed from top to bottom */
export class ControlStack extends ControlElement {
    /** Create a stack element with given content, if any */
    constructor(content?: ControlElement[]);
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ControlStack.Initializer) => this;
    /** Controls to be displayed (observed) */
    content: Array<ControlElement | undefined>;
    /** Spacing between elements (CSS value, platform default used if empty, observed) */
    spacing: string;
    /** Horizontal alignment of fixed-width elements within control stack area */
    horzAlign: "start" | "end" | "left" | "center" | "right";
    /** Set to true to shrink this component horizontally such that it occupies as little space as possible; set to false to expand horizontally within row (observed); note that shrinkwrapping a control stack with non-shrinkwrapped controls may lead to unexpected results; by default, this component observes child components and is only shrinkwrapped if all child components are shrinkwrapped */
    shrinkwrap: boolean;
    /** Append a control to this stack; returns this */
    appendChild(control?: ControlElement): this;
    /** Returns an array of directly contained components (observable) */
    getChildren(): Component[];
}
export namespace ControlStack {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: list of stacked controls */
        content?: ComponentFactory.SpecList;
        /** Property initializer: margin between controls (CSS value) */
        spacing?: UIValueOrAsync<string>;
        /** Property initializer: horizontal alignment of controls ("start", "end", "left", "center", "right") */
        horzAlign?: UIValueOrAsync<string>;
    }
}
/** Represents a stack containing control elements with equal width placed from top to bottom, with spacing set to 0 (no margin) */
export class CloseControlStack extends ControlStack {
    spacing: string;
}

}

declare module "@typescene/core/UI/Components/Controls/Icon" {
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
/** Represents an icon control (horizontally centered) */
export class Icon extends ControlElement {
    /** Create an icon element */
    constructor(icon?: string);
    /** Initialize an icon control with given icon name */
    static withIcon<T extends typeof Icon>(this: T, icon: UIValueOrAsync<string>): T & ComponentFactory<Icon>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Icon.Initializer) => this;
    /** Icon name as CSS class(es), e.g. "glyphicon-edit" or "fa-edit fa-2x" or "material-icons:file_download"; first part is repeated Bootstrap-style automatically, e.g. "fa-edit" becomes "fa fa-edit"; observed); style properties can be appended like "fa-edit color=#ccc fontSize=200%" (or font-size); use quotes to wrap values with spaces, e.g. 'fa-edit border="1px solid #ccc"' */
    icon: string;
    /** Tooltip text (observed) */
    tooltipText: string;
    /** Set to false to expand horizontally within row (observed) */
    shrinkwrap: boolean;
}
export namespace Icon {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: icon to display */
        icon?: UIValueOrAsync<string>;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | TextLabelFactory>;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/Image" {
import { Style } from "@typescene/core/UI/Style";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
/** Represents an image control */
export class Image extends ControlElement {
    /** Create an image element */
    constructor(imageUrl?: string);
    /** Initialize an image control with given URL */
    static withUrl<T extends typeof Image>(this: T, imageUrl: UIValueOrAsync<string>): T & ComponentFactory<Image>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Image.Initializer) => this;
    /** Image URL (observed) */
    imageUrl: string;
    /** Tooltip text (observed) */
    tooltipText: string;
    /** Set to false to expand horizontally within row (observed) */
    shrinkwrap: boolean;
    /** Encapsulation of image element style (observed) */
    readonly style_img: Style;
    /** True if a load error occurred (observable) */
    hasError: boolean;
    /** Promise that resolves when the image is loaded, or if an error occurred (see .hasError) */
    ready: PromiseLike<void>;
}
export namespace Image {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: image URL */
        imageUrl?: UIValueOrAsync<string>;
        /** Property initializer: image element style */
        style_img?: UIValueOrAsync<Style | Style.StyleSet>;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | TextLabelFactory>;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/InputControls/Checkbox" {
import { Style } from "@typescene/core/UI/Style";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
import { InputControl } from "@typescene/core/UI/Components/Controls/InputControls/InputControl";
/** Represents a single checkbox or radio button control */
export class Checkbox extends InputControl {
    /** Create a checkbox element */
    constructor(name?: string, label?: string | TextLabelFactory, type?: Checkbox.Type, checked?: boolean);
    /** Initialize a checkbox control factory with given values */
    static withName<T extends typeof Checkbox>(this: T, name: string, label?: string | TextLabelFactory, checked?: boolean, value?: string): T & ComponentFactory<Checkbox>;
    /** Initialize a radio button control factory with given values */
    static withRadioName<T extends typeof Checkbox>(this: T, name: string, label?: string | TextLabelFactory, checked?: boolean, value?: string): T & ComponentFactory<Checkbox>;
    /** Initialize with given (observable) values; returns this */
    initializeWith: (values: Checkbox.Initializer) => this;
    /** Type: checkbox or radio button (observed), defaults to checkbox */
    type: Checkbox.Type;
    /** Text value used when selected (observed), defaults to "checked" */
    value: string;
    /** Current selection status (observable) */
    checked: boolean;
    /** Set to false to expand horizontally within row (observed) */
    shrinkwrap: boolean;
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: any): any;
    /** Sets all input values by element name */
    setFormValues(values: any): void;
    /** Encapsulation of inner text element style (observed) */
    readonly style_text: Style;
}
export namespace Checkbox {
    enum Type {
        Checkbox = 0,
        Radio = 1,
    }
    /** Initializer for .with({ ... }) */
    interface Initializer extends InputControl.Initializer {
        /** Property initializer: true to check checkbox/radio */
        checked?: UIValueOrAsync<boolean | undefined>;
        /** Property initializer: checkbox or radio */
        type?: UIValueOrAsync<Checkbox.Type>;
        /** Property initializer: text element style */
        style_text?: UIValueOrAsync<Style | Style.StyleSet>;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/InputControls/InputControl" {
import { Style } from "@typescene/core/UI/Style";
import { ActionHandler, ComponentSignal } from "@typescene/core/UI/Components/ComponentSignal";
import { UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
/** Input field control base class (abstract) */
export abstract class InputControl extends ControlElement {
    /** Input value (read/write) */
    value: string;
    /** Form input property name, if any (observed) */
    name: string;
    /** Label text (observed) */
    label: string;
    /** Tooltip text (observed) */
    tooltipText: string;
    /** True if input is disabled and read-only (observed) */
    disabled: boolean;
    /** Encapsulation of label element style (observed) */
    readonly style_label: Style;
    /** Encapsulation of input element style (observed) */
    readonly style_input: Style;
    /** Signal emitted when the input value is committed (on change); captured from containers down to contained components, not consumed */
    readonly ValueChange: ComponentSignal.Emittable<any>;
    /** Signal emitted immediately before the input value changes (on input); captured from containers down to contained components, not consumed */
    readonly ValueInput: ComponentSignal.Emittable<any>;
}
export namespace InputControl {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: form input property name */
        name?: string;
        /** Property initializer: input value */
        value?: UIValueOrAsync<string>;
        /** Property initializer: label text */
        label?: UIValueOrAsync<string | undefined> | TextLabelFactory;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | undefined> | TextLabelFactory;
        /** Property initializer: true to disable this input */
        disabled?: UIValueOrAsync<boolean>;
        /** Property initializer: label style */
        style_label?: UIValueOrAsync<Style | Style.StyleSet>;
        /** Property initializer: input style */
        style_input?: UIValueOrAsync<Style | Style.StyleSet>;
        /** Signal initializer: method name or handler */
        ValueChange?: string | ActionHandler;
        /** Signal initializer: method name or handler */
        ValueInput?: string | ActionHandler;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/InputControls/SelectField" {
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
import { InputControl } from "@typescene/core/UI/Components/Controls/InputControls/InputControl";
/** Represents a native dropdown selection field control */
export class SelectField extends InputControl {
    /** Create a select field element */
    constructor(name?: string, label?: string | TextLabelFactory, options?: SelectField.Option[]);
    /** Initialize a select field control factory with given name, label, and options */
    static withOptions<T extends typeof SelectField>(this: T, name: string, label?: string | TextLabelFactory, options?: UIValueOrAsync<SelectField.Option[]>): T & ComponentFactory<SelectField>;
    /** Initialize with given (observable) values; returns this */
    initializeWith: (values: SelectField.Initializer) => this;
    /** List of options and their values (observed) */
    options: Array<SelectField.Option | undefined>;
    /** Currently selected value (read/write observable) */
    value: string;
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: any): any;
    /** Sets all input values by element name */
    setFormValues(values: any): void;
}
export namespace SelectField {
    /** Represents a select field option */
    interface Option {
        /** Selection value */
        value?: string;
        /** Text label */
        text: string | TextLabelFactory;
    }
    /** Initializer for .with({ ... }) */
    interface Initializer extends InputControl.Initializer {
        /** Property initializer: options with text labels and (optional) values */
        options?: UIValueOrAsync<SelectField.Option[]>;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/InputControls/TextField" {
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
import { InputControl } from "@typescene/core/UI/Components/Controls/InputControls/InputControl";
/** Represents a single- or multi-line text input field control */
export class TextField extends InputControl {
    /** Create a text field */
    constructor(name?: string, label?: string | TextLabelFactory, textareaLines?: number);
    /** Initialize a text field control factory with given name, label, and placeholder */
    static withName<T extends typeof TextField>(this: T, name: string, label?: string | TextLabelFactory, placeholderText?: string | TextLabelFactory): T & ComponentFactory<TextField>;
    /** Initialize with given (observable) values; returns this */
    initializeWith: (values: TextField.Initializer) => this;
    /** Number of rows for a multiline text field, default 0 (NOT observed) */
    textareaLines: number;
    /** Text field type (text, password, number, etc.; observed) */
    type: TextField.Type;
    /** Current input value (read/write observable) value changes only on blur or enter press unless `.immediateValueUpdate` is set */
    value: string;
    /** Placeholder text (observed) */
    placeholderText: string;
    /** Set to true to update `.value` immediately after the input field text has changed, instead of only on blur or enter press (observed) */
    immediateValueUpdate: boolean;
    /** Select (a part of) the text in this text field, returns this */
    selectText(start?: number, end?: number): this;
    /** Returns an object containing all current values of input elements (observable) */
    getFormValues(result?: any): any;
    /** Sets all input values by element name */
    setFormValues(values: any): void;
}
export namespace TextField {
    /** Text field type options (e.g. Text, Password, Email etc.) */
    enum Type {
        Text = 0,
        Password = 1,
        DateTime = 2,
        Date = 3,
        Month = 4,
        Time = 5,
        Week = 6,
        Number = 7,
        Email = 8,
        Url = 9,
        Search = 10,
        Tel = 11,
        Color = 12,
    }
    /** Initializer for .with({ ... }) */
    interface Initializer extends InputControl.Initializer {
        /** Property initializer: number of text area lines */
        textareaLines?: UIValueOrAsync<number>;
        /** Property initializer: text field type */
        type?: UIValueOrAsync<TextField.Type>;
        /** Property initializer: placeholder text */
        placeholderText?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: true to update value immediately on input */
        immediateValueUpdate?: UIValueOrAsync<boolean>;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/Label" {
import { Style } from "@typescene/core/UI/Style";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
/** Represents a minimal text control with icon and badge */
export class Label extends ControlElement {
    /** Create a label element */
    constructor(text?: string | TextLabelFactory, icon?: string, remGutter?: number, badge?: string | TextLabelFactory);
    /** Initialize a text control factory with given text and style */
    static withText<T extends typeof Label>(this: T, text: UIValueOrAsync<string | TextLabelFactory>, style?: UIValueOrAsync<Style | Style.StyleSet>): T & ComponentFactory<Label>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Label.Initializer) => this;
    /** Set to false to expand horizontally within row (default true; observed) */
    shrinkwrap: boolean;
    /** Text to display (observed) */
    text: string;
    /** Smaller text to display before/above `.text`, e.g. as a sub heading (observed) */
    textBefore: string;
    /** Smaller text to display after/below `.text`, e.g. as a sub heading (observed) */
    textAfter: string;
    /** Icon to be placed in front of the label text (CSS class(es), e.g. "glyphicon-edit" or "fa-edit fa-2x" or "material-icons:file_download"; first part is repeated Bootstrap-style automatically, e.g. "fa-edit" becomes "fa fa-edit"; observed); style properties can be appended like "fa-edit color=#ccc fontSize=200%" (or font-size); use quotes to wrap values with spaces, e.g. 'fa-edit border="1px solid #ccc"' */
    icon?: string;
    /** Space reserved for icon (rem units), if > 0 (observed) */
    remGutter: number;
    /** Badge text, if any (observed) */
    badge: string;
    /** Tooltip text (observed) */
    tooltipText: string;
}
export namespace Label {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: text to display */
        text?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: text to display */
        textBefore?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: text to display */
        textAfter?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: icon to display */
        icon?: UIValueOrAsync<string>;
        /** Property initializer: space reserved for icon, in rem units */
        remGutter?: UIValueOrAsync<number>;
        /** Property initializer: badge text to display */
        badge?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | TextLabelFactory>;
    }
}
/** Stretched label control: a label that expands horizontally, while not breaking across lines (uses ellipsis if available) */
export class WideLabel extends Label {
    /** Set to true to shrink horizontally (default false; observed) */
    shrinkwrap: boolean;
}
/** Paragraph control: a label that expands horizontally, with text that breaks automatically across lines, and added line spacing for enhanced readability */
export class Paragraph extends Label {
    /** Set to true to shrink horizontally (default false; observed) */
    shrinkwrap: boolean;
    /** Automatically break text across lines (default true, observed) */
    wrapText: boolean;
}
/** H1 label control */
export class Heading1 extends Label {
}
/** H2 label control */
export class Heading2 extends Label {
}
/** H3 label control */
export class Heading3 extends Label {
}
/** H4 label control */
export class Heading4 extends Label {
}
/** H5 label control */
export class Heading5 extends Label {
}
/** H6 label control */
export class Heading6 extends Label {
}

}

declare module "@typescene/core/UI/Components/Controls/ProgressBar" {
import { Style } from "@typescene/core/UI/Style";
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { TextLabelFactory } from "@typescene/core/UI/Components/TextLabelFactory";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
/** Represents a progress bar control (full width by default) */
export class ProgressBar extends ControlElement {
    /** Create a progress bar control element */
    constructor(progress?: number);
    /** Initialize a progress bar control factory with given progress value (0-1) */
    static withProgress<T extends typeof ProgressBar>(this: T, progress: UIValueOrAsync<number>): T & ComponentFactory<ProgressBar>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: ProgressBar.Initializer) => this;
    /** Current progress value, between 0 and 1, inclusive (observed) */
    progress: number;
    /** Tooltip text (observed) */
    tooltipText: string;
    /** Encapsulation of inner bar style (observed) */
    readonly style_bar: Style;
}
export namespace ProgressBar {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
        /** Property initializer: progress value (0-1) */
        progress?: UIValueOrAsync<number>;
        /** Property initializer: tooltip text */
        tooltipText?: UIValueOrAsync<string | TextLabelFactory>;
        /** Property initializer: inner bar element style */
        style_bar?: UIValueOrAsync<Style | Style.StyleSet>;
    }
}

}

declare module "@typescene/core/UI/Components/Controls/Spacer" {
import { ComponentFactory, UIValueOrAsync } from "@typescene/core/UI/Components/ComponentFactory";
import { ControlElement } from "@typescene/core/UI/Components/Controls/ControlElement";
/** Represents an empty control element to take up horizontal space within a row */
export class Spacer extends ControlElement {
    /** Create a spacer element with given height (default 1px) */
    constructor(height?: string);
    /** Initialize a spacer control factory with given size (CSS lengths); also sets `.shrinkwrap` to true if a width is given */
    static withSize<T extends typeof Spacer>(this: T, width?: UIValueOrAsync<string>, height?: UIValueOrAsync<string>): T & ComponentFactory<Spacer>;
    /** Initialize with given (observable) properties; returns this */
    initializeWith: (values: Spacer.Initializer) => this;
}
export namespace Spacer {
    /** Initializer for .with({ ... }) */
    interface Initializer extends ControlElement.Initializer {
    }
}

}

declare module "@typescene/core/UI/Components/TextLabelFactory" {
import Async from "@typescene/core/Async";
import { Binding } from "@typescene/core/UI/Binding";
import { Label } from "@typescene/core/UI";
import { Component } from "@typescene/core/UI/Components/Component";
/** Shared factory implementation for a piece of text as a string and/or as (an observable value representing) a Label instance (or sub class); can be used in Component factory specs using UI.tl(...) or with backticks */
export class TextLabelFactory {
    /** Create the text label factory using the given string, stringable (object with a `toString` method), or observable value, along with an optional array of (observable) substitution arguments or a function that returns such an array for a component to bind to, and a Label base class that is used if not overridden by string content prefix */
    constructor(text: {
        toString: () => string;
    } | Async.ObservableValue<{
        toString: () => string;
    }>, args?: Array<string | Async.ObservableValue<string>> | ((baseComponent: Component, propertyName: string) => Array<string | Async.ObservableValue<string>>), observeArgs?: boolean, baseClass?: typeof Label);
    /** Get the (translated) encapsulated text as a string; adds a dependency on the observable value if called from an observable value getter; trims {...} prefix if present */
    toString(): string;
    /** Get the encapsulated text wrapped in a new Label (or derived) instance, or an observable value representing the instance; uses {...} prefix to control component type and its properties; parameters are used by component factory to initialize bindings used in `tl` strings, if any */
    getComponent(baseComponent?: Component, propertyName?: string): Label | Async.ObservableValue<Label>;
    /** Injectable method to translate given text (including substitution and pluralization placeholders); injected by App sub module to proxy the `culture` service */
    ["@translateText"](text: string): string;
    /** Injectable method to pick a plural form for given number; defaults to English (singular/plural) forms; injected by App sub module to proxy the `culture` service */
    ["@pluralizeText"](n: number, forms: string[]): string;
    /** Returns string value with specific substituted arguments */
    private _toString(args?);
    /** Helper function to turn text into a component instance (possibly reusing given old Label instance) */
    private _createComponent(str, prev?);
    private _baseClass;
    private _value;
    private _args?;
    private _observe?;
}
/** Tagged template string function that returns a text label factory instance to be used with component factory content lists; functions in the expanded values (i.e. result of `${...}`), and bindings (instanceof Binding), are used as getters for nested observable string values (e.g. `${() => ...}` is observed and converted to a string); pluralization forms can be substituted based on existing arguments by number (base 1) using e.g. `%{1|is|are}`; prefixes can be used to change the type of component factory created and its styles and properties:
 * * `{p}` for Paragraph,
 * * `{h1-6}` for Heading,
 * * `{w}` for WideLabel,
 * * `{b|i|u}` for text styles,
 * * `{left|center|right}` for alignment,
 * * `{#...}` for text colors,
 * * `{nnn}` for font weights,
 * * `{icon:...}` for icons,
 * * `{icon:... property-name=...}` for icon style properties,
 * * `{property-name=...}` or `{propertyName=...}` for individual style properties,
 * * `{.classname}` and `{.class1.class2}` for class name(s),
 * * `{...%|...em|...rem| etc.}` for font sizes, and
 * * `{l:...%|...rem| etc.}` for Label with given width;
 *
 * Prefixes can be combined using the pipe | symbol and may also be the result of an expanded value (i.e. first ${...} part)
 */
export function tl(strings: TemplateStringsArray, ...values: any[]): TextLabelFactory;
/** Simplified version of tagged template helper .tl\`...\` with a single piece of text, possibly with a base Label class that is used if given string does not override the class using e.g. `{p}` or `{h1}` */
export function tl(text: string | Async.ObservableValue<string>, baseClass?: typeof Label): TextLabelFactory;
/** Simplified version of tagged template helper .tl\`...\` observing a single piece of text, possibly with a base Label class that is used if given string does not override the class using e.g. `{p}` or `{h1}` */
export function tl(getter: () => (string | Async.ObservableValue<string>), baseClass?: typeof Label): TextLabelFactory;
/** Simplified version of tagged template helper .tl\`...\` observing a single binding, possibly with a base Label class that is used if given string does not override the class using e.g. `{p}` or `{h1}` */
export function tl(getter: Binding<string>, baseClass?: typeof Label): TextLabelFactory;

}

declare module "@typescene/core/UI/Components" {
export * from "@typescene/core/UI/Components/Component";
export * from "@typescene/core/UI/Components/ComponentSignal";
export * from "@typescene/core/UI/Components/ComponentFactory";
export * from "@typescene/core/UI/Components/ComponentRenderer";
export * from "@typescene/core/UI/Components/TextLabelFactory";
export * from "@typescene/core/UI/Components/Containers/Container";
export * from "@typescene/core/UI/Components/Containers/DialogContainer";
export * from "@typescene/core/UI/Components/Containers/DrawerContainer";
export * from "@typescene/core/UI/Components/Containers/LayoutContainer";
export * from "@typescene/core/UI/Components/Blocks/Block";
export * from "@typescene/core/UI/Components/Blocks/Card";
export * from "@typescene/core/UI/Components/Blocks/ContainerBlock";
export * from "@typescene/core/UI/Components/Blocks/Divider";
export * from "@typescene/core/UI/Components/Blocks/List";
export * from "@typescene/core/UI/Components/Blocks/TreeList";
export * from "@typescene/core/UI/Components/Blocks/TreeListRow";
export * from "@typescene/core/UI/Components/Blocks/NavList";
export * from "@typescene/core/UI/Components/Blocks/Row";
export * from "@typescene/core/UI/Components/Blocks/Table";
export * from "@typescene/core/UI/Components/Blocks/TableRow";
export * from "@typescene/core/UI/Components/Controls/ControlElement";
export * from "@typescene/core/UI/Components/Controls/BlockControl";
export * from "@typescene/core/UI/Components/Controls/Button";
export * from "@typescene/core/UI/Components/Controls/ButtonGroup";
export * from "@typescene/core/UI/Components/Controls/ContainerControl";
export * from "@typescene/core/UI/Components/Controls/ControlStack";
export * from "@typescene/core/UI/Components/Controls/Icon";
export * from "@typescene/core/UI/Components/Controls/Image";
export * from "@typescene/core/UI/Components/Controls/Label";
export * from "@typescene/core/UI/Components/Controls/ProgressBar";
export * from "@typescene/core/UI/Components/Controls/Spacer";
export * from "@typescene/core/UI/Components/Controls/InputControls/InputControl";
export * from "@typescene/core/UI/Components/Controls/InputControls/Checkbox";
export * from "@typescene/core/UI/Components/Controls/InputControls/SelectField";
export * from "@typescene/core/UI/Components/Controls/InputControls/TextField";

}

declare module "@typescene/core/UI/Drag" {
import { Signal } from "@typescene/core/Async";
import { Component, PointerEvent } from "@typescene/core/UI";
/** Represents a drag operation (created by static .start(...) method) */
export abstract class Drag {
    /** Returns a list of current drag operations (for forwards compatibility, supporting multi touch); use this while handling drag events, e.g. get/set .detail with custom data, or observe coordinates) */
    static getCurrentInstances(): Drag[];
    /** Start tracking mouse movement based on given event (with initial screen coordinates); creates a new instance of a platform specific class derived from Drag with given payload data; Drop targets may listen for drag events (enter/leave/drop), and use information from the data object to respond */
    static start(event: PointerEvent, data?: any): Drag;
    /** Event payload data for this operation (sealed observable object) */
    readonly detail: Drag.DragEventDetail;
    /** Current screen X coordinate (read-only observable, constrained) */
    readonly abstract x: number;
    /** Current screen Y coordinate (read-only observable, constrained) */
    readonly abstract y: number;
    /** Resolves to `this` when the observed coordinates actually change by a reasonable amount (to distinguish from a click), useful e.g. for calling `.pickUp(...)` only when resolved */
    readonly abstract moved: PromiseLike<Drag>;
    /** Signal emitted when the drag operation completes successfully */
    readonly Dropped: Signal.Emittable<Drag>;
    /** Signal emitted when the drag operation is canceled */
    readonly Canceled: Signal.Emittable<Drag>;
    /** Constrain effective drag coordinates on (original) X and/or Y axis of the viewport, and/or contrain to stay within given component on screen (calling this method twice does not constrain further, but the constraints are replaced) */
    abstract constrain(constrainX?: boolean, constrainY?: boolean, component?: Component): void;
    /** Make given component follow the mouse cursor while dragging */
    abstract pickUp(component: Component, removeWhenDone?: boolean): void;
    /** Stop this drag operation, emits the `.Canceled` signal; throws an exception if this operation was already canceled or dropped */
    cancel(): void;
    /** Accept the current drop target (i.e. perform the drop, called automatically based on input events, but can be called manually as well), emits the `.Dropped` signal; throws an exception if this operation was already canceled or dropped */
    drop(): void;
}
export namespace Drag {
    /** Details that are emitted along with a drag event */
    interface DragEventDetail {
        /** Platform-specific drag event identifier (may be undefined) */
        id: undefined;
        /** Application defined payload to identify the object being dragged */
        data: undefined;
    }
}

}

declare module "@typescene/core/UI/Menu" {
import { Component, PointerEvent, TextLabelFactory } from "@typescene/core/UI";
/** Contains methods for displaying dropdown menus and context menus */
export namespace Menu {
    /** Display a modal context menu; returns a Promise that resolves to the index(base 1)/key of the selected menu item, or is rejected if the user cancels the context menu */
    function displayContextMenu(options: Menu.Option[], event: PointerEvent): PromiseLike<string | number>;
    /** Display a modal dropdown menu below the given component (or above, depending on available screen space); returns a Promise that resolves to the index(base 1)/key of the selected menu item, or is rejected if the user cancels the context menu */
    function displayDropdown(options: Menu.Option[], component: Component): PromiseLike<string | number>;
    /** Dismiss the menu currently on screen, if any */
    function dismiss(): void;
    /** Represents a context/dropdown menu option or divider */
    interface Option {
        /** Optional key (string) used as an identifier */
        key?: string;
        /** Menu item label text */
        label?: string | TextLabelFactory;
        /** Menu item icon */
        icon?: string;
        /** Menu item icon displayed on the far side, next to where a sub menu would open */
        sideIcon?: string;
        /** Set to true to disable this menu item */
        disabled?: boolean;
        /** Set to true (and leave other properties out) to display a divider instead of a menu option in this position */
        divider?: boolean;
        /** Sub menu options, displayed when this item is selected/focused */
        subMenu?: Option[];
    }
}

}

declare module "@typescene/core/UI/Page" {
import { Signal } from "@typescene/core/Async";
import { Component, KeyboardEvent } from "@typescene/core/UI";
/** Represents a page to be displayed on screen */
export class Page {
    /** Returns the page currently displayed on screen, if any (observable) */
    static getCurrentPage(): Page | undefined;
    /** Returns a new Page class with a constructor that creates instances of given component classes and appends them to the page content array */
    static withContent(...componentClasses: Array<{
        new (): Component;
    }>): {
        new (): Page;
    };
    /** Create a page with given content, if any */
    constructor(content?: Array<Component | undefined>);
    /** Globally unique page identifier */
    readonly uid: string;
    /** Components that are displayed on this page, each component stacked on top of the previous one along the z-axis (observed) */
    content: Array<Component | undefined>;
    /** Returns the nearest matching child element with given ID, if any (observable) */
    getComponentById(id: string): Component | undefined;
    /** Returns the nearest matching child element with given ID _and_ that is an instance of given class, if any (observable) */
    getComponentById<C extends Component>(id: string, componentClass: typeof Component & {
        new (...p: any[]): C;
    }): C | undefined;
    /** Returns all (recursive) child elements that are an instance of given class (observable) */
    getComponentsByType<C extends Component>(componentClass: typeof Component & {
        new (...p: any[]): C;
    }): C[];
    /** Returns true if given component is a child component of this page or any of its child components (observable, but triggers re-evaluation upon every change in child [sub] components) */
    contains(component: Component): boolean;
    /** Invoke the `onEsc` handler of the component closest to the foreground that defines it (usually a modal dialog container in the foreground); returns true if handler was called, otherwise does nothing and returns false */
    handleEsc(): boolean;
    /** Scroll the page and all parent components of given component, such that the entire component becomes visible */
    scrollTo(component: Component): void;
    /** Display this page on screen; also re-enables the page if input was blocked; replaces the currently displaying page on screen, which is removed automatically, but the result may be an empty screen if this page has no content; always waits for `Screen.ready`; returns a promise that is fulfilled when the components on this page have been rendered */
    displayAsync(): PromiseLike<void>;
    /** Remove this page from the screen, if currently displayed; returns this */
    remove(): this;
    /** Block all input events on this page, until given promise is resolved, or until page is re-displayed */
    disable(promise?: PromiseLike<any>): void;
    /** Signal that is emitted after this page is displayed on screen */
    readonly Displayed: Signal.VoidEmittable;
    /** Signal that is emitted after this page has been removed from the screen */
    readonly Removed: Signal.VoidEmittable;
    /** Signal that is emitted after the content of this page has been (re-) rendered, e.g. when a component is added or removed (but not when one of the components itself is re-rendered due to changes in its own sub content, use the `Component#Rendered` signal for that) */
    readonly Rendered: Signal.VoidEmittable;
    /** Signal that is emitted when a key is being pressed on the keyboard, while this page is displayed in the foreground */
    readonly KeyDown: Signal.Emittable<KeyboardEvent>;
    /** Layout/text flow direction for switching between left-to-right and right-to-left languages */
    flowDirection?: "ltr" | "rtl";
    /** @Internal disabled state */
    private _disabled?;
}
export namespace Page {
    /** Options to be set on the `.displayOptions` object property of a component, if any, to define its positioning and behavior when displayed directly on a page */
    interface DisplayOptions {
        /** Set to true to add a backdrop behind this component */
        shade?: boolean;
        /** Set to true to float this component on top of previous components on the page, and block input to components below */
        modal?: boolean;
        /** Set to true to keep this component on top of all other components; only relevant if `.modal` is also true */
        stayOnTop?: boolean;
        /** Vertical alignment of this component relative to the page; only relevant if `.modal` is also true */
        modalVertAlign?: "top" | "middle" | "bottom";
        /** Horizontal alignment of this component relative to the page; only relevant if `.modal` is also true */
        modalHorzAlign?: "start" | "end" | "left" | "center" | "right";
        /** Margin around the side(s) of this component that are aligned to the side(s) of the screen (CSS length value, defaults to 0) */
        alignMargin?: string;
        /** Margin around the side(s) of this component that are away from the side(s) of the screen (CSS length value, defaults to 0) */
        outerMargin?: string;
        /** Flow direction: `ltr` or `rtl`, defaults to `ltr` if not set */
        flowDirection?: "ltr" | "rtl";
        /** Callback invoked when the user clicks or touches outside of this component, presses a modal-close button, or presses the escape key */
        onEsc?: () => void;
    }
}

}

declare module "@typescene/core/UI/Screen" {
import Async from "@typescene/core/Async";
import { Component, Page } from "@typescene/core/UI";
/** Methods for managing the available (fixed) screen space in the application viewport */
export namespace Screen {
    /** Display given view in the foreground, replacing the current page or adding to it (or to a new blank page, if none was displayed); returns a promise that is fulfilled after the component is rendered */
    function displayAsync(view: Component | Page): PromiseLike<void>;
    /** Returns true if given Page is currently displayed, or given Component is displayed _directly_ on the current page (i.e. not as a child component) */
    function isDisplayed(view: Component | Page): boolean | undefined;
    /** Remove given component from the page (i.e. the page it was _last displayed_ on using the `.display(...)` method) */
    function remove(view: Component): void;
    /** Remove given page from the screen, if it is currently displayed */
    function remove(view: Page): void;
    /** Promise that resolves to true when ready to display the UI, after all static resources have been loaded */
    const ready: PromiseLike<true>;
    /** Default flow direction for all pages upon rendering (if not overridden at page or component level); this value is set asynchronously by the `App` sub module when the current `App.CultureService` changes */
    var defaultFlowDirection: "ltr" | "rtl" | undefined;
    /** Viewport dimensions (sealed observable object) */
    const dimensions: Dimensions & Async.ObservableObject;
    /** Type definition for the `Screen.dimensions` observable object */
    interface Dimensions extends Async.ObservableObject {
        /** Number of logical pixels available on horizontal axis (observable) */
        readonly width: number;
        /** Number of logical pixels available on vertical axis (observable) */
        readonly height: number;
        /** True if the width of the viewport is greater than its height */
        readonly isLandscape: boolean;
        /** True if viewport width is less than NARROW_WIDTH; implies that .isSmall is also true (observable) */
        readonly isNarrow: boolean;
        /** True if viewport width is less than SMALL_WIDTH (observable) */
        readonly isSmall: boolean;
        /** True if viewport width is WIDE_WIDTH or above (observable) */
        readonly isWide: boolean;
        /** True if viewport width is EXTRAWIDE_WIDTH or above; implies that .isWide is also true (observable) */
        readonly isExtraWide: boolean;
    }
    /** "Narrow" horizontal root width in logical pixels, default 550 */
    var NARROW_WIDTH: number;
    /** "Small" horizontal root width in logical pixels, default 720 */
    var SMALL_WIDTH: number;
    /** "Wide" horizontal root width in logical pixels, default 960 */
    var WIDE_WIDTH: number;
    /** "Extra wide" horizontal root width in logical pixels, default 1200 */
    var EXTRAWIDE_WIDTH: number;
}

}

declare module "@typescene/core/UI/Style" {
import Async from "@typescene/core/Async";
/** Encapsulates CSS style properties, classes, and hidden/selected attributes; these styles are observed when applied to components on screen, by themselves or overridden using another Style instance (see `.override(...)`); properties are always applied in alphabetical order, i.e `backgroundColor` after `background`, `paddingTop` after `padding`, etc. */
export class Style {
    /** Create a Style instance that only contains given class name(s); alias for new Style(undefined, className) */
    static withClass(className: string): Style;
    /** Create a new instance with given styles; class name argument may contain multiple class names separated with spaces */
    constructor(styles?: Style.StyleSet, className?: string, hidden?: boolean);
    /** Globally unique ID for this Style instance */
    readonly uid: string;
    /** Add the given class name(s); returns this */
    addClass(...classNames: string[]): this;
    /** Remove the given class name(s), from this instance as well as any instances that this instance overrides; returns this */
    removeClass(...classNames: string[]): this;
    /** Remove (all) existing CSS class name(s) and use given class(es) (only on this Style instance, not on overriding or overridden styles); returns this */
    setClass(...classNames: string[]): this;
    /** Returns the current CSS class name(s) stored in this instance (observable) */
    getClassName(): string;
    /** Returns value for given property; the property must be set explicitly on this Style instance or overriding Style instances */
    get(propertyName: string): string | undefined;
    /** Add a drop shadow effect, with given depth factor (0-1); returns this */
    addShadowEffect(depth: number | Async.ObservableValue<number>): this;
    /** Add the "hidden" attribute; returns this */
    hide(): this;
    /** Map the "hidden" attribute to the value of given observable; returns this */
    hide(hidden?: boolean | Async.ObservableValue<boolean>): this;
    /** Remove the "hidden" attribute; returns this */
    show(): this;
    /** Returns hidden state for this Style instance, true if explicitly hidden, false if explicity shown, undefined otherwise (observable) */
    isHidden(): string | boolean | undefined;
    /** Add the "selected" attribute; returns this */
    select(): this;
    /** Map the "selected" attribute to the value of given observable; returns this */
    select(selected?: boolean | Async.ObservableValue<boolean>): this;
    /** Remove the "selected" attribute; returns this */
    deselect(): this;
    /** Returns selection state for this Style instance, true if explicitly selected, false if explicity deselected, undefined otherwise (observable) */
    isSelected(): string | boolean | undefined;
    /** Set a style property; if given value is observable, this value will be observed while this Style instance is applied to an element on screen; returns this */
    set(propertyName: string, value: string | Async.ObservableValue<string>): this;
    /** Set multiple style properties using values (strings or `ObservableValue` instances) in given object; if given object is an `ObservableObject`, only _existing observable_ properties are observed; returns this */
    set(obj: Style.StyleSet | Async.ObservableObject): this;
    /** Override styles and classes with those from given Style instance; returns this */
    override(style?: Style | Style.StyleSet | Async.ObservableObject | Async.ObservableValue<Style | Style.StyleSet | Async.ObservableObject | undefined>): this;
    /** Returns a list that consists of this Style instance itself, plus any recursively overriding Style instances in effect; except for instances without any non-empty properties or classes (observable) */
    getOverrides(): Style[];
    /** Helper method to set an observable property on `._props` to given value and set `._status` accordingly; creates the `._props` object, makes the property observable, and adds the property name to the `._keys` array if needed (but does NOT sort it) */
    private _setProperty(name, value?);
}
export namespace Style {
    /** A set of styles: properties with CSS values, e.g. { textAlign: "left" }; the operator "||" may be used within CSS value strings to indicate fallbacks for older platforms, e.g. "start || left" where "left" is applied before "start" */
    interface StyleSet {
        [cssProperty: string]: string | Async.ObservableValue<string>;
    }
}

}

declare module "@typescene/core/UI" {
export * from "@typescene/core/UI/Components";
export * from "@typescene/core/UI/Style";
export * from "@typescene/core/UI/Page";
export * from "@typescene/core/UI/Screen";
export * from "@typescene/core/UI/Binding";
export * from "@typescene/core/UI/Animation";
export * from "@typescene/core/UI/Drag";
export * from "@typescene/core/UI/Menu";

}

declare module "@typescene/core/UI" {
export * from "@typescene/core/UI/index";
import * as UI from "@typescene/core/UI/index";
export default UI;

}

declare module "@typescene/core" {
import Async from "@typescene/core/Async";
import * as UI from "@typescene/core/UI";
import * as App from "@typescene/core/App";
export { Async, UI, App };
declare const _default: {
    Async: typeof Async;
    UI: typeof UI;
    App: typeof App;
};
export default _default;

}

declare module "@typescene/dom/App/DOMApplication" {
import { Application } from "@typescene/core/App";
/** Platform specific encapsulation of the application as a singleton object */
export class DOMApplication extends Application {
    /** Disable synchronization of activity stack with browser history */
    static disableBrowserHistory(): void;
    /** Create the application instance (either from a derived class or from the Application class itself); can be called only once */
    constructor(title?: string);
    /** Returns the full URL from `window.location.href`; used to resolve relative URLs to start routed activities */
    protected getCurrentUrl(): string;
    /** Sets the browser's current URL (using `window.location.href`), to navigate to another page or website */
    protected navigateToUrl(url: string): void;
    private _startLocationActivity(replace?);
    private _updateHistoryState(op?);
}

}

declare module "@typescene/dom/App/Http" {
import { Signal } from "@typescene/core/Async";
/** Namespace that encapsulates `.fetch` and related functionality */
export namespace Http {
    /** Configuration options */
    var config: GlobalConfig;
    /** Configuration options (for exported `config` variable) */
    interface GlobalConfig {
        /** Force `fetch` to use XMLHttpRequest instead of native `fetch` implementation (defaults to false) */
        FORCE_XHR_FETCH: boolean;
        /** Automatically set `fetch` credentials mode to "include" (defaults to true) */
        FETCH_INCLUDE_CREDENTIALS: boolean;
    }
    /** Signal that is emitted before sending a request; can be used to intercept requests, modify request options, and provide an alternate response; if one of the connected handlers returns a (promise for) an alternate response, i.e. an object that implements `FetchResponse`, then the request will not be sent, and the (first) resulting alternate response is used instead; if one of the connected handlers throws an exception, the original promise for the request is rejected; otherwise the request is sent as per normal */
    var Requesting: Signal.Emittable<FetchOptions>;
    /** Signal that is emitted after obtaining a remote response (from an actual request, not an alternate response provided by a connected handler of `.Requesting`) */
    var Responded: Signal.Emittable<FetchResponse>;
    /** Definition of a collection of HTTP headers as an object */
    interface Headers {
        [headerName: string]: string;
    }
    /** Interface definition for the simple read-only methods of a native Headers instance */
    interface FetchHeaders {
        /** Returns the first value of a single header by name */
        get(name: string): string;
        /** Returns all values of a single header by name (e.g. `Accept-Encoding`) */
        getAll(name: string): string[];
        /** Returns true if this instance contains the given header */
        has(name: string): boolean;
        /** Returns an iterator that lists all headers by name (polyfill only supports manual iteration with the `next` method for compatibility) */
        keys(): {
            next(): {
                done?: boolean;
                value?: string;
            };
        };
    }
    /** Interface definition for supported fetch options */
    interface FetchOptions {
        /** The HTTP method (GET, PUT, POST, DELETE, etc) */
        method?: string;
        /** The URL to send a request to */
        url?: string;
        /** Request headers (object literal or native Headers instance) */
        headers?: Headers | FetchHeaders;
        /** Request body (string, or possibly a Blob if using the native `fetch` implementation) */
        body?: string | Blob;
    }
    /** Interface definition for Response properties available in the native Fetch implementation as well as the polyfill implementation */
    interface FetchResponse {
        /** Headers returned to the client */
        readonly headers: FetchHeaders;
        /** True if the response was successful (status 200-299) */
        readonly ok: boolean;
        /** Status code of the response */
        readonly status: number;
        /** Status message */
        readonly statusText: string;
        /** Returns a promise for the response body read into a Blob, if supported */
        blob(): PromiseLike<Blob>;
        /** Returns a promise for the response body */
        text(): PromiseLike<string>;
        /** Returns a promise for the response body, parsed as JSON */
        json(): PromiseLike<any>;
    }
    /** Implements the FetchResponse interface, can be used to mock responses or initialize a response from an XMLHttpRequest */
    class MockResponse implements FetchResponse {
        /** Create a response with given data encoded as JSON, the `application/json` content type, and status 200 */
        static withJSONContent(data: any): MockResponse;
        /** Create a response with given properties (an XMLHttpRequest object can be passed in directly, along with a native fetch `Headers` instance or a MockResponseHeaders instance); the response itself is taken from `.responseText` if it is not undefined, or from `.response` if it is a Blob */
        constructor(init?: {
            status?: number;
            statusText?: string;
            responseText?: string;
            response?: Blob;
        }, headers?: FetchHeaders);
        /** Headers returned to the client */
        readonly headers: FetchHeaders;
        /** True if the response was successful (status 200-299) */
        readonly ok: boolean;
        /** Status code of the response */
        readonly status: number;
        /** Status message */
        readonly statusText: string;
        /** Returns a promise for the response body read into a Blob, if supported */
        blob(): PromiseLike<Blob>;
        /** Returns a promise for the response body */
        text(): PromiseLike<string>;
        /** Returns a promise for the response body, parsed as JSON */
        json(): PromiseLike<any>;
        /** Helper method that returns a Promise with the text from the constructor initializer (with text in `.responseText`, or a blob in `.response`) */
        private _readText();
    }
    /** Implements the FetchResponse interface, can be used to mock response headers or initialize response headers from an XMLHttpRequest */
    class MockResponseHeaders implements FetchHeaders {
        /** Initialize the list of headers using given HTTP header text (i.e. one or more lines with header name, colon, and header value; strips all whitespace around names and values) */
        constructor(allResponseHeaders?: string);
        private _headers;
        get(name: string): string;
        getAll(name: string): string[];
        has(name: string): boolean;
        keys(): {
            next: () => {
                done?: boolean | undefined;
                value?: string | undefined;
            };
        };
    }
    /** Perform a request to fetch a resource at given URL; provides a partial polyfill for the Fetch standard using XMLHttpRequest, but uses native `fetch()` internally if available */
    function fetch(inputUrl: string, init?: FetchOptions): PromiseLike<FetchResponse>;
    /** Perform a request to fetch a resource; provides a partial polyfill for the Fetch standard using XMLHttpRequest, but uses native `fetch` internally if available */
    function fetch(inputRequest: any): PromiseLike<FetchResponse>;
    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to the response text, or gets rejected if the request fails or response status is not in 2xx range */
    function getTextAsync(url: string, params?: any, headers?: Headers | FetchHeaders): PromiseLike<string>;
    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to a blob, or gets rejected if the request fails or response status is not in 2xx range; requires a browser that supports Blob constructors */
    function getBlobAsync(url: string, params?: any, headers?: Headers | FetchHeaders): PromiseLike<Blob>;
    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to the parsed HTML result body as a document fragment (ignores everything before and after body tag, if any; inserts everything if no body tag is found, i.e. partial HTML), or gets rejected if the request fails or response status is not in 2xx range */
    function getHtmlContentAsync(url: string, params?: any, headers?: Headers | FetchHeaders): PromiseLike<DocumentFragment>;
    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */
    function getAsync(url: string, params?: any, headers?: Headers | FetchHeaders): PromiseLike<any>;
    /** Perform a POST request with given object (sent as JSON) and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */
    function postAsync(url: string, data?: any, headers?: Headers): PromiseLike<any>;
    /** Perform a PUT request with given object (sent as JSON) and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */
    function putAsync(url: string, data?: any, headers?: Headers): PromiseLike<any>;
    /** Perform a DELETE request with given object (sent as JSON) and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */
    function deleteAsync(url: string, data?: any, headers?: Headers): PromiseLike<any>;
}

}

declare module "@typescene/dom/App/Layout" {

}

declare module "@typescene/dom/App" {
export * from "@typescene/core/App";
export * from "@typescene/dom/App/DOMApplication";
export * from "@typescene/dom/App/Http";
import "@typescene/dom/App/Layout";

}

declare module "@typescene/dom/App" {
export * from "@typescene/dom/App/index";
import * as App from "@typescene/dom/App/index";
export default App;

}

declare module "@typescene/dom/Async" {
export * from "@typescene/core/Async";

}

declare module "@typescene/dom/UI/DOM/DOMAnimation" {
import { Animation, Style, Component } from "@typescene/core/UI";
/** Represents a CSS keyframe animation */
export class DOMAnimation extends Animation {
    /** Create a combined animation out of given key frame animations */
    static together(...animations: DOMAnimation[]): Animation;
    /** Get an animation with given keyframes and given playback options ready for use */
    constructor(name: string, keyframes?: DOMAnimation.Keyframe[], options?: DOMAnimation.Options);
    /** Clone the animation with the same keyframes but with extra options */
    clone(options: DOMAnimation.Options): DOMAnimation;
    /** Combine this animation with given key frame animations; this does *not* work for animations that use the same CSS property, such as `transform` (rotate, scale, translate...) */
    togetherWith(...animations: DOMAnimation[]): Animation;
    /** Clone this animation and override timings */
    withTiming(msDuration: number, msDelay?: number): DOMAnimation;
    /** Clone this animation and specify to be played in reverse */
    reverse(): DOMAnimation;
    /** Play the animation once on given component */
    play(component: Component): Animation.AnimationControl<DOMAnimation>;
}
export namespace DOMAnimation {
    /** Represents a single keyframe in an animation */
    interface Keyframe {
        /** Keyframe position (fraction, 0-1), defaults to the relative position of this keyframe from 0 to 1 (i.e. first keyframe to 0, second in a set of three keyframes to 0.5, second in a set of four keyframes to 0.25, etc) */
        t?: number;
        /** Keyframe style properties */
        style: Style.StyleSet | Style;
    }
    /** Keyframe animation options */
    interface Options {
        /** Duration in milliseconds (default 500) */
        duration?: number;
        /** Duration specified in CSS (copied from duration if unspecified) */
        specDuration?: number;
        /** Delay in milliseconds before starting the animation (default 0) */
        delay?: number;
        /** Number of iterations to play (default 1; can be Infinity) */
        count?: number;
        /** Direction to play the keyframes in (normal, reverse, alternate, or alternate-reverse; default normal) */
        direction?: "normal" | "reverse" | "alternate" | "alternate-reverse";
        /** Set to true to ease the animation timing */
        ease?: boolean;
    }
    /** List of basic animations [implementation] */
    var basic: {
        in: {
            fade: DOMAnimation;
            fadeUp: DOMAnimation;
            fadeDown: DOMAnimation;
            fadeLeft: DOMAnimation;
            fadeRight: DOMAnimation;
            slideUp: DOMAnimation;
            slideDown: DOMAnimation;
            slideLeft: DOMAnimation;
            slideRight: DOMAnimation;
            scale: DOMAnimation;
            scaleOver: DOMAnimation;
            turnX: DOMAnimation;
            turnY: DOMAnimation;
            maxHeight: DOMAnimation;
            maxWidth: DOMAnimation;
        };
        out: {
            fade: DOMAnimation;
            fadeUp: DOMAnimation;
            fadeDown: DOMAnimation;
            fadeLeft: DOMAnimation;
            fadeRight: DOMAnimation;
            slideUp: DOMAnimation;
            slideDown: DOMAnimation;
            slideLeft: DOMAnimation;
            slideRight: DOMAnimation;
            scale: DOMAnimation;
            scaleOver: DOMAnimation;
            turnX: DOMAnimation;
            turnY: DOMAnimation;
            maxHeight: DOMAnimation;
            maxWidth: DOMAnimation;
        };
        highlight: {
            yellow: DOMAnimation;
            jumpOut: DOMAnimation;
            jumpIn: DOMAnimation;
        };
    };
}

}

declare module "@typescene/dom/UI/DOM/DOMBlock" {
import * as Async from "@typescene/core/Async";
import { Block } from "@typescene/core/UI";
/** Platform specific Block base class: full-width horizontal block containing DOM element(s) */
export class DOMBlock extends Block {
    /** Create a new block component with given content */
    constructor(...elements: Array<Node | Async.ObservableValue<Node>>);
    /** Create a new block component with elements from the given DOM fragment */
    constructor(documentFragment: DocumentFragment);
    /** Array of DOM nodes (observed) */
    nodes: Array<Node | undefined>;
}

}

declare module "@typescene/dom/UI/DOM/DOMPageOptions" {
/** Collection of options that control page rendering */
export interface DOMPageOptions {
    /** The z-index style property of the page and all content (default 1000) */
    baseZIndex: number;
    /** Timing (ms) for the modal "shade" in/out animation (default 200) */
    shadeTransition: number;
    /** Opacity level (0-1) for the modal "shade" backdrop (default 0.2) */
    shadeOpacity: number;
    /** CSS base color for the modal "shade" backdrop (default "#000") */
    shadeColor: string;
}
/** Options that control page rendering */
export const PAGE_OPTIONS: DOMPageOptions;

}

declare module "@typescene/dom/UI/DOM/Focus" {
import { Component } from "@typescene/core/UI";
/** Try to focus given component, its live element (from rendered output), or the first focusable element within given component, as soon as it becomes available */
export function focus(component: Component): void;
/** Remove focus from given component, or the currently focused element */
export function blur(component?: Component): void;

}

declare module "@typescene/dom/UI/DOM/Styles" {
import { ObservableObject } from "@typescene/core/Async";
import { Stylesheet } from "@typescene/dom/UI/DOM/Stylesheet";
/** A set of predefined styles and style sheets that are used by specific components; these may be modified to apply a "theme", which will generally update all styles in the DOM asynchronously; _however_, styles defined here are subject to change for now and it is not guaranteed that selectors and class names will continue to exist across versions */
export namespace Styles {
    /** Groups basic component style sheet definitions together, indexed by class name (e.g. "UI-Container") */
    const components: {
        readonly [className: string]: Stylesheet;
    };
    /** Contains basic font settings that are applied globally for this instance; to disable, either set value(s) to `inherit`, or disable `cssReset` altogether */
    const font: {
        family: string;
    } & ObservableObject;
    /** Contains basic measurements that determine the sizing of text and certain components; custom observable properties can be added here if required */
    const size: {
        text: string;
        paragraphLineHeight: string;
        controlSpacing: string;
        listSelectionFocusOutline: string;
        dialogBorderRadius: string;
        cardBorderRadius: string;
        badgeBorderRadius: string;
        buttonBorderRadius: string;
        inputBorderRadius: string;
        controlBorderWidth: string;
    } & ObservableObject;
    /** Contains an observable color scheme based on the color wheel, with a selection of primary and accent colors; custom observable properties can be added here if required */
    const color: {
        black: string;
        white: string;
        darkerGray: string;
        darkGray: string;
        lightGray: string;
        slate: string;
        lightSlate: string;
        red: string;
        orange: string;
        yellow: string;
        lime: string;
        green: string;
        turquoise: string;
        cyan: string;
        blue: string;
        violet: string;
        purple: string;
        magenta: string;
        background: string;
        text: string;
        textFaded: string;
        divider: string;
        primary: string;
        primaryText: string;
        primaryDark: string;
        primaryLight: string;
        accent: string;
        accentText: string;
        accentDark: string;
        accentLight: string;
        linkText: string;
        linkVisitedText: string;
        titleBarBackground: string;
        titleBarText: string;
        listSelectionBackground: string;
        listSelectionText: string;
        listSelectionFocusBackground: string;
        listSelectionFocusText: string;
        controlBase: string;
        controlBaseText: string;
        controlFocus: string;
        controlFocusText: string;
    } & ObservableObject;
    /** CSS reboot stylesheet that defines basic styles for common HTML elements (except those already overridden by `Component` renderers), _enabled by default_: applied as a live stylesheet at the page level for this instance; can be modified to adjust or add CSS reset styles, or disabled using the `.disable()` method if an external CSS reset stylesheet is already loaded */
    const rebootStyles: Stylesheet;
    /** Basic control theme stylesheet that uses colors from the `.color` object, _enabled by default_: applied as a live stylesheet at the page level for this instance; can be modified to adjust or add CSS reset styles, or disabled using the `.disable()` method if external CSS styles are already loaded */
    const controlStyles: Stylesheet;
}

}

declare module "@typescene/dom/UI/DOM/Stylesheet" {
import { Style } from "@typescene/core/UI";
/** Unique random identifier for this runtime instance of the library, used as an identifier on page root elements */
export const uid: string;
/** Represents a (live updating) style sheet, with an optional base class name; the style sheet consists of one or more CSS selectors that each contain a reference to a `Style` instance */
export class Stylesheet {
    /** Returns true if the pseudo-luminance of given color (in hex format `#112233` or `#123` or rgb format `rgb(255, 255, 255)` or hsl format `hsl(255, 0%, 0%)`) is greater than 55%; can be used e.g. to decide on a contrasting text color for a given background color */
    static isBrightColor(color: string): boolean;
    /** Returns a color in hex format (e.g. `#112233`) that lies between given colors (in hex format `#112233` or `#123` or rgb format `rgb(255, 255, 255)`) at given point (0-1, with 0 being the same as the first color, 1 being the same as the second color, and 0.5 being an equal mix) */
    static mixColors(color1: string, color2: string, p: number): string;
    /** Create a new style sheet, with given base class name(s) (optional) and given selectors and styles; selectors may be written as `"@... { selector }"` for e.g. @keyframe and @media nested at-rules; also, `.~~` will be replaced with the full base class name and `.~` with the final part, or if not included then the base class name will be prepended */
    constructor(baseClassName?: string, sheet?: {
        [selector: string]: Style.StyleSet | Style | undefined;
    });
    /** Base class name for this style sheet (set using constructor call) */
    readonly baseClassName: string;
    /** Disable all style rules in one go without removing them (use `.enable()` to reverse the effect); returns this */
    disable(): this;
    /** Re-enable all style rules (after using `.disable()` to disable them); returns this */
    enable(): this;
    /** Returns a list of selectors defined in this style sheet (observable) */
    listSelectors(): string[];
    /** Append a rule to this style sheet; returns this */
    define(text: string): this;
    /** Define or override styles for given selector, based on the properties stored in given `Style` instance (class names are ignored); selectors may be written as `"@... { selector }"` for e.g. @keyframe and @media nested at-rules; returns this */
    define(selector: string, style: Style.StyleSet | Style): this;
    /** Remove defined styles for given selector or pattern; returns this */
    remove(selector: string | RegExp): this;
    /** Invoke given function for each selector of this style sheet, including instance identifier class and base class (except for keyframe selectors), if any, and the referenced `Style` instance, if any; to be used in an observable context to watch for changes*/
    forEach(callback: (selector: string, style?: Style) => void): void;
    private _selectors;
    private _keys;
    private _disabled;
}
/** Define global CSS styles from given style sheet, in the context of the current runtime instance; if the `liveUpdate` argument is set to true, changes to the style sheet and any of its observable properties are observed and reflected in the DOM asynchronously (and the `.disable` method can be used to remove the stylesheet from the DOM temporarily or permanently) */
export function applyStylesheet(sheet: Stylesheet | {
    [selector: string]: Style.StyleSet | Style;
}, liveUpdate?: boolean): void;
/** Helper function to apply Style properties to given DOM element; returns the Style object (does not observe styles directly, but can be used in an observable getter, e.g. using `ComponentRenderer#watch` to reapply styles when they change) */
export function applyStyleTo(style: Style, element: HTMLElement): void;
/** Set the global root-em unit size in pixels or using a CSS value string; the `rem` unit size is defined at the HTML level and should be set to `16px` on all browsers, however some CSS frameworks (e.g. Bootstrap 3) modify this unit; use this method to override the `rem` unit size again */
export function setCSSRemSize(px: number | string): void;
/** Set the class name globally applied to selected items (in addition to the `selected` DOM attribute), i.e. those items selected using `Style.select` */
export function setSelectionClass(className: string): void;
/** Get the class name globally applied to selected items (if any) */
export function getSelectionClass(): string;
/** Load external stylesheet(s) by URL; returns a promise that resolves after the style sheet(s) have been applied OR after a 1 second wait (e.g. when offline or browser does not support this function) */
export function loadExternalCSS(...urls: string[]): PromiseLike<any>;

}

declare module "@typescene/dom/UI/DOM" {
export * from "@typescene/dom/UI/DOM/Stylesheet";
export * from "@typescene/dom/UI/DOM/Styles";
export * from "@typescene/dom/UI/DOM/DOMPageOptions";
export * from "@typescene/dom/UI/DOM/DOMBlock";
export * from "@typescene/dom/UI/DOM/DOMAnimation";
export * from "@typescene/dom/UI/DOM/Focus";
export * from "@typescene/dom/UI/DOM/main";

}

declare module "@typescene/dom/UI/DOM/main" {
import { Component } from "@typescene/core/UI";
/** Returns true if given component contains given DOM node */
export function contains(component: Component, node: Node): boolean;

}

declare module "@typescene/dom/UI/DOM/styles/controls" {
import { Stylesheet } from "@typescene/dom/UI/DOM/Stylesheet";
declare const _default: Stylesheet;
export default _default;

}

declare module "@typescene/dom/UI/DOM/styles/reboot" {
import { Stylesheet } from "@typescene/dom/UI/DOM/Stylesheet";
declare const _default: Stylesheet;
export default _default;

}

declare module "@typescene/dom/UI/Drag" {

}

declare module "@typescene/dom/UI/Events" {

}

declare module "@typescene/dom/UI/Menu" {

}

declare module "@typescene/dom/UI/PageRenderer" {

}

declare module "@typescene/dom/UI/Renderers/Blocks/Block" {

}

declare module "@typescene/dom/UI/Renderers/Blocks/Card" {

}

declare module "@typescene/dom/UI/Renderers/Blocks/ContainerBlock" {

}

declare module "@typescene/dom/UI/Renderers/Blocks/Divider" {

}

declare module "@typescene/dom/UI/Renderers/Blocks/List" {

}

declare module "@typescene/dom/UI/Renderers/Blocks/NavList" {

}

declare module "@typescene/dom/UI/Renderers/Blocks/Row" {

}

declare module "@typescene/dom/UI/Renderers/Blocks/Table" {

}

declare module "@typescene/dom/UI/Renderers/Blocks/TableRow" {

}

declare module "@typescene/dom/UI/Renderers/Containers/Container" {

}

declare module "@typescene/dom/UI/Renderers/Containers/DialogContainer" {

}

declare module "@typescene/dom/UI/Renderers/Containers/DrawerContainer" {

}

declare module "@typescene/dom/UI/Renderers/Containers/LayoutContainer" {

}

declare module "@typescene/dom/UI/Renderers/Controls/BlockControl" {

}

declare module "@typescene/dom/UI/Renderers/Controls/Button" {

}

declare module "@typescene/dom/UI/Renderers/Controls/ButtonGroup" {

}

declare module "@typescene/dom/UI/Renderers/Controls/ContainerControl" {

}

declare module "@typescene/dom/UI/Renderers/Controls/ControlElement" {

}

declare module "@typescene/dom/UI/Renderers/Controls/ControlStack" {

}

declare module "@typescene/dom/UI/Renderers/Controls/Icon" {

}

declare module "@typescene/dom/UI/Renderers/Controls/Image" {

}

declare module "@typescene/dom/UI/Renderers/Controls/InputControls/Checkbox" {

}

declare module "@typescene/dom/UI/Renderers/Controls/InputControls/SelectField" {

}

declare module "@typescene/dom/UI/Renderers/Controls/InputControls/TextField" {

}

declare module "@typescene/dom/UI/Renderers/Controls/Label" {

}

declare module "@typescene/dom/UI/Renderers/Controls/ProgressBar" {

}

declare module "@typescene/dom/UI/Renderers/Controls/Spacer" {

}

declare module "@typescene/dom/UI/Renderers" {
import "@typescene/dom/UI/Renderers/Containers/Container";
import "@typescene/dom/UI/Renderers/Containers/DialogContainer";
import "@typescene/dom/UI/Renderers/Containers/DrawerContainer";
import "@typescene/dom/UI/Renderers/Containers/LayoutContainer";
import "@typescene/dom/UI/Renderers/Blocks/Block";
import "@typescene/dom/UI/Renderers/Blocks/Card";
import "@typescene/dom/UI/Renderers/Blocks/ContainerBlock";
import "@typescene/dom/UI/Renderers/Blocks/Divider";
import "@typescene/dom/UI/Renderers/Blocks/List";
import "@typescene/dom/UI/Renderers/Blocks/NavList";
import "@typescene/dom/UI/Renderers/Blocks/Row";
import "@typescene/dom/UI/Renderers/Blocks/Table";
import "@typescene/dom/UI/Renderers/Blocks/TableRow";
import "@typescene/dom/UI/Renderers/Controls/BlockControl";
import "@typescene/dom/UI/Renderers/Controls/Button";
import "@typescene/dom/UI/Renderers/Controls/ButtonGroup";
import "@typescene/dom/UI/Renderers/Controls/ContainerControl";
import "@typescene/dom/UI/Renderers/Controls/ControlElement";
import "@typescene/dom/UI/Renderers/Controls/ControlStack";
import "@typescene/dom/UI/Renderers/Controls/Icon";
import "@typescene/dom/UI/Renderers/Controls/Image";
import "@typescene/dom/UI/Renderers/Controls/Label";
import "@typescene/dom/UI/Renderers/Controls/ProgressBar";
import "@typescene/dom/UI/Renderers/Controls/Spacer";
import "@typescene/dom/UI/Renderers/Controls/InputControls/Checkbox";
import "@typescene/dom/UI/Renderers/Controls/InputControls/SelectField";
import "@typescene/dom/UI/Renderers/Controls/InputControls/TextField";

}

declare module "@typescene/dom/UI/UpdateContext" {

}

declare module "@typescene/dom/UI" {
export * from "@typescene/core/UI";
import * as DOM from "@typescene/dom/UI/DOM";
export { DOM };
import "@typescene/dom/UI/Drag";
import "@typescene/dom/UI/PageRenderer";
import "@typescene/dom/UI/UpdateContext";
import "@typescene/dom/UI/Renderers";
import "@typescene/dom/UI/Menu";
import "@typescene/dom/UI/Events";

}

declare module "@typescene/dom/UI" {
export * from "@typescene/dom/UI/index";
import * as UI from "@typescene/dom/UI/index";
export default UI;

}

declare module "@typescene/dom" {
import * as Async from "@typescene/dom/Async";
import * as UI from "@typescene/dom/UI";
import * as App from "@typescene/dom/App";
export { Async, UI, App };
declare const _default: {
    Async: typeof Async;
    UI: typeof UI;
    App: typeof App;
};
export default _default;

}
