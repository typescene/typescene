<!DOCTYPE html>
<meta charset="utf-8">
<title>Async - Typescene Documentation</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>pre { white-space: pre-wrap }</style>
<body style="margin: 0; padding: 0; font: menu; text-align: center">
    <header style="background: #222; color: #eee; padding: 1rem">
        <p>Loading documentation viewer...</p>
    </header>
    <section style="padding: 1rem; max-width: 28rem; margin: 0 auto; text-align: left">
        <p>
            <a href="index.html">&lt; Text Index</a>
            
        </p>
<h1>Async</h1><p>This sub module exports generic classes and functions that implement common ‘async’ patterns, such as promises, signals, and observables.</p>
<h3>Structure</h3><p>The included functions and classes build on one another, in the following order:</p>
<ul>
<li><code>defer</code> function — provides a basic queueing mechanism to schedule code asynchronously.</li>
<li><strong>Signals</strong> — defined using <code>Signal.create</code>, which creates a <em>class</em> that derives from <code>Signal</code>, of which instances can be emitted along with a single value. Signals can be used like events in other GUI toolkits.</li>
<li><strong>Promises</strong> — the <code>Promise</code> class provides a <a href="http://promisesaplus.com/" target="_blank">Promises/A+</a> compliant promise implementation, along with some additional convenience methods.</li>
<li><strong>Observable values</strong> — these are objects wrapped around a single value (in the <code>.value</code> property of an <code>ObservableValue</code> object), which can be subscribed to for capturing changes to this value. In addition, observables can be defined using a getter function, which may use other observable values in turn (making changes cascade asynchronously down a dependency tree when subscribed to; this can be employed to implement composite UIs efficiently).</li>
<li><strong>Observable arrays</strong> — arrays of observable values, hiding the <code>ObservableValue</code> instances in getters and setters for all array indices of an <code>ObservableArray</code> object.</li>
<li><strong>Observable objects</strong> — loosely defined objects for which some or all of the properties are made observable (using getters and setters) as properties of an <code>ObservableObject</code>, which also defines a <code>PropertyChange</code> signal to listen for changes without having to subscribe to observable values directly.</li>
<li><strong>Injection</strong> — this mechanism can be used to inject default (observable) values into a property on <em>all instances</em> of a class.</li>
</ul>
<ul><li><a href="Async.ObservableArray.html">Async &gt; ObservableArray (class)</a></li><li><a href="Async.ObservableObject.html">Async &gt; ObservableObject (class)</a></li><li><a href="Async.ObservableValue.html">Async &gt; ObservableValue (class)</a></li><li><a href="Async.Promise.html">Async &gt; Promise (class)</a></li><li><a href="Async.Signal.html">Async &gt; Signal (class)</a></li><li><a href="Async.SignalConnection.html">Async &gt; SignalConnection (interface)</a></li><li><a href="Async.defer.html">Async &gt; defer</a></li><li><a href="Async.deleteObservableProperty.html">Async &gt; deleteObservableProperty</a></li><li><a href="Async.inject.html">Async &gt; inject</a></li><li><a href="Async.isObservableProperty.html">Async &gt; isObservableProperty</a></li><li><a href="Async.makeObjectObservable.html">Async &gt; makeObjectObservable</a></li><li><a href="Async.makePropertyObservable.html">Async &gt; makePropertyObservable</a></li><li><a href="Async.observe.html">Async &gt; observe</a></li><li><a href="Async.observeArray.html">Async &gt; observeArray</a></li><li><a href="Async.runYield.html">Async &gt; runYield</a></li><li><a href="Async.sleep.html">Async &gt; sleep</a></li><li><a href="Async.unobserved.html">Async &gt; unobserved</a></li><li><a href="Async.injectable.html">Async &gt; injectable</a></li><li><a href="Async.observable.html">Async &gt; observable</a></li><li><a href="Async.observable_freeze.html">Async &gt; observable_freeze</a></li><li><a href="Async.observable_not_null.html">Async &gt; observable_not_null</a></li><li><a href="Async.observable_number.html">Async &gt; observable_number</a></li><li><a href="Async.observable_seal.html">Async &gt; observable_seal</a></li><li><a href="Async.observable_shallow.html">Async &gt; observable_shallow</a></li><li><a href="Async.observable_string.html">Async &gt; observable_string</a></li><li><a href="Async.unobservable.html">Async &gt; unobservable</a></li><li><a href="Async.unobservable_memoize_get.html">Async &gt; unobservable_memoize_get</a></li><li><a href="Async.UnhandledException.html">Async &gt; UnhandledException</a></li></ul>
    </section>
    
    <script>
        !(function () {
            var xhr = new XMLHttpRequest();
            xhr.addEventListener("load", load);
            xhr.open("GET", "/index.0.9.html");
            xhr.send();
            function load() {
                var html = xhr.responseText
                    .replace(/^.!DOCTYPE.*\n/gm, "")
                    .replace(/^.meta.*\n/gm, "")
                    .replace(/^.title.*\n/gm, "");
                var div = document.createElement("div");
                div.innerHTML = html;
                var oldHeader = document.body.querySelector("header");
                var oldContent = document.body.querySelector("section");
                location.hash = "#/Async";
                var scripts = [];
                function execNextScript() {
                    if (scripts.length) document.body.appendChild(scripts.shift());
                }
                while (div.firstChild) {
                    var tag = div.firstChild.tagName;
                    if (tag && tag.toLowerCase() === "script") {
                        var script = document.createElement("script");
                        script.onload = execNextScript;
                        script.onerror = execNextScript;
                        script.src = div.firstChild.src;
                        div.removeChild(div.firstChild);
                        scripts.push(script);
                    }
                    else {
                        document.body.appendChild(div.firstChild);
                    }
                }
                execNextScript();
                var interval = setInterval(function () {
                    if (window.typescene) {
                        clearInterval(interval);
                        window.typescene.App.Application.ready.then(function () {
                            document.body.removeChild(oldHeader);
                            document.body.removeChild(oldContent);
                            window.typescene.Async.sleep(10).then(function () {
                                history.replaceState && history.replaceState(
                                    history.state || {},
                                    window.title, "/index.0.9.html" + location.hash)
                            });
                        });
                    }
                }, 10);
            }
        })();
    </script>

</body>
