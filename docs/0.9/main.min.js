/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./dist/core/lib/Async/Promise.js\n\n\n/** Represents a value to be resolved at any time in the future */\nvar Promise_Promise = (function () {\n    /** Create a new Promise instance by running the given callback function, which is given callbacks to resolve and/or reject the promise; the promise is also rejected if the callback function throws an exception */\n    function Promise(executor) {\n        /* @internal */\n        this._Resolve = Signal_Signal.create();\n        /* @internal */\n        this._Reject = Signal_Signal.create();\n        if (typeof executor === \"function\")\n            this._resolveWith(executor);\n    }\n    /** Delay the execution of a callback but return a promise for its result */\n    Promise.delay = function (f, ms, args) {\n        var result = new Promise();\n        // set a timer and run all deferred functions right away (e.g. .then(...))\n        setTimeout(function () {\n            result._resolveWith(function (r) { return r(f.apply(undefined, args)); });\n            runYield();\n        }, ms);\n        return result;\n    };\n    /** Return a promise that will be resolved after a delay */\n    Promise.sleep = function (ms, value) {\n        return Promise.delay(function () { return value; }, ms);\n    };\n    /** Defer the execution of a callback but return a promise for its result */\n    Promise.defer = function (f, args) {\n        var result = new Promise();\n        Defer_defer(function () { result._resolveWith(function (r) { return r(f.apply(undefined, args)); }); });\n        return result;\n    };\n    /** Executes given callback, providing it with a Node.js-style (err, result) => {...} handler that immediately resolves or rejects the resulting promise when called; (use as e.g. `Promise.fn(f => fs.readFile('/etc/passwd', f)).then(...))` */\n    Promise.fn = function (callback) {\n        return new Promise(function (resolve, reject) {\n            callback(function (err, result) {\n                if (err)\n                    reject(err);\n                else\n                    resolve(result);\n            });\n        });\n    };\n    /** Return a resolved promise */\n    Promise.resolve = function (value) {\n        return new Promise()._resolve(value);\n    };\n    /** Return a rejected promise */\n    Promise.reject = function (error) {\n        return new Promise()._reject(error);\n    };\n    /** Return a promise that is fulfilled when all given promises are fulfilled and is immediately rejected when one of the promises is rejected */\n    Promise.all = function (promises) {\n        var result = new Promise();\n        var values = [];\n        var left = promises.length;\n        // fulfill promise if not rejected before\n        function fulfill() {\n            !result._isRejected && result._resolve(values);\n        }\n        // wait for each given promise\n        promises.forEach(function (p, i) {\n            p.then(function (value) {\n                values[i] = value;\n                --left || fulfill();\n            }, function (error) {\n                result._reject(error);\n            });\n        });\n        // fulfill already if no promises given\n        !left && fulfill();\n        return result;\n    };\n    /** Return a promise that is resolved or rejected exactly like the first of the given promises that is resolved or rejected */\n    Promise.race = function (promises) {\n        var result = new Promise();\n        promises.forEach(function (p) {\n            p.then(function (value) { return result._resolve(value); }, function (error) { return result._reject(error); });\n        });\n        return result;\n    };\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n        var _this = this;\n        var result = new Promise();\n        if (this._isResolved) {\n            // if already fulfilled, schedule call to onFulfilled or fulfill now\n            if (typeof onFulfilled === \"function\")\n                Defer_defer(function () { result._resolveWith(function (r) { return r(onFulfilled(_this._value)); }); });\n            else\n                result._resolve(this._value);\n        }\n        else if (this._isRejected) {\n            // if already rejected, schedule call to onRejected or reject now\n            if (typeof onRejected === \"function\")\n                Defer_defer(function () { result._resolveWith(function (r) { return r(onRejected(_this._error)); }); });\n            else\n                result._reject(this._error);\n            // set flag to make sure UnhandledException does not get called async\n            this._hndRejection = true;\n        }\n        else {\n            // fulfill result when ready\n            if (typeof onFulfilled === \"function\") {\n                this._Resolve._connect(function (v) {\n                    return result._resolveWith(function (r) { return r(onFulfilled(v)); });\n                });\n            }\n            else {\n                // pass on result if no handler passed in\n                this._Resolve._connect(function (v) { return result._resolve(v); });\n            }\n            // handle rejections\n            if (typeof onRejected === \"function\") {\n                this._Reject._connect(function (v) {\n                    return result._resolveWith(function (r) { return r(onRejected(v)); });\n                });\n            }\n            else {\n                // pass on rejections if no handler passed in\n                this._Reject._connect(function (v) { return result._reject(v); });\n            }\n        }\n        // always return a promise with the result of onFulfilled OR onRejected\n        return result;\n    };\n    Promise.prototype.catch = function (onRejected) {\n        return this.then(undefined, onRejected);\n    };\n    /** @internal Return current status: null if unfulfilled, object with value property (if resolved), and/or error property (if rejected) */\n    Promise.prototype._getStatus = function () {\n        if (this._isResolved)\n            return { value: this._value };\n        if (this._isRejected)\n            return { rejected: true, error: this._error };\n        return null;\n    };\n    /** @internal Resolve the promise with a value, or (future) result of a promise */\n    Promise.prototype._resolve = function (value, resolving) {\n        var _this = this;\n        if (!this._isResolved && !this._isRejected &&\n            (!this._resolving || resolving === this._resolving)) {\n            if (value === this)\n                throw new TypeError(\"Recursive promise found\");\n            try {\n                var thenFn = value && value.then;\n                if (typeof thenFn === \"function\" &&\n                    ((typeof value === \"object\") || (typeof value === \"function\"))) {\n                    // wait for promise to be resolved and recurse\n                    resolving = this._resolving = {};\n                    thenFn.call(value, function (v) { _this._resolve(v, resolving); }, function (e) { _this._reject(e, resolving); });\n                }\n                else {\n                    // set status and schedule handler chain (if any)\n                    this._isResolved = true;\n                    delete this._resolving;\n                    this._value = value;\n                    this._Resolve.emit(value);\n                    // remove signal references to help garbage collection\n                    delete this._Resolve;\n                    delete this._Reject;\n                }\n            }\n            catch (e) {\n                // oops, caught an exception, now reject this promise\n                this._reject(e, resolving);\n            }\n        }\n        return this;\n    };\n    /** @internal Run a function that may resolve or reject the promise, if still not fulfilled */\n    Promise.prototype._resolveWith = function (executor) {\n        var _this = this;\n        try {\n            // call resolver function with callback for resolving this promise\n            this._isResolved || this._isRejected ||\n                executor(function (v) { _this._resolve(v); }, function (e) { _this._reject(e); });\n        }\n        catch (e) {\n            // oops, caught an exception, now reject this promise\n            this._reject(e);\n        }\n        return this;\n    };\n    /** @internal Reject the promise because an error occurred */\n    Promise.prototype._reject = function (error, resolving) {\n        var _this = this;\n        // set status and schedule handler chain (if any)\n        if (!this._isResolved && !this._isRejected &&\n            (!this._resolving || resolving === this._resolving)) {\n            this._isRejected = true;\n            this._error = error;\n            if (this._Reject.isConnected()) {\n                // emit signal which is handled by onRejected handler(s)\n                this._Reject.emit(error);\n                // remove signal references to help garbage collection\n                delete this._Resolve;\n                delete this._Reject;\n            }\n            else {\n                // emit signal async if still not handled\n                // (wait for chained calls on already-rejected promise)\n                Defer_defer(function () {\n                    _this._hndRejection ||\n                        UnhandledException.emit(error);\n                });\n            }\n        }\n        return this;\n    };\n    return Promise;\n}());\n\n/** Return a promise that will be resolved after a delay */\nfunction sleep(ms, value) {\n    return Promise_Promise.delay(function () { return value; }, ms);\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/Async/Signal.js\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n// remove cyclical dependency by requiring this from root:\n\n/** Flag used to coordinate between handler added by connectOnce, and emitSync method (set when deleted own handler, i.e. emitSync needs to call handler at same index again) */\nvar _handlerDeletedSelf = false;\n/** Variable used by Signal.create to keep track of most specific signal to be emitted */\nvar _currentSignal;\n/** Helper function that generates a handler function which looks for a given method on given target */\nfunction makeMethodHandler(method, target) {\n    if (!target)\n        throw new TypeError(\"Target is \" + target);\n    return function () {\n        var f = target[method];\n        if (typeof f !== \"function\")\n            throw new TypeError(\"Target does not contain method: \" + method);\n        f.apply(target, arguments);\n    };\n}\n/** Encapsulates a signal that can be used to trigger one or more handlers asynchronously; do _not_ construct `Signal` classes directly, use the static `.create` method to create derived classes which can be instantiated and emitted */\nvar Signal_Signal = (function () {\n    function Signal(data, self) {\n        if (!(this instanceof Signal)) {\n            // called as a function, not a constructor: emit directly\n            self && self.emit.call(self, data, true);\n        }\n        else {\n            if (!this.constructor.__emittable)\n                throw new TypeError;\n            this._data = data;\n        }\n    }\n    Signal.create = function () {\n        var Result = (function (_super) {\n            __extends(DefinedSignal, _super);\n            function DefinedSignal(value) {\n                var _this = this;\n                if (!_currentSignal)\n                    _currentSignal = Result;\n                _this = _super.call(this, value, _currentSignal) || this;\n                _currentSignal = undefined;\n                return _this;\n            }\n            return DefinedSignal;\n        }(this));\n        Result.$sigNHnd = 0;\n        Result.__emittable = true;\n        return Result;\n    };\n    /** [implementation] Create a read-only observable value that contains the last emitted value (initially undefined, only contains a value after the first time this signal is emitted) */\n    Signal.observe = function () {\n        return Observable_ObservableValue.fromSignal(this);\n    };\n    /** [implementation] Add a handler */\n    Signal.connect = function (callback, target) {\n        // make handler function if given only a method name\n        if (typeof callback === \"string\")\n            callback = makeMethodHandler(callback, target);\n        // add handler to the list, return a SignalConnection object\n        var connection = { disconnected: false };\n        connection.disconnect = Signal._connect.call(this, callback, connection);\n        return connection;\n    };\n    /** [implementation] Add a one-time handler */\n    Signal.connectOnce = function (callback, target) {\n        // make handler function if given only a method name\n        if (typeof callback === \"string\")\n            callback = makeMethodHandler(callback, target);\n        // add wrapper to the list, call handler only once\n        var called = false, un = Signal._connect.call(this, function (data, src) {\n            if (!called) {\n                called = true;\n                _handlerDeletedSelf = true;\n                un();\n                callback(data, src);\n            }\n        });\n    };\n    /** @internal Implementation of connect: returns disconnect function [used to speed up connections in other Async classes] */\n    Signal._connect = function (callback, signalConnection) {\n        // copy all inherited static properties onto this class instance\n        // (or initialize re-used object)\n        var s = this;\n        if (s.$sigSelf !== s) {\n            s.$sigSelf = s;\n            s.$sigh1 = s.$sigh1, s.$sigh2 = s.$sigh2, s.$sigh3 = s.$sigh3, s.$sigh4 = s.$sigh4;\n            s.$sigHnd = s.$sigHnd && s.$sigHnd.slice();\n            s.$sigNHnd = s.$sigNHnd || 0;\n        }\n        // add handler to the list\n        switch (s.$sigNHnd++) {\n            case 0:\n                // call \"up\" listener to make sure signals get emitted\n                s.$sigh1 = callback;\n                s.onHandlerConnected && s.onHandlerConnected();\n                break;\n            case 1:\n                s.$sigh2 = callback;\n                break;\n            case 2:\n                s.$sigh3 = callback;\n                break;\n            case 3:\n                s.$sigh4 = callback;\n                break;\n            default: (s.$sigHnd || (s.$sigHnd = [])).push(callback);\n        }\n        return function () {\n            // remove handler from the list\n            if (s.$sigh1 === callback)\n                _a = [s.$sigh2, s.$sigh3, s.$sigh4, s.$sigHnd && s.$sigHnd.shift()], s.$sigh1 = _a[0], s.$sigh2 = _a[1], s.$sigh3 = _a[2], s.$sigh4 = _a[3], _a,\n                    s.$sigNHnd--;\n            else if (s.$sigh2 === callback)\n                _b = [s.$sigh3, s.$sigh4, s.$sigHnd && s.$sigHnd.shift()], s.$sigh2 = _b[0], s.$sigh3 = _b[1], s.$sigh4 = _b[2], _b,\n                    s.$sigNHnd--;\n            else if (s.$sigh3 === callback)\n                _c = [s.$sigh4, s.$sigHnd && s.$sigHnd.shift()], s.$sigh3 = _c[0], s.$sigh4 = _c[1], _c,\n                    s.$sigNHnd--;\n            else if (s.$sigh4 === callback)\n                s.$sigh4 = s.$sigHnd && s.$sigHnd.shift(),\n                    s.$sigNHnd--;\n            else if (s.$sigNHnd > 4) {\n                for (var i = s.$sigHnd.length - 1; i >= 0; i--) {\n                    if (s.$sigHnd[i] === callback) {\n                        s.$sigHnd.splice(i, 1);\n                        s.$sigNHnd--;\n                        break;\n                    }\n                }\n            }\n            // check new length: call \"down\" listener if none\n            if (!s.$sigNHnd && s.onHandlersDisconnected)\n                s.onHandlersDisconnected();\n            // set disconnected flag\n            if (signalConnection)\n                signalConnection.disconnected = true;\n            var _a, _b, _c;\n        };\n    };\n    /** [implementation] Remove all handlers */\n    Signal.disconnectAll = function () {\n        // call \"down\" callback to allow signals to stop for now\n        if (this.$sigNHnd) {\n            this.$sigh1 = undefined;\n            this.$sigh2 = undefined;\n            this.$sigh3 = undefined;\n            this.$sigh4 = undefined;\n            this.$sigHnd = undefined;\n            this.$sigNHnd = 0;\n            this.onHandlersDisconnected && this.onHandlersDisconnected();\n        }\n        return this;\n    };\n    /** [implementation] Returns true if this signal has any handlers */\n    Signal.isConnected = function () {\n        return (this.$sigNHnd > 0);\n    };\n    /** @internal Invoke all handlers synchronously, without creating a Signal instance at all; exceptions in handlers are NOT caught here */\n    Signal.emitSync = function (data) {\n        if (this.$sigNHnd) {\n            _handlerDeletedSelf = false;\n            while (this.$sigh1 && (this.$sigh1.call(undefined, data),\n                _handlerDeletedSelf))\n                _handlerDeletedSelf = false;\n            while (this.$sigh2 && (this.$sigh2.call(undefined, data),\n                _handlerDeletedSelf))\n                _handlerDeletedSelf = false;\n            while (this.$sigh3 && (this.$sigh3.call(undefined, data),\n                _handlerDeletedSelf))\n                _handlerDeletedSelf = false;\n            while (this.$sigh4 && (this.$sigh4.call(undefined, data),\n                _handlerDeletedSelf))\n                _handlerDeletedSelf = false;\n            var handlers = this.$sigHnd;\n            if (handlers) {\n                for (var i = 0; i < handlers.length; i++) {\n                    while (handlers[i] &&\n                        (handlers[i].call(undefined, data),\n                            _handlerDeletedSelf))\n                        _handlerDeletedSelf = false;\n                }\n            }\n        }\n    };\n    /** @internal Invoke all handlers asynchronously, possibly without creating a Signal instance at all; exceptions in handlers are NOT caught here */\n    Signal.emit = function (data) {\n        if (!this.__emittable)\n            throw new TypeError;\n        if (this.$sigNHnd) {\n            if (this.$sigh1)\n                Defer_defer(this.$sigh1.bind(this, data));\n            if (this.$sigh2)\n                Defer_defer(this.$sigh2.bind(this, data));\n            if (this.$sigh3)\n                Defer_defer(this.$sigh3.bind(this, data));\n            if (this.$sigh4)\n                Defer_defer(this.$sigh4.bind(this, data));\n            var handlers = this.$sigHnd;\n            if (handlers) {\n                for (var i = 0, len = handlers.length; i < len; i++)\n                    handlers[i] && Defer_defer(handlers[i].bind(this, data));\n            }\n        }\n    };\n    /** Invoke all handlers and capture promises of their return values in .results (unless argument is true); works only once; returns this */\n    Signal.prototype.emit = function (noResults) {\n        var _this = this;\n        if (this._emitted)\n            return this;\n        this._emitted = true;\n        var nHandlers = this.constructor.$sigNHnd;\n        if (!nHandlers)\n            return this;\n        var handler1 = this.constructor.$sigh1;\n        var handler2 = this.constructor.$sigh2;\n        var handler3 = this.constructor.$sigh3;\n        var handler4 = this.constructor.$sigh4;\n        var handlers = this.constructor.$sigHnd;\n        var data = this._data;\n        if (!noResults) {\n            // intialize an array of Promises\n            var results = this._results = [handler1 ?\n                    Promise_Promise.defer(handler1.bind(this, data)) :\n                    Promise_Promise.resolve(undefined)];\n            if (nHandlers > 1)\n                results.push(handler2 ?\n                    Promise_Promise.defer(handler2.bind(this, data)) :\n                    Promise_Promise.resolve(undefined));\n            if (nHandlers > 2)\n                results.push(handler3 ?\n                    Promise_Promise.defer(handler3.bind(this, data)) :\n                    Promise_Promise.resolve(undefined));\n            if (nHandlers > 3)\n                results.push(handler4 ?\n                    Promise_Promise.defer(handler4.bind(this, data)) :\n                    Promise_Promise.resolve(undefined));\n            if (nHandlers > 4)\n                handlers.forEach(function (f) { return results.push(f ?\n                    Promise_Promise.defer(f.bind(_this, data)) :\n                    Promise_Promise.resolve(undefined)); });\n        }\n        else {\n            // no need to capture results, schedule plain handlers\n            Defer_defer(handler1.bind(this, data));\n            if (nHandlers > 1)\n                Defer_defer(handler2.bind(this, data));\n            if (nHandlers > 2)\n                Defer_defer(handler3.bind(this, data));\n            if (nHandlers > 3)\n                Defer_defer(handler4.bind(this, data));\n            if (nHandlers > 4)\n                handlers.forEach(function (f) { return f && Defer_defer(f.bind(_this, data)); });\n        }\n        if (this._onEmit)\n            this._onEmit(true);\n        return this;\n    };\n    /** Invoke given callback(s) with return values of all handlers, or any exception that occurred during execution of all handlers; returns a Promise that resolves to the return value of the callback(s) itself */\n    Signal.prototype.then = function (onFulfilled, onRejected) {\n        var _this = this;\n        if (!this._promise) {\n            if (!this._emitted)\n                this._promise = new Promise_Promise(function (r) { _this._onEmit = r; })\n                    .then(function () { return Promise_Promise.all(_this.results); });\n            else\n                this._promise = Promise_Promise.all(this.results);\n        }\n        return this._promise.then(onFulfilled, onRejected);\n    };\n    /** Catch errors that occur during execution of all handlers; returns a Promise that resolves to the return value of the callback itself */\n    Signal.prototype.catch = function (onRejected) {\n        return this.then(undefined, onRejected);\n    };\n    Object.defineProperty(Signal.prototype, \"results\", {\n        /** Array of Promises that resolve to return values of all handlers */\n        get: function () {\n            return this._results || [];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Signal.prototype, \"data\", {\n        /** The payload data for this signal instance */\n        get: function () { return this._data; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internal Number of handlers */\n    Signal.$sigNHnd = 0;\n    return Signal;\n}());\n\n/** Signal that is emitted for all exceptions that were unhandled during async execution; a custom handler may be added here, the default handler just logs a warning message to the console; to disable this behavior for specific errors, set error.message to a blank string */\nvar UnhandledException = Signal_Signal.create();\n// hook up default behavior:\nUnhandledException._connect(function (error) {\n    try {\n        error && error.message && console && (console.warn || console.log)(\"Unhandled exception in asynchronous code - \", error);\n    }\n    catch (all) { }\n});\n\n// CONCATENATED MODULE: ./dist/core/lib/Async/Defer.js\n\n/** Queue of functions to execute when idle (deferred functions) */\nvar deferred = [];\nvar deferredArgs = [];\n/** True if currently handling deferred functions */\nvar runningDeferred = false;\n/** True if already scheduled next handler */\nvar scheduled;\n/** Current setTimeout ID, if >= 0 */\nvar deferTimeout = -1;\n/** True if postMessage works, too */\nvar canPostMessage;\n/** True if requestAnimationFrame works */\nvar canRequestAnimationFrame = (typeof window !== \"undefined\") &&\n    (typeof window.requestAnimationFrame === \"function\") &&\n    (typeof performance !== \"undefined\");\n/** True if native Promise exists */\nvar resolvedPromise = (typeof window !== \"undefined\") &&\n    (typeof window.Promise !== \"undefined\") &&\n    window.Promise.resolve(0);\n/** Run a batch of deferred functions */\nfunction _runDeferred(time, manualYield) {\n    var trackTime = (time > 0);\n    if (manualYield !== true)\n        scheduled = false;\n    if (deferTimeout >= 0) {\n        clearTimeout(deferTimeout);\n        deferTimeout = -1;\n    }\n    // run a number of deferred functions\n    runningDeferred = true;\n    var n = deferred.length;\n    var max = Math.max(trackTime ? 1000 : 100, n >> 2);\n    for (var i = 0; i < deferred.length && i < max; i++) {\n        try {\n            deferred[i].apply(undefined, deferredArgs[i]);\n        }\n        catch (err) {\n            UnhandledException(err);\n        }\n        // stop if exceeding animation frame time (if applicable),\n        // keep going if queue is still growing\n        if (trackTime && (deferred.length < n + i) &&\n            performance.now() - time > 60)\n            break;\n    }\n    runningDeferred = false;\n    // reschedule if necessary\n    if (i < deferred.length) {\n        deferred.splice(0, i);\n        deferredArgs.splice(0, i);\n        // reschedule slowly if queue didn't grow significantly\n        _reschedule(deferred.length > n + 20);\n    }\n    else {\n        deferred.length = 0;\n        deferredArgs.length = 0;\n    }\n}\n/** Schedule a deferred function run (but not through Promise twice in a row) */\nfunction _reschedule(immediate) {\n    if (!scheduled && !runningDeferred) {\n        scheduled = true;\n        if (!immediate && canRequestAnimationFrame)\n            window.requestAnimationFrame(_runDeferred);\n        else if (immediate && resolvedPromise)\n            resolvedPromise.then(_runDeferred);\n        else if (canPostMessage)\n            window.postMessage(\"yield\", \"*\");\n        else\n            deferTimeout = setTimeout(_runDeferred, 0, 0);\n    }\n}\n/** Execute given function only when idle, with given arguments (array or `arguments` object) if any */\nfunction Defer_defer(f, args) {\n    deferred.push(f);\n    deferredArgs.push(args);\n    _reschedule(true);\n}\n/** Run a batch of deferred functions; returns true if there are still more deferred functions in the queue, or false if there are none or if already running; set argument to true to run _all_ deferred functions that are currently in the queue (but not those that get added after the call to `runYield`) */\nfunction runYield(yieldAll) {\n    if (runningDeferred)\n        return false;\n    if (yieldAll) {\n        // run up to current position in queue\n        var stop = false;\n        deferred.push(function () { stop = true; });\n        deferredArgs.push(undefined);\n        while (_runDeferred(0, true) && !stop)\n            ;\n    }\n    else {\n        // run only one batch or until timed out\n        var time = canRequestAnimationFrame ? performance.now() : 0;\n        _runDeferred(time, true);\n    }\n    return (deferred.length > 0);\n}\n// check if postMessage works in this browser and set flag\nif (typeof window === \"object\") {\n    window.addEventListener(\"message\", function () {\n        canPostMessage = true;\n        _runDeferred();\n    });\n    setTimeout(function () { return window.postMessage(\"yield\", \"*\"); }, 1);\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/Async/ObservableObject.js\n\n\nvar OBSERVABLE_HIDDEN_PROP_PREFIX = \"*observable:\";\nvar HAS_GETTER_PROP = \"*observable-getter\";\n/** Represents an object with (some) observable members; may be extended into a derived class, or use `makeObjectObservable` function to mix into any object [requires ES5+ target] */\nvar ObservableObject_ObservableObject = (function () {\n    /** Create an object with (some) observable members */\n    function ObservableObject() {\n        assertUnobserved();\n        _addSignalGetter(this);\n    }\n    /** Returns true if property with given name is observable */\n    ObservableObject.prototype.hasObservableProperty = function (name) {\n        return isObservableProperty(this, name);\n    };\n    /** Add an observable property with given name and value; any existing (observable) properties with this name are removed first */\n    ObservableObject.prototype.addObservableProperty = function (name, value) {\n        makePropertyObservable(this, name);\n        this[name] = value;\n    };\n    return ObservableObject;\n}());\n\n/** Returns a new `ObservableObject` with properties copied from given object; `ObservableValue` instances are referenced directly (including getter and setter), Array properties are turned into `ObservableArray` instances, and plain Object instances into `ObservableObject` instances; also seals the new instance if the object parameter was sealed, and freezes it if the object parameter was frozen*/\nfunction makeObjectObservable(obj) {\n    var result = new ObservableObject_ObservableObject();\n    if (obj instanceof Object) {\n        // define non-configurable properties with getters and setters\n        var specIsObservable = (obj instanceof ObservableObject_ObservableObject);\n        var desc;\n        for (var member in obj) {\n            if ((specIsObservable ?\n                obj.hasObservableProperty(member) :\n                Object.prototype.hasOwnProperty.call(obj, member)) &&\n                (desc = Object.getOwnPropertyDescriptor(obj, member))) {\n                _defineObservableProperty(result, member, desc.value, desc.get, desc.set);\n            }\n        }\n        // mixin method and signal\n        Object.defineProperty(result, \"hasObservableProperty\", {\n            configurable: false,\n            writable: false,\n            enumerable: false,\n            value: ObservableObject_ObservableObject.prototype.hasObservableProperty\n        });\n        _addSignalGetter(result);\n        // copy object status\n        if (Object.isFrozen(obj)) {\n            // go through all properties to initialize hidden observable first\n            for (var member in obj)\n                result[member];\n            Object.freeze(result);\n        }\n        else if (Object.isSealed(obj)) {\n            // go through all properties to initialize hidden observable first\n            for (var member in obj)\n                result[member];\n            Object.seal(result);\n        }\n    }\n    return result;\n}\n/** Make the property with given name observable; use given observable value instance, if any, otherwise use a new observable value instance that holds the current property value and/or uses the current property getter and setter [requires ES5+ target] */\nfunction makePropertyObservable(obj, member, instance) {\n    var propertyName = String(member);\n    if (instance instanceof Observable_ObservableValue) {\n        // use given instance\n        _defineObservableProperty(obj, propertyName, instance);\n    }\n    else {\n        // use property descriptor, or otherwise just the value\n        var desc = Object.getOwnPropertyDescriptor(obj, propertyName);\n        _defineObservableProperty(obj, propertyName, desc ? desc.value : obj[propertyName], desc && desc.get, desc && desc.set);\n    }\n}\n/** Delete the property with given name and clear its observable value */\nfunction deleteObservableProperty(obj, member) {\n    var hiddenMember = _getHiddenName(member);\n    var observable = obj[hiddenMember];\n    if (observable && observable.subscribed && observable.writable)\n        observable.value = undefined;\n    delete obj[member];\n    delete obj[hiddenMember];\n}\n/** Returns true if property with given name is defined and is observable */\nfunction isObservableProperty(obj, member) {\n    var hiddenMember = _getHiddenName(member);\n    if (Object.prototype.hasOwnProperty.call(obj, hiddenMember))\n        return true;\n    var ppDescriptor = _getProtoPropDesc(obj, member);\n    if (ppDescriptor && ppDescriptor.get && ppDescriptor.get[HAS_GETTER_PROP])\n        return true;\n    return false;\n}\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n/** Helper function to add a getter for the `ObservableObject.PropertyChange` signal to any object */\nfunction _addSignalGetter(obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, \"PropertyChange\")) {\n        var S;\n        Object.defineProperty(obj, \"PropertyChange\", {\n            configurable: false,\n            enumerable: false,\n            get: function () {\n                if (!S) {\n                    S = Signal_Signal.create();\n                    S.target = obj;\n                    this._hasPropertyChangeSignal = true;\n                }\n                return S;\n            }\n        });\n    }\n}\n/** Helper function to get a prototype's property descriptor */\nfunction _getProtoPropDesc(obj, member) {\n    var proto = Object.getPrototypeOf(obj);\n    return proto ?\n        Object.getOwnPropertyDescriptor(proto, String(member)) ||\n            _getProtoPropDesc(proto, member) :\n        undefined;\n}\n/** Helper function to add a getter and setter for a single property */\nfunction _defineObservableProperty(obj, member, initial, getter, setter) {\n    var hiddenMember = _getHiddenName(member);\n    // clear existing observable value, if any, or define hidden property\n    if (Object.prototype.hasOwnProperty.call(obj, hiddenMember))\n        deleteObservableProperty(obj, member);\n    else {\n        Object.defineProperty(obj, hiddenMember, {\n            configurable: true,\n            enumerable: false,\n            value: false,\n            writable: true\n        });\n    }\n    // define observable property itself\n    var descriptor = { enumerable: true, configurable: true };\n    _makeObservablePropertyDef(descriptor, member, getter, setter);\n    Object.defineProperty(obj, member, descriptor);\n    // store observable value instance, if referenced directly\n    if (initial instanceof Observable_ObservableValue)\n        obj[hiddenMember] = initial;\n    else if (initial !== undefined)\n        obj[member] = initial;\n}\n/** Helper function to get a property definition for an observable property */\nfunction _makeObservablePropertyDef(descriptor, member, getter, setter, getFilter, setFilter, shallow) {\n    var hiddenMember = _getHiddenName(member);\n    // helper function that returns ObservableValue for a member\n    function getObservableValue(obj) {\n        if (obj[hiddenMember])\n            return obj[hiddenMember];\n        // create new observable value\n        return obj[hiddenMember] = unobserved(function () {\n            var o = new Observable_ObservableValue();\n            if (shallow)\n                o.shallow = true;\n            if (getter)\n                o.getter(getter.bind(obj));\n            if (setter)\n                o.setter(setter.bind(obj));\n            // emit PropertyChange for Observable object properties\n            o.invokeOnChange(function () {\n                if (obj._hasPropertyChangeSignal)\n                    obj.PropertyChange(member);\n            });\n            return o;\n        });\n    }\n    // save getter with flag\n    descriptor.get = getFilter ?\n        function () {\n            return getFilter(getObservableValue(this).value);\n        } :\n        function () {\n            return getObservableValue(this).value;\n        };\n    descriptor.get[HAS_GETTER_PROP] = true;\n    // save setter\n    descriptor.set = setFilter ?\n        function (v) {\n            return getObservableValue(this).value = setFilter(v);\n        } :\n        function (v) {\n            return getObservableValue(this).value = v;\n        };\n}\nfunction _getHiddenName(name) {\n    return OBSERVABLE_HIDDEN_PROP_PREFIX + name;\n}\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n/** _Method/accessor decorator_, wraps a method or getter (but not setter) in an `unobserved` call, so that any observable values read by this method (or functions invoked synchronously from within this method) are not marked as dependencies of any currently evaluating observable values [requires ES5+ target] [decorator] */\nfunction unobservable(target, key, descriptor) {\n    if (descriptor) {\n        if (descriptor.get) {\n            // wrap getter to invoke it as unobserved (no arguments)\n            var f_1 = descriptor.get;\n            descriptor.get = function () {\n                return unobserved.call(this, f_1);\n            };\n            return descriptor;\n        }\n        else if (typeof descriptor.value === \"function\") {\n            // wrap function to monkey patch it as unobserved\n            var f_2 = descriptor.value;\n            descriptor.value = function () {\n                var _this = this;\n                var a = arguments;\n                return unobserved(function () { return f_2.apply(_this, a); });\n            };\n            return descriptor;\n        }\n    }\n    throw new TypeError();\n}\n/** _Read-only-accessor decorator_, wraps a getter (without setter) in an `unobserved` call, so that any observable values read by the accessor (or functions invoked synchronously from within the accessor) are not marked as dependencies of any currently evaluating observable values; defines a read-only property using the result of the accessor call, after the first time it was invoked for each instance [requires ES5+ target] [decorator] */\nfunction unobservable_memoize_get(target, key, descriptor) {\n    if (descriptor && descriptor.get) {\n        // property cannot contain a setter (must be read-only)\n        if (descriptor.set)\n            throw new TypeError;\n        // wrap getter to invoke it as unobserved (no arguments)\n        var f = descriptor.get;\n        descriptor.get = function () {\n            var value = unobserved.call(this, f);\n            // redefine the property on this instance\n            Object.defineProperty(this, key, {\n                enumerable: true,\n                writable: false,\n                configurable: true,\n                value: value\n            });\n            return value;\n        };\n        return descriptor;\n    }\n    throw new TypeError();\n}\nfunction observable(target, key, descriptor, getFilter, setFilter, shallow) {\n    if (!descriptor)\n        descriptor = { enumerable: true };\n    _makeObservablePropertyDef(descriptor, key, descriptor.get, descriptor.set, getFilter, setFilter, shallow);\n    return descriptor;\n}\n/** _Property/accessor decorator_, makes a property observable on every instance and converts values to strings when read (empty string for null/undefined/NaN) [requires ES5+ target] [decorator] */\nfunction observable_string(target, key, descriptor) {\n    return observable(target, key, descriptor, function (value) {\n        return (value || value === 0 || value === false) ? String(value) : \"\";\n    });\n}\n/** _Property/accessor decorator_, makes a property observable on every instance and converts values to numbers using Number(...) when read [requires ES5+ target] [decorator] */\nfunction observable_number(target, key, descriptor) {\n    return observable(target, key, descriptor, function (value) { return Number(value); });\n}\n/** _Property/accessor decorator_, makes a property observable on every instance, as a shallow observable value (i.e. does not read values from observable values assigned to this property; and does not convert arrays to observable arrays nor objects to observable objects) [requires ES5+ target] [decorator] */\nfunction observable_shallow(target, key, descriptor) {\n    return observable(target, key, descriptor, undefined, undefined, true);\n}\n/** _Property/accessor decorator_, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that undefined/null values cannot be set (also throws TypeError) [requires ES5+ target] [decorator] */\nfunction observable_not_null(target, key, descriptor) {\n    return observable(target, key, descriptor, function (value) {\n        if (value === undefined || value === null)\n            throw new TypeError(key + \" is \" + value);\n        return value;\n    }, function (value) {\n        if (value === undefined || value === null)\n            throw new TypeError(key + \" cannot be \" + value);\n        return value;\n    });\n}\n/** @internal Alias for backwards compatibility */\nfunction observable_nonNull() {\n    return observable_not_null.call(undefined, arguments);\n}\n/** _Property/accessor decorator_, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that only instances of Object can be set, which are sealed automatically [requires ES5+ target] [decorator] */\nfunction observable_seal(target, key, descriptor) {\n    return observable(target, key, descriptor, function (value) {\n        if (value === undefined || value === null)\n            throw new TypeError(key + \" is \" + value);\n        return value;\n    }, function (value) {\n        if (!(value instanceof Object))\n            throw new Error(key + \" must be an Object, not \" + value);\n        return Object.isSealed(value) ? value : Object.seal(value);\n    });\n}\n/** _Property/accessor decorator_, makes a property observable on every instance and enforces that values are not undefined or null when read (throws TypeError) and that only instances of Object can be set, which are frozen automatically [requires ES5+ target] [decorator] */\nfunction observable_freeze(target, key, descriptor) {\n    return observable(target, key, descriptor, function (value) {\n        if (value === undefined || value === null)\n            throw new TypeError(key + \" is \" + value);\n        return value;\n    }, function (value) {\n        if (!(value instanceof Object))\n            throw new Error(key + \" must be an Object, not \" + value);\n        return Object.isFrozen(value) ? value : Object.freeze(value);\n    });\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/Async/ObservableArray.js\n\n\n\n;\n/** Encapsulates `Array` with observable properties; the result works exactly like a regular array, but setting elements outside the bounds of the array (>= length) does NOT work: length must be set first */\nvar ObservableArray_ObservableArray = (function () {\n    /** Create a new empty `ObservableArray` instance */\n    function ObservableArray() {\n        var _this = this;\n        assertUnobserved();\n        var _length = Observable_ObservableValue.fromValue(0);\n        Object.defineProperty(this, \"length\", {\n            get: function () { return _length.value; },\n            set: function (value) {\n                // make new numeric properties observable\n                var currentLength = _length.getLastValue() || 0;\n                while (currentLength < value)\n                    makePropertyObservable(_this, currentLength++);\n                // clear removed properties\n                for (var l = value; l < currentLength; l++)\n                    deleteObservableProperty(_this, l);\n                _length.value = value;\n            },\n            configurable: true\n        });\n    }\n    /** Create an `ObservableArray` out of a regular Array */\n    ObservableArray.fromArray = function (array) {\n        var result = new ObservableArray();\n        for (var i = array.length - 1; i >= 0; i--)\n            result[i] = array[i];\n        result.length = array.length;\n        return result;\n    };\n    /** Create an `ObservableArray` that takes array elements from the array in given `ObservableValue`, or the value itself as a single element if it is not an array, or an empty array if the value is null or undefined; changes in array elements and/or observable values are reflected asynchronously; use the `lazy` argument to defer initialization of array elements until the `.length` property is accessed */\n    ObservableArray.fromObservableValue = function (observableValue, lazy) {\n        var result = new ObservableArray();\n        // proxy length and all numeric properties in result\n        var _length = 0;\n        var makeMap = function (i) { return new Observable_ObservableValue(function () {\n            var value = observableValue.value;\n            if (value instanceof Array)\n                return value[i];\n            else if (i === 0 && value !== null)\n                return value;\n            else\n                return undefined;\n        }); };\n        Object.defineProperty(result, \"length\", {\n            get: function () {\n                var value = observableValue.value;\n                var newLength = (value instanceof Array) ? value.length :\n                    (value === undefined || value === null) ? 0 : 1;\n                if (newLength > _length) {\n                    unobserved(function () {\n                        // make new numeric properties observable\n                        for (var l = _length; l < newLength; l++)\n                            makePropertyObservable(result, l, makeMap(l));\n                    });\n                }\n                else {\n                    unobserved(function () {\n                        // clear removed properties\n                        for (var l = newLength; l < _length; l++)\n                            deleteObservableProperty(result, l);\n                    });\n                }\n                return _length = newLength;\n            },\n            set: function () {\n                throw new Error(\"Cannot modify length of mapped array\");\n            }\n        });\n        // initialize all values\n        if (!lazy)\n            unobserved(function () { return result.length; });\n        return result;\n    };\n    /** Create a read-only `ObservableArray` with each value of the original array mapped to the result of the given getter function; observable values used in the map function are not observed (like `ObservableValue#map`); the getter is called for combinations of value and index (i.e. deleting a value in the middle of the source array will trigger changes for all elements after it; if the index is not important then use `.mapAsyncValues` instead); the resulting array length changes along with the original array length; use the `lazy` argument to defer initialization of array elements until the `.length` property is accessed */\n    ObservableArray.prototype.mapAsync = function (callback, thisArg, lazy) {\n        var _this = this;\n        var result = new ObservableArray();\n        // keep length in an observable just like the properties to avoid\n        // unexpected differences in change propagation timings\n        var observableLength = new Observable_ObservableValue(function () { return _this.length; });\n        // proxy all numeric properties in result\n        var _length = 0;\n        var makeMap = function (i) {\n            var lastValue = {};\n            var mapped = new Observable_ObservableValue(function () {\n                var value = _this[i];\n                if (value === lastValue)\n                    return mapped.value;\n                mapped.value = unobserved(function (value) {\n                    return (i >= 0 && i < _this.length) ?\n                        callback.call(thisArg || result, value, i, _this) :\n                        undefined;\n                }, lastValue = value);\n            });\n            return mapped;\n        };\n        Object.defineProperty(result, \"length\", {\n            get: function () {\n                var newLength = observableLength.value;\n                if (newLength > _length) {\n                    unobserved(function () {\n                        // make new numeric properties observable\n                        for (var l = _length; l < newLength; l++)\n                            makePropertyObservable(result, l, makeMap(l));\n                    });\n                }\n                else if (newLength < _length) {\n                    unobserved(function () {\n                        // clear removed properties\n                        for (var l = newLength; l < _length; l++)\n                            deleteObservableProperty(result, l);\n                    });\n                }\n                return _length = newLength;\n            },\n            set: function () {\n                throw new Error(\"Cannot modify length of mapped array\");\n            }\n        });\n        // initialize all values\n        if (!lazy)\n            unobserved(function () { return result.length; });\n        return result;\n    };\n    /** Create a read-only ObservableArray with each value of the original array mapped to the result of the given function; observable values used in the map function are not observed (like ObservableValue map method); the resulting array length changes along with the original array length; this method is slightly more expensive than mapAsync for larger arrays, especially in non-ES6 environments, but is overall more efficient because it avoids unnecessary callbacks when subscribed to; use the `lazy` argument to defer initialization of array elements until the `.length` property is accessed */\n    ObservableArray.prototype.mapAsyncValues = function (callback, thisArg, lazy) {\n        var _this = this;\n        // keep track of previously seen values in a Map (with \"semi-polyfill\")\n        var _get, _add;\n        var _del;\n        var _forEach;\n        if (typeof Map === \"function\") {\n            // use native Map implementation\n            var map = new Map();\n            _get = map.get.bind(map), _add = map.set.bind(map);\n            _forEach = map.forEach.bind(map);\n            _del = map.delete.bind(map);\n        }\n        else {\n            // use minimal approximation of Map methods\n            var ownMap = [];\n            _add = function (v, o) { ownMap.push({ v: v, o: o }); };\n            _get = function (v) {\n                var result;\n                ownMap.some(function (x) { return (x.v === v ? (result = x.o, true) : false); });\n                return result;\n            };\n            _del = function (v) {\n                ownMap.some(function (x, i) { return (x.v === v ? !!ownMap.splice(i, 1) : false); });\n            };\n            _forEach = function (f) {\n                ownMap.slice(0).forEach(function (x) { return f(x.o, x.v); });\n            };\n        }\n        // keep track of all current inputs to be able to prune the map\n        // (really only works when entire array is subscribed to)\n        var currentInputs = [];\n        var timer = -1;\n        var deferPrune = function () {\n            if (timer >= 0)\n                clearTimeout(timer);\n            var myTimer = timer = setTimeout(function () {\n                if (myTimer === timer) {\n                    timer = -1;\n                    var len = _this.length;\n                    if (currentInputs.length > len)\n                        currentInputs.length = len;\n                    _forEach(function (o, v) {\n                        currentInputs.indexOf(v) < 0 && _del(v);\n                    });\n                }\n            }, 1);\n        };\n        // prune the map when the array gets shorter\n        var pruning = false;\n        var subscribeToPrune = function () {\n            pruning = true;\n            unobserved(function () {\n                new Observable_ObservableValue(function () { return _this.length; }).subscribe(function (len) {\n                    if (currentInputs.length > len)\n                        deferPrune();\n                });\n            });\n        };\n        // map input array to another observable array\n        var ownNaN = {}, ownUndefined = {};\n        return this.mapAsync(function (v, i) {\n            var defv = v === undefined ? ownUndefined :\n                (typeof v === \"number\" && isNaN(v)) ? ownNaN : v;\n            if (currentInputs[i] !== undefined && currentInputs[i] !== defv)\n                deferPrune();\n            else if (!pruning)\n                subscribeToPrune();\n            currentInputs[i] = defv;\n            // return last result for same input value if found\n            var found = _get(defv);\n            if (found !== undefined)\n                return found;\n            // get result for current input value and keep it for later\n            var o = callback.call(thisArg || _this, v);\n            _add(defv, o);\n            return o;\n        }, undefined, lazy);\n    };\n    /** Create a read-only observable array that contains all values from the original array and all nested (observable) arrays, optionally removing gaps (i.e. undefined or null elements); the resulting array and its length _always_ change asynchronously with the contents of the original array, even if not subscribed to a value or the length property; use the `lazy` argument to defer initialization of array elements until the `.length` property is accessed */\n    ObservableArray.prototype.flattenAsync = function (removeGaps, lazy) {\n        var _this = this;\n        // create an observable that all other properties depend on; this is\n        // where the flattening actually happens, asynchronously\n        var nonObservableFlat = [];\n        var count = 0, lastCount;\n        var o = new Observable_ObservableValue(function () {\n            var i = 0;\n            var f = function (a) {\n                for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n                    var v = a_1[_i];\n                    if (v instanceof Array) {\n                        // recurse on arrays, to add elements in this position\n                        f(v);\n                    }\n                    else if (!removeGaps || v !== undefined && v !== null) {\n                        // add element to result\n                        nonObservableFlat[i++] = v;\n                    }\n                }\n            };\n            f(_this);\n            nonObservableFlat.length = i;\n            // always return something new to force updates\n            return (lastCount = ++count);\n        });\n        // use the observable value to update flattened array\n        // (temporarily subscribe to avoid flattening again within\n        // current defer timeframe)\n        function flattenAutoSubscribe() {\n            if (!o.subscribed && !Observable_ObservableValue.isObserving()) {\n                unobserved(function () {\n                    var temp = o.map(function (v) { return v; }).subscribe();\n                    Defer_defer(function () { temp.clear(); });\n                });\n            }\n            o.value;\n        }\n        // proxy all flattened properties in result\n        var makeItem = function (i) {\n            var io = new Observable_ObservableValue(function () {\n                // flatten the array first, if needed\n                flattenAutoSubscribe();\n                return nonObservableFlat[i];\n            });\n            return io;\n        };\n        // now, map all properties from this observable\n        var result = new ObservableArray();\n        var _length = 0;\n        Object.defineProperty(result, \"length\", {\n            get: function () {\n                // flatten the array first, if needed\n                flattenAutoSubscribe();\n                var newLength = nonObservableFlat.length;\n                if (newLength > _length) {\n                    unobserved(function () {\n                        // make new numeric properties observable\n                        for (var l = _length; l < newLength; l++)\n                            makePropertyObservable(result, l, makeItem(l));\n                    });\n                }\n                else if (newLength < _length) {\n                    unobserved(function () {\n                        // clear removed properties\n                        for (var l = newLength; l < _length; l++)\n                            deleteObservableProperty(result, l);\n                    });\n                }\n                return _length = newLength;\n            },\n            set: function () {\n                throw new Error(\"Cannot modify length of flattened array\");\n            }\n        });\n        // initialize all values\n        if (!lazy)\n            unobserved(function () { return result.length; });\n        return result;\n    };\n    /** Represent observable arrays as regular JSON arrays */\n    ObservableArray.prototype.toJSON = function () {\n        return this.slice(0);\n    };\n    return ObservableArray;\n}());\n\nvar _mapAsync = ObservableArray_ObservableArray.prototype.mapAsync;\nvar _mapAsyncValues = ObservableArray_ObservableArray.prototype.mapAsyncValues;\nvar _flattenAsync = ObservableArray_ObservableArray.prototype.flattenAsync;\nvar _toJSON = ObservableArray_ObservableArray.prototype.toJSON;\nObservableArray_ObservableArray.prototype = new Array;\nObservableArray_ObservableArray.prototype.constructor = ObservableArray_ObservableArray;\nObservableArray_ObservableArray.prototype.mapAsync = _mapAsync;\nObservableArray_ObservableArray.prototype.mapAsyncValues = _mapAsyncValues;\nObservableArray_ObservableArray.prototype.flattenAsync = _flattenAsync;\nObservableArray_ObservableArray.prototype.toJSON = _toJSON;\n// these functions should not depend on .length but would if not wrapped\nvar _arrayPush = ObservableArray_ObservableArray.prototype.push;\nObservableArray_ObservableArray.prototype.push = function () {\n    var _this = this;\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    return unobserved(function () { return _arrayPush.apply(_this, items); });\n};\nvar _arrayUnshift = ObservableArray_ObservableArray.prototype.unshift;\nObservableArray_ObservableArray.prototype.unshift = function () {\n    var _this = this;\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    return unobserved(function () { return _arrayUnshift.apply(_this, items); });\n};\n// override concat, which otherwise would see ObservableArrays as values:\nObservableArray_ObservableArray.prototype.concat = function () {\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    return Array.prototype.concat.apply(this.slice(0), items.map(function (item) { return (item instanceof ObservableArray_ObservableArray) ? item.slice(0) : item; }));\n};\n/** Returns an ObservableArray instance based on the result of given function: if the returned value is an array, then all elements are copied to the result; if the returned value is an observable array, all elements are proxied; if the returned value is not an array, the result contains this value as a single element; if the returned value is null or undefined, the result will be an empty array; changes in values/elements are reflected asynchronously */\nfunction observeArray(f) {\n    return ObservableArray_ObservableArray.fromObservableValue(new Observable_ObservableValue(f));\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/Async/Observable.js\n\n\n\n\n\n/** Watched observable currently evaluating, if any; used to connect dependencies through signals */\nvar currentWatchedEvaling;\n/** Unwatched observable currently evaluating, if any; used to collect dependencies for dirty checking */\nvar currentUnwatchedEvaling;\n/** @internal Throws an error if currently running an observable getter */\nfunction assertUnobserved() {\n    if (currentWatchedEvaling || currentUnwatchedEvaling)\n        throw new Error(\"Observable getter must be a pure function, \" +\n            \"cannot create or set other observables\");\n}\n/** Represents an observable value (with the value itself in `.value`) */\nvar Observable_ObservableValue = (function () {\n    /** Create a new (single) observed value using optional getter and setter functions; note that getters *should* be pure functions without side effects, creating or setting other observables from the getter will result in an error; getter is not called immediately but only when being subscribed to or when obtaining the value itself (from `.value`) */\n    function ObservableValue(getter, setter) {\n        /** @internal Unique ID used to quickly index dependants of observables */\n        this._uid = String(++ObservableValue.UID);\n        /** @internal Counter that is incremented every time the value becomes unstable (i.e. value set directly, dependency changed, etc.) */\n        this._dirtyIdx = 0;\n        assertUnobserved();\n        // hold off on evaluating until value getter is called\n        if (getter) {\n            this._getter = getter;\n            this._dirtyIdx++;\n        }\n        this._setter = setter;\n    }\n    /** Returns true if currently running in a subscribed-to observable context (i.e. evaluating an observable value, recording dependencies on other observable values being accessed from this context) */\n    ObservableValue.isObserving = function () {\n        return !!currentWatchedEvaling;\n    };\n    /** Encapsulate given value as an ObservableValue */\n    ObservableValue.fromValue = function (value) {\n        var result = new ObservableValue();\n        result.value = value;\n        return result;\n    };\n    /** Encapsulate given promised value as an ObservableValue; the observed value will start out as `undefined` but then changes to the `Promise` result when resolved; or if promise was rejected, hangs on to the error and throws it when retrieving the observable value */\n    ObservableValue.fromPromise = function (valuePromise) {\n        var result = new ObservableValue();\n        if (valuePromise instanceof Promise_Promise) {\n            // shortcut promise status to avoid async\n            var status = valuePromise._getStatus();\n            if (status) {\n                if (status.rejected) {\n                    // set value to \"error\" to trigger change signal\n                    result.value = \"error\";\n                    result._error = status.error;\n                    result._ro = result._nc = true;\n                    return result;\n                }\n                else {\n                    // set value to resolved promise value\n                    result.value = status.value;\n                    result._ro = result._nc = true;\n                    return result;\n                }\n            }\n            // if not fulfilled yet, use .then anyway:\n        }\n        valuePromise.then(function (value) {\n            // set value to resolved promise value\n            result.value = value;\n            result._ro = result._nc = true;\n        }, function (error) {\n            // set value to \"error\" to trigger change signal\n            result.value = \"error\";\n            result._error = error;\n            result._ro = result._nc = true;\n        });\n        return result;\n    };\n    /** Connect to given `Signal`, and create a read-only observable value that always contains the last emitted signal value (initially undefined; the value is only set after the next time the signal is emitted) */\n    ObservableValue.fromSignal = function (signal) {\n        var result = new ObservableValue();\n        result._ro = true;\n        signal._connect(function (v) {\n            result._ro = false;\n            result.value = v;\n            result._ro = true;\n        });\n        return result;\n    };\n    /** Set a getter function for the observable value, which should return a current value, or another ObservableValue instance, or set `.value` directly; note that getters *should* be pure functions without side effects, creating or setting other observables from the getter will result in an error; the getter is only invoked (asynchronously) if a value had been set previously and needs to be updated; reading `.value` from the getter results in the value previously set, no recursion occurs; returns this */\n    ObservableValue.prototype.getter = function (f) {\n        if (this._ro)\n            throw new Error(\"Cannot modify this observable value\");\n        assertUnobserved();\n        this._getter = f;\n        // remove current static value and re-eval if needed\n        if (Object.prototype.hasOwnProperty.call(this, \"_val\")) {\n            if (f)\n                delete this._val;\n            this._asyncEval();\n        }\n        if (!f) {\n            // remove all (old getter's) dependencies if clearing getter\n            this._removeDependencies();\n        }\n        return this;\n    };\n    /** Set a setter function for the observable value; setting `.value` directly from the setter results in changing the underlying observable value (which can also be read by the getter, or the setter itself), no recursion occurs; returns this */\n    ObservableValue.prototype.setter = function (f) {\n        if (this._ro)\n            throw new Error(\"Cannot modify this observable value\");\n        assertUnobserved();\n        this._setter = f;\n        return this;\n    };\n    Object.defineProperty(ObservableValue.prototype, \"value\", {\n        /** Observable value, (re-) evaluated only if necessary; when set to an `ObservableValue` instance, this property returns that instance's value, until this property is set to another value (except if the `ObservableValue` has a setter, which is called first); plain Array values are turned into `ObservableArray` instances, and plain Object instances into `ObservableObject` instances --- unless `.shallow` is set to true */\n        get: function () {\n            var _this = this;\n            if (this._error)\n                throw this._error;\n            // return current value if running getter, setter, or value will not\n            // change and is not proxied from another observable value:\n            if (this._getting && !this._set)\n                return undefined;\n            if (this._getting || this._setting ||\n                this._nc && !(this._val instanceof ObservableValue))\n                return this._val;\n            // register as dependency to previously evaluating observable\n            if (currentWatchedEvaling)\n                currentWatchedEvaling._addConnection(this);\n            else if (currentUnwatchedEvaling)\n                currentUnwatchedEvaling._addCheck(this);\n            // re-evaluate if necessary:\n            var hadValue = !!this._valIdx;\n            var oldValue = this._val;\n            if (this._needsEval()) {\n                this._oldConnections = this._depConnections;\n                // set this instance as currently evaluating to find dependencies\n                var prevWatched = currentWatchedEvaling, prevUnwatched = currentUnwatchedEvaling;\n                if (this._watched) {\n                    currentWatchedEvaling = this;\n                    this._depConnections = {};\n                }\n                else {\n                    currentUnwatchedEvaling = this;\n                    this._depChecks = [];\n                }\n                this._getting = true;\n                this._direct = false;\n                try {\n                    // store getter result or let getter set value directly\n                    var result = this._getter.call(undefined);\n                    if (!(result === undefined && this._direct))\n                        this._val = result;\n                }\n                finally {\n                    this._getting = false;\n                    // stop solliciting dependencies\n                    currentWatchedEvaling = prevWatched;\n                    currentUnwatchedEvaling = prevUnwatched;\n                    // unsubscribe from old dependencies that are no longer used\n                    var oldConnections = this._oldConnections;\n                    delete this._oldConnections;\n                    if (this._depConnections) {\n                        for (var uid in oldConnections)\n                            if (!this._depConnections[uid])\n                                oldConnections[uid].dis();\n                    }\n                }\n                // mark value as up to date\n                this._valIdx = this._dirtyIdx;\n            }\n            // return new value\n            var value = this._val;\n            // proxy other ObservableValues' values\n            var oldConnection = this._proxyConnection;\n            if (!this.shallow && value instanceof ObservableValue) {\n                if (this._watched) {\n                    // subscribers should also be notified for proxy value changes\n                    // (until next value is evaluated, or this observable is\n                    // unsubscribed from)\n                    var proxied = value;\n                    var sig = proxied;\n                    this._proxyConnection = sig.connect(function (v) {\n                        if (_this._val === proxied)\n                            _this.emitSync(v);\n                    });\n                }\n                value = value.value;\n            }\n            if (oldConnection) {\n                oldConnection.disconnect();\n                if (this._proxyConnection === oldConnection)\n                    delete this._proxyConnection;\n            }\n            // emit signal(s) if changed\n            if (hadValue && this._val !== oldValue) {\n                this._auxCallbacks && this._auxCallbacks.forEach(function (f) { return f(); });\n                this.emitSync(value);\n            }\n            return value;\n        },\n        set: function (value) {\n            if (!this._getting && !this._setting)\n                assertUnobserved();\n            // convert plain arrays and objects (unless about to run setter)\n            if (!this.shallow && (!this._setter || this._setting)) {\n                // make ObservableArray instances out of plain Arrays\n                if (value instanceof Array && value.constructor === Array) {\n                    unobserved(function () {\n                        value = ObservableArray_ObservableArray.fromArray(value);\n                    });\n                }\n                // make ObservableObject instances out of plain Objects\n                if (value instanceof Object && value.constructor === Object) {\n                    unobserved(function () {\n                        value = makeObjectObservable(value);\n                    });\n                }\n            }\n            // check what to do with the new value:\n            if (this._getting) {\n                // set value directly, no signals but mark as changed\n                this._val = value;\n                this._set = true;\n                this._direct = true;\n                this._valIdx = ++this._dirtyIdx;\n            }\n            else if (this._getter && !this._setter || this._ro) {\n                // cannot set value directly outside of getter function\n                // (or value is resolved Promise)\n                throw new Error(\"Cannot set value\");\n            }\n            else if ((!this._setter || this._setting) &&\n                (this._val instanceof ObservableValue) &&\n                this._val._setter) {\n                // proxy through observable value setter\n                this._val.value = value;\n            }\n            else if (this._setter && !this._setting) {\n                // invoke setter\n                this._setting = true;\n                try {\n                    this._setter.call(undefined, value);\n                }\n                finally {\n                    this._setting = false;\n                }\n            }\n            else if (value !== this._val) {\n                // mark value as changed (but not dirty)\n                this._valIdx = ++this._dirtyIdx;\n                // set value and emit signal(s)\n                this._val = value;\n                this._set = true;\n                this._auxCallbacks && this._auxCallbacks.forEach(function (f) { return f(); });\n                this.emitSync(value);\n            }\n            else {\n                this._set = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Returns .value (observable if used within an observable getter) */\n    ObservableValue.prototype.valueOf = function () { return this.value; };\n    /** Returns .value as a string (observable if used within an observable getter) */\n    ObservableValue.prototype.toString = function () { return String(this.value); };\n    /** Returns last value set, does not re-evaluate and/or add dependency */\n    ObservableValue.prototype.getLastValue = function () {\n        // return value or proxy other ObservableValue's value\n        var value = this._val;\n        while (value instanceof ObservableValue)\n            value = value.getLastValue();\n        return value;\n    };\n    /** Transform this observable value using given function, into a new ObservableValue instance; note that the transformation function is not necessarily invoked after each value change, if the new observable is not subscribed to and/or multiple changes occur (asynchronously) before the transformation is evaluated; observables used by the given function itself are not automatically subscribed to (wrap given function in observe(...) to observe dependencies as well) */\n    ObservableValue.prototype.map = function (callback) {\n        var _this = this;\n        var lastValue = {};\n        var mapped = new ObservableValue(function () {\n            var value = _this.value;\n            if (value === lastValue)\n                return mapped.value;\n            mapped.value = unobserved(callback, lastValue = value);\n        });\n        return mapped;\n    };\n    ObservableValue.prototype.subscribe = function (callback) {\n        var _this = this;\n        this._connect(callback);\n        // listen for signal emissions while initializing value if needed\n        var current = this._val, emitted = false, f;\n        if (this._getter || this._val instanceof ObservableValue) {\n            if (!this._auxCallbacks)\n                this._auxCallbacks = [];\n            this._auxCallbacks.push(f = function () { emitted = true; });\n            unobserved(function () { current = _this.value; });\n            if (this._auxCallbacks.length === 1)\n                delete this._auxCallbacks;\n            else\n                this._auxCallbacks = this._auxCallbacks.filter(function (v) { return v !== f; });\n        }\n        // if not already emitted signal, invoke callback for current value\n        if (!emitted)\n            callback && Defer_defer(callback, [current]);\n        return this;\n    };\n    /** Start listening for changes to this observable value and all of its dependencies asynchronously, and return a promise for the next (different) value of the observable; does _not_ force evaluation of the current value (i.e. getters are not called); stops subscribing immediately after the promise is resolved */\n    ObservableValue.prototype.next = function () {\n        var _this = this;\n        // force signal even if no value had been set yet\n        if (!this._valIdx)\n            this._valIdx = -1;\n        return new Promise_Promise(function (resolve) {\n            _this.connectOnce(function (v) { resolve(v); });\n        });\n    };\n    Object.defineProperty(ObservableValue.prototype, \"subscribed\", {\n        /** True if this observable value is currently subscribed to, either directly or from dependent observables */\n        get: function () { return !!this._watched; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ObservableValue.prototype, \"writable\", {\n        /** True if this observable value is writable (not only a getter defined) */\n        get: function () { return !(this._ro || this._getter && !this._setter); },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internal Add a callback to invoke (synchronously) when this value changes, but do not watch for changes directly (i.e. does not connect to signal and start watching), callback must NOT throw an exception; used for emitting Observable.PropertyChange */\n    ObservableValue.prototype.invokeOnChange = function (callback) {\n        if (!this._auxCallbacks)\n            this._auxCallbacks = [];\n        this._auxCallbacks.push(callback);\n    };\n    /** Clear value and remove getter/setter functions, unsubscribe from dependencies */\n    ObservableValue.prototype.clear = function () {\n        this.getter(undefined).setter(undefined);\n        delete this._val;\n        delete this._set;\n    };\n    /** Manually invoke the getter function synchronously, if any; can be used only if not currently evaluating another observable value (otherwise, wrap in a call to `unobserved`); calling this method is normally not necessary, and should only be used if external factors outside of observables change in such a way that the result of the getter function changes; if so, then subsequent retrieval of `.value` results in the new value, and dependent observable values are scheduled to update automatically (asynchronously) */\n    ObservableValue.prototype.update = function () {\n        assertUnobserved();\n        if (this._getter) {\n            this._dirtyIdx++;\n            this.value;\n        }\n    };\n    /** @internal Returns true if value needs to be reevaluated */\n    ObservableValue.prototype._needsEval = function () {\n        if (!this._getter)\n            return false;\n        if ((this._valIdx || 0) !== this._dirtyIdx)\n            return true;\n        // if value is watched, then dependencies are watched too\n        // and are up to date if value is up to date (above check)\n        if (this._watched)\n            return false;\n        // check if dependencies (may) have changed since last evaluation\n        return !this._depChecks || this._depChecks.some(function (f) { return f({}); });\n    };\n    /** @internal Mark as dirty (if not already dirty) and schedule re-evaluation of value if still watched */\n    ObservableValue.prototype._asyncEval = function () {\n        var _this = this;\n        if ((this._valIdx || 0) === this._dirtyIdx && !this._getting) {\n            this._dirtyIdx++;\n            Defer_defer(function () {\n                if (_this._watched && _this._valIdx !== _this._dirtyIdx)\n                    _this.value;\n            });\n        }\n    };\n    /** @internal Register a watched dependency of this value */\n    ObservableValue.prototype._addConnection = function (other) {\n        if (other === this)\n            return;\n        if (!this._depConnections)\n            this._depConnections = {};\n        // check if connection already existed\n        var old;\n        if (this._oldConnections && (old = this._oldConnections[other._uid])) {\n            // use existing object\n            this._depConnections[other._uid] = old;\n        }\n        else {\n            // add handler to mark this value as dirty whenever other value\n            // changes (not async since signal is always emitted synchronously,\n            // see above); _connect returns disconnect method\n            var dis = other._connect(this._asyncEval.bind(this));\n            // store new dependency object\n            this._depConnections[other._uid] = { dep: other, dis: dis };\n        }\n    };\n    /** @internal Register an unwatched dependency of this value (checked for changes every time when getting the unwatched observable value) */\n    ObservableValue.prototype._addCheck = function (other) {\n        var _this = this;\n        if (other === this)\n            return;\n        // maintain a function to check if the other value has changed\n        // (different _dirtyIdx or recurse down dependency tree)\n        var lastDirtyIdx = other._dirtyIdx;\n        (this._depChecks || (this._depChecks = [])).push(function (seen) {\n            if (seen[_this._uid])\n                return true;\n            seen[_this._uid] = true;\n            return (other._dirtyIdx !== lastDirtyIdx ||\n                !other._depChecks || other._depChecks.some(function (f) { return f(seen); }));\n        });\n    };\n    /** @internal Disconnect existing dependencies */\n    ObservableValue.prototype._removeDependencies = function () {\n        delete this._depChecks;\n        var connections = this._depConnections;\n        delete this._depConnections;\n        for (var uid in connections)\n            connections[uid].dis();\n        // also disconnect from proxied observable, if any\n        if (this._proxyConnection) {\n            this._proxyConnection.disconnect();\n            delete this._proxyConnection;\n        }\n    };\n    /** @internal handler for first signal connection */\n    ObservableValue.prototype.onHandlerConnected = function () {\n        this._watched = true;\n        if (!this._depChecks || this._depChecks.length) {\n            // not sure about dependencies, force re-eval\n            this._removeDependencies();\n            this._dirtyIdx++;\n        }\n        else {\n            // no dependencies last time, no need to check\n            this._removeDependencies();\n        }\n    };\n    /** @internal handler for last signal disconnection */\n    ObservableValue.prototype.onHandlersDisconnected = function () {\n        this._watched = false;\n        this._removeDependencies();\n    };\n    /** @internal */\n    ObservableValue.UID = 0;\n    return ObservableValue;\n}());\n\n// NOTE: mixing in required signal methods here for better performance,\n// repurposing ObservableValue instances as their own change signals\nObservable_ObservableValue.prototype._connect = Signal_Signal._connect;\nObservable_ObservableValue.prototype.connect = Signal_Signal.connect;\nObservable_ObservableValue.prototype.connectOnce = Signal_Signal.connectOnce;\nObservable_ObservableValue.prototype.emitSync = Signal_Signal.emitSync;\nfunction observe(v) {\n    return (typeof v === \"function\") ? new Observable_ObservableValue(v) :\n        (v && typeof v === \"object\" && typeof v.then === \"function\") ?\n            Observable_ObservableValue.fromPromise(v) :\n            (v instanceof Array) ?\n                ObservableArray_ObservableArray.fromArray(v) :\n                (v instanceof Object) ?\n                    makeObjectObservable(v) :\n                    (function () { throw new TypeError(); })();\n}\nfunction unobserved(f) {\n    var prevWatched = currentWatchedEvaling;\n    var prevUnwatched = currentUnwatchedEvaling;\n    try {\n        currentWatchedEvaling = undefined;\n        currentUnwatchedEvaling = undefined;\n        return f.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n    finally {\n        currentWatchedEvaling = prevWatched;\n        currentUnwatchedEvaling = prevUnwatched;\n    }\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/Async/Inject.js\n\n\n/** _Property decorator_, makes a property observable on every instance, with a read-only value shared across all instances taken from an (earlier OR later) call to `inject`, *until* the property is directly assigned to [requires ES5+ target] [decorator] */\nfunction injectable(target, key, descriptor) {\n    if (!descriptor)\n        descriptor = { enumerable: true };\n    // capture existing value (e.g. method on prototype)\n    var value = descriptor.value;\n    delete descriptor.value;\n    delete descriptor.writable;\n    // use a single observable per class to capture the last injected value\n    var injector = Observable_ObservableValue.fromValue(value);\n    descriptor.get = function () {\n        var _this = this;\n        unobserved(function () {\n            makePropertyObservable(_this, key, Observable_ObservableValue.fromValue(injector));\n        });\n        return this[key];\n    };\n    // setter just initializes an observable with given value\n    // (will ignore injection altogether)\n    descriptor.set = function (value) {\n        makePropertyObservable(this, key);\n        this[key] = value;\n    };\n    // store a reference to the observable injector value\n    descriptor.get[\"*injector\"] = injector;\n    return descriptor;\n}\n/** Set given injectable observable properties (decorated with `injectable`) on *all* instances of given class and derived classes to the given values, except for instances where the property has been overwritten directly; may be called multiple times even with the same properties to redefine their injected value; returns an object that contains the previous injected values (for e.g. overriding an injected function that calls into the previously injected function; when injecting into a derived class, these properties use accessors to return latest overridden injected values on base class(es) dynamically) */\nfunction inject(targetClass, spec) {\n    var result = {};\n    var _loop_1 = function () {\n        if (!Object.prototype.hasOwnProperty.call(spec, name))\n            return \"continue\";\n        // get the injector observable for the property on given prototype,\n        // add a value or getter on the result object that reflects the old OR\n        // overridden (observable) value\n        var getInjector = function (proto, d) {\n            if (!proto)\n                return undefined;\n            var desc = Object.getOwnPropertyDescriptor(proto, name);\n            if (!desc || !desc.get || !desc.get[\"*injector\"]) {\n                // recurse if not defined at this level\n                var getter_1 = function () { return getInjector(Object.getPrototypeOf(proto)); };\n                var injector_1 = getter_1();\n                if (d && injector_1) {\n                    // found the injector further down the prototype chain\n                    d.get = function () { return getter_1().getLastValue(); };\n                }\n                return injector_1;\n            }\n            else {\n                // found the injector observable\n                var injector_2 = desc.get[\"*injector\"];\n                if (d) {\n                    // store the last value\n                    d.value = injector_2.getLastValue();\n                }\n                return injector_2;\n            }\n        };\n        d = { enumerable: true, configurable: false };\n        injector = getInjector(targetClass.prototype, d);\n        if (!injector)\n            throw new TypeError(\"Not an injected property: \" + name);\n        // store getter or value on result object\n        Object.defineProperty(result, name, d);\n        // if injecting on derived class, use overriding injector instead\n        if (d.get) {\n            override = injectable(targetClass.prototype, name);\n            Object.defineProperty(targetClass.prototype, name, override);\n            injector = override.get[\"*injector\"];\n        }\n        // set the new value in the (new) injector observable\n        injector.value = spec[name];\n    };\n    var d, injector, override;\n    for (var name in spec) {\n        _loop_1();\n    }\n    return result;\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/Async/index.js\nvar Async_namespaceObject = {};\n__webpack_require__.d(Async_namespaceObject, \"defer\", function() { return Defer_defer; });\n__webpack_require__.d(Async_namespaceObject, \"runYield\", function() { return runYield; });\n__webpack_require__.d(Async_namespaceObject, \"Signal\", function() { return Signal_Signal; });\n__webpack_require__.d(Async_namespaceObject, \"UnhandledException\", function() { return UnhandledException; });\n__webpack_require__.d(Async_namespaceObject, \"Promise\", function() { return Promise_Promise; });\n__webpack_require__.d(Async_namespaceObject, \"sleep\", function() { return sleep; });\n__webpack_require__.d(Async_namespaceObject, \"assertUnobserved\", function() { return assertUnobserved; });\n__webpack_require__.d(Async_namespaceObject, \"ObservableValue\", function() { return Observable_ObservableValue; });\n__webpack_require__.d(Async_namespaceObject, \"observe\", function() { return observe; });\n__webpack_require__.d(Async_namespaceObject, \"unobserved\", function() { return unobserved; });\n__webpack_require__.d(Async_namespaceObject, \"ObservableArray\", function() { return ObservableArray_ObservableArray; });\n__webpack_require__.d(Async_namespaceObject, \"observeArray\", function() { return observeArray; });\n__webpack_require__.d(Async_namespaceObject, \"ObservableObject\", function() { return ObservableObject_ObservableObject; });\n__webpack_require__.d(Async_namespaceObject, \"makeObjectObservable\", function() { return makeObjectObservable; });\n__webpack_require__.d(Async_namespaceObject, \"makePropertyObservable\", function() { return makePropertyObservable; });\n__webpack_require__.d(Async_namespaceObject, \"deleteObservableProperty\", function() { return deleteObservableProperty; });\n__webpack_require__.d(Async_namespaceObject, \"isObservableProperty\", function() { return isObservableProperty; });\n__webpack_require__.d(Async_namespaceObject, \"unobservable\", function() { return unobservable; });\n__webpack_require__.d(Async_namespaceObject, \"unobservable_memoize_get\", function() { return unobservable_memoize_get; });\n__webpack_require__.d(Async_namespaceObject, \"observable\", function() { return observable; });\n__webpack_require__.d(Async_namespaceObject, \"observable_string\", function() { return observable_string; });\n__webpack_require__.d(Async_namespaceObject, \"observable_number\", function() { return observable_number; });\n__webpack_require__.d(Async_namespaceObject, \"observable_shallow\", function() { return observable_shallow; });\n__webpack_require__.d(Async_namespaceObject, \"observable_not_null\", function() { return observable_not_null; });\n__webpack_require__.d(Async_namespaceObject, \"observable_nonNull\", function() { return observable_nonNull; });\n__webpack_require__.d(Async_namespaceObject, \"observable_seal\", function() { return observable_seal; });\n__webpack_require__.d(Async_namespaceObject, \"observable_freeze\", function() { return observable_freeze; });\n__webpack_require__.d(Async_namespaceObject, \"injectable\", function() { return injectable; });\n__webpack_require__.d(Async_namespaceObject, \"inject\", function() { return inject; });\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./dist/core/lib/Async.js\n\n\n/* harmony default export */ var Async_defaultExport = (Async_namespaceObject);\n\n// CONCATENATED MODULE: ./dist/dom/node_modules/@typescene/core/Async.js\n\n// CONCATENATED MODULE: ./dist/dom/lib/Async.js\nvar dom_lib_Async_namespaceObject = {};\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"defer\", function() { return Defer_defer; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"runYield\", function() { return runYield; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"Signal\", function() { return Signal_Signal; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"UnhandledException\", function() { return UnhandledException; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"Promise\", function() { return Promise_Promise; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"sleep\", function() { return sleep; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"assertUnobserved\", function() { return assertUnobserved; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"ObservableValue\", function() { return Observable_ObservableValue; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"observe\", function() { return observe; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"unobserved\", function() { return unobserved; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"ObservableArray\", function() { return ObservableArray_ObservableArray; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"observeArray\", function() { return observeArray; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"ObservableObject\", function() { return ObservableObject_ObservableObject; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"makeObjectObservable\", function() { return makeObjectObservable; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"makePropertyObservable\", function() { return makePropertyObservable; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"deleteObservableProperty\", function() { return deleteObservableProperty; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"isObservableProperty\", function() { return isObservableProperty; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"unobservable\", function() { return unobservable; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"unobservable_memoize_get\", function() { return unobservable_memoize_get; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"observable\", function() { return observable; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"observable_string\", function() { return observable_string; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"observable_number\", function() { return observable_number; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"observable_shallow\", function() { return observable_shallow; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"observable_not_null\", function() { return observable_not_null; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"observable_nonNull\", function() { return observable_nonNull; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"observable_seal\", function() { return observable_seal; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"observable_freeze\", function() { return observable_freeze; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"injectable\", function() { return injectable; });\n__webpack_require__.d(dom_lib_Async_namespaceObject, \"inject\", function() { return inject; });\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Style.js\n\n/** Next UID to be used */\nvar _nextUID = 0;\n/** Encapsulates CSS style properties, classes, and hidden/selected attributes; these styles are observed when applied to components on screen, by themselves or overridden using another Style instance (see `.override(...)`); properties are always applied in alphabetical order, i.e `backgroundColor` after `background`, `paddingTop` after `padding`, etc. */\nvar Style_Style = (function () {\n    /** Create a new instance with given styles; class name argument may contain multiple class names separated with spaces */\n    function Style(styles, className, hidden) {\n        /** Globally unique ID for this Style instance */\n        this.uid = \"S\" + _nextUID++;\n        this._keys = new Async_defaultExport.ObservableArray();\n        this._status = new Async_defaultExport.ObservableValue();\n        this._overrides = new Async_defaultExport.ObservableValue();\n        if (className !== undefined)\n            this.addClass.apply(this, className.split(/\\s+/));\n        if (hidden !== undefined)\n            hidden ? this.hide() : this.show();\n        if (styles)\n            this.set(styles);\n    }\n    /** Create a Style instance that only contains given class name(s); alias for new Style(undefined, className) */\n    Style.withClass = function (className) {\n        return new Style(undefined, className);\n    };\n    /** Add the given class name(s); returns this */\n    Style.prototype.addClass = function () {\n        var classNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            classNames[_i] = arguments[_i];\n        }\n        for (var _a = 0, classNames_1 = classNames; _a < classNames_1.length; _a++) {\n            var s = classNames_1[_a];\n            s = s.trim();\n            if (s)\n                this._setProperty(\".\" + s, true);\n        }\n        return this;\n    };\n    /** Remove the given class name(s), from this instance as well as any instances that this instance overrides; returns this */\n    Style.prototype.removeClass = function () {\n        var classNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            classNames[_i] = arguments[_i];\n        }\n        for (var _a = 0, classNames_2 = classNames; _a < classNames_2.length; _a++) {\n            var s = classNames_2[_a];\n            s = s.trim();\n            if (s)\n                this._setProperty(\".\" + s, false);\n        }\n        return this;\n    };\n    /** Remove (all) existing CSS class name(s) and use given class(es) (only on this Style instance, not on overriding or overridden styles); returns this */\n    Style.prototype.setClass = function () {\n        var _this = this;\n        var classNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            classNames[_i] = arguments[_i];\n        }\n        this._keys.forEach(function (name) {\n            if (name[0] === \".\")\n                _this._props[name] = false;\n        });\n        this.addClass.apply(this, classNames);\n        return this;\n    };\n    /** Returns the current CSS class name(s) stored in this instance (observable) */\n    Style.prototype.getClassName = function () {\n        return this._keys\n            .map(function (key) { return key[0] === \".\" ? \" \" + key.slice(1) : \"\"; })\n            .join(\"\").slice(1);\n    };\n    /** Returns value for given property; the property must be set explicitly on this Style instance or overriding Style instances */\n    Style.prototype.get = function (propertyName) {\n        var result = this._props && this._props[propertyName];\n        var overrides = this._overrides.value;\n        overrides && overrides.forEach(function (style) {\n            var r = style && style.get(propertyName);\n            if (r !== undefined)\n                result = r;\n        });\n        return result;\n    };\n    /** Add a drop shadow effect, with given depth factor (0-1); returns this */\n    Style.prototype.addShadowEffect = function (depth) {\n        this._setProperty(\":shadow\", depth);\n        return this;\n    };\n    Style.prototype.hide = function (hidden) {\n        if (hidden === void 0) { hidden = true; }\n        this._setProperty(\":hidden\", hidden);\n        return this;\n    };\n    /** Remove the \"hidden\" attribute; returns this */\n    Style.prototype.show = function () {\n        this._setProperty(\":hidden\", false);\n        return this;\n    };\n    /** Returns hidden state for this Style instance, true if explicitly hidden, false if explicity shown, undefined otherwise (observable) */\n    Style.prototype.isHidden = function () {\n        if (!this._props || !this._props[\":hidden\"])\n            this._setProperty(\":hidden\");\n        return this._props[\":hidden\"];\n    };\n    Style.prototype.select = function (selected) {\n        if (selected === void 0) { selected = true; }\n        this._setProperty(\":selected\", selected);\n        return this;\n    };\n    /** Remove the \"selected\" attribute; returns this */\n    Style.prototype.deselect = function () {\n        this._setProperty(\":selected\", false);\n        return this;\n    };\n    /** Returns selection state for this Style instance, true if explicitly selected, false if explicity deselected, undefined otherwise (observable) */\n    Style.prototype.isSelected = function () {\n        if (!this._props || !this._props[\":selected\"])\n            this._setProperty(\":selected\");\n        return this._props[\":selected\"];\n    };\n    Style.prototype.set = function (obj, value) {\n        if (typeof obj === \"string\") {\n            // set single property\n            this._setProperty(obj, value);\n        }\n        else if (obj instanceof Async_defaultExport.ObservableObject) {\n            // proxy all existing observable properties\n            for (var prop in obj) {\n                if (obj.hasObservableProperty(prop))\n                    this._setProperty(prop, Async_defaultExport.observe(function () { return obj[prop]; }));\n            }\n        }\n        else {\n            // copy all properties directly\n            for (var prop in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, prop))\n                    this._setProperty(prop, obj[prop]);\n            }\n        }\n        // update observable list of sorted properties\n        var sorted = this._keys;\n        if (sorted.length) {\n            var unsorted = Object.keys(this._props);\n            sorted.length = unsorted.length;\n            unsorted.sort().forEach(function (key, i) { sorted[i] = key; });\n        }\n        return this;\n    };\n    /** @internal Call given callback for each property that has been set on this Style instance, in alphabetical (ASCII) order, _plus_ properties \":hidden\", \":selected\" and \".classname\" properties if defined on this instance */\n    Style.prototype.forEachProperty = function (f) {\n        var _this = this;\n        this._keys.forEach(function (name) { f(name, _this._props[name]); });\n    };\n    /** Override styles and classes with those from given Style instance; returns this */\n    Style.prototype.override = function (style) {\n        var overrides = this._overrides.value ||\n            (this._overrides.value = new Async_defaultExport.ObservableArray());\n        if (style instanceof Async_defaultExport.ObservableValue) {\n            // add an observable value to the overrides list\n            overrides.push(Async_defaultExport.observe(function () {\n                var s = style.value;\n                if (s && !(s instanceof Style))\n                    s = Async_defaultExport.unobserved(function () { return new Style(s); });\n                return s;\n            }));\n        }\n        else if (style) {\n            // add a Style instance to the overrides list\n            if (!(style instanceof Style))\n                style = new Style(style);\n            else if (style === this)\n                throw new Error();\n            overrides.push(style);\n        }\n        return this;\n    };\n    /** Returns a list that consists of this Style instance itself, plus any recursively overriding Style instances in effect; except for instances without any non-empty properties or classes (observable) */\n    Style.prototype.getOverrides = function () {\n        var result = [];\n        var base = this;\n        (function addOverrides(s) {\n            if (!s)\n                return;\n            if (s._status.value >= (s === base ? 2 : 1))\n                result.push(s);\n            var overrides = s._overrides.value;\n            overrides && overrides.forEach(addOverrides);\n        })(this);\n        return result;\n    };\n    /** Helper method to set an observable property on `._props` to given value and set `._status` accordingly; creates the `._props` object, makes the property observable, and adds the property name to the `._keys` array if needed (but does NOT sort it) */\n    Style.prototype._setProperty = function (name, value) {\n        if (!this._props)\n            this._props = new Async_defaultExport.ObservableObject();\n        // make property observable and add to list of keys\n        if (!this._props.hasObservableProperty(name)) {\n            Async_defaultExport.makePropertyObservable(this._props, name);\n            this._keys.push(name);\n        }\n        // set value\n        this._props[name] = value;\n        // increase current status\n        var status = (value !== undefined && value !== \"\") ? 2 : 1;\n        if (!this._status.value || this._status.value < status)\n            this._status.value = status;\n    };\n    return Style;\n}());\n\n(function (Style) {\n    ;\n})(Style_Style || (Style_Style = {}));\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/ComponentSignal.js\nvar ComponentSignal___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n/** Signal that is emitted by a component instance as the result of a user action */\nvar ComponentSignal = (function (_super) {\n    ComponentSignal___extends(ComponentSignal, _super);\n    function ComponentSignal() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ComponentSignal;\n}(Async_defaultExport.Signal));\n\n/** [implementation] \"Constructor\" wrapper for a UI signal handler */\nvar ComponentSignalHandler = (function () {\n    function ComponentSignalHandler(f) {\n        if (!this || !this.constructor ||\n            this.constructor !== ComponentSignalHandler &&\n                !(this.constructor.prototype instanceof ComponentSignalHandler))\n            throw new TypeError();\n        var result = f;\n        result.connectTo = function (signal) {\n            return signal.connect(this);\n        };\n        result.isEventHandler = true;\n        return result;\n    }\n    return ComponentSignalHandler;\n}());\n\n/** @internal Returns a new component signal class specific to a component, with given signal base class */\nfunction defineComponentSignal(base, component, properties) {\n    if (properties === void 0) { properties = {}; }\n    var sig = base.create();\n    for (var p in properties)\n        sig[p] = properties[p];\n    sig.component = component;\n    return sig;\n}\n/** Constructor for a component signal handler (no event data) */\nvar ActionHandler = (function (_super) {\n    ComponentSignal___extends(ActionHandler, _super);\n    function ActionHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ActionHandler;\n}(ComponentSignalHandler));\n\n/** Signal that is emitted when a keyboard event occurs */\nvar KeyEventSignal = (function (_super) {\n    ComponentSignal___extends(KeyEventSignal, _super);\n    function KeyEventSignal() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return KeyEventSignal;\n}(ComponentSignal));\n\n/** Constructor for a keyboard event handler */\nvar KeyHandler = (function (_super) {\n    ComponentSignal___extends(KeyHandler, _super);\n    function KeyHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return KeyHandler;\n}(ComponentSignalHandler));\n\n/** Signal that is emitted when a mouse/pointer event occurs */\nvar PointerEventSignal = (function (_super) {\n    ComponentSignal___extends(PointerEventSignal, _super);\n    function PointerEventSignal() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PointerEventSignal;\n}(ComponentSignal));\n\n/** Constructor for a mouse/pointer event handler */\nvar PointerHandler = (function (_super) {\n    ComponentSignal___extends(PointerHandler, _super);\n    function PointerHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return PointerHandler;\n}(ComponentSignalHandler));\n\n/** Signal that is emitted when a custom drag event occurs */\nvar DragEventSignal = (function (_super) {\n    ComponentSignal___extends(DragEventSignal, _super);\n    function DragEventSignal() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return DragEventSignal;\n}(ComponentSignal));\n\n/** Constructor for a drag event handler */\nvar DragHandler = (function (_super) {\n    ComponentSignal___extends(DragHandler, _super);\n    function DragHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return DragHandler;\n}(ComponentSignalHandler));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Binding.js\nvar Binding___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n/** Represents a property binding, used with component factories to proxy values taken from the base component instance onto properties of its sub components */\nvar Binding_Binding = (function () {\n    /** Create a new binding based on the given property name/path (referring to the base component, on which .with or .initializeWith was called; resulting values can also be instances of ObservableValue or Promise), and optionally a transformation function, invoked each time the observed value changes (outside of any observable context, like `map` on `ObservableValue`, i.e. no further dependencies are recorded); if no path is specified, the name of the initializer property that contains this binding is used, if any */\n    function Binding(sourcePath, getTransform) {\n        if (typeof sourcePath === \"string\") {\n            sourcePath = String(sourcePath || \"\");\n            if (this._neg = sourcePath[0] === \"!\")\n                sourcePath = sourcePath.slice(1);\n            this._p = sourcePath.split(\".\");\n        }\n        this._fget = getTransform;\n    }\n    /** Construct an ObservableValue that is bound to the value on given component (used by factory initializer to apply binding) */\n    Binding.prototype.observeOn = function (component, name) {\n        var parts = this._p, neg = this._neg, fget = this._fget;\n        if (!parts)\n            parts = [name || \"\"];\n        var getter = neg ?\n            (function (f) { return function () { return !f(); }; })(makePathFinder(parts, component)) :\n            makePathFinder(parts, component);\n        return fget ?\n            Async_defaultExport.observe(getter).map(function (v) { return unpromise(fget(v, component)); }) :\n            Async_defaultExport.observe(function () { return unpromise(getter()); });\n    };\n    return Binding;\n}());\n\n/** Represents a two-way binding (`Binding` that also includes a setter on the proxy property) */\nvar TwoWayBinding = (function (_super) {\n    Binding___extends(TwoWayBinding, _super);\n    /** Create a new two-way binding based on the given property name/path (see `new Binding`), and optionally a transformation function, invoked each time a new value is being set (outside of any observable context); if no path is specified, the name of the initializer property that contains this binding is used, if any */\n    function TwoWayBinding(sourcePath, getTransform, setTransform) {\n        var _this = _super.call(this, sourcePath, getTransform) || this;\n        _this._fset = setTransform;\n        if (sourcePath && sourcePath.slice(-2) === \"()\")\n            throw new Error(\"Invalid binding: cannot assign to a method\");\n        return _this;\n    }\n    /** Make an ObservableValue that is bound to the value on given component (used by factory initializer to apply binding) */\n    TwoWayBinding.prototype.observeOn = function (component, name) {\n        var result = _super.prototype.observeOn.call(this, component, name);\n        var parts = this._p, neg = this._neg, fset = this._fset;\n        if (!parts)\n            parts = [name || \"\"];\n        var baseFinder = makePathFinder(parts.slice(0, -1), component);\n        var target = parts[parts.length - 1];\n        result.setter(function (value) {\n            var obj = baseFinder();\n            if (obj) {\n                if (fset)\n                    value = fset(neg ? !value : value, component);\n                else if (neg)\n                    value = !value;\n                obj[target] = value;\n            }\n        });\n        return result;\n    };\n    return TwoWayBinding;\n}(Binding_Binding));\n\n/** Represents an array property binding, used with component factories to proxy arrays taken from the base component instance onto array properties of its sub components; all arrays are _lazily bound_, i.e. elements remain undefined until their `length` property has been evaluated */\nvar Binding_ArrayBinding = (function (_super) {\n    Binding___extends(ArrayBinding, _super);\n    function ArrayBinding(sourcePath, getTransform, itemTransform, uniqueValues, flatten) {\n        var _this = _super.call(this, sourcePath, getTransform) || this;\n        _this._eltset = itemTransform;\n        _this._flatten = flatten;\n        _this._mapValues = uniqueValues;\n        return _this;\n    }\n    /** Make an ObservableValue that is bound to the value on given component (used by factory initializer to apply binding); wraps an observable array in an observable value; for better performance, use `.observeArrayOn(...)` directly (used by component factory initializer) */\n    ArrayBinding.prototype.observeOn = function (component, name) {\n        return Async_defaultExport.ObservableValue.fromValue(this.observeArrayOn(component, name));\n    };\n    /** Make an ObservableArray that is bound to the value on given component (used by factory initializer to apply binding); since accessing the bound value at time of binding may be premature, all array elements remain undefined _until_ the `length` property is accessed (e.g. from an observable context such as a component renderer) */\n    ArrayBinding.prototype.observeArrayOn = function (component, name) {\n        // create a lazily-initialized observable array\n        var result = Async_defaultExport.ObservableArray.fromObservableValue(_super.prototype.observeOn.call(this, component, name), true);\n        if (this._eltset) {\n            // additional transformation of values: use mapAsync[Values]\n            var setter_1 = this._eltset;\n            result = this._mapValues ?\n                result.mapAsyncValues(function (v) { return setter_1(v, component); }, undefined, true) :\n                result.mapAsync(function (v) { return setter_1(v, component); }, undefined, true);\n        }\n        if (this._flatten) {\n            // additional flattening required (transformation may return array)\n            result = result.flattenAsync(true, true);\n        }\n        return result;\n    };\n    return ArrayBinding;\n}(Binding_Binding));\n\nfunction bind(sourcePath, getTransform) {\n    return new Binding_Binding(sourcePath, getTransform);\n}\nfunction bind2(sourcePath, getTransform, setTransform) {\n    return new TwoWayBinding(sourcePath, getTransform, setTransform);\n}\n/** Create a new `ArrayBinding` for given property name/path on the base component, which should contain an array; the binding resolves to an observable array of instances of given `Component` class (with a constructor that takes one or two arguments: the original array element value, and optionally the base component reference); for use in a component initializer; uses `mapAsync` on the observable array by default: deleting a value in the middle of the array will trigger reinstantiation of all components after it; to use `mapAsyncValues` for better results with arrays of objects, set the `uniqueValues` argument to true; to create components asynchronously in batches, set the `batchSize` argument to a number; all arrays are _lazily bound_, i.e. elements remain undefined until their `length` property has been evaluated */\nfunction bindComponents(sourcePath, componentClass, uniqueValues, batchSize) {\n    if (batchSize === void 0) { batchSize = 0; }\n    var f = function (value, baseComponent) { return new componentClass(value, baseComponent); };\n    return new Binding_ArrayBinding(sourcePath, undefined, _getBatchTransformer(f, batchSize), uniqueValues);\n}\n/** @internal Helper function to generate a getter/transformation function that either returns a result right away or returns a promise that is resolved asynchronously based on given batch size */\nfunction _getBatchTransformer(f, batchSize) {\n    // create components straight away if no batch size specified\n    if (!batchSize)\n        return f;\n    // use a promise to create components in batches\n    var p;\n    var n = 0;\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n        var resolve = function () { return f.apply(undefined, args); };\n        if (n++ === batchSize) {\n            // another batch processed, delay further\n            p = p ? p.then(function () { return Async_defaultExport.sleep(0); }) : Async_defaultExport.sleep(0);\n            n = 1;\n        }\n        return p ? p.then(resolve) : resolve();\n    };\n}\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n// HELPER FUNCTIONS\n/** Helper function to unpack promises transparently */\nfunction unpromise(v) {\n    return (v && typeof v === \"object\" && typeof v.then === \"function\") ?\n        Async_defaultExport.unobserved(function () { return Async_defaultExport.ObservableValue.fromPromise(v); }) : v;\n}\n/** Helper function to make a getter for the given path segment \"...()\" on the result of a chained getter function */\nfunction makeFuncGetter(getter, s) {\n    s = s.slice(0, -2);\n    return function () {\n        var base = getter();\n        return (base && (typeof base[s] === \"function\")) ?\n            base[s]() : undefined;\n    };\n}\n/** Helper function to make a getter for a component by ID \"$(...)\" on the result of a chained getter function */\nfunction makeIDGetter(getter, s) {\n    s = s.slice(2, -1);\n    return function () {\n        var c = getter();\n        return c && c.getComponentById(s);\n    };\n}\n/** Helper function to create a function that returns the value of a property with given path segments on the given base component */\nfunction makePathFinder(parts, component) {\n    var f = function () { return component; };\n    return parts.reduce(function (f, s) {\n        // identity:\n        if (s === \"$\" || s === \"$()\")\n            return f;\n        // get component by ID\n        if (s[0] === \"$\" && s[1] === \"(\" && s.slice(-1) === \")\")\n            return makeIDGetter(f, s);\n        // getter call:\n        if (s.slice(-2) === \"()\")\n            return makeFuncGetter(f, s);\n        // property getter:\n        return function () { return (f() || {})[s]; };\n    }, f);\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/TextLabelFactory.js\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Shared factory implementation for a piece of text as a string and/or as (an observable value representing) a Label instance (or sub class); can be used in Component factory specs using UI.tl(...) or with backticks */\nvar TextLabelFactory_TextLabelFactory = (function () {\n    /** Create the text label factory using the given string, stringable (object with a `toString` method), or observable value, along with an optional array of (observable) substitution arguments or a function that returns such an array for a component to bind to, and a Label base class that is used if not overridden by string content prefix */\n    function TextLabelFactory(text, args, observeArgs, baseClass) {\n        this._value = text;\n        if (args)\n            this._args = args;\n        if (observeArgs)\n            this._observe = true;\n        if (baseClass)\n            this._baseClass = baseClass;\n    }\n    /** Get the (translated) encapsulated text as a string; adds a dependency on the observable value if called from an observable value getter; trims {...} prefix if present */\n    TextLabelFactory.prototype.toString = function () {\n        // return string (use ObservableValue:toString if needed)\n        if (typeof this._args === \"function\")\n            throw new Error(\"Cannot resolve bindings in text label\");\n        return this._toString(this._args).replace(/^\\{[^\\}]\\}/, \"\");\n    };\n    /** Get the encapsulated text wrapped in a new Label (or derived) instance, or an observable value representing the instance; uses {...} prefix to control component type and its properties; parameters are used by component factory to initialize bindings used in `tl` strings, if any */\n    TextLabelFactory.prototype.getComponent = function (baseComponent, propertyName) {\n        var _this = this;\n        var args = (typeof this._args === \"function\") ?\n            this._args(baseComponent, propertyName) : this._args;\n        if (this._observe) {\n            // map the observable value to a Label instance\n            var label;\n            return Async_defaultExport.observe(function () { return _this._toString(args); })\n                .map(function (text) { return (label = _this._createComponent(text, label)); });\n        }\n        else {\n            // just create and return the component itself\n            return this._createComponent(this._toString(args));\n        }\n    };\n    /** @internal Injectable method to translate given text (including substitution and pluralization placeholders); injected by App sub module to proxy the `culture` service */\n    TextLabelFactory.prototype[_a = \"@translateText\"] = function (text) { return text; };\n    /** @internal Injectable method to pick a plural form for given number; defaults to English (singular/plural) forms; injected by App sub module to proxy the `culture` service */\n    TextLabelFactory.prototype[_b = \"@pluralizeText\"] = function (n, forms) {\n        return (n > 1 || n < -1) ? (forms[1] || forms[0]) : forms[0];\n    };\n    /** Returns string value with specific substituted arguments */\n    TextLabelFactory.prototype._toString = function (args) {\n        var _this = this;\n        var val = String(this._value);\n        // find out where prefix ends, if any\n        var start = val[0] === \"{\" ? val.indexOf(\"}\") + 1 : 0;\n        if (start === val.length)\n            return val;\n        // translate text itself\n        var text = val.slice(start);\n        if (args && args.length && text === \"%{1}\") {\n            // shortcut: substitute first argument right away\n            return val.slice(0, start) + args[0];\n        }\n        text = this[\"@translateText\"](text);\n        // replace substitutions and put the string back together\n        return val.slice(0, start) + text.replace(/%\\{(\\d+)((?:\\|[^\\|\\}]*)+)?\\}/g, function (s, n, plu) {\n            // ignore substitution/pluralization placeholder if no argument\n            if (!args || args.length < n)\n                return s;\n            // get value and either pluralize or substitute\n            var val = args[parseInt(n, 10) - 1];\n            if (plu)\n                return _this[\"@pluralizeText\"](val, plu.slice(1).split(\"|\"));\n            else\n                return String(val);\n        });\n    };\n    /** Helper function to turn text into a component instance (possibly reusing given old Label instance) */\n    TextLabelFactory.prototype._createComponent = function (str, prev) {\n        var LabelClass = this._baseClass;\n        var icon, width;\n        var style;\n        var setStyle = function (key, value) {\n            if (!style)\n                style = new Style_Style();\n            style.set(key, value);\n        };\n        if (str[0] === \"{\") {\n            var idx = str.indexOf(\"}\");\n            if (idx > 0) {\n                // interpret flags to change label class or styles\n                var flags = str.slice(1, idx).split(\"|\");\n                str = str.slice(idx + 1);\n                flags.forEach(function (f) {\n                    switch (f) {\n                        case \"p\":\n                            LabelClass = Paragraph;\n                            break;\n                        case \"w\":\n                            LabelClass = WideLabel;\n                            break;\n                        case \"l\":\n                            LabelClass = Label_Label;\n                            break;\n                        case \"h1\":\n                            LabelClass = Heading1;\n                            break;\n                        case \"h2\":\n                            LabelClass = Heading2;\n                            break;\n                        case \"h3\":\n                            LabelClass = Heading3;\n                            break;\n                        case \"h4\":\n                            LabelClass = Heading4;\n                            break;\n                        case \"h5\":\n                            LabelClass = Heading5;\n                            break;\n                        case \"h6\":\n                            LabelClass = Heading6;\n                            break;\n                        case \"b\":\n                            setStyle(\"fontWeight\", \"bold\");\n                            break;\n                        case \"i\":\n                            setStyle(\"fontStyle\", \"italic\");\n                            break;\n                        case \"u\":\n                            setStyle(\"textDecoration\", \"underline\");\n                            break;\n                        case \"start\":\n                        case \"end\":\n                        case \"left\":\n                        case \"right\":\n                        case \"center\":\n                            setStyle(\"textAlign\", f);\n                            if (!LabelClass)\n                                LabelClass = Paragraph;\n                            break;\n                        default:\n                            if (/^l:[\\d\\.]+(\\%|[a-z]+)$/.test(f))\n                                width = f.slice(2);\n                            else if (/^#\\w+$/.test(f))\n                                setStyle(\"color\", f);\n                            else if (/^icon:/.test(f))\n                                icon = f.slice(5);\n                            else if (/^\\d+$/.test(f))\n                                setStyle(\"fontWeight\", f);\n                            else if (/^[\\d\\.]+(\\%|[a-z]+)$/.test(f))\n                                setStyle(\"fontSize\", f);\n                            else if (/^\\./.test(f))\n                                f.slice(1).split(\".\").forEach(function (s) {\n                                    return (style || (style = new Style_Style)).addClass(s);\n                                });\n                            else {\n                                var match = /^([\\w-]+)\\s*=\\s*(.*)$/.exec(f);\n                                if (match) {\n                                    var prop = match[1].replace(/-\\w/g, function (s) { return s[1].toUpperCase(); });\n                                    var val = match[2];\n                                    setStyle(prop, (val[0] === '\"') ?\n                                        JSON.parse(val) : val);\n                                }\n                            }\n                    }\n                });\n            }\n        }\n        // create or reuse Label instance\n        if (!LabelClass)\n            LabelClass = Label_Label;\n        var result = (prev instanceof LabelClass) ? prev : new LabelClass();\n        if (icon)\n            result.icon = icon;\n        if (style)\n            result.style.override(style);\n        if (width)\n            result.width = width;\n        result.text = str;\n        return result;\n    };\n    __decorate([\n        Async_defaultExport.injectable\n    ], TextLabelFactory.prototype, _a, null);\n    __decorate([\n        Async_defaultExport.injectable\n    ], TextLabelFactory.prototype, _b, null);\n    return TextLabelFactory;\n    var _a, _b;\n}());\n\n// implementation:\nfunction tl(strings) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    if (strings instanceof Array) {\n        if (strings.length === 1) {\n            // if given just a single text, use a shortcut here\n            return new TextLabelFactory_TextLabelFactory(strings[0]);\n        }\n        // map all function/binding values to observable values with getters\n        var hasBindings = false, hasObservables = false;\n        var args = values && values.map(function (v) {\n            if (typeof v === \"function\") {\n                // use given function as an observable getter\n                v = new Async_defaultExport.ObservableValue(v);\n                hasObservables = true;\n            }\n            else if (v instanceof Binding_Binding) {\n                // make sure to turn into observable later\n                hasBindings = true;\n            }\n            else if (v instanceof Async_defaultExport.ObservableValue) {\n                // remember to observe any other observables\n                hasObservables = true;\n            }\n            return v;\n        });\n        // substitute values with placeholders in the text\n        var text = strings.map(function (s, i) { return i ? i + \"}\" + s : s; }).join(\"%{\");\n        if (hasBindings) {\n            // pass a function that returns the substitution args, after binding\n            return new TextLabelFactory_TextLabelFactory(text, function (baseComponent, propName) {\n                return args.map(function (v) { return (v instanceof Binding_Binding) ?\n                    v.observeOn(baseComponent, propName) : v; });\n            }, true);\n        }\n        else {\n            // pass (observable) values directly\n            return new TextLabelFactory_TextLabelFactory(text, args, hasObservables);\n        }\n    }\n    else if (typeof strings === \"function\") {\n        // if given a getter function, map single observable\n        return new TextLabelFactory_TextLabelFactory(new Async_defaultExport.ObservableValue(strings), undefined, true, values[0]);\n    }\n    else if (strings instanceof Binding_Binding) {\n        // if given a single binding, create a function that returns\n        // the observable value that returns the final text\n        return new TextLabelFactory_TextLabelFactory(\"%{1}\", function (baseComponent, propName) { return [strings.observeOn(baseComponent, propName)]; }, true, values[0]);\n    }\n    else {\n        // if given just a single value, just use a single piece of text\n        return new TextLabelFactory_TextLabelFactory(strings, undefined, false, values[0]);\n    }\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/ComponentFactory.js\nvar ComponentFactory___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n/** Next factory UID */\nvar ComponentFactory__nextUID = 1;\nvar ComponentFactory_ComponentFactory;\n(function (ComponentFactory) {\n    /** Choices for the level at which components in (array) properties are expected to be; used by factory to expand/wrap initializer property values before appending as child nodes on a component decorated with `appendChildComponents`, or storing them in a property decorated with `applyComponentsArray` or `applyComponentRef` */\n    var CLevel;\n    (function (CLevel) {\n        CLevel[CLevel[\"Container\"] = 0] = \"Container\";\n        CLevel[CLevel[\"Block\"] = 1] = \"Block\";\n        CLevel[CLevel[\"ControlElement\"] = 2] = \"ControlElement\";\n        CLevel[CLevel[\"TableRow\"] = 3] = \"TableRow\";\n        CLevel[CLevel[\"TableHeader\"] = 4] = \"TableHeader\";\n    })(CLevel = ComponentFactory.CLevel || (ComponentFactory.CLevel = {}));\n    /** _Class decorator_ for a component class that expects child components (through `appendChild` method) of given type; the factory will then expand/wrap regular and observable objects, factories, classes, or components into the correct type; if `acceptFragments` is set, then components constructed from factories with the `isFragmentFactory` are passed in as-is; used on root component classes, should not need to be used in application code [decorator] */\n    function appendChildComponents(type, acceptFragments) {\n        return function (target) {\n            // store given type in flag property\n            target[\"@ComponentFactory.childType\"] = type;\n            if (acceptFragments) {\n                // set flag to also accept fragment components as-is\n                target[\"@ComponentFactory.acceptFragments\"] = true;\n            }\n        };\n    }\n    ComponentFactory.appendChildComponents = appendChildComponents;\n    /** _Property decorator_ for a property where values from an initializer spec should be applied as an (observable) array of components of given type (e.g. `Block`, `ControlElement`, `TableRow`); the factory will then expand/wrap regular and observable arrays of objects, factories, classes, or components into the correct type [decorator] */\n    function applyComponentsArray(type) {\n        return function (target, key) {\n            // store given type in flag property\n            target[\"@ComponentFactory.apply[]:\" + key] = type;\n        };\n    }\n    ComponentFactory.applyComponentsArray = applyComponentsArray;\n    /** _Property decorator_ for a property where values from an initializer spec should be applied as a reference to a component of given type (e.g. `Block`, `ControlElement`); the factory will then expand/wrap objects, factories, classes, and components into the correct type [decorator] */\n    function applyComponentRef(type) {\n        return function (target, key) {\n            // store given type in flag property\n            target[\"@ComponentFactory.apply:\" + key] = type;\n        };\n    }\n    ComponentFactory.applyComponentRef = applyComponentRef;\n    /** _Property decorator_ for a property for which values from an initializer spec should be applied asynchronously (using an `Async.defer(...)` call), instead of being set directly [decorator] */\n    function applyAsync(target, key) {\n        // set a flag property\n        target[\"@ComponentFactory.async:\" + key] = true;\n    }\n    ComponentFactory.applyAsync = applyAsync;\n    /** _Method decorator_ for the method that should be called to apply the value of an initializer spec property with the given property name; the method should always accept values as well as instances of `Async.ObservableValue` [decorator] */\n    function setterFor(initializerPropertyName) {\n        return function (target, key) {\n            // store method reference in flag property\n            target[\"@ComponentFactory.setter:\" + initializerPropertyName] =\n                target[key];\n        };\n    }\n    ComponentFactory.setterFor = setterFor;\n    /** @internal Initialize given component with properties from given spec, and for given base component, if any; returns the component itself */\n    function initializeWith(spec, base) {\n        if (base === void 0) { base = this; }\n        var component = this;\n        if (spec.id)\n            base[spec.id] = component;\n        var _loop_1 = function (key) {\n            var value = component[key];\n            if ((value instanceof Function) && (value.prototype instanceof Async_defaultExport.Signal)) {\n                // connect signal directly, or use string to find base method\n                t = typeof spec[key];\n                if (t === \"function\" || t === \"string\") {\n                    value.connect(spec[key], base);\n                }\n            }\n            else if (value instanceof Style_Style) {\n                // use style as override\n                component[key] = value.override((spec instanceof Async_defaultExport.ObservableObject) ?\n                    Async_defaultExport.observe(function () { return _getAsyncValue(key, spec[key], base); }) :\n                    _getAsyncValue(key, spec[key], base));\n            }\n            else {\n                var _set_1 = function (value, sync) {\n                    // check if decorated with applyAsync:\n                    if (!sync && component[\"@ComponentFactory.async:\" + key])\n                        return Async_defaultExport.defer(function () { return _set_1(value, true); });\n                    // convert arrays and references, if decorated with apply*\n                    var type = component[\"@ComponentFactory.apply[]:\" + key];\n                    if (type >= 0) {\n                        value = _transformFactoryArray(key, value, type, base, component instanceof TableRow_TableRow);\n                    }\n                    type = component[\"@ComponentFactory.apply:\" + key];\n                    if (type >= 0) {\n                        value = _transformObservableInitializer(key, value, type, base);\n                    }\n                    // check for a setter method\n                    if (component[\"@ComponentFactory.setter:\" + key]) {\n                        // invoke setter with (observable) value\n                        component[\"@ComponentFactory.setter:\" + key](value);\n                    }\n                    else {\n                        // assign (observable) value to component property\n                        component[key] = value;\n                    }\n                };\n                // take or observe value (or binding, or promise)\n                isObservable = (spec instanceof Async_defaultExport.ObservableObject) &&\n                    component.hasObservableProperty(key);\n                _set_1(isObservable ?\n                    Async_defaultExport.observe(function () { return _getAsyncValue(key, spec[key], base); }) :\n                    _getAsyncValue(key, spec[key], base));\n            }\n        };\n        var t, isObservable;\n        for (var key in spec) {\n            _loop_1(key);\n        }\n        return component;\n    }\n    ComponentFactory.initializeWith = initializeWith;\n    ;\n})(ComponentFactory_ComponentFactory || (ComponentFactory_ComponentFactory = {}));\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n// INTERNAL IMPLEMENTATION\n/** @internal Helper function to create a component factory for given target Component class using given factory spec */\nfunction makeFactory() {\n    var values = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        values[_i] = arguments[_i];\n    }\n    var FactoryComponent = this;\n    var InitializedComponent = (function (_super) {\n        ComponentFactory___extends(InitializedComponent, _super);\n        function InitializedComponent() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var _this = _super.apply(this, args) || this;\n            // initialize properties, only if in highest-level constructor\n            // (i.e. not overridden by another component factory, or part of\n            // another component factory UNLESS extended into another class)\n            var C = _this.constructor;\n            if (C.isBaseComponent && C.FactoryComponent === FactoryComponent) {\n                // this is the base component, at the highest level\n                _this.initialize();\n            }\n            else if (!Object.prototype.hasOwnProperty.call(C.prototype, \"_factoryComponent\")) {\n                // this component class is extended into an application class\n                _this.initialize();\n            }\n            return _this;\n        }\n        InitializedComponent.override = function (overrideValues) {\n            values.push(overrideValues);\n        };\n        InitializedComponent.prototype.initialize = function (base) {\n            if (base === void 0) { base = this; }\n            if (_super.prototype.initialize.call(this, base)) {\n                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n                    var spec = values_1[_i];\n                    if (spec && spec.constructor === Object) {\n                        // initialize with given properties\n                        this.initializeWith(spec, base);\n                    }\n                    else if (typeof spec === \"function\" &&\n                        !(spec.prototype instanceof Component_Component)) {\n                        // run given function\n                        spec(this, base);\n                    }\n                    else {\n                        // transform and append given child component\n                        var level = FactoryComponent[\"@ComponentFactory.childType\"];\n                        var frag = FactoryComponent[\"@ComponentFactory.acceptFragments\"];\n                        this.appendChild(_transformFactorySpec(\"child\", spec, level, base, false, frag));\n                    }\n                }\n                return true;\n            }\n            return false;\n        };\n        InitializedComponent.FactoryComponent = FactoryComponent;\n        InitializedComponent.componentFactoryId = \"F\" + ComponentFactory__nextUID++;\n        InitializedComponent.isComponentFactory = true;\n        InitializedComponent.isBaseComponent = true;\n        return InitializedComponent;\n    }(FactoryComponent));\n    // add a property in the prototype to identify this exact class as a factory\n    Object.defineProperty(InitializedComponent.prototype, \"_factoryComponent\", {\n        enumerable: false,\n        value: FactoryComponent\n    });\n    return InitializedComponent;\n}\n/** Helper function to resolve Promise or Binding, or just get value */\nfunction _getAsyncValue(key, value, base) {\n    if (value instanceof Binding_ArrayBinding) {\n        // apply array binding on base component\n        return value.observeArrayOn(base, key);\n    }\n    else if (value instanceof Binding_Binding) {\n        // apply binding on base component\n        return value.observeOn(base, key);\n    }\n    else if (value && typeof value === \"object\" &&\n        typeof value.then === \"function\") {\n        // convert promise to observable value\n        return Async_defaultExport.ObservableValue.fromPromise(value);\n    }\n    return value;\n}\n/** Helper function to transform a single component factory spec to a UI component, or an observable value (if given source is PromiseLike); either the object and property name must be specified, or the property name and value (if recursed) */\nfunction _transformFactorySpec(key, src, targetLevel, base, asTableCol, acceptFragments) {\n    // get value from property, resolve promises/bindings as observable values\n    var value = _getAsyncValue(key, src, base);\n    // recurse for observable values (and promises, bindings...)\n    if (value instanceof Async_defaultExport.ObservableValue)\n        return value.map(function (value) { return _transformFactorySpec(key, value, targetLevel, base, asTableCol); });\n    // use factories to instantiate nested elements\n    if (src && src.isComponentFactory) {\n        var F = src;\n        F.isBaseComponent = false;\n        src = new F();\n        src.initialize(base);\n        // return component without checking/wrapping if it is an accepted fragment\n        if (acceptFragments) {\n            for (var ref = F; ref; ref = ref.FactoryComponent)\n                if (ref.isFragmentFactory)\n                    return src;\n        }\n    }\n    // create valid Component\n    if (typeof src == \"string\" || typeof src == \"number\") {\n        if (!asTableCol)\n            src = new Label_Label(String(src));\n    }\n    else if (src instanceof Array) {\n        // create stack or (table) row containing given components\n        if (targetLevel === ComponentFactory_ComponentFactory.CLevel.TableRow)\n            src = new TableRow_TableRow(_transformFactoryArray(key, src, ComponentFactory_ComponentFactory.CLevel.ControlElement, base, true));\n        else if (targetLevel === ComponentFactory_ComponentFactory.CLevel.TableHeader)\n            src = new TableRow_TableHeader(_transformFactoryArray(key, src, ComponentFactory_ComponentFactory.CLevel.ControlElement, base, true));\n        else if (targetLevel === ComponentFactory_ComponentFactory.CLevel.ControlElement)\n            src = new ControlStack_ControlStack(_transformFactoryArray(key, src, ComponentFactory_ComponentFactory.CLevel.ControlElement, base));\n        else\n            src = new Row_Row(_transformFactoryArray(key, src, ComponentFactory_ComponentFactory.CLevel.ControlElement, base));\n    }\n    else if ((src instanceof Function) &&\n        (src.prototype instanceof Component_Component)) {\n        // instantiate given component class\n        src = new src();\n    }\n    else if (src instanceof TextLabelFactory_TextLabelFactory) {\n        // return (observable) component, or create Row or Container\n        src = src.getComponent(base, key);\n        if (targetLevel !== ComponentFactory_ComponentFactory.CLevel.ControlElement) {\n            src = new Row_Row([src]);\n            if (targetLevel !== ComponentFactory_ComponentFactory.CLevel.Block)\n                src = new Container_Container([src]);\n        }\n        return src;\n    }\n    // wrap if needed\n    if (targetLevel === ComponentFactory_ComponentFactory.CLevel.ControlElement) {\n        // wrap to class down to ControlElement\n        if (src instanceof Container_Container) {\n            var control = new ContainerControl_ContainerControl(src);\n            if (src.width !== \"auto\")\n                control.shrinkwrap = true;\n            return control;\n        }\n        if (src instanceof Block_Block && !asTableCol) {\n            var control = new BlockControl_BlockControl(src);\n            if (src.width !== \"auto\")\n                control.shrinkwrap = true;\n            return control;\n        }\n        return src;\n    }\n    else if (targetLevel === ComponentFactory_ComponentFactory.CLevel.Block) {\n        // wrap into Row, or class down to Row\n        if (src instanceof ControlElement_ControlElement)\n            return new Row_Row([src]);\n        if (src instanceof Container_Container)\n            return new ContainerBlock_ContainerBlock(src);\n        return src;\n    }\n    else if (targetLevel === ComponentFactory_ComponentFactory.CLevel.TableRow ||\n        targetLevel === ComponentFactory_ComponentFactory.CLevel.TableHeader) {\n        // wrap into table row\n        if ((src instanceof TableRow_TableRow) || (src instanceof TableRow_TableHeader))\n            return src;\n        if (src instanceof Container_Container)\n            src = new ContainerControl_ContainerControl(src);\n        if (src !== undefined)\n            return new TableRow_TableRow([src]);\n        return src;\n    }\n    else {\n        // wrap into (Row, and then) container\n        if (src instanceof ControlElement_ControlElement)\n            src = new Row_Row([src]);\n        if (src instanceof Block_Block) {\n            var block_1 = src;\n            src = new Container_Container([block_1]);\n            src.height = Async_defaultExport.observe(function () { return block_1.height; });\n            src.width = Async_defaultExport.observe(function () {\n                var w = block_1.width;\n                return (w !== \"auto\") ? w : \"\";\n            });\n        }\n        return src;\n    }\n}\n/** Helper function to transform an (observable) array of component factory specs */\nfunction _transformFactoryArray(key, src, targetLevel, base, asTableCol) {\n    if (src instanceof Binding_ArrayBinding) {\n        // use bound array directly for better performance\n        src = src.observeArrayOn(base, key);\n    }\n    else if (src instanceof Binding_Binding) {\n        // recurse for bindings\n        return src.observeOn(base, key).map(function (value) {\n            return _transformFactoryArray(key, value, targetLevel, base, asTableCol);\n        });\n    }\n    else if (src instanceof Async_defaultExport.ObservableValue) {\n        // recurse for observable values\n        return src.map(function (value) { return _transformFactoryArray(key, value, targetLevel, base, asTableCol); });\n    }\n    else if (typeof src === \"object\" &&\n        typeof src.then === \"function\") {\n        // recurse for promises of (observable) arrays\n        var obv = Async_defaultExport.ObservableValue.fromPromise(src.then(function (value) {\n            return _transformFactoryArray(key, value, targetLevel, base, asTableCol);\n        }));\n        // use an empty array (rather than undefined) initially,\n        // if promise was not already fulfilled\n        if (!obv.getLastValue())\n            obv.value = [];\n        return obv;\n    }\n    if (src instanceof Async_defaultExport.ObservableArray) {\n        // map observable array asynchronously and lazily\n        return src.mapAsync(function (v, i) { return _transformFactorySpec(key + \".\" + i, v, targetLevel, base, asTableCol); }, undefined, true);\n    }\n    else if (src instanceof Array) {\n        // create an observable array but map only once\n        var result = new Async_defaultExport.ObservableArray();\n        result.length = src.length;\n        src.forEach(function (v, i) {\n            result[i] = _transformFactorySpec(key + \".\" + i, v, targetLevel, base, asTableCol);\n        });\n        return result;\n    }\n    else {\n        // nothing to map, return an empty array\n        return new Async_defaultExport.ObservableArray();\n    }\n}\n/** Helper function to transform a component factory spec value */\nfunction _transformObservableInitializer(key, value, targetLevel, base) {\n    if (value instanceof Async_defaultExport.ObservableValue) {\n        // recurse for observable values\n        return value.map(function (v) { return _transformObservableInitializer(key, v, targetLevel, base); });\n    }\n    // otherwise transform spec now\n    return _transformFactorySpec(key, value, targetLevel, base);\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Component.js\nvar Component___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Component___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Next component UID */\nvar Component__nextUID = 1;\n/** Next selection order number (incremented when an element is selected) */\nvar _selectionOrder = 1;\n/** Component base class to represent every part of the user interface, to be extended by application code (e.g. as a sub class of `Container` or another component class) or constructed from derived component classes (e.g. `Button`) */\nvar Component_Component = (function (_super) {\n    Component___extends(Component, _super);\n    /** Abstract constructor with any number of arguments */\n    function Component() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.call(this) || this;\n        /** Globally unique component identifier */\n        _this.uid = \"C\" + Component__nextUID++;\n        /** Signal emitted after updating DOM (render) */\n        _this.Rendered = _this.createComponentSignal();\n        /** Read-only reference to an instance of `Style`, encapsulating CSS styles and classes for this component; for extensible component classes, do not override this property but use static method `.addStyleOverride(...)` instead */\n        _this.style = _this[\"@overrideStyle\"](Style_Style.withClass(\"UI\"));\n        return _this;\n    }\n    // ^^^ copied from ComponentFactory below\n    /** Initialize this component, i.e. apply properties from component factories, if any; called automatically by the highest-level component factory constructor with the base component as argument (i.e. component on which `.with` was called), can be overridden to initialize other properties before those from the component factory (and invoke `super.initialize()` manually); returns true only if this component had not been initialized before */\n    Component.prototype.initialize = function (base) {\n        return this._initialized ? false : (this._initialized = true);\n    };\n    /** Returns a new component signal class specific to this component, with optional signal base class which must derive from ComponentSignal; can be used to define custom signals in a component constructor or public property initializer (or memoized get-accessor for lazy initialization); sets static property `ComponentSignal.component` of the derived signal class to the component instance, as well as any other static properties given */\n    Component.prototype.createComponentSignal = function (base, properties) {\n        if (properties === void 0) { properties = {}; }\n        return defineComponentSignal(base || ComponentSignal, this, properties);\n    };\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // HIERARCHY METHODS\n    /** Add a child component to this component; only supported by components that actually contain other components (e.g. `Container`), throws an Error otherwise; returns this */\n    Component.prototype.appendChild = function (child) {\n        throw new Error(\"Not implemented\");\n    };\n    /** Returns an array of directly contained components (observable) */\n    Component.prototype.getChildren = function () {\n        return [];\n    };\n    /** Returns a list of currently selected directly contained components, in order of selection (observable) */\n    Component.prototype.getSelectedChildren = function () {\n        return this.getChildren().filter(function (c) { return c.selected; })\n            .sort(function (a, b) { return a._selectionOrder - b._selectionOrder; });\n    };\n    /** Returns the last selected directly contained component (observable); evaluated asynchronously if automatic selection management mode is `ItemClick` or `ItemFocus`, otherwise evaluated synchronously from current selection status of child components */\n    Component.prototype.getLastSelectedChild = function () {\n        return this._lastSelectionAsync ? this._lastSelectionAsync.value :\n            this.getSelectedChildren().pop();\n    };\n    Component.prototype.getComponentById = function (id, componentClass) {\n        var queue = this.getChildren();\n        while (queue.length) {\n            var c = queue.shift();\n            if (c && c.id === id &&\n                (!componentClass || c instanceof componentClass))\n                return c;\n            c && c.getChildren().forEach(function (d) { return queue.push(d); });\n        }\n        return undefined;\n    };\n    /** Returns all (recursive) child components that are an instance of given class (observable) */\n    Component.prototype.getComponentsByType = function (componentClass) {\n        var result = [];\n        this.getChildren().forEach(function (c) {\n            if (c instanceof componentClass)\n                result.push(c);\n            c && c.getComponentsByType(componentClass).forEach(function (r) { return result.push(r); });\n        });\n        return result;\n    };\n    /** Returns true if given component is a child component of this component or any of its child components (observable, but triggers re-evaluation upon every change in child [sub] components) */\n    Component.prototype.contains = function (component) {\n        var queue = this.getChildren();\n        while (queue.length) {\n            var c = queue.shift();\n            if (c === component)\n                return true;\n            c && c.getChildren().forEach(function (d) { return queue.push(d); });\n        }\n        return false;\n    };\n    /** Returns an object containing all current values of input elements (observable) */\n    Component.prototype.getFormValues = function (result) {\n        if (result === void 0) { result = {}; }\n        this.getChildren().forEach(function (v) { v.getFormValues(result); });\n        return result;\n    };\n    /** Set all input values by element name */\n    Component.prototype.setFormValues = function (values) {\n        this.getChildren().forEach(function (v) { v.setFormValues(values); });\n    };\n    Component.prototype.animate = function (animation, continuous, after) {\n        var anim = (typeof animation === \"string\") ?\n            this.animations && this.animations[animation] :\n            animation;\n        var control = anim ?\n            continuous ? anim.play(this) : anim.playOnce(this) :\n            undefined;\n        if (after)\n            control ? control.done.then(after) : Async_defaultExport.defer(after);\n        return control;\n    };\n    /** Wait for this component to be rendered and return a promise for its output (value of `.out`), unless the component is already rendered, in which case this method returns a resolved promise for the last rendered output; never forces the component to be rendered */\n    Component.prototype.getRenderedOutputAsync = function () {\n        var _this = this;\n        // use output property on current renderer\n        var result = this._renderer.output.getLastValue();\n        if (result) {\n            // return value as-is (not undefined)\n            return Async_defaultExport.Promise.resolve(result);\n        }\n        else {\n            // return a promise for the first non-undefined value\n            return new Async_defaultExport.Promise(function (r) {\n                var c = _this._renderer.Rendered.connect(function (out) {\n                    if (out)\n                        r(out), c.disconnect();\n                });\n            });\n        }\n    };\n    /** Returns the last rendered output for this component, if any (value of `.out`); does not trigger a render */\n    Component.prototype.getLastRenderedOutput = function () {\n        return this._renderer.output.getLastValue();\n    };\n    Object.defineProperty(Component.prototype, \"out\", {\n        /** Rendered output for this component (observable); retrieving this value triggers a render operation, if it was not already subscribed to, e.g. if the component is displayed on screen; the renderer is lazily constructed from the class reference injected into the `.Renderer` property */\n        get: function () {\n            return this._renderer.output.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Render this component synchronously, always updating any existing rendered output; this method should _not_ be used unless changes may have occurred outside of the observable context, otherwise read the value from `.out`, include it on a `Page`, or use the `.display()` method where available */\n    Component.prototype.render = function () {\n        this._renderer.output.update();\n        return this._renderer.output.getLastValue();\n    };\n    Object.defineProperty(Component.prototype, \"_renderer\", {\n        /** Current renderer instance, created upon access */\n        get: function () {\n            var _this = this;\n            if (typeof this.Renderer !== \"function\")\n                throw new TypeError(\"No renderer defined\");\n            // construct the renderer, forward its signal\n            var renderer = new this.Renderer(this);\n            renderer.beforeFirstRender = function () { _this.beforeFirstRender(renderer); };\n            renderer.Rendered.connect(this.Rendered);\n            return renderer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Method that is called immediately after the renderer for this component is constructed; override this method (and invoke `super.beforeFirstRender`) to be able to call or inject renderer methods before this component is first rendered */\n    Component.prototype.beforeFirstRender = function (renderer) {\n        this._watchFocusMode(renderer);\n        this._watchSelectionMode(renderer);\n    };\n    /** Helper method to watch and apply list focus mode on renderer instance */\n    Component.prototype._watchFocusMode = function (renderer) {\n        var _this = this;\n        var childConnections;\n        var subscribed;\n        var links;\n        renderer.watch(function () { return (_this.focusMode === Component.FocusMode.Items); }, function (t) {\n            if (!t && !childConnections)\n                return;\n            // remember old links, and connections to unsubscribe from\n            var oldChildConnections = childConnections;\n            var oldSubscribed = subscribed;\n            links = {};\n            // manage focus mode for all child components\n            subscribed = t && Async_defaultExport.observe(function () {\n                var oldConnections = childConnections;\n                childConnections = {};\n                var oldLinks = links;\n                var focusable;\n                var noAutoFocusChild = true;\n                var children = _this.getChildren();\n                // helper function to set one child to auto focus, rest to click\n                var setSingleAutoFocus = function (c) {\n                    c.focusMode = Component.FocusMode.Auto;\n                    // set siblings back to click\n                    children.forEach(function (sibling) {\n                        if (sibling !== c &&\n                            sibling.focusMode ===\n                                Component.FocusMode.Auto)\n                            sibling.focusMode =\n                                Component.FocusMode.Click;\n                    });\n                };\n                // keep track of all children (re-eval when list changes)\n                var prevLink;\n                children.forEach(function (c) {\n                    Async_defaultExport.unobserved(function () {\n                        // skip unfocusable components, remember first focusable,\n                        // set click as default\n                        if (c.focusMode === Component.FocusMode.None)\n                            return;\n                        if (c.focusMode === Component.FocusMode.Auto)\n                            noAutoFocusChild = false;\n                        else if ((!focusable ||\n                            !(focusable._selectionOrder > c._selectionOrder)) &&\n                            c.focusMode !== Component.FocusMode.Items)\n                            focusable = c;\n                        if (c.focusMode === undefined)\n                            c.focusMode = Component.FocusMode.Click;\n                        // maintain chain of components for moving up/down\n                        var link = oldLinks && oldLinks[c.uid] || { c: c };\n                        links[c.uid] = link;\n                        if (prevLink) {\n                            link.pv = prevLink.c;\n                            prevLink.nx = c;\n                        }\n                        prevLink = link;\n                        // keep connections for this component, if any\n                        if (oldConnections && oldConnections[c.uid]) {\n                            childConnections[c.uid] = oldConnections[c.uid];\n                            delete oldConnections[c.uid];\n                        }\n                        else {\n                            // connect to this child component's signals\n                            childConnections[c.uid] = [];\n                            childConnections[c.uid].push(c.FocusGained.connect(function () {\n                                // set to auto focus to enable tabbing\n                                setSingleAutoFocus(c);\n                            }), c.ArrowUpKeyPressed.connect(function (event) {\n                                // if possible, focus previous child\n                                if (link.pv) {\n                                    link.pv.hasFocus = true;\n                                    if (event.preventDefault)\n                                        event.preventDefault();\n                                }\n                            }), c.ArrowDownKeyPressed.connect(function (event) {\n                                // if possible, focus next child\n                                if (link.nx) {\n                                    link.nx.hasFocus = true;\n                                    if (event.preventDefault)\n                                        event.preventDefault();\n                                }\n                            }));\n                        }\n                    });\n                });\n                // watch single selected item and change its focus mode to auto\n                // wrap in static observable value to observe but not reevaluate\n                // (this is to catch situations where selection changed in code,\n                // not on focus/click, and user expects to tab (back) to newly\n                // selected item, not last one focused)\n                if (_this.selectionMode === Component.SelectionMode.ItemClick ||\n                    _this.selectionMode === Component.SelectionMode.ItemFocus) {\n                    Async_defaultExport.unobserved(function () {\n                        return Async_defaultExport.observe(function () { return _this.getLastSelectedChild(); })\n                            .map(function (sel) { return sel && setSingleAutoFocus(sel); });\n                    }).value;\n                }\n                // set first focusable component to auto if needed\n                focusable && noAutoFocusChild && Async_defaultExport.unobserved(function () {\n                    focusable.focusMode = Component.FocusMode.Auto;\n                });\n                // disconnect from old components\n                for (var id in oldConnections) {\n                    oldConnections[id].forEach(function (c) { return c.disconnect(); });\n                }\n            }).subscribe();\n            // disconnect old connections (after connecting new ones, to prevent\n            // unnecessary event connected state flip flopping)\n            oldSubscribed && oldSubscribed.clear();\n            for (var id in oldChildConnections)\n                oldChildConnections[id].forEach(function (c) { return c.disconnect(); });\n        });\n    };\n    /** Helper method to watch and apply selection mode on renderer instance */\n    Component.prototype._watchSelectionMode = function (renderer) {\n        var _this = this;\n        var connections = [];\n        var subscribed;\n        renderer.watch(function () { return _this.selectionMode; }, function (selectionMode) {\n            // remember connections to unsubscribe from\n            _this._lastSelectionAsync = undefined;\n            var oldConnections = connections.splice(0);\n            var oldSubscribed = subscribed;\n            // check what needs to be managed here (click/toggle/focus/items)\n            switch (selectionMode) {\n                // manual selection using click/touch or space bar:\n                case Component.SelectionMode.Click:\n                    var clickSelect = function () { _this.selected = true; };\n                    connections.push(_this.Clicked.connect(clickSelect), _this.SpaceBarPressed.connect(clickSelect));\n                    subscribed = undefined;\n                    break;\n                // manual toggle selection using click/touch or space bar:\n                case Component.SelectionMode.Toggle:\n                    var toggle_1 = function () { _this.selected = !_this.selected; };\n                    connections.push(_this.Clicked.connect(toggle_1), _this.SpaceBarPressed.connect(function (event) {\n                        toggle_1();\n                        event.preventDefault && event.preventDefault();\n                    }));\n                    subscribed = undefined;\n                    break;\n                // automatic selection on focus:\n                case Component.SelectionMode.Focus:\n                    var focusSelect = function () { _this.selected = true; };\n                    connections.push(_this.FocusGained.connect(focusSelect));\n                    subscribed = undefined;\n                    break;\n                // select one child element only, on click or focus\n                case Component.SelectionMode.ItemClick:\n                    var isClick = true;\n                case Component.SelectionMode.ItemFocus:\n                    subscribed = _this._observeSingleSelection(isClick ? Component.SelectionMode.Click :\n                        Component.SelectionMode.Focus)\n                        .subscribe(function (component) {\n                        if (_this._lastSelectionAsync)\n                            _this._lastSelectionAsync.value = component;\n                    });\n                    // initialize observable value with current selection\n                    _this._lastSelectionAsync =\n                        Async_defaultExport.ObservableValue.fromValue(subscribed.value);\n                    break;\n                // make child elements toggleable\n                case Component.SelectionMode.ItemToggle:\n                    subscribed = Async_defaultExport.observe(function () {\n                        // set selection mode to toggle for new components\n                        _this.getChildren().forEach(function (c) {\n                            if (c.selectionMode === undefined) {\n                                Async_defaultExport.unobserved(function () {\n                                    c.selectionMode = Component.SelectionMode.Toggle;\n                                });\n                            }\n                        });\n                    }).subscribe();\n                    break;\n            }\n            // disconnect old connections (after connecting new ones, to prevent\n            // unnecessary event connected state flip flopping)\n            oldConnections.forEach(function (c) { return c.disconnect(); });\n            if (oldSubscribed)\n                oldSubscribed.clear();\n        });\n    };\n    /** Helper method to observe selected child component(s), and deselect all except component selected latest; also overrides selection mode for components where this property is undefined; returns an observable for the single (last) selected component */\n    Component.prototype._observeSingleSelection = function (setSelectionMode) {\n        var _this = this;\n        return Async_defaultExport.observe(function () {\n            var lastSelection;\n            var lastSelectedNumber;\n            _this.getChildren().forEach(function (c) {\n                var isSelected = c.selected;\n                Async_defaultExport.unobserved(function () {\n                    if (c.selectionMode === undefined)\n                        c.selectionMode = setSelectionMode;\n                    if (isSelected) {\n                        // deselect component if selected earlier\n                        if (c._selectionOrder < lastSelectedNumber) {\n                            c.selected = false;\n                        }\n                        else {\n                            if (lastSelection) {\n                                // deselect component found earlier\n                                lastSelection.selected = false;\n                            }\n                            lastSelection = c;\n                            lastSelectedNumber = c._selectionOrder;\n                        }\n                    }\n                });\n            });\n            // return last selected component\n            return lastSelection;\n        });\n    };\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // DIMENSIONS & STYLE\n    /** Add a new style override to this component class (and derived classes); does not have any effect on existing component instances, but changes to previously added style overrides are always observed; returns given style instance */\n    Component.addStyleOverride = function (style) {\n        var chain = Async_defaultExport.inject(this, {\n            \"@overrideStyle\": function (prev) {\n                return chain[\"@overrideStyle\"](prev).override(style);\n            }\n        });\n        return style;\n    };\n    /** @internal Adds overrides to the current base style for this component (injected using `addStyleOverride`, DO NOT use or override directly) */\n    Component.prototype[_a = \"@overrideStyle\"] = function (style) { return style; };\n    /** Returns the current dimensions for this component, in logical (CSS) pixel units; may return 0x0 if this component is not yet displayed on screen (i.e. use the `.Rendered` signal and/or a timeout to obtain accurate results) */\n    Component.prototype.getActualDimensions = function () {\n        // implemented by platform dependent code\n        return { width: 0, height: 0 };\n    };\n    Object.defineProperty(Component.prototype, \"height\", {\n        /** Overall target height of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be \"auto\") */\n        get: function () { return this.height || \"auto\"; },\n        set: function (h) {\n            if (h === \"auto\")\n                h = \"\";\n            this.style.set(\"height\", this.height = h);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"width\", {\n        /** Overall target width of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component width, may be \"auto\") */\n        get: function () { return this.width || \"auto\"; },\n        set: function (w) {\n            if (w === \"auto\")\n                w = \"\";\n            this.style.set(\"width\", this.width = w);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"shadowEffect\", {\n        /** Set to a number between 0 and 1 to add a drop shadow to this component (shadow \"depth\" of 1 creates the illusion of a component lifted off the canvas the furthest, 0 means no shadow at all; observable, directly adds shadow effect to `.style`) */\n        get: function () { return this.shadowEffect || 0; },\n        set: function (d) {\n            this.style.addShadowEffect(this.shadowEffect = d);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Override the drop shadow \"depth\" value while mouse cursor is hovering over this component, with given number between 0 and 1 */\n    Component.prototype.addShadowEffectOnHover = function (d) {\n        var _this = this;\n        // add an overriding observable for the shadow effect depth\n        var override = new Style_Style().addShadowEffect(d);\n        this.style.override(Async_defaultExport.observe(function () {\n            return _this.hoverState ? override : undefined;\n        }));\n    };\n    /** Override the drop shadow \"depth\" value while this component or a child component has input focus, with given number between 0 and 1 */\n    Component.prototype.addShadowEffectOnFocus = function (d) {\n        var _this = this;\n        // add an overriding observable for the shadow effect depth\n        var override = new Style_Style().addShadowEffect(d);\n        this.style.override(Async_defaultExport.observe(function () {\n            return _this.hasFocus ? override : undefined;\n        }));\n    };\n    Object.defineProperty(Component.prototype, \"hidden\", {\n        /** Set to true to hide this component (observable, directly modifies hidden state of `.style` and plays show/hide animations) */\n        get: function () { return this.hidden; },\n        set: function (yesno) {\n            var _this = this;\n            // complexity here is due to animation: the element is hidden only\n            // after the animation completes; while the Style object should still\n            // observe the source observable indirectly as well\n            var o;\n            var doHide = function (hide) {\n                if (!_this.getLastRenderedOutput()) {\n                    // if not rendered yet, do not animate\n                    if (o)\n                        o.value = hide;\n                    else\n                        _this.style.hide(hide);\n                }\n                else if (hide && !_this._hidden) {\n                    // animate, then hide\n                    _this.animate(\"hide\", false, function () {\n                        if (_this._hidden) {\n                            if (o)\n                                o.value = true;\n                            else\n                                _this.style.hide();\n                        }\n                    });\n                }\n                else if (!hide && _this._hidden) {\n                    // show and animate\n                    if (o)\n                        o.value = false;\n                    else\n                        _this.style.show();\n                    _this.animate(\"show\");\n                }\n                _this._hidden = !!hide;\n                return o;\n            };\n            if (yesno instanceof Async_defaultExport.ObservableValue) {\n                // use shadow observable that changes after animation\n                o = Async_defaultExport.ObservableValue.fromValue(this._hidden);\n                this.style.hide(Async_defaultExport.observe(function () { return !!yesno.value; })\n                    .map(doHide));\n            }\n            else {\n                // modify style directly\n                doHide(yesno);\n            }\n            this.hidden = yesno;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"selected\", {\n        /** Set to true to display this component in a selected state (observable, directly modifies selected state of `.style` and plays select/deselect animations) */\n        get: function () { return this.selected; },\n        set: function (yesno) {\n            var _this = this;\n            // complexity here is due to animation: the element is selected only\n            // after the animation completes; while the Style object should still\n            // observe the source observable indirectly as well\n            var o;\n            var doSelect = function (select) {\n                // check selection mode first, update selection order\n                if (select) {\n                    if (_this.selectionMode === Component.SelectionMode.None)\n                        throw new Error(\"This component cannot be selected\");\n                    _this._selectionOrder = _selectionOrder++;\n                }\n                if (!_this.getLastRenderedOutput()) {\n                    // if not rendered yet, do not animate\n                    if (o)\n                        o.value = select;\n                    else\n                        _this.style.select(select);\n                }\n                else if (!select && _this._selected) {\n                    // animate, then deselect\n                    _this.animate(\"deselect\", false, function () {\n                        if (!_this._selected) {\n                            if (o)\n                                o.value = false;\n                            else\n                                _this.style.deselect();\n                        }\n                    });\n                }\n                else if (select && !_this._selected) {\n                    // select and animate\n                    if (o)\n                        o.value = true;\n                    else\n                        _this.style.select();\n                    _this.animate(\"select\");\n                }\n                _this._selected = !!select;\n                return o;\n            };\n            if (yesno instanceof Async_defaultExport.ObservableValue) {\n                // use shadow observable that changes after animation\n                o = Async_defaultExport.ObservableValue.fromValue(this._selected);\n                this.style.select(Async_defaultExport.observe(function () { return !!yesno.value; })\n                    .map(doSelect));\n            }\n            else {\n                // modify style directly\n                doSelect(yesno);\n            }\n            this.selected = yesno;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"hasFocus\", {\n        /** True if this component _or_ a child component has input focus, false otherwise; set to true to focus the component itself, if and when available (throws an exception if this component is unable to receive input focus); set to false to remove focus from this component */\n        get: function () {\n            var _this = this;\n            if (this._liveFocus === undefined)\n                Async_defaultExport.unobserved(function () { return _this._connectFocus(); });\n            return this.hasFocus;\n        },\n        set: function (wantFocus) {\n            // connect to platform focus events\n            if (this._liveFocus === undefined)\n                this._connectFocus();\n            // blur or focus the component itself, if possible\n            if (!((wantFocus instanceof Async_defaultExport.ObservableValue) ?\n                wantFocus.value : wantFocus))\n                this[\"@blurLiveComponent\"]();\n            else if (!this._liveFocus) {\n                if (this.focusMode === Component.FocusMode.None)\n                    throw new Error(\"This component cannot be focused\");\n                else\n                    this[\"@focusLiveComponent\"]();\n            }\n            this.hasFocus = wantFocus;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internal Method to retrieve the current focus state of a component (injected by platform specific code, if applicable) */\n    Component.prototype[_b = \"@getLiveComponentFocusState\"] = function () { return false; };\n    /** @internal Set input focus to this component (injected by platform specific code, if applicable) */\n    Component.prototype[_c = \"@focusLiveComponent\"] = function () { throw new TypeError(); };\n    /** @internal Remove input focus from this component (injected by platform specific code, if applicable) */\n    Component.prototype[_d = \"@blurLiveComponent\"] = function () { };\n    /** Connect Focus and Blur signal handlers to maintain `_liveFocus` and `hasFocus` */\n    Component.prototype._connectFocus = function () {\n        var _this = this;\n        this.hasFocus = this._liveFocus = this[\"@getLiveComponentFocusState\"]();\n        this.Focus.connect(function () {\n            _this._liveFocus = true;\n            _this.hasFocus = true;\n        });\n        this.Blur.connect(function () {\n            _this._liveFocus = false;\n            _this.hasFocus = false;\n        });\n    };\n    Object.defineProperty(Component.prototype, \"hoverState\", {\n        /** True if the mouse cursor is hovering over this component, false otherwise; evaluated lazily using `.MouseEnter` and `.MouseLeave`, value is `false` initially until first signal is emitted after this property has been read once */\n        get: function () {\n            var _this = this;\n            if (!this._liveHover) {\n                Async_defaultExport.unobserved(function () {\n                    _this._liveHover = Async_defaultExport.ObservableValue.fromValue(false);\n                    _this.MouseEnter.connect(function () { _this._liveHover.value = true; });\n                    _this.MouseLeave.connect(function () { _this._liveHover.value = false; });\n                });\n            }\n            return this._liveHover.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // EVENT SIGNALS\n    // Note: actual implementation is injected by platform dependent code\n    // (see createEventSignal)\n    /** @internal Method to create event signal for this component (injected by platform specific code) */\n    Component.prototype[_e = \"@createEventSignal\"] = function (id, signalClass, opt) {\n        throw new TypeError();\n    };\n    Object.defineProperty(Component.prototype, \"Click\", {\n        /** Signal emitted when this component _or_ a child component is clicked, touched, or otherwise activated; captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"Click\", PointerEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"Clicked\", {\n        /** Signal emitted asynchronously after this component _or_ a child component is clicked, touched, or otherwise activated; propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () {\n            return this[\"@createEventSignal\"](\"Clicked\", PointerEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"DoubleClick\", {\n        /** Signal emitted when this component _or_ a child component is double-clicked; captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"DoubleClick\", PointerEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"DoubleClicked\", {\n        /** Signal emitted asynchronously after this component _or_ a child component is double-clicked; propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () {\n            return this[\"@createEventSignal\"](\"DoubleClicked\", PointerEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"Press\", {\n        /** Signal emitted when a mouse button is pressed down, or a touch occurs, on this component _or_ a child component; captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"Press\", PointerEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"Pressed\", {\n        /** Signal emitted asynchronously after a mouse button is pressed down, or a touch occurs, on this component _or_ a child component; propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () {\n            return this[\"@createEventSignal\"](\"Pressed\", PointerEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"MouseEnter\", {\n        /** Signal emitted when the cursor begins to hover over this component; captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"MouseEnter\", PointerEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"MouseLeave\", {\n        /** Signal emitted when the cursor has left this component; captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"MouseLeave\", PointerEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"MouseContextMenu\", {\n        /** Signal emitted when a context menu is requested for this component or a child component (usually by right-clicking); captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"MouseContextMenu\", PointerEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"KeyDown\", {\n        /** Signal emitted when a key is pressed down (while this component _or_ a child component is focused); captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"KeyDown\", KeyEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"KeyPress\", {\n        /** Signal emitted after a key is pressed (while this component _or_ a child component is focused); captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"KeyPress\", KeyEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"Focus\", {\n        /** Signal emitted when this component _or_ a child component receives focus; captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"Focus\", ComponentSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"Blur\", {\n        /** Signal emitted when this component _or_ a child component loses focus; captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"Blur\", ComponentSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"FocusGained\", {\n        /** Signal emitted asynchronously after this component receives focus; propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () {\n            return this[\"@createEventSignal\"](\"FocusGained\", ComponentSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"FocusLost\", {\n        /** Signal emitted asynchronously after this component loses focus, and only if `.FocusGained` was emitted previously; propagates from child components to parents, not consumable */\n        get: function () {\n            return this[\"@createEventSignal\"](\"FocusLost\", ComponentSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"DragStart\", {\n        /** Signal emitted when this component _or_ a child component commences a drag operation; captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"DragStart\", DragEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"DragEnter\", {\n        /** Signal emitted when a drag operation begins to hover over this component; captured from containers down to contained components, not consumable */\n        get: function () {\n            return this[\"@createEventSignal\"](\"DragEnter\", DragEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"DragLeave\", {\n        /** Signal emitted when a drag operation has left this component; captured from containers down to contained components, not consumable */\n        get: function () {\n            return this[\"@createEventSignal\"](\"DragLeave\", DragEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"DragDrop\", {\n        /** Signal emitted when this element or a child element is the target of a drop after a drag operation; captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"DragDrop\", DragEventSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n    // KEYPRESS EVENTS\n    /** Helper function to create a key event signal */\n    Component.prototype._makeKeyEvent = function (key) {\n        return this[\"@createEventSignal\"](\"FnKeyPressed\", KeyEventSignal, key);\n    };\n    Object.defineProperty(Component.prototype, \"EnterKeyPressed\", {\n        /** Signal emitted after the enter key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () { return this._makeKeyEvent(13); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"SpaceBarPressed\", {\n        /** Signal emitted after the space bar is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () { return this._makeKeyEvent(32); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"BackspaceKeyPressed\", {\n        /** Signal emitted after the backspace key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () { return this._makeKeyEvent(8); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"DeleteKeyPressed\", {\n        /** Signal emitted after the forward-delete key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () { return this._makeKeyEvent(46); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"EscapeKeyPressed\", {\n        /** Signal emitted after the escape key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () { return this._makeKeyEvent(27); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"ArrowLeftKeyPressed\", {\n        /** Signal emitted after the left arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () { return this._makeKeyEvent(37); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"ArrowUpKeyPressed\", {\n        /** Signal emitted after the up arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () { return this._makeKeyEvent(38); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"ArrowRightKeyPressed\", {\n        /** Signal emitted after the right arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () { return this._makeKeyEvent(39); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Component.prototype, \"ArrowDownKeyPressed\", {\n        /** Signal emitted after the down arrow/d-pad key is pressed (while focused); propagates from child components to parents, until a component consumes the event by connecting to this signal */\n        get: function () { return this._makeKeyEvent(40); },\n        enumerable: true,\n        configurable: true\n    });\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"displayOptions\", void 0);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"renderOptions\", void 0);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"flowDirection\", void 0);\n    Component___decorate([\n        Async_defaultExport.injectable\n    ], Component.prototype, \"Renderer\", void 0);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"_renderer\", null);\n    Component___decorate([\n        Async_defaultExport.injectable\n    ], Component.prototype, _a, null);\n    Component___decorate([\n        Async_defaultExport.injectable\n    ], Component.prototype, \"getActualDimensions\", null);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"height\", null);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"width\", null);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"shadowEffect\", null);\n    Component___decorate([\n        ComponentFactory_ComponentFactory.setterFor(\"shadowEffectOnHover\")\n    ], Component.prototype, \"addShadowEffectOnHover\", null);\n    Component___decorate([\n        ComponentFactory_ComponentFactory.setterFor(\"shadowEffectOnFocus\")\n    ], Component.prototype, \"addShadowEffectOnFocus\", null);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"hidden\", null);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"selected\", null);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"selectionMode\", void 0);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"focusMode\", void 0);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"hasFocus\", null);\n    Component___decorate([\n        Async_defaultExport.injectable\n    ], Component.prototype, _b, null);\n    Component___decorate([\n        Async_defaultExport.injectable\n    ], Component.prototype, _c, null);\n    Component___decorate([\n        Async_defaultExport.injectable\n    ], Component.prototype, _d, null);\n    Component___decorate([\n        Async_defaultExport.observable\n    ], Component.prototype, \"hoverState\", null);\n    Component___decorate([\n        Async_defaultExport.injectable\n    ], Component.prototype, _e, null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"Click\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"Clicked\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"DoubleClick\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"DoubleClicked\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"Press\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"Pressed\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"MouseEnter\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"MouseLeave\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"MouseContextMenu\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"KeyDown\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"KeyPress\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"Focus\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"Blur\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"FocusGained\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"FocusLost\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"DragStart\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"DragEnter\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"DragLeave\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"DragDrop\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"EnterKeyPressed\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"SpaceBarPressed\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"BackspaceKeyPressed\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"DeleteKeyPressed\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"EscapeKeyPressed\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"ArrowLeftKeyPressed\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"ArrowUpKeyPressed\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"ArrowRightKeyPressed\", null);\n    Component___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Component.prototype, \"ArrowDownKeyPressed\", null);\n    return Component;\n    var _a, _b, _c, _d, _e;\n}(Async_defaultExport.ObservableObject));\n\n// copy methods from ComponentFactory\nComponent_Component.with = makeFactory;\nComponent_Component.prototype.initializeWith = ComponentFactory_ComponentFactory.initializeWith;\n(function (Component) {\n    /** Options for automatic focus management */\n    var FocusMode;\n    (function (FocusMode) {\n        /** Unable to focus this component */\n        FocusMode[FocusMode[\"None\"] = 0] = \"None\";\n        /** Click or touch to focus */\n        FocusMode[FocusMode[\"Click\"] = 1] = \"Click\";\n        /** Click, touch, or use keyboard (tab key) to focus */\n        FocusMode[FocusMode[\"Auto\"] = 2] = \"Auto\";\n        /** Focus a child component on click, touch, or up/down arrow key press; child components with focus mode `None` are ignored */\n        FocusMode[FocusMode[\"Items\"] = 3] = \"Items\";\n    })(FocusMode = Component.FocusMode || (Component.FocusMode = {}));\n    /** Options for automatic selection management */\n    var SelectionMode;\n    (function (SelectionMode) {\n        /** Unable to select this component */\n        SelectionMode[SelectionMode[\"None\"] = 0] = \"None\";\n        /** Focus to select */\n        SelectionMode[SelectionMode[\"Focus\"] = 1] = \"Focus\";\n        /** Click or touch, or use space bar (while focused) to select */\n        SelectionMode[SelectionMode[\"Click\"] = 2] = \"Click\";\n        /** Click or touch, or use space bar (while focused) to toggle selection */\n        SelectionMode[SelectionMode[\"Toggle\"] = 3] = \"Toggle\";\n        /** Select _one_ child component on click or touch; set selection mode of child components to `Click` if undefined */\n        SelectionMode[SelectionMode[\"ItemClick\"] = 4] = \"ItemClick\";\n        /** Select _one_ child component on focus; set selection mode of child components to `Focus` if undefined; to be combined with focus mode `Items` for directional keyboard navigation */\n        SelectionMode[SelectionMode[\"ItemFocus\"] = 5] = \"ItemFocus\";\n        /** Toggle selection on child components on click or touch, or space bar (while focused): set selection mode of child components to `Toggle` if undefined */\n        SelectionMode[SelectionMode[\"ItemToggle\"] = 6] = \"ItemToggle\";\n    })(SelectionMode = Component.SelectionMode || (Component.SelectionMode = {}));\n})(Component_Component || (Component_Component = {}));\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/ComponentRenderer.js\nvar ComponentRenderer___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n/** Class that contains the code necessary to render a component; to retrieve rendering output, Component methods only use the `.output` property, which is an ObservableValue instance that is populated using the (protected) `.render` method */\nvar ComponentRenderer_ComponentRenderer = (function () {\n    /** Create a new renderer instance for given component */\n    function ComponentRenderer(component) {\n        var _this = this;\n        /** Signal that is emitted after updating `.output` (but not if undefined) and/or when the `updated` promise on the rendered output is resolved */\n        this.Rendered = Signal_Signal.create();\n        this.component = component;\n        // create observable value with a getter for rendered output\n        var rendered = false;\n        this.output = new Async_defaultExport.ObservableValue(function () {\n            if (!rendered) {\n                rendered = true;\n                if (_this.beforeFirstRender)\n                    Async_defaultExport.unobserved(_this.beforeFirstRender);\n            }\n            var result = _this.output.value = _this.render();\n            // add dependencies for all watchers\n            if (_this._watches)\n                _this._watches.forEach(function (f) { return f.value; });\n            // emit own signal, directly or asynchronously based on promise\n            if (result !== undefined) {\n                if (result.updated)\n                    result.updated.then(function () { _this.Rendered(result); });\n                else\n                    _this.Rendered(result);\n            }\n        });\n    }\n    /** Component renderer function; to be overridden, *must* be a pure function, based on the current `.component` and `.output` properties (otherwise *creating* or *setting* ObservableValue instances should be done within a function that is passed to `unobserved`) */\n    ComponentRenderer.prototype.render = function () { return this.output.value; };\n    /** Add a method that will be called (synchronously and asynchronously) from a new observable context, after previously added methods, immediately *after* the `.render` method has run once, along with an optional method that will be called (synchronously, unobserved) with the result of the first method; i.e. observable values used in the first method will be subscribed to while the output is subscribed to, but changes to these values will never trigger re-rendering the entire component -- instead, the second function is invoked; useful for partially updating existing output using a subset of component properties; should be called _before_ rendering takes place */\n    ComponentRenderer.prototype.watch = function (getter, map) {\n        var _this = this;\n        if (!this._watches)\n            this._watches = [];\n        this._watches.push(map ?\n            Async_defaultExport.observe(function () {\n                // call getter (observed) and forward result (unobserved)\n                Async_defaultExport.unobserved(map.bind(_this, getter.call(_this)));\n            }) :\n            Async_defaultExport.observe(function () {\n                // just call getter (observed), don't care about result\n                getter.call(_this);\n            }));\n    };\n    return ComponentRenderer;\n}());\n\n(function (ComponentRenderer) {\n    /** Encapsulates output for a rendered component; class type parameters indicate the type of component rendered, and the output type (e.g. HTMLElement) */\n    var Output = (function () {\n        /** Create a new instance for given component, with given element (should not be undefined) */\n        function Output(component, element, context) {\n            /** Flag that can be used for duck typing */\n            this.isComponentOutput = true;\n            this.component = component;\n            this.element = element;\n            this[\"@context\"] = context;\n        }\n        return Output;\n    }());\n    ComponentRenderer.Output = Output;\n})(ComponentRenderer_ComponentRenderer || (ComponentRenderer_ComponentRenderer = {}));\n/** Constructor for a component render event handler */\nvar ComponentRenderHandler = (function (_super) {\n    ComponentRenderer___extends(ComponentRenderHandler, _super);\n    function ComponentRenderHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ComponentRenderHandler;\n}(ComponentSignalHandler));\n\n/** _Class decorator_, maps the decorated `ComponentRenderer` class to a `Component` class as its primary renderer; the renderer class constructor must have a single argument, being the component to be rendered; overrides previously mapped renderer entirely, to extend super class renderer functionality inject a class that extends the previous renderer class [decorator] */\nfunction mapComponentRenderer(componentClass) {\n    return function (target) {\n        Async_defaultExport.inject(componentClass, { Renderer: target });\n    };\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Containers/Container.js\nvar Container___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Container___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents a container with vertically stacked blocks */\nvar Container_Container = (function (_super) {\n    Container___extends(Container, _super);\n    /** Create a container with given content, if any */\n    function Container(content) {\n        if (content === void 0) { content = []; }\n        var _this = _super.call(this) || this;\n        _this.content = content;\n        // containers are not focusable by default:\n        _this.focusMode = Component_Component.FocusMode.None;\n        return _this;\n    }\n    Object.defineProperty(Container.prototype, \"scrolledToTop\", {\n        /** Flag that becomes true when the container content is scrolled all the way to the top (observable); scroll position is continuously monitored after this value is read once */\n        get: function () {\n            if (!this._scrolledToTop)\n                this._monitorPlatformScroll();\n            return this._scrolledToTop.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Container.prototype, \"scrolledToBottom\", {\n        /** Flag that becomes true when the container content is scrolled all the way to the bottom, or to the threshold defined by `.scrollBottomThreshold` (observable); scroll position is continuously monitored after this value is read once */\n        get: function () {\n            if (!this._scrolledToBottom)\n                this._monitorPlatformScroll();\n            return this._scrolledToBottom.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Container.prototype, \"scrolledToLeft\", {\n        /** Flag that becomes true when the container content is scrolled all the way to the left (observable); scroll position is continuously monitored after this value is read once */\n        get: function () {\n            if (!this._scrolledToLeft)\n                this._monitorPlatformScroll();\n            return this._scrolledToLeft.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Container.prototype, \"scrolledToRight\", {\n        /** Flag that becomes true when the container content is scrolled all the way to the right (observable); scroll position is continuously monitored after this value is read once */\n        get: function () {\n            if (!this._scrolledToRight)\n                this._monitorPlatformScroll();\n            return this._scrolledToRight.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Container.prototype, \"ScrolledUp\", {\n        /** Signal emitted when the container content is scrolled up (i.e. content moves down relative to the viewable area of the container), only once on first scroll or after changing direction; scroll position is continuously monitored only after this signal is connected to */\n        get: function () {\n            if (!this._scrolledToTop)\n                this._monitorPlatformScroll();\n            return this.createComponentSignal();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Container.prototype, \"ScrolledDown\", {\n        /** Signal emitted when the container content is scrolled down (i.e. content moves up relative to the viewable area of the container), only once on first scroll or after changing direction; scroll position is continuously monitored only after this signal is connected to */\n        get: function () {\n            if (!this._scrolledToTop)\n                this._monitorPlatformScroll();\n            return this.createComponentSignal();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Returns true if this container contains a List component without items, optionally of given type (observable if used in getter); useful as a shortcut in a getter for .hidden on a \"blank-slate\" block */\n    Container.prototype.hasEmptyList = function (listComponentClass) {\n        if (listComponentClass === void 0) { listComponentClass = List_List; }\n        return this.getComponentsByType(listComponentClass)\n            .some(function (l) { return !(l.items && l.items.length); });\n    };\n    /** Append a block to this container; returns this */\n    Container.prototype.appendChild = function (block) {\n        this.content.push(block);\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    Container.prototype.getChildren = function () {\n        return this.content.filter(function (c) { return (c instanceof Component_Component); });\n    };\n    /** @internal Monitor scroll position to keep _scrolledToTop and _scrolledToBottom updated */\n    Container.prototype._monitorPlatformScroll = function () {\n        var _this = this;\n        Async_defaultExport.unobserved(function () {\n            _this._scrolledToTop = new Async_defaultExport.ObservableValue();\n            _this._scrolledToBottom = new Async_defaultExport.ObservableValue();\n            _this._scrolledToLeft = new Async_defaultExport.ObservableValue();\n            _this._scrolledToRight = new Async_defaultExport.ObservableValue();\n            var oldTop, wasUp = false, wasDown = false;\n            var atTop, atBottom;\n            var atLeft, atRight;\n            _this[\"@monitorPlatformScroll\"](function (t, b, l, r) {\n                // emit signal for scroll direction if needed\n                if (t > oldTop && !wasDown) {\n                    wasDown = true, wasUp = false;\n                    _this.ScrolledDown();\n                }\n                else if (t < oldTop && !wasUp) {\n                    wasUp = true, wasDown = false;\n                    _this.ScrolledUp();\n                }\n                oldTop = t;\n                // set observable top flag only if changed\n                var tThr = _this.scrollTopThreshold || 0;\n                if (t <= tThr && !atTop)\n                    _this._scrolledToTop.value = atTop = true;\n                else if (t > tThr && atTop !== false)\n                    _this._scrolledToTop.value = atTop = false;\n                // set observable bottom flag only if changed\n                var bThr = _this.scrollBottomThreshold || 0;\n                if (b <= bThr && !atBottom)\n                    _this._scrolledToBottom.value = atBottom = true;\n                else if (b > bThr && atBottom !== false)\n                    _this._scrolledToBottom.value = atBottom = false;\n                // set observable left flag only if changed\n                if (l <= 0 && !atLeft)\n                    _this._scrolledToLeft.value = atLeft = true;\n                else if (l > 0 && atLeft !== false)\n                    _this._scrolledToLeft.value = atLeft = false;\n                // set observable right flag only if changed\n                if (r <= 0 && !atRight)\n                    _this._scrolledToRight.value = atRight = true;\n                else if (r > 0 && atRight !== false)\n                    _this._scrolledToRight.value = atRight = false;\n            });\n        });\n    };\n    /** @internal Register callback to be called with current and following vertical scroll positions; injected by platform renderer */\n    Container.prototype[_a = \"@monitorPlatformScroll\"] = function (callback) {\n        // do nothing if not injected\n    };\n    Container___decorate([\n        ComponentFactory_ComponentFactory.applyComponentsArray(ComponentFactory_ComponentFactory.CLevel.Block),\n        Async_defaultExport.observable_not_null\n    ], Container.prototype, \"content\", void 0);\n    Container___decorate([\n        Async_defaultExport.observable\n    ], Container.prototype, \"vertAlign\", void 0);\n    Container___decorate([\n        Async_defaultExport.observable\n    ], Container.prototype, \"horzAlign\", void 0);\n    Container___decorate([\n        Async_defaultExport.observable_string\n    ], Container.prototype, \"maxContentWidth\", void 0);\n    Container___decorate([\n        Async_defaultExport.observable\n    ], Container.prototype, \"scrollable\", void 0);\n    Container___decorate([\n        Async_defaultExport.observable\n    ], Container.prototype, \"scrolledToTop\", null);\n    Container___decorate([\n        Async_defaultExport.observable\n    ], Container.prototype, \"scrolledToBottom\", null);\n    Container___decorate([\n        Async_defaultExport.observable\n    ], Container.prototype, \"scrolledToLeft\", null);\n    Container___decorate([\n        Async_defaultExport.observable\n    ], Container.prototype, \"scrolledToRight\", null);\n    Container___decorate([\n        Async_defaultExport.observable\n    ], Container.prototype, \"scrollBottomThreshold\", void 0);\n    Container___decorate([\n        Async_defaultExport.observable\n    ], Container.prototype, \"scrollTopThreshold\", void 0);\n    Container___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Container.prototype, \"ScrolledUp\", null);\n    Container___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Container.prototype, \"ScrolledDown\", null);\n    Container___decorate([\n        Async_defaultExport.observable\n    ], Container.prototype, \"displayOptions\", void 0);\n    Container___decorate([\n        Async_defaultExport.injectable\n    ], Container.prototype, _a, null);\n    Container = Container___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.Block)\n    ], Container);\n    return Container;\n    var _a;\n}(Component_Component));\n\n/** Represents a container with blocks that are laid out horizontally (just like text), automatically spanning multiple rows if necessary */\nvar FlowContainer = (function (_super) {\n    Container___extends(FlowContainer, _super);\n    function FlowContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return FlowContainer;\n}(Container_Container));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Drag.js\nvar Drag___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/** Current drag operation(s) */\nvar instances = [];\n/** Represents a drag operation (created by static .start(...) method) */\nvar Drag_Drag = (function () {\n    function Drag() {\n        /** Event payload data for this operation (sealed observable object) */\n        this.detail = {\n            id: undefined, data: undefined\n        };\n        /** Signal emitted when the drag operation completes successfully */\n        this.Dropped = Signal_Signal.create();\n        /** Signal emitted when the drag operation is canceled */\n        this.Canceled = Signal_Signal.create();\n    }\n    /** Returns a list of current drag operations (for forwards compatibility, supporting multi touch); use this while handling drag events, e.g. get/set .detail with custom data, or observe coordinates) */\n    Drag.getCurrentInstances = function () {\n        return instances.slice();\n    };\n    /** Start tracking mouse movement based on given event (with initial screen coordinates); creates a new instance of a platform specific class derived from Drag with given payload data; Drop targets may listen for drag events (enter/leave/drop), and use information from the data object to respond */\n    Drag.start = function (event, data) {\n        var result = new Drag.BaseClass(event);\n        if (data)\n            result.detail.data = data;\n        instances.push(result);\n        return result;\n    };\n    /** Stop this drag operation, emits the `.Canceled` signal; throws an exception if this operation was already canceled or dropped */\n    Drag.prototype.cancel = function () {\n        var _this = this;\n        if (!instances.some(function (o) { return o === _this; }))\n            throw new Error(\"Drag operation already stopped\");\n        instances = instances.filter(function (o) { return o !== _this; });\n        this.Canceled(this);\n    };\n    /** Accept the current drop target (i.e. perform the drop, called automatically based on input events, but can be called manually as well), emits the `.Dropped` signal; throws an exception if this operation was already canceled or dropped */\n    Drag.prototype.drop = function () {\n        var _this = this;\n        if (!instances.some(function (o) { return o === _this; }))\n            throw new Error(\"Drag operation already stopped\");\n        instances = instances.filter(function (o) { return o !== _this; });\n        this.Dropped(this);\n    };\n    Drag___decorate([\n        Async_defaultExport.observable_seal\n    ], Drag.prototype, \"detail\", void 0);\n    return Drag;\n}());\n\n(function (Drag) {\n    ;\n})(Drag_Drag || (Drag_Drag = {}));\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Screen.js\n\n\n/** Methods for managing the available (fixed) screen space in the application viewport */\nvar Screen_Screen;\n(function (Screen) {\n    /** Display given view in the foreground, replacing the current page or adding to it (or to a new blank page, if none was displayed); returns a promise that is fulfilled after the component is rendered */\n    function displayAsync(view) {\n        if (view instanceof Page_Page) {\n            // display given page\n            return view.displayAsync();\n        }\n        else {\n            // create blank page if none displayed\n            var page = Page_Page.getCurrentPage() || new Page_Page();\n            // remember the current page, to be able to remove this component\n            // (and remove component from another page if needed)\n            var result = view.getRenderedOutputAsync().then(function (out) {\n                var prev = out[\"@Screen.page\"];\n                if (prev && prev !== page)\n                    Screen.remove(view);\n                out[\"@Screen.page\"] = page;\n            });\n            // add component as content, move to back if already added\n            var content = page.content;\n            for (var i = 0; i < content.length; i++) {\n                if (content[i] === view)\n                    content.splice(i--, 1);\n            }\n            page.content.push(view);\n            return page.displayAsync().then(function () { return result; });\n        }\n    }\n    Screen.displayAsync = displayAsync;\n    /** Returns true if given Page is currently displayed, or given Component is displayed _directly_ on the current page (i.e. not as a child component) */\n    function isDisplayed(view) {\n        if (view instanceof Page_Page) {\n            return Page_Page.getCurrentPage() === view;\n        }\n        else {\n            var page = Page_Page.getCurrentPage();\n            return page && page.contains(view);\n        }\n    }\n    Screen.isDisplayed = isDisplayed;\n    function remove(view) {\n        if (view instanceof Page_Page) {\n            // remove given page\n            if (Page_Page.getCurrentPage() === view)\n                view.remove();\n        }\n        else {\n            // remove given component from the page it belongs to\n            var out = view.getLastRenderedOutput();\n            var page = out && out[\"@Screen.page\"];\n            if (page) {\n                var content = page.content;\n                for (var i = 0; i < content.length; i++) {\n                    if (content[i] === view)\n                        content.splice(i--, 1);\n                }\n                out[\"@Screen.page\"] = undefined;\n            }\n        }\n    }\n    Screen.remove = remove;\n    /** Promise that resolves to true when ready to display the UI, after all static resources have been loaded */\n    Screen.ready = new Async_defaultExport.Promise(function (resolve) {\n        Screen.resolveReady = resolve;\n    });\n    /** Viewport dimensions (sealed observable object) */\n    Screen.dimensions = Async_defaultExport.observe(Object.seal({\n        width: NaN,\n        height: NaN,\n        get isLandscape() {\n            return this.width > this.height;\n        },\n        get isNarrow() {\n            return this.width < Screen.NARROW_WIDTH;\n        },\n        get isSmall() {\n            return this.width < Screen.SMALL_WIDTH;\n        },\n        get isWide() {\n            return this.width > Screen.WIDE_WIDTH;\n        },\n        get isExtraWide() {\n            return this.width > Screen.EXTRAWIDE_WIDTH;\n        }\n    }));\n    /** \"Narrow\" horizontal root width in logical pixels, default 550 */\n    Screen.NARROW_WIDTH = 550;\n    /** \"Small\" horizontal root width in logical pixels, default 720 */\n    Screen.SMALL_WIDTH = 720;\n    /** \"Wide\" horizontal root width in logical pixels, default 960 */\n    Screen.WIDE_WIDTH = 960;\n    /** \"Extra wide\" horizontal root width in logical pixels, default 1200 */\n    Screen.EXTRAWIDE_WIDTH = 1200;\n})(Screen_Screen || (Screen_Screen = {}));\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Page.js\nvar Page___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Page___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n/** Next page UID */\nvar Page__nextUID = 1;\n/** References the currently displayed page */\nvar Page_current = new Async_defaultExport.ObservableValue();\n/** Represents a page to be displayed on screen */\nvar Page_Page = (function () {\n    /** Create a page with given content, if any */\n    function Page(content) {\n        if (content === void 0) { content = []; }\n        /** Globally unique page identifier */\n        this.uid = \"PG\" + Page__nextUID++;\n        /** Signal that is emitted after this page is displayed on screen */\n        this.Displayed = Signal_Signal.create();\n        /** Signal that is emitted after this page has been removed from the screen */\n        this.Removed = Signal_Signal.create();\n        /** Signal that is emitted after the content of this page has been (re-) rendered, e.g. when a component is added or removed (but not when one of the components itself is re-rendered due to changes in its own sub content, use the `Component#Rendered` signal for that) */\n        // NOTE: emitted by page renderer after updating content, not here!\n        this.Rendered = Signal_Signal.create();\n        /** Signal that is emitted when a key is being pressed on the keyboard, while this page is displayed in the foreground */\n        this.KeyDown = Signal_Signal.create();\n        this.content = content;\n    }\n    /** Returns the page currently displayed on screen, if any (observable) */\n    Page.getCurrentPage = function () {\n        return Page_current.value;\n    };\n    /** Returns a new Page class with a constructor that creates instances of given component classes and appends them to the page content array */\n    Page.withContent = function () {\n        var componentClasses = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            componentClasses[_i] = arguments[_i];\n        }\n        return (function (_super) {\n            Page___extends(PageWithContent, _super);\n            function PageWithContent() {\n                var _this = _super.call(this) || this;\n                componentClasses.forEach(function (c) {\n                    _this.content.push(new c());\n                });\n                return _this;\n            }\n            return PageWithContent;\n        }(Page));\n    };\n    Page.prototype.getComponentById = function (id, componentClass) {\n        for (var _i = 0, _a = this.content; _i < _a.length; _i++) {\n            var c = _a[_i];\n            var match = c && c.getComponentById(id, componentClass);\n            if (match)\n                return match;\n        }\n        return undefined;\n    };\n    /** Returns all (recursive) child elements that are an instance of given class (observable) */\n    Page.prototype.getComponentsByType = function (componentClass) {\n        var result = [];\n        this.content.forEach(function (c) {\n            if (c instanceof componentClass)\n                result.push(c);\n            c && c.getComponentsByType(componentClass)\n                .forEach(function (r) { return result.push(r); });\n        });\n        return result;\n    };\n    /** Returns true if given component is a child component of this page or any of its child components (observable, but triggers re-evaluation upon every change in child [sub] components) */\n    Page.prototype.contains = function (component) {\n        return this.content.some(function (c) { return !!c && c.contains(component); });\n    };\n    /** Invoke the `onEsc` handler of the component closest to the foreground that defines it (usually a modal dialog container in the foreground); returns true if handler was called, otherwise does nothing and returns false */\n    Page.prototype.handleEsc = function () {\n        for (var i = this.content.length - 1; i >= 0; i--) {\n            var component = this.content[i];\n            if (component) {\n                var options = component.displayOptions;\n                if (options && (typeof options.onEsc === \"function\")) {\n                    options.onEsc.call(undefined);\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /** Scroll the page and all parent components of given component, such that the entire component becomes visible */\n    Page.prototype.scrollTo = function (component) {\n        this._renderer.scrollTo(component);\n    };\n    /** Display this page on screen; also re-enables the page if input was blocked; replaces the currently displaying page on screen, which is removed automatically, but the result may be an empty screen if this page has no content; always waits for `Screen.ready`; returns a promise that is fulfilled when the components on this page have been rendered */\n    Page.prototype.displayAsync = function () {\n        var _this = this;\n        return new Async_defaultExport.Promise(function (resolve) {\n            var displayed = Page_current.value;\n            if (_this === displayed) {\n                // this page is already displayed (or now displaying)\n                resolve(undefined);\n                return;\n            }\n            // remove current page and unblock input if needed\n            displayed && displayed.remove();\n            if (_this._disabled) {\n                _this._renderer.enableInput();\n                _this._disabled = false;\n            }\n            Page_current.value = _this;\n            // subscribe to an observable that depends on all page content\n            var screenIsReady = Async_defaultExport.observe(Screen_Screen.ready);\n            var resolved = false;\n            _this._sub = Async_defaultExport.observe(function () {\n                if (screenIsReady.value) {\n                    _this._renderer.updateAsync().then(function () {\n                        // resolve and emit if rendered for the first time\n                        if (!resolved) {\n                            resolve(undefined);\n                            _this.Displayed();\n                        }\n                    });\n                }\n            }).subscribe();\n        });\n    };\n    /** Remove this page from the screen, if currently displayed; returns this */\n    Page.prototype.remove = function () {\n        if (this._sub) {\n            // unsubscribe from content components (deferred, to allow\n            // re-connection by another page immediately)\n            var sub = this._sub;\n            Async_defaultExport.defer(function () { return sub.clear(); });\n            this._sub = undefined;\n        }\n        if (Page_current.value === this) {\n            Page_current.value = undefined;\n            this._renderer.remove();\n            this.Removed();\n        }\n        return this;\n    };\n    /** Block all input events on this page, until given promise is resolved, or until page is re-displayed */\n    Page.prototype.disable = function (promise) {\n        var _this = this;\n        if (this._disabled || !this._sub)\n            return;\n        this._renderer.disableInput();\n        this._disabled = true;\n        if (promise) {\n            promise.then(function () {\n                if (_this._disabled && _this._sub)\n                    _this._renderer.enableInput();\n            });\n        }\n    };\n    Object.defineProperty(Page.prototype, \"_renderer\", {\n        /** @internal The current page renderer instance */\n        get: function () {\n            // create renderer (once) and forward KeyDown signal\n            var result = new this.Renderer(this);\n            result.KeyDown.connect(this.KeyDown);\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Page___decorate([\n        Async_defaultExport.observable_not_null\n    ], Page.prototype, \"content\", void 0);\n    Page___decorate([\n        Async_defaultExport.observable\n    ], Page.prototype, \"flowDirection\", void 0);\n    Page___decorate([\n        Async_defaultExport.injectable\n    ], Page.prototype, \"Renderer\", void 0);\n    Page___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], Page.prototype, \"_renderer\", null);\n    return Page;\n}());\n\n/** @internal Platform dependent page rendering/display implementation */\nvar Page_PageRenderer = (function () {\n    /** Create the renderer for given page */\n    function PageRenderer(page) {\n        /** Signal that should be emitted when a key is being pressed on the keyboard, while the rendered page is displayed in the foreground */\n        this.KeyDown = Signal_Signal.create();\n        this.page = page;\n    }\n    return PageRenderer;\n}());\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Menu.js\n/** Contains methods for displaying dropdown menus and context menus */\nvar Menu;\n(function (Menu) {\n    /** Display a modal context menu; returns a Promise that resolves to the index(base 1)/key of the selected menu item, or is rejected if the user cancels the context menu */\n    function displayContextMenu(options, event) {\n        /* implemented by platform dependent code */\n        throw new Error();\n    }\n    Menu.displayContextMenu = displayContextMenu;\n    /** Display a modal dropdown menu below the given component (or above, depending on available screen space); returns a Promise that resolves to the index(base 1)/key of the selected menu item, or is rejected if the user cancels the context menu */\n    function displayDropdown(options, component) {\n        /* implemented by platform dependent code */\n        throw new Error();\n    }\n    Menu.displayDropdown = displayDropdown;\n    /** Dismiss the menu currently on screen, if any */\n    function dismiss() {\n        /* implemented by platform dependent code */\n    }\n    Menu.dismiss = dismiss;\n})(Menu || (Menu = {}));\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/ControlElement.js\nvar ControlElement___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ControlElement___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n/** UI control element base class */\nvar ControlElement_ControlElement = (function (_super) {\n    ControlElement___extends(ControlElement, _super);\n    function ControlElement() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Width (CSS length), default \"auto\" (observed) */\n        _this.width = \"auto\";\n        /** Set to true to shrink this element to use as little horizontal space as possible in a row; set to false to expand (observed) */\n        _this.shrinkwrap = false;\n        /** Set to true to automatically break text across lines (observed) */\n        _this.wrapText = false;\n        return _this;\n    }\n    ControlElement___decorate([\n        Async_defaultExport.observable_string\n    ], ControlElement.prototype, \"width\", void 0);\n    ControlElement___decorate([\n        Async_defaultExport.observable\n    ], ControlElement.prototype, \"shrinkwrap\", void 0);\n    ControlElement___decorate([\n        Async_defaultExport.observable\n    ], ControlElement.prototype, \"wrapText\", void 0);\n    return ControlElement;\n}(Component_Component));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/Button.js\nvar Button___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Button___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n\n/** Represents a button control */\nvar Button_Button = (function (_super) {\n    Button___extends(Button, _super);\n    /** Create a button control element */\n    function Button(label, icon) {\n        if (label === void 0) { label = \"\"; }\n        var _this = _super.call(this) || this;\n        /** Set to false to expand horizontally within row (observed) */\n        _this.shrinkwrap = true;\n        /** Encapsulation of button element style (observed) */\n        _this.style_button = new Style_Style();\n        /** Signal emitted when a dropdown option has been selected */\n        _this.DropdownClicked = _this.createComponentSignal(Button.DropdownClickSignal);\n        _this.label = label;\n        _this.icon = icon;\n        // connect to Click signal to show dropdown and/or activate target\n        _this.Click.connect(function () {\n            if (_this.dropdown && _this.dropdown.length) {\n                // create menu and display, then emit signal on selection\n                Menu.displayDropdown(_this.dropdown, _this)\n                    .then(function (choice) { return _this.DropdownClicked(choice); });\n            }\n            else if (_this.target) {\n                // activate given target\n                new Button.Activation().activate(_this.target);\n            }\n        });\n        return _this;\n    }\n    /** Initialize a button control factory with given label and handler */\n    Button.withLabel = function (label, clickedHandler) {\n        return this.with({ label: label, Clicked: clickedHandler });\n    };\n    /** Initialize a button control factory with given icon and handler */\n    Button.withIcon = function (icon, clickedHandler) {\n        return this.with({ label: \"\", icon: icon, Clicked: clickedHandler });\n    };\n    Button___decorate([\n        Async_defaultExport.observable_string\n    ], Button.prototype, \"label\", void 0);\n    Button___decorate([\n        Async_defaultExport.observable\n    ], Button.prototype, \"icon\", void 0);\n    Button___decorate([\n        Async_defaultExport.observable\n    ], Button.prototype, \"iconAfter\", void 0);\n    Button___decorate([\n        Async_defaultExport.observable\n    ], Button.prototype, \"remGutter\", void 0);\n    Button___decorate([\n        Async_defaultExport.observable_string\n    ], Button.prototype, \"badge\", void 0);\n    Button___decorate([\n        Async_defaultExport.observable_string\n    ], Button.prototype, \"tooltipText\", void 0);\n    Button___decorate([\n        Async_defaultExport.observable\n    ], Button.prototype, \"disabled\", void 0);\n    Button___decorate([\n        Async_defaultExport.observable\n    ], Button.prototype, \"primary\", void 0);\n    Button___decorate([\n        Async_defaultExport.observable\n    ], Button.prototype, \"dropdown\", void 0);\n    Button___decorate([\n        Async_defaultExport.observable\n    ], Button.prototype, \"target\", void 0);\n    Button___decorate([\n        Async_defaultExport.observable_not_null\n    ], Button.prototype, \"style_button\", void 0);\n    return Button;\n}(ControlElement_ControlElement));\n\n(function (Button) {\n    /** Signal that is emitted when a dropdown item has been selected */\n    var DropdownClickSignal = (function (_super) {\n        Button___extends(DropdownClickSignal, _super);\n        function DropdownClickSignal() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return DropdownClickSignal;\n    }(ComponentSignal));\n    Button.DropdownClickSignal = DropdownClickSignal;\n    /** Contains injectable method for activating targets; instantiated by `Button` */\n    var Activation = (function () {\n        function Activation() {\n        }\n        /** Injectable method to activate given target (e.g. URL, or Activity instance or class); default ony handles URLs, `Application` instance injects more functionality here */\n        Activation.prototype.activate = function (target) { };\n        Button___decorate([\n            Async_defaultExport.injectable\n        ], Activation.prototype, \"activate\", null);\n        return Activation;\n    }());\n    Button.Activation = Activation;\n})(Button_Button || (Button_Button = {}));\n/** Constructor for a button dropdown click event handler */\nvar ButtonDropdownClickHandler = (function (_super) {\n    Button___extends(ButtonDropdownClickHandler, _super);\n    function ButtonDropdownClickHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ButtonDropdownClickHandler;\n}(ComponentSignalHandler));\n\n/** Primary button control (shortcut for setting `.primary` on regular `Button` class) */\nvar PrimaryButton = (function (_super) {\n    Button___extends(PrimaryButton, _super);\n    function PrimaryButton() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.primary = true;\n        return _this;\n    }\n    return PrimaryButton;\n}(Button_Button));\n\n/** Button that switches between selected (active) and deselected (inactive) when clicked (shortcut for setting `toggleMode` on regular `Button` class) */\nvar Button_ToggleButton = (function (_super) {\n    Button___extends(ToggleButton, _super);\n    function ToggleButton(label, icon) {\n        if (label === void 0) { label = \"\"; }\n        var _this = _super.call(this, label, icon) || this;\n        _this.selectionMode = Component_Component.SelectionMode.Toggle;\n        return _this;\n    }\n    return ToggleButton;\n}(Button_Button));\n\n/** Link-styled button control (\"btn-link\" class) */\nvar LinkButton = (function (_super) {\n    Button___extends(LinkButton, _super);\n    function LinkButton() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LinkButton;\n}(Button_Button));\n\n/** Button control that is not decorated as a button */\nvar TextButton = (function (_super) {\n    Button___extends(TextButton, _super);\n    function TextButton() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return TextButton;\n}(Button_Button));\n\n/** Round button control (e.g. with an icon) */\nvar RoundButton = (function (_super) {\n    Button___extends(RoundButton, _super);\n    function RoundButton() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return RoundButton;\n}(Button_Button));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Containers/DialogContainer.js\nvar DialogContainer___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DialogContainer___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n\n\n// TextButton is needed directly in static init of TopCloseButton:\n\n/** Represents a modal dialog container */\nvar DialogContainer_DialogContainer = (function (_super) {\n    DialogContainer___extends(DialogContainer, _super);\n    /** Create a new modal dialog with given content, if any */\n    function DialogContainer(content, width) {\n        if (width === void 0) { width = \"27rem\"; }\n        var _this = _super.call(this, content) || this;\n        /** Signal emitted by the `.open` method before displaying the dialog; if any handler throws an error then the dialog will not open */\n        _this.Opening = _this.createComponentSignal();\n        /** Signal emitted when user clicks outside dialog, presses esc or clicks DialogContainer.TopCloseButton; if any handler throws an error then the dialog will not close */\n        _this.Closing = _this.createComponentSignal();\n        /** Signal emitted when this dialog has been closed */\n        _this.Closed = _this.createComponentSignal();\n        /** @internal True if a drag handle has been (un)set explicitly */\n        _this._dragHandleSet = false;\n        _this.width = width;\n        // set default display options\n        _this.displayOptions = {\n            modal: true,\n            shade: true,\n            modalHorzAlign: \"center\",\n            outerMargin: \".5rem\",\n            onEsc: function () {\n                Async_defaultExport.Promise.all(new _this.Closing({}).emit().results)\n                    .then(function () { return _this.close(); });\n            }\n        };\n        // add default animations\n        if (!_this.animations)\n            _this.animations = {};\n        _this.animations.appear = DialogContainer.APPEAR_ANIMATION;\n        _this.animations.disappear = DialogContainer.DISAPPEAR_ANIMATION;\n        // set header as drag handle if none set explicitly\n        _this.Rendered.connect(function () {\n            if (!_this._dragHandleSet && _this.header)\n                Async_defaultExport.unobserved(function () { _this.setDragHandle(_this.header); });\n        });\n        return _this;\n    }\n    /** Show the dialog on screen (in front of other components on the current page, if any), asynchronously after emitting the `.Opening` signal; returns a promise that is fulfilled after the dialog has been rendered */\n    DialogContainer.prototype.openAsync = function () {\n        var _this = this;\n        return Async_defaultExport.Promise.all(new this.Opening({}).results)\n            .then(function () { return Screen_Screen.displayAsync(_this); });\n    };\n    /** Remove the dialog from screen (does not emit or wait for `.Closing` signal, only emits `.Closed`); returns this */\n    DialogContainer.prototype.close = function () {\n        Screen_Screen.remove(this);\n        this.Closed();\n        return this;\n    };\n    /** Use given component as a drag handle for this dialog (and releases handle currently in use; defaults to .header) */\n    DialogContainer.prototype.setDragHandle = function (handle) {\n        var _this = this;\n        this._dragHandleSet = true;\n        if (this._dragHandleConnection)\n            this._dragHandleConnection.disconnect();\n        // listen to mouse down and start drag, then pick up container\n        if (handle) {\n            this._dragHandleConnection = handle.Pressed.connect(function (event) {\n                if (!event.button)\n                    Drag_Drag.start(event).pickUp(_this);\n            });\n        }\n    };\n    /** Returns an array of directly contained components (observable) */\n    DialogContainer.prototype.getChildren = function () {\n        var result = _super.prototype.getChildren.call(this);\n        if (this.header instanceof Component_Component)\n            result.unshift(this.header);\n        if (this.footer instanceof Component_Component)\n            result.push(this.footer);\n        return result;\n    };\n    DialogContainer___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Block),\n        Async_defaultExport.observable\n    ], DialogContainer.prototype, \"header\", void 0);\n    DialogContainer___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Block),\n        Async_defaultExport.observable\n    ], DialogContainer.prototype, \"footer\", void 0);\n    return DialogContainer;\n}(Container_Container));\n\n(function (DialogContainer) {\n    /** Predefined modal close button (\"X\") control, based on `TextButton` */\n    var TopCloseButton = (function (_super) {\n        DialogContainer___extends(TopCloseButton, _super);\n        /** Create a modal close button (\"X\") control */\n        function TopCloseButton() {\n            var _this = _super.call(this) || this;\n            _this.label = \"\\u00D7\";\n            _this.tooltipText = \"Close\";\n            _this.Click.connect(function () {\n                var page = Page_Page.getCurrentPage();\n                page && page.handleEsc();\n            });\n            return _this;\n        }\n        return TopCloseButton;\n    }(TextButton));\n    DialogContainer.TopCloseButton = TopCloseButton;\n})(DialogContainer_DialogContainer || (DialogContainer_DialogContainer = {}));\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Containers/DrawerContainer.js\nvar DrawerContainer___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n/** Represents a modal container displayed on the side of the screen */\nvar DrawerContainer = (function (_super) {\n    DrawerContainer___extends(DrawerContainer, _super);\n    /** Create a drawer component with given content, if any */\n    function DrawerContainer(content, width) {\n        var _this = _super.call(this, content) || this;\n        if (width)\n            _this.width = width;\n        // amend alignment and margin\n        _this.displayOptions.modalHorzAlign = \"left\";\n        _this.displayOptions.outerMargin = \"1.5rem\";\n        // amend default animations\n        if (!_this.animations)\n            _this.animations = {};\n        _this.animations.appear = DrawerContainer.APPEAR_ANIMATION;\n        _this.animations.disappear = DrawerContainer.DISAPPEAR_ANIMATION;\n        return _this;\n    }\n    return DrawerContainer;\n}(DialogContainer_DialogContainer));\n\n/** Represents a modal container displayed on the right hand side of the screen (i.e. DrawerContainer with different alignment and animations) */\nvar OppositeDrawerContainer = (function (_super) {\n    DrawerContainer___extends(OppositeDrawerContainer, _super);\n    /** Create a drawer component with given content, if any */\n    function OppositeDrawerContainer(content, width) {\n        var _this = _super.call(this, content, width) || this;\n        // amend alignment\n        _this.displayOptions.modalHorzAlign = \"right\";\n        // amend default animations\n        if (!_this.animations)\n            _this.animations = {};\n        _this.animations.appear = OppositeDrawerContainer.APPEAR_ANIMATION;\n        _this.animations.disappear = OppositeDrawerContainer.DISAPPEAR_ANIMATION;\n        return _this;\n    }\n    return OppositeDrawerContainer;\n}(DrawerContainer));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Containers/LayoutContainer.js\nvar LayoutContainer___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar LayoutContainer___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents a container with sub containers on up to four sides, and a main area with vertically stacked blocks */\nvar LayoutContainer_LayoutContainer = (function (_super) {\n    LayoutContainer___extends(LayoutContainer, _super);\n    function LayoutContainer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Set to true to make content within container scrollable; defaults to true for `LayoutContainer` (observed) */\n        _this.scrollable = true;\n        return _this;\n    }\n    /** Returns an array of directly contained components (observable) */\n    LayoutContainer.prototype.getChildren = function () {\n        var result = _super.prototype.getChildren.call(this);\n        if (this.header instanceof Component_Component)\n            result.push(this.header);\n        if (this.footer instanceof Component_Component)\n            result.push(this.footer);\n        if (this.insideGutter instanceof Component_Component)\n            result.push(this.insideGutter);\n        if (this.outsideGutter instanceof Component_Component)\n            result.push(this.outsideGutter);\n        return result;\n    };\n    /** Default inside gutter width, used when inside gutter container has no defined width (CSS value, initially 18rem) */\n    LayoutContainer.INSIDE_GUTTER_WIDTH = \"18rem\";\n    /** Default outside gutter width, used when outside gutter container has no defined width (CSS value, initially 22rem) */\n    LayoutContainer.OUTSIDE_GUTTER_WIDTH = \"22rem\";\n    /** Default header height, used when header container has no defined height (CSS value, initially 4rem) */\n    LayoutContainer.HEADER_HEIGHT = \"4rem\";\n    /** Default footer height, used when footer container has no defined height (CSS value, initially 2rem) */\n    LayoutContainer.FOOTER_HEIGHT = \"2rem\";\n    LayoutContainer___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Container),\n        Async_defaultExport.observable\n    ], LayoutContainer.prototype, \"header\", void 0);\n    LayoutContainer___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Container),\n        Async_defaultExport.observable\n    ], LayoutContainer.prototype, \"footer\", void 0);\n    LayoutContainer___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Container),\n        Async_defaultExport.observable\n    ], LayoutContainer.prototype, \"insideGutter\", void 0);\n    LayoutContainer___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Container),\n        Async_defaultExport.observable\n    ], LayoutContainer.prototype, \"outsideGutter\", void 0);\n    LayoutContainer___decorate([\n        Async_defaultExport.observable\n    ], LayoutContainer.prototype, \"scrollable\", void 0);\n    return LayoutContainer;\n}(Container_Container));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/Block.js\nvar Block___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Block___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n/** Block base class: full-width block component */\nvar Block_Block = (function (_super) {\n    Block___extends(Block, _super);\n    /** Create a new empty block component */\n    function Block() {\n        return _super.call(this) || this;\n        // nothing here\n    }\n    Block___decorate([\n        Async_defaultExport.observable\n    ], Block.prototype, \"overlayPosition\", void 0);\n    return Block;\n}(Component_Component));\n\n(function (Block) {\n    /** Overlay positioning options */\n    var OverlayPosition;\n    (function (OverlayPosition) {\n        /** Top (full width) */\n        OverlayPosition[OverlayPosition[\"Top\"] = 0] = \"Top\";\n        /** Top left corner */\n        OverlayPosition[OverlayPosition[\"TopLeft\"] = 1] = \"TopLeft\";\n        /** Top right corner */\n        OverlayPosition[OverlayPosition[\"TopRight\"] = 2] = \"TopRight\";\n        /** Top inside corner (left for default ltr mode) */\n        OverlayPosition[OverlayPosition[\"TopStart\"] = 3] = \"TopStart\";\n        /** Top outside corner (right for default ltr mode) */\n        OverlayPosition[OverlayPosition[\"TopEnd\"] = 4] = \"TopEnd\";\n        /** Bottom (full width) */\n        OverlayPosition[OverlayPosition[\"Bottom\"] = 5] = \"Bottom\";\n        /** Bottom left corner */\n        OverlayPosition[OverlayPosition[\"BottomLeft\"] = 6] = \"BottomLeft\";\n        /** Bottom right corner */\n        OverlayPosition[OverlayPosition[\"BottomRight\"] = 7] = \"BottomRight\";\n        /** Bottom inside corner (left for default ltr mode) */\n        OverlayPosition[OverlayPosition[\"BottomStart\"] = 8] = \"BottomStart\";\n        /** Bottom outside corner (right for default ltr mode) */\n        OverlayPosition[OverlayPosition[\"BottomEnd\"] = 9] = \"BottomEnd\";\n    })(OverlayPosition = Block.OverlayPosition || (Block.OverlayPosition = {}));\n    ;\n})(Block_Block || (Block_Block = {}));\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/Card.js\nvar Card___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Card___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents a card block containing a header, content, and a footer */\nvar Card_Card = (function (_super) {\n    Card___extends(Card, _super);\n    /** Create a card block with given content, if any */\n    function Card(content) {\n        if (content === void 0) { content = []; }\n        var _this = _super.call(this) || this;\n        _this.content = content;\n        return _this;\n    }\n    /** Append a block to this component */\n    Card.prototype.appendChild = function (block) {\n        this.content.push(block);\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    Card.prototype.getChildren = function () {\n        var result = this.content.filter(function (c) { return (c instanceof Component_Component); });\n        if (this.header instanceof Component_Component)\n            result.unshift(this.header);\n        if (this.footer instanceof Component_Component)\n            result.push(this.footer);\n        return result;\n    };\n    Card___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Block),\n        Async_defaultExport.observable\n    ], Card.prototype, \"header\", void 0);\n    Card___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Block),\n        Async_defaultExport.observable\n    ], Card.prototype, \"footer\", void 0);\n    Card___decorate([\n        ComponentFactory_ComponentFactory.applyComponentsArray(ComponentFactory_ComponentFactory.CLevel.Block),\n        Async_defaultExport.observable_not_null\n    ], Card.prototype, \"content\", void 0);\n    Card = Card___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.Block)\n    ], Card);\n    return Card;\n}(Block_Block));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/ContainerBlock.js\nvar ContainerBlock___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ContainerBlock___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents a block with an embedded sub container within its margins/padding */\nvar ContainerBlock_ContainerBlock = (function (_super) {\n    ContainerBlock___extends(ContainerBlock, _super);\n    /** Create a container block component with given container, if any */\n    function ContainerBlock(container) {\n        var _this = _super.call(this) || this;\n        if (container)\n            _this.container = container;\n        // apply automatic height to start with\n        _this.style.set(\"height\", Async_defaultExport.observe(function () { return _this.height; }));\n        return _this;\n    }\n    Object.defineProperty(ContainerBlock.prototype, \"container\", {\n        /** Container element (created if not set, never undefined; observed) */\n        get: function () {\n            // get underlying property or create a new container\n            return this.container || (this.container = Async_defaultExport.unobserved(function () { return new Container_Container(); }));\n        },\n        set: function (c) {\n            // set underlying property\n            this.container = c;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ContainerBlock.prototype, \"height\", {\n        /** Overall target height of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be \"auto\"); if a height has not been set explicitly, or is set to \"auto\", then the value is taken from the height of the container; for `LayoutContainer`, a value of \"100%\" is used if the container's height is also \"auto\" */\n        get: function () {\n            var result = this.height;\n            if (!result) {\n                // while no height set, observe container height and type\n                result = this.container && this.container.height || \"auto\";\n                if ((this.container instanceof LayoutContainer_LayoutContainer) &&\n                    result === \"auto\")\n                    result = \"100%\";\n            }\n            return result;\n        },\n        set: function (h) {\n            var _this = this;\n            if (h === \"auto\")\n                h = \"\";\n            this.style.set(\"height\", h ? h : Async_defaultExport.observe(function () { return _this.height; }));\n            this.height = h;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Set the container for this component (overwrites existing value, if any); returns this */\n    ContainerBlock.prototype.appendChild = function (c) {\n        this.container = c;\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    ContainerBlock.prototype.getChildren = function () {\n        return [this.container];\n    };\n    ContainerBlock___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Container),\n        Async_defaultExport.observable\n    ], ContainerBlock.prototype, \"container\", null);\n    ContainerBlock___decorate([\n        Async_defaultExport.observable\n    ], ContainerBlock.prototype, \"height\", null);\n    ContainerBlock = ContainerBlock___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.Container)\n    ], ContainerBlock);\n    return ContainerBlock;\n}(Block_Block));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/Divider.js\nvar Divider___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Divider___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Represents a divider block element (horizontal line placed between blocks) */\nvar Divider_Divider = (function (_super) {\n    Divider___extends(Divider, _super);\n    /** Create a new divider with given (optional) properties */\n    function Divider(color, thickness, margin, insetStart, insetEnd) {\n        var _this = _super.call(this) || this;\n        if (color)\n            _this.color = color;\n        if (thickness)\n            _this.thickness = thickness;\n        if (margin)\n            _this.margin = margin;\n        if (insetStart)\n            _this.insetStart = insetStart;\n        if (insetEnd)\n            _this.insetEnd = insetEnd;\n        // make sure this component cannot be focused (e.g. in a List)\n        _this.focusMode = Component_Component.FocusMode.None;\n        return _this;\n    }\n    Divider___decorate([\n        Async_defaultExport.observable_string\n    ], Divider.prototype, \"color\", void 0);\n    Divider___decorate([\n        Async_defaultExport.observable_string\n    ], Divider.prototype, \"thickness\", void 0);\n    Divider___decorate([\n        Async_defaultExport.observable_string\n    ], Divider.prototype, \"margin\", void 0);\n    Divider___decorate([\n        Async_defaultExport.observable_string\n    ], Divider.prototype, \"insetStart\", void 0);\n    Divider___decorate([\n        Async_defaultExport.observable_string\n    ], Divider.prototype, \"insetEnd\", void 0);\n    return Divider;\n}(Block_Block));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/List.js\nvar List___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar List___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n\n/** Represents a list of blocks */\nvar List_List = (function (_super) {\n    List___extends(List, _super);\n    /** Create a list component with given items */\n    function List(items) {\n        if (items === void 0) { items = []; }\n        var _this = _super.call(this) || this;\n        /** Signal emitted when the list selection changes, while displayed on screen */\n        _this.SelectionChange = _this.createComponentSignal(List_1.SelectionSignal);\n        _this._dividers = {};\n        _this.items = items.slice();\n        return _this;\n    }\n    List_1 = List;\n    /** Method that is called immediately after the renderer for this list is constructed; adds observers for item selection */\n    List.prototype.beforeFirstRender = function (renderer) {\n        var _this = this;\n        _super.prototype.beforeFirstRender.call(this, renderer);\n        // emit SelectionChange if selection changes (based on list of child\n        // components and their selection status)\n        var lastIndex = -1, lastItem;\n        renderer.watch(function () {\n            var item = _this.getLastSelectedChild();\n            var index = item ? _this.items.indexOf(item) : -1;\n            if (index < 0)\n                item = undefined;\n            return { index: index, item: item };\n        }, function (change) {\n            if (lastIndex !== change.index || lastItem !== change.item) {\n                _this.SelectionChange(change);\n                lastIndex = change.index;\n                lastItem = change.item;\n            }\n            // update selected index asynchronously\n            _this.selectedIndex = change.index;\n        });\n        // watch selectedIndex, update selection asynchronously if needed\n        // (e.g. if selectedIndex is set to an observable using a binding)\n        renderer.watch(function () { return _this.selectedIndex; }, function (i) {\n            if (i !== _this.selectedIndex)\n                return; // avoid race/loop\n            var item = (i >= 0 && i < _this.items.length) ?\n                _this.items[i] : undefined;\n            if (item)\n                item.selected = true;\n            else\n                _this.deselectAll();\n        });\n    };\n    Object.defineProperty(List.prototype, \"selectedIndex\", {\n        /** Current (last) selected item index (base 0), or -1 if no item is selected (observed) */\n        get: function () {\n            // return last selected index (manually, async from beforeFirstRender,\n            // or return the observable value given to setter below)\n            return this.selectedIndex;\n        },\n        set: function (i) {\n            var value;\n            if ((i instanceof Async_defaultExport.ObservableValue)) {\n                this._observableSelectedIndex = i;\n                this.selectedIndex = i;\n                value = i.value;\n                if (value === undefined)\n                    return;\n            }\n            else {\n                // update underlying value or set observable value\n                if (this._observableSelectedIndex) {\n                    if (this._observableSelectedIndex.writable)\n                        this._observableSelectedIndex.value = i;\n                }\n                else {\n                    // no observable bound, just set own value\n                    this.selectedIndex = i;\n                }\n                value = i;\n            }\n            // use -1 for any other invalid value\n            if (value < 0 || value >= this.items.length || !this.items[value])\n                value = -1;\n            // select given item synchronously\n            this.selectItem(value >= 0 ? this.items[value] : undefined);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Deselect all items currently in this list */\n    List.prototype.deselectAll = function () {\n        this.items.forEach(function (c) { if (c)\n            c.selected = false; });\n    };\n    /** Select given item (block), and immediately deselect others if `.selectionMode` is `ItemClick` or `ItemFocus`; does _not_ check if the item is included in `.items` at all for performance reasons */\n    List.prototype.selectItem = function (item) {\n        // select given item\n        if (item)\n            item.selected = true;\n        // check if need to deselect others (do not wait for async)\n        if (this.selectionMode === Component_Component.SelectionMode.ItemClick ||\n            this.selectionMode === Component_Component.SelectionMode.ItemFocus) {\n            for (var j = this.items.length - 1; j >= 0; j--)\n                if (this.items[j] && this.items[j] !== item)\n                    this.items[j].selected = false;\n        }\n    };\n    /** Append a block to this list */\n    List.prototype.appendChild = function (block) {\n        this.items.push(block);\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    List.prototype.getChildren = function () {\n        var _this = this;\n        var result = [];\n        var dividers = {};\n        this.items.forEach(function (item) {\n            if (!item)\n                return;\n            // add a divider if needed (not before first item)\n            if (_this.divider && result.length) {\n                var divider = dividers[item.uid] =\n                    _this._dividers[item.uid] ||\n                        Async_defaultExport.unobserved(function () { return ComponentFactory_ComponentFactory.initializeWith\n                            .call(new Divider_Divider(), _this.divider); });\n                result.push(divider);\n            }\n            // add the item itself\n            result.push(item);\n        });\n        this._dividers = dividers;\n        return result;\n    };\n    /** Returns an object containing all current values of input elements (observable) */\n    List.prototype.getFormValues = function (result) {\n        if (result === void 0) { result = {}; }\n        if (this.name)\n            result[this.name] = this.items\n                .mapAsyncValues(function (item) { return Async_defaultExport.observe(function () { return item.getFormValues(); }); });\n        else\n            _super.prototype.getFormValues.call(this, result);\n        return result;\n    };\n    /** Set all input values by element name */\n    List.prototype.setFormValues = function (values) {\n        var _this = this;\n        if (this.name) {\n            values && values[this.name] && this.items.forEach(function (item, i) {\n                item && item.setFormValues(values[_this.name][i]);\n            });\n        }\n        else\n            _super.prototype.setFormValues.call(this, values);\n    };\n    List___decorate([\n        ComponentFactory_ComponentFactory.applyComponentsArray(ComponentFactory_ComponentFactory.CLevel.Block),\n        Async_defaultExport.observable_not_null\n    ], List.prototype, \"items\", void 0);\n    List___decorate([\n        ComponentFactory_ComponentFactory.applyAsync,\n        Async_defaultExport.observable\n    ], List.prototype, \"selectedIndex\", null);\n    List___decorate([\n        Async_defaultExport.observable\n    ], List.prototype, \"divider\", void 0);\n    List___decorate([\n        Async_defaultExport.observable\n    ], List.prototype, \"name\", void 0);\n    List = List_1 = List___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.Block)\n    ], List);\n    return List;\n    var List_1;\n}(Block_Block));\n\n(function (List) {\n    /** Signal that is emitted when a list selection event occurs */\n    var SelectionSignal = (function (_super) {\n        List___extends(SelectionSignal, _super);\n        function SelectionSignal() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return SelectionSignal;\n    }(ComponentSignal));\n    List.SelectionSignal = SelectionSignal;\n})(List_List || (List_List = {}));\n/** Constructor for a list selection event handler */\nvar ListSelectionHandler = (function (_super) {\n    List___extends(ListSelectionHandler, _super);\n    function ListSelectionHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ListSelectionHandler;\n}(ComponentSignalHandler));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/TreeList.js\nvar TreeList___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar TreeList___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n/** Represents a hierarchical list of blocks */\nvar TreeList_TreeList = (function (_super) {\n    TreeList___extends(TreeList, _super);\n    /** Create a tree list component with given items */\n    function TreeList(items) {\n        if (items === void 0) { items = []; }\n        var _this = _super.call(this) || this;\n        /** Signal emitted when the list selection changes, while displayed on screen */\n        _this.SelectionChange = _this.createComponentSignal(TreeList_1.SelectionSignal);\n        /** Signal emitted when a tree list item is collapsed, while displayed on screen */\n        _this.ItemCollapsed = _this.createComponentSignal(TreeList_1.FoldSignal);\n        /** Signal emitted when a tree list item is expanded, while displayed on screen */\n        _this.ItemExpanded = _this.createComponentSignal(TreeList_1.FoldSignal);\n        _this.items = items.slice();\n        return _this;\n    }\n    TreeList_1 = TreeList;\n    /** Method that is called immediately after the renderer for this list is constructed; adds observers for item selection */\n    TreeList.prototype.beforeFirstRender = function (renderer) {\n        var _this = this;\n        _super.prototype.beforeFirstRender.call(this, renderer);\n        // create an observable flattened array with all open items\n        this._flattened = recurse(function () { return _this.items; }).flattenAsync(true);\n        function recurse(f) {\n            return Async_defaultExport.observeArray(f).mapAsyncValues(function (b) {\n                if (b instanceof Block_Block) {\n                    var sub = recurse(function () { return b.treeListItems; });\n                    return Async_defaultExport.observe(function () {\n                        return (!b.collapsed &&\n                            b.treeListItems) ?\n                            [b, sub] :\n                            b;\n                    });\n                }\n                return undefined;\n            });\n        }\n        // keep track of expanded and collapsed items\n        var count = 0;\n        var items = {};\n        var expanded = {};\n        var visible = {};\n        var trackItems = Async_defaultExport.observe(function () {\n            count++;\n            _this._flattened && _this._flattened.forEach(function (b) {\n                if (b) {\n                    items[b.uid] = b;\n                    var wasVisible = visible[b.uid];\n                    visible[b.uid] = count;\n                    if (!b.collapsed && b.treeListItems) {\n                        // set marker to current count, or 0 if new\n                        var wasExpanded = expanded[b.uid] > 0;\n                        expanded[b.uid] = (wasExpanded || !wasVisible) ?\n                            count : 0;\n                    }\n                }\n            });\n            return count;\n        });\n        renderer.watch(function () { return trackItems.value; }, function (c) {\n            if (c !== count)\n                return; // overtaken\n            // find newly expanded items and newly collapsed visible items\n            for (var uid in visible) {\n                if (visible[uid] < c) {\n                    // no longer visible, forget about this item\n                    delete items[uid];\n                    delete visible[uid];\n                    delete expanded[uid];\n                }\n                else if (expanded[uid] === 0) {\n                    // newly expanded (while already visible)\n                    expanded[uid] = c;\n                    _this.ItemExpanded({ item: items[uid] });\n                }\n                else if (expanded[uid] < c) {\n                    // no longer expanded but still visible\n                    _this.ItemCollapsed({ item: items[uid] });\n                    delete expanded[uid];\n                }\n            }\n        });\n        // emit SelectionChange if selection changes (based on list of child\n        // components and their selection status)\n        var lastItem;\n        renderer.watch(function () { return _this.getLastSelectedChild(); }, function (item) {\n            if (!item || item.selected) {\n                if (item !== lastItem) {\n                    lastItem = item;\n                    _this.SelectionChange({\n                        item: item,\n                        key: item && item.key\n                    });\n                }\n            }\n        });\n    };\n    /** Select given item (block), and immediately deselect others if `.selectionMode` is `ItemClick` or `ItemFocus`; does _not_ check if the item is included in `.items` at all for performance reasons */\n    TreeList.prototype.selectItem = function (item) {\n        // select given item\n        if (item)\n            item.selected = true;\n        // check if need to deselect others (do not wait for async)\n        if (this.selectionMode === Component_Component.SelectionMode.ItemClick ||\n            this.selectionMode === Component_Component.SelectionMode.ItemFocus) {\n            this._flattened && this._flattened.slice().forEach(function (b) {\n                if (b && b !== item)\n                    b.selected = false;\n            });\n        }\n    };\n    Object.defineProperty(TreeList.prototype, \"selectedKey\", {\n        /** Key (string value) of selected item, if any (observable); see `TreeList.BlockItem/key`; if set to a string value, all items in the hierarchy will be checked for a matching key, and selected or deselected; for selected items, parent items will be expanded automatically; input focus will be removed from deselected items as well, but selected items are not focused automatically */\n        get: function () {\n            // find selected item and return its key, if any\n            var item = this.getLastSelectedChild();\n            return item ? item.key : undefined;\n        },\n        set: function (key) {\n            var _this = this;\n            // use an object to compare against instead of undefined,\n            // so that none will match\n            if (key === undefined)\n                key = {};\n            // clear previous observable, do not keep looking for old key\n            this._selectedKeySetter && this._selectedKeySetter.clear();\n            // recurse over *all* items and select or deselect\n            var hasUndefined = false;\n            function recurse(list) {\n                var didSelect = false;\n                list.forEach(function (block) {\n                    if (!block) {\n                        hasUndefined = true;\n                        return;\n                    }\n                    // deselect or select and focus/blur if possible\n                    var doSelect = (block.key === key);\n                    if (doSelect)\n                        didSelect = true;\n                    if (doSelect !== (block.selected || false)) {\n                        Async_defaultExport.unobserved(function () {\n                            block.selected = doSelect;\n                            if (!doSelect &&\n                                block.focusMode !== Component_Component.FocusMode.None)\n                                block.hasFocus = false;\n                        });\n                    }\n                    if (block.treeListItems && block.treeListItems.length &&\n                        recurse(block.treeListItems)) {\n                        didSelect = true;\n                        // expand parent items of matching items\n                        Async_defaultExport.unobserved(function () { block.collapsed = false; });\n                    }\n                });\n                return didSelect;\n            }\n            // keep watch on undefined items\n            var watcher = this._selectedKeySetter = Async_defaultExport.observe(function () { return recurse(_this.items); })\n                .subscribe(function (didSelect) {\n                if (didSelect || !hasUndefined) {\n                    // clear observable, do not keep looking\n                    watcher.clear();\n                }\n                else if (!didSelect) {\n                    // keep looking until another item has been selected\n                    hasUndefined = false;\n                    _this.SelectionChange.connectOnce(function () {\n                        watcher.clear();\n                    });\n                }\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Append a tree list block to this list */\n    TreeList.prototype.appendChild = function (block) {\n        this.items.push(block);\n        return this;\n    };\n    /** Returns an array of directly contained components (observable); i.e. a flattened list of all _visible_ tree list items */\n    TreeList.prototype.getChildren = function () {\n        return this._flattened ? this._flattened.slice() : [];\n    };\n    TreeList___decorate([\n        ComponentFactory_ComponentFactory.applyComponentsArray(ComponentFactory_ComponentFactory.CLevel.Block),\n        Async_defaultExport.observable_not_null\n    ], TreeList.prototype, \"items\", void 0);\n    TreeList = TreeList_1 = TreeList___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.Block)\n    ], TreeList);\n    return TreeList;\n    var TreeList_1;\n}(Block_Block));\n\n(function (TreeList) {\n    /** Signal that is emitted when a tree list selection event occurs */\n    var SelectionSignal = (function (_super) {\n        TreeList___extends(SelectionSignal, _super);\n        function SelectionSignal() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return SelectionSignal;\n    }(ComponentSignal));\n    TreeList.SelectionSignal = SelectionSignal;\n    /** Signal that is emitted when a tree list item is collapsed or expanded */\n    var FoldSignal = (function (_super) {\n        TreeList___extends(FoldSignal, _super);\n        function FoldSignal() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return FoldSignal;\n    }(ComponentSignal));\n    TreeList.FoldSignal = FoldSignal;\n})(TreeList_TreeList || (TreeList_TreeList = {}));\n/** Constructor for a tree list selection event handler */\nvar TreeListSelectionHandler = (function (_super) {\n    TreeList___extends(TreeListSelectionHandler, _super);\n    function TreeListSelectionHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return TreeListSelectionHandler;\n}(ComponentSignalHandler));\n\n/** Constructor for a tree list fold (collapse/expand) event handler */\nvar TreeListFoldHandler = (function (_super) {\n    TreeList___extends(TreeListFoldHandler, _super);\n    function TreeListFoldHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return TreeListFoldHandler;\n}(ComponentSignalHandler));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/Row.js\nvar Row___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Row___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents a row containing control elements placed horizontally */\nvar Row_Row = (function (_super) {\n    Row___extends(Row, _super);\n    /** Create a row block with given content, if any */\n    function Row(content) {\n        if (content === void 0) { content = []; }\n        var _this = _super.call(this) || this;\n        _this.content = content;\n        return _this;\n    }\n    /** Append a control element to this row */\n    Row.prototype.appendChild = function (controlElement) {\n        this.content.push(controlElement);\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    Row.prototype.getChildren = function () {\n        return this.content.filter(function (c) { return (c instanceof Component_Component); });\n    };\n    Row___decorate([\n        ComponentFactory_ComponentFactory.applyComponentsArray(ComponentFactory_ComponentFactory.CLevel.ControlElement),\n        Async_defaultExport.observable_not_null\n    ], Row.prototype, \"content\", void 0);\n    Row___decorate([\n        Async_defaultExport.observable_string\n    ], Row.prototype, \"spacing\", void 0);\n    Row___decorate([\n        Async_defaultExport.observable_string\n    ], Row.prototype, \"verticalSpacing\", void 0);\n    Row___decorate([\n        Async_defaultExport.observable\n    ], Row.prototype, \"horzAlign\", void 0);\n    Row = Row___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.ControlElement)\n    ], Row);\n    return Row;\n}(Block_Block));\n\n/** Represents a row containing control elements placed horizontally, with spacing set to `0` (no margin) */\nvar CloseRow = (function (_super) {\n    Row___extends(CloseRow, _super);\n    function CloseRow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.spacing = \"0\";\n        _this.verticalSpacing = \"0\";\n        return _this;\n    }\n    return CloseRow;\n}(Row_Row));\n\n/** A row element with components aligned to the opposite side (\"end\" alignment, i.e. right-aligned for left-to-right languages) */\nvar OppositeRow = (function (_super) {\n    Row___extends(OppositeRow, _super);\n    function OppositeRow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Horizontal positioning of content within the outer boundaries of the row (observed), set to \"end\" for `OppositeRow` instances */\n        _this.horzAlign = \"end\";\n        return _this;\n    }\n    return OppositeRow;\n}(Row_Row));\n\n/** A row element with components aligned in the center */\nvar CenterRow = (function (_super) {\n    Row___extends(CenterRow, _super);\n    function CenterRow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Horizontal positioning of content within the outer boundaries of the row (observed), set to \"center\" for `CenterRow` instances */\n        _this.horzAlign = \"center\";\n        return _this;\n    }\n    return CenterRow;\n}(Row_Row));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/TreeListRow.js\nvar TreeListRow___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar TreeListRow___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents a tree list row, with an optional list of sub rows; implements the `TreeList.BlockItem` interface */\nvar TreeListRow_TreeListRow = (function (_super) {\n    TreeListRow___extends(TreeListRow, _super);\n    /** Creates a new tree list row for given item data, with given open/closed icon names and measurements; set the `batchSize` argument to a value greater than 0 to create child rows in batches for faster initial rendering */\n    function TreeListRow(itemData, openIcon, closedIcon, remGutter, height, batchSize) {\n        if (remGutter === void 0) { remGutter = TreeListRow.REM_GUTTER; }\n        if (height === void 0) { height = TreeListRow.HEIGHT; }\n        var _this = _super.call(this) || this;\n        /** True if this row is collapsed (defaults to true; observable) */\n        _this.collapsed = true;\n        if (!itemData)\n            throw new Error();\n        _this.itemData = itemData;\n        _this.openIcon = openIcon;\n        _this.closedIcon = closedIcon;\n        _this.remGutter = remGutter;\n        _this.height = height;\n        if (itemData.autoExpand)\n            _this.collapsed = false;\n        // populate list and content with observables\n        _this.treeListItems = _this._getTreeListItems(batchSize);\n        _this.initializeWith({\n            content: Async_defaultExport.observe(function () { return _this._getContentSpec(); })\n        });\n        // add event handlers\n        _this.Clicked.connect(function () {\n            // open on click (outside toggle icon)\n            if (_this.collapsed && _this.itemData && _this.itemData.items)\n                _this.collapsed = false;\n        });\n        _this.ArrowLeftKeyPressed.connect(function () {\n            // on left arrow press, close and then move up\n            if (_this.collapsed && _this.treeListRowParent &&\n                _this.treeListRowParent.focusMode !== Component_Component.FocusMode.None)\n                _this.treeListRowParent.hasFocus = true;\n            else\n                _this.collapsed = true;\n        });\n        _this.ArrowRightKeyPressed.connect(function () {\n            // on right arrow press, open and then move down\n            if (_this.collapsed) {\n                if (_this.itemData && _this.itemData.items)\n                    _this.collapsed = false;\n            }\n            else if (_this.treeListItems.length > 0 &&\n                _this.treeListItems[0].focusMode !== Component_Component.FocusMode.None) {\n                _this.treeListItems[0].hasFocus = true;\n            }\n        });\n        return _this;\n    }\n    /** Create an _array_ of tree list row components from the given array of tree item data objects, with given icons and measurements */\n    TreeListRow.arrayFromItems = function (itemData, openIcon, closedIcon, remGutter, height) {\n        return itemData.map(function (item) {\n            return new TreeListRow(item, openIcon, closedIcon, remGutter, height);\n        });\n    };\n    /** Create a new `ArrayBinding` for given property name/path on the base component, which should contain an array of unique tree item data objects; the binding resolves to an observable array of `TreeListRow` instances; for use in a component initializer; set the `batchSize` argument to a value greater than 0 to create rows in batches for faster initial rendering */\n    TreeListRow.arrayFromBinding = function (sourcePath, openIcon, closedIcon, remGutter, height, batchSize) {\n        var f = function (v) { return new TreeListRow(v, openIcon, closedIcon, remGutter, height, batchSize); };\n        return new Binding_ArrayBinding(sourcePath, undefined, _getBatchTransformer(f, batchSize), true);\n    };\n    Object.defineProperty(TreeListRow.prototype, \"key\", {\n        /** Item key for this row (read-only, taken directly from the `itemData` object; observable) */\n        get: function () {\n            return this.itemData ? this.itemData.key : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Generate the content factory initializer spec for this row (used as an observable getter) */\n    TreeListRow.prototype._getContentSpec = function () {\n        var _this = this;\n        if (!this.itemData)\n            return [];\n        // figure out the indentation of this row\n        if (!this._indent) {\n            this._indent = 1;\n            var parent = this.treeListRowParent;\n            while (parent) {\n                if (parent._indent) {\n                    this._indent += parent._indent;\n                    break;\n                }\n                this._indent++;\n                parent = parent.treeListRowParent;\n            }\n        }\n        // get all observable values first\n        var items = this.itemData.items;\n        var remGutter = this.remGutter;\n        var icon = this.itemData.icon, name = this.itemData.name;\n        var content = this.itemData.content;\n        // return a full factory initializer spec\n        return Async_defaultExport.unobserved(function () {\n            // insert a spacer of the correct width, and the icons\n            var result = _this._contentSpec || (_this._contentSpec = []);\n            result.length = 0;\n            var indent = _this._indent || 1;\n            indent = indent - (indent * .5) + (items ? 0 : 1);\n            var spacer = _this._contentSpecSpacer || new Spacer();\n            spacer.width = (indent * remGutter).toFixed(4) + \"rem\";\n            spacer.shrinkwrap = true;\n            result.push(spacer);\n            _this._contentSpecSpacer = spacer;\n            if (items) {\n                var toggle = _this._contentSpecToggleIcon || new Icon_Icon();\n                toggle.icon = Async_defaultExport.observe(function () {\n                    return (_this.collapsed ? _this.closedIcon : _this.openIcon);\n                });\n                toggle.width = remGutter + \"rem\";\n                result.push(toggle);\n                if (!_this._contentSpecToggleIcon) {\n                    _this._contentSpecToggleIcon = toggle;\n                    toggle.Clicked.connect(function () {\n                        _this.collapsed = !_this.collapsed;\n                    });\n                }\n            }\n            if (icon) {\n                result.push(Icon_Icon.with({ icon: icon, width: remGutter + \"rem\" }));\n            }\n            // add further content, or just a label with the item name\n            if (content) {\n                // join with content initializer spec array\n                result.push.apply(result, content);\n            }\n            else if (name !== undefined) {\n                // use a WideLabel instance\n                var label = _this._contentSpecLabel || new WideLabel();\n                label.text = name;\n                result.push(label);\n                _this._contentSpecLabel = label;\n            }\n            return result;\n        });\n    };\n    /** Generate the observable array that contains `TreeListRow` instances for child items */\n    TreeListRow.prototype._getTreeListItems = function (batchSize) {\n        var _this = this;\n        var f = _getBatchTransformer(function (item) {\n            var row = new TreeListRow(item, _this.openIcon, _this.closedIcon, _this.remGutter, _this.height, batchSize);\n            row.treeListRowParent = _this;\n            return row;\n        }, batchSize);\n        return Async_defaultExport.observeArray(function () { return _this.itemData && _this.itemData.items; })\n            .mapAsyncValues(function (v) {\n            // transform item data to a row (or observe the resulting promise)\n            var row = f(v);\n            return row.then ? Async_defaultExport.observe(row) : row;\n        });\n    };\n    /** Default height for new instances (CSS length, initially 1.75em) */\n    TreeListRow.HEIGHT = \"1.75em\";\n    /** Default gutter width for new instances (CSS length in rem units, initially 1.5) */\n    TreeListRow.REM_GUTTER = 1.5;\n    TreeListRow___decorate([\n        Async_defaultExport.observable_shallow\n    ], TreeListRow.prototype, \"itemData\", void 0);\n    TreeListRow___decorate([\n        Async_defaultExport.observable\n    ], TreeListRow.prototype, \"remGutter\", void 0);\n    TreeListRow___decorate([\n        Async_defaultExport.observable_string\n    ], TreeListRow.prototype, \"openIcon\", void 0);\n    TreeListRow___decorate([\n        Async_defaultExport.observable_string\n    ], TreeListRow.prototype, \"closedIcon\", void 0);\n    TreeListRow___decorate([\n        Async_defaultExport.observable\n    ], TreeListRow.prototype, \"collapsed\", void 0);\n    return TreeListRow;\n}(CloseRow));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/NavList.js\nvar NavList___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar NavList___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n/** Represents a list of tabs or links */\nvar NavList_NavList = (function (_super) {\n    NavList___extends(NavList, _super);\n    /** Create a navigation list component */\n    function NavList(navItems, type, selectedIndex) {\n        if (navItems === void 0) { navItems = []; }\n        if (selectedIndex === void 0) { selectedIndex = -1; }\n        var _this = _super.call(this) || this;\n        /** Type of nav: tabs or pills, inline or stacked; default tabs (observed) */\n        _this.type = NavList.Type.Tabs;\n        /** Signal emitted when the selected nav item changes, while displayed on screen */\n        _this.NavChange = _this.createComponentSignal(NavList.SelectionSignal);\n        /** Container block that contains the container for currently selected item, if any */\n        _this._containerBlock = new ContainerBlock_ContainerBlock();\n        /** Activation instance, with injected methods */\n        _this._activation = new NavList.Activation();\n        _this.navItems = navItems;\n        if (type !== undefined)\n            _this.type = type;\n        _this.selectedIndex = selectedIndex;\n        return _this;\n    }\n    /** Method that is called immediately after the renderer for this component is constructed; adds observers for nav item selection */\n    NavList.prototype.beforeFirstRender = function (renderer) {\n        var _this = this;\n        _super.prototype.beforeFirstRender.call(this, renderer);\n        // watch for changes to selected item\n        renderer.watch(function () {\n            var index = _this.selectedIndex;\n            var item = (index >= 0 && index < _this.navItems.length) ?\n                _this.navItems[index] : undefined;\n            // find (or possibly create) container\n            var container = item && item.container;\n            if (container &&\n                container.isComponentFactory) {\n                // keep current container if possible, otherwise create\n                container =\n                    (container.componentFactoryId ===\n                        _this._factoryUID) ?\n                        _this._containerBlock.container :\n                        Async_defaultExport.unobserved(function () { return new container(); });\n                _this._factoryUID =\n                    container.componentFactoryId;\n            }\n            else {\n                // reset stored factory UID if not created from factory\n                _this._factoryUID = undefined;\n            }\n            return {\n                index: item ? index : -1,\n                key: item && item.key,\n                container: container\n            };\n        }, function (change) {\n            // set current container as container block content\n            _this._containerBlock.container = change.container;\n            // emit change signal\n            _this.NavChange(change);\n        });\n        // watch for targets activated externally (e.g. URL, activities)\n        renderer.watch(function () {\n            var selectedIndex = _this.selectedIndex;\n            _this.navItems.forEach(function (item, index) {\n                if (index !== selectedIndex &&\n                    _this._activation.isActive(item.target)) {\n                    // select item activated externally\n                    Async_defaultExport.unobserved(function () {\n                        _this.selectedIndex = index;\n                    });\n                }\n            });\n        });\n    };\n    Object.defineProperty(NavList.prototype, \"selectedIndex\", {\n        /** Index of selected nav item (base 0), or -1 if no selection (observed); does not automatically activate nav item targets; to do so, use the `.activate(...)` function instead */\n        get: function () {\n            // return last selected index (manually, async from beforeFirstRender,\n            // or return the observable value given to setter below)\n            return this.selectedIndex;\n        },\n        set: function (i) {\n            var value;\n            if ((i instanceof Async_defaultExport.ObservableValue)) {\n                this._observableSelectedIndex = i;\n                this.selectedIndex = i;\n            }\n            else {\n                // use -1 for any other invalid value\n                if (i < 0 || i >= this.navItems.length || !this.navItems[i])\n                    i = -1;\n                // update underlying value or set observable value\n                if (this._observableSelectedIndex) {\n                    if (this._observableSelectedIndex.writable)\n                        this._observableSelectedIndex.value = i;\n                }\n                else {\n                    // no observable bound, just set own value\n                    this.selectedIndex = i;\n                }\n                value = i;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NavList.prototype, \"selectedKey\", {\n        /** Key (string value) of selected item, if any (read-only, observable) */\n        get: function () {\n            // find selected item and return its key, if any\n            var index = this.selectedIndex;\n            var item = (index >= 0 && index < this.navItems.length) ?\n                this.navItems[index] : undefined;\n            return item ? item.key : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Select nav item by index or key, display associated container if any, and/or start associated activity if any; returns this */\n    NavList.prototype.activate = function (selection) {\n        var index = (typeof selection === \"string\") ?\n            this.navItems.reduce(function (v, item, i) {\n                return item.key == selection ? i : v;\n            }, -1) :\n            selection;\n        var item = (index >= 0 && index < this.navItems.length) ?\n            this.navItems[index] : undefined;\n        if (!item) {\n            // no active selection\n            this.selectedIndex = -1;\n        }\n        else {\n            // set selected index\n            this.selectedIndex = index;\n            // activate item using Application instance\n            if (item.target)\n                this._activation.activate(item.target);\n        }\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    NavList.prototype.getChildren = function () {\n        return this._containerBlock.container ? [this._containerBlock] : [];\n    };\n    NavList___decorate([\n        Async_defaultExport.observable_not_null\n    ], NavList.prototype, \"navItems\", void 0);\n    NavList___decorate([\n        Async_defaultExport.observable\n    ], NavList.prototype, \"remGutter\", void 0);\n    NavList___decorate([\n        ComponentFactory_ComponentFactory.applyAsync,\n        Async_defaultExport.observable\n    ], NavList.prototype, \"selectedIndex\", null);\n    NavList___decorate([\n        Async_defaultExport.observable\n    ], NavList.prototype, \"type\", void 0);\n    NavList___decorate([\n        Async_defaultExport.observable\n    ], NavList.prototype, \"justified\", void 0);\n    NavList___decorate([\n        ComponentFactory_ComponentFactory.applyAsync,\n        ComponentFactory_ComponentFactory.setterFor(\"activate\")\n    ], NavList.prototype, \"activate\", null);\n    return NavList;\n}(Block_Block));\n\n(function (NavList) {\n    /** Contains injectable methods for activating targets and querying activation state; instantiated by `NavList` */\n    var Activation = (function () {\n        function Activation() {\n        }\n        /** Injectable method to activate given target (e.g. URL, or Activity instance or class); default ony handles URLs, `Application` instance injects more functionality here */\n        Activation.prototype.activate = function (target) { };\n        /** Injectable method that returns true (observable) if and when given target matches the current target, i.e. URL/path matches, or activity/class matches current activity or one of its parent activities; this method is called from within an observable context to be able to observe changes to target states */\n        Activation.prototype.isActive = function (target) { return false; };\n        NavList___decorate([\n            Async_defaultExport.injectable\n        ], Activation.prototype, \"activate\", null);\n        NavList___decorate([\n            Async_defaultExport.injectable\n        ], Activation.prototype, \"isActive\", null);\n        return Activation;\n    }());\n    NavList.Activation = Activation;\n    ;\n    /** NavList display type */\n    var Type;\n    (function (Type) {\n        /** Display as a row of tabs */\n        Type[Type[\"Tabs\"] = 0] = \"Tabs\";\n        /** Display as a row of pills */\n        Type[Type[\"Pills\"] = 1] = \"Pills\";\n        /** Display as a list of pills */\n        Type[Type[\"StackedPills\"] = 2] = \"StackedPills\";\n    })(Type = NavList.Type || (NavList.Type = {}));\n    ;\n    /** Signal that is emitted when a navlist's selection changes */\n    var SelectionSignal = (function (_super) {\n        NavList___extends(SelectionSignal, _super);\n        function SelectionSignal() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return SelectionSignal;\n    }(ComponentSignal));\n    NavList.SelectionSignal = SelectionSignal;\n})(NavList_NavList || (NavList_NavList = {}));\n/** Constructor for a navlist selection event handler */\nvar NavListSelectionHandler = (function (_super) {\n    NavList___extends(NavListSelectionHandler, _super);\n    function NavListSelectionHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return NavListSelectionHandler;\n}(ComponentSignalHandler));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/TableRow.js\nvar TableRow___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar TableRow___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents a row within a `Table` component */\nvar TableRow_TableRow = (function (_super) {\n    TableRow___extends(TableRow, _super);\n    /** Create a table row with given columns, if any */\n    function TableRow(columns, widths, styles) {\n        if (columns === void 0) { columns = []; }\n        if (widths === void 0) { widths = []; }\n        if (styles === void 0) { styles = []; }\n        var _this = _super.call(this) || this;\n        /** Row index (base 0) the last time this row was rendered, or -1 (observable) */\n        _this.rowIndex = -1;\n        _this.columns = columns;\n        _this.widths = widths;\n        _this.styles = styles;\n        return _this;\n    }\n    /** Append a table cell to this row */\n    TableRow.prototype.appendChild = function (cell) {\n        this.columns.push(cell);\n        return this;\n    };\n    /** Returns an array of directly contained components */\n    TableRow.prototype.getChildren = function () {\n        return this.columns.filter(function (v) { return (v instanceof Component_Component); });\n    };\n    TableRow___decorate([\n        ComponentFactory_ComponentFactory.applyComponentsArray(ComponentFactory_ComponentFactory.CLevel.ControlElement),\n        Async_defaultExport.observable_not_null\n    ], TableRow.prototype, \"columns\", void 0);\n    TableRow___decorate([\n        Async_defaultExport.observable_not_null\n    ], TableRow.prototype, \"widths\", void 0);\n    TableRow___decorate([\n        Async_defaultExport.observable_not_null\n    ], TableRow.prototype, \"styles\", void 0);\n    TableRow___decorate([\n        Async_defaultExport.observable\n    ], TableRow.prototype, \"rowIndex\", void 0);\n    return TableRow;\n}(Block_Block));\n\n/** A table header at the top of a table */\nvar TableRow_TableHeader = (function (_super) {\n    TableRow___extends(TableHeader, _super);\n    function TableHeader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Automatic selection management mode: table header rows are not selectable */\n        _this.selectionMode = Component_Component.SelectionMode.None;\n        /** Automatic focus management mode: table header rows are not focusable */\n        _this.focusMode = Component_Component.FocusMode.None;\n        return _this;\n        // implemented by platform specific renderer\n    }\n    return TableHeader;\n}(TableRow_TableRow));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Blocks/Table.js\nvar Table___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Table___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n/** Represents a table block component */\nvar Table_Table = (function (_super) {\n    Table___extends(Table, _super);\n    /** Create a table with given header and rows, if any */\n    function Table(headerColumns, widths, rows) {\n        if (rows === void 0) { rows = []; }\n        var _this = _super.call(this) || this;\n        _this.header = new TableRow_TableHeader(headerColumns, widths);\n        _this.rows = rows;\n        return _this;\n    }\n    /** Append a row to this table */\n    Table.prototype.appendChild = function (tableRow) {\n        this.rows.push(tableRow);\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    Table.prototype.getChildren = function () {\n        var results = this.rows.filter(function (c) { return (c instanceof Component_Component); });\n        if (this.header)\n            results.unshift(this.header);\n        return results;\n    };\n    /** Returns an object containing all current values of input elements (observable) */\n    Table.prototype.getFormValues = function (result) {\n        if (result === void 0) { result = {}; }\n        if (this.name)\n            result[this.name] = this.rows\n                .mapAsyncValues(function (item) { return Async_defaultExport.observe(function () { return item.getFormValues(); }); });\n        else\n            _super.prototype.getFormValues.call(this, result);\n        return result;\n    };\n    /** Set all input values by element name */\n    Table.prototype.setFormValues = function (values) {\n        var _this = this;\n        if (this.name && values && values[this.name]) {\n            this.rows.forEach(function (row, i) {\n                row && row.setFormValues(values[_this.name][i]);\n            });\n        }\n        else\n            _super.prototype.setFormValues.call(this, values);\n    };\n    Table___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.TableHeader),\n        Async_defaultExport.observable\n    ], Table.prototype, \"header\", void 0);\n    Table___decorate([\n        ComponentFactory_ComponentFactory.applyComponentsArray(ComponentFactory_ComponentFactory.CLevel.TableRow),\n        Async_defaultExport.observable_not_null\n    ], Table.prototype, \"rows\", void 0);\n    Table___decorate([\n        Async_defaultExport.observable\n    ], Table.prototype, \"name\", void 0);\n    Table = Table___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.TableRow)\n    ], Table);\n    return Table;\n}(Block_Block));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/BlockControl.js\nvar BlockControl___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar BlockControl___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents a control element that contains a block */\nvar BlockControl_BlockControl = (function (_super) {\n    BlockControl___extends(BlockControl, _super);\n    /** Create a new block control element containing the given block, if any */\n    function BlockControl(block) {\n        var _this = _super.call(this) || this;\n        _this.block = block;\n        // apply automatic width to start with\n        _this.style.set(\"width\", Async_defaultExport.observe(function () { return _this.width; }));\n        return _this;\n    }\n    Object.defineProperty(BlockControl.prototype, \"width\", {\n        /** Overall target width of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be \"auto\"); if a width has not been set explicitly, or is set to \"auto\", then the value is taken from the width of the container */\n        get: function () {\n            // while no width set, observe container width\n            return this.width ||\n                this.block && this.block.width ||\n                \"auto\";\n        },\n        set: function (w) {\n            var _this = this;\n            if (w === \"auto\")\n                w = \"\";\n            this.style.set(\"width\", w ? w : Async_defaultExport.observe(function () { return _this.width; }));\n            this.width = w;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Set the block for this component (overwrites existing value, if any); returns this */\n    BlockControl.prototype.appendChild = function (c) {\n        this.block = c;\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    BlockControl.prototype.getChildren = function () {\n        return (this.block instanceof Component_Component) ?\n            [this.block] : [];\n    };\n    BlockControl___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Block),\n        Async_defaultExport.observable\n    ], BlockControl.prototype, \"block\", void 0);\n    BlockControl___decorate([\n        Async_defaultExport.observable\n    ], BlockControl.prototype, \"width\", null);\n    BlockControl = BlockControl___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.Block)\n    ], BlockControl);\n    return BlockControl;\n}(ControlElement_ControlElement));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/ButtonGroup.js\nvar ButtonGroup___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ButtonGroup___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents a button group (toggle, tab, or toolbar) control */\nvar ButtonGroup_ButtonGroup = (function (_super) {\n    ButtonGroup___extends(ButtonGroup, _super);\n    /** Create a button group element */\n    function ButtonGroup(buttons) {\n        if (buttons === void 0) { buttons = []; }\n        var _this = _super.call(this) || this;\n        /** Set to false to expand horizontally within row (observed) */\n        _this.shrinkwrap = true;\n        _this.buttons = buttons;\n        return _this;\n    }\n    /** Method that is called immediately after the renderer for this button group is constructed; adds observers for button activation */\n    ButtonGroup.prototype.beforeFirstRender = function (renderer) {\n        var _this = this;\n        _super.prototype.beforeFirstRender.call(this, renderer);\n        renderer.watch(function () { return _this.getLastSelectedChild(); }, function (button) {\n            _this.selectedIndex = button ?\n                _this.buttons.indexOf(button) : -1;\n        });\n        renderer.watch(function () { return _this.selectedIndex; }, function (i) {\n            if (_this.selectedIndex === i && _this.buttons[i])\n                _this.buttons[i].selected = true;\n            else\n                _this.buttons.forEach(function (b) { return b && (b.selected = false); });\n        });\n    };\n    Object.defineProperty(ButtonGroup.prototype, \"selectedIndex\", {\n        /** Currently selected button index (base 0) or -1 if no selection (observed) */\n        get: function () {\n            // return last selected index (manually, async from beforeFirstRender,\n            // or return the observable value given to setter below)\n            return this.selectedIndex;\n        },\n        set: function (i) {\n            var value;\n            if ((i instanceof Async_defaultExport.ObservableValue)) {\n                this._observableSelectedIndex = i;\n                this.selectedIndex = i;\n                value = i.value;\n                if (value === undefined)\n                    return;\n            }\n            else {\n                // update underlying value or set observable value\n                if (this._observableSelectedIndex) {\n                    if (this._observableSelectedIndex.writable)\n                        this._observableSelectedIndex.value = i;\n                }\n                else {\n                    // no observable bound, just set own value\n                    this.selectedIndex = i;\n                }\n                value = i;\n            }\n            // use -1 for any other invalid value\n            if (value < 0 || value >= this.buttons.length || !this.buttons[value])\n                value = -1;\n            // select given button synchronously\n            var button = value >= 0 ? this.buttons[value] : undefined;\n            if (button)\n                button.selected = true;\n            // check if need to deselect others (do not wait for async)\n            if (this.selectionMode === Component_Component.SelectionMode.ItemClick ||\n                this.selectionMode === Component_Component.SelectionMode.ItemFocus) {\n                for (var j = this.buttons.length - 1; j >= 0; j--)\n                    if (this.buttons[j] && this.buttons[j] !== button)\n                        this.buttons[j].selected = false;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Append a button to this group; returns this */\n    ButtonGroup.prototype.appendChild = function (button) {\n        this.buttons.push(button);\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    ButtonGroup.prototype.getChildren = function () {\n        return this.buttons.filter(function (b) { return (b instanceof Component_Component); });\n    };\n    ButtonGroup___decorate([\n        ComponentFactory_ComponentFactory.applyComponentsArray(ComponentFactory_ComponentFactory.CLevel.ControlElement),\n        Async_defaultExport.observable_not_null\n    ], ButtonGroup.prototype, \"buttons\", void 0);\n    ButtonGroup___decorate([\n        Async_defaultExport.observable\n    ], ButtonGroup.prototype, \"vertical\", void 0);\n    ButtonGroup___decorate([\n        ComponentFactory_ComponentFactory.applyAsync,\n        Async_defaultExport.observable\n    ], ButtonGroup.prototype, \"selectedIndex\", null);\n    ButtonGroup = ButtonGroup___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.ControlElement)\n    ], ButtonGroup);\n    return ButtonGroup;\n}(ControlElement_ControlElement));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/ContainerControl.js\nvar ContainerControl___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ContainerControl___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n/** Represents a control element that contains a container */\nvar ContainerControl_ContainerControl = (function (_super) {\n    ContainerControl___extends(ContainerControl, _super);\n    /** Create a container control element that contains the given container, if any */\n    function ContainerControl(container) {\n        var _this = _super.call(this) || this;\n        if (container)\n            _this.container = container;\n        // apply automatic height and width to start with\n        _this.style.set(\"height\", Async_defaultExport.observe(function () { return _this.height; }));\n        _this.style.set(\"width\", Async_defaultExport.observe(function () { return _this.width; }));\n        return _this;\n    }\n    Object.defineProperty(ContainerControl.prototype, \"container\", {\n        /** Container element (created if not set, never undefined; observed); if set to a container (other than LayoutContainer) with maxContentWidth other than auto, and this control's width is set to auto, this control will shrinkwrap to the same width as the container */\n        get: function () {\n            // get underlying property or create a new container\n            return this.container || (this.container = Async_defaultExport.unobserved(function () { return new Container_Container(); }));\n        },\n        set: function (c) {\n            // set underlying property\n            this.container = c;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ContainerControl.prototype, \"height\", {\n        /** Overall target height of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be \"auto\"); if a height has not been set explicitly, or is set to \"auto\", then the value is taken from the height of the container; for `LayoutContainer`, a value of \"100%\" is used if the container's height is also \"auto\" */\n        get: function () {\n            var result = this.height;\n            if (!result) {\n                // while no height set, observe container height and type\n                result = this.container && this.container.height || \"auto\";\n                if ((this.container instanceof LayoutContainer_LayoutContainer) &&\n                    result === \"auto\")\n                    result = \"100%\";\n            }\n            return result;\n        },\n        set: function (h) {\n            var _this = this;\n            if (h === \"auto\")\n                h = \"\";\n            this.style.set(\"height\", h ? h : Async_defaultExport.observe(function () { return _this.height; }));\n            this.height = h;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ContainerControl.prototype, \"width\", {\n        /** Overall target width of this component (CSS length; observable, directly modifies `.style` property, does _not_ retrieve actual component height, may be \"auto\"); if a width has not been set explicitly, or is set to \"auto\", then the value is taken from the width of the container */\n        get: function () {\n            // while no width set, observe container width\n            return this.width ||\n                this.container && this.container.width ||\n                \"auto\";\n        },\n        set: function (w) {\n            var _this = this;\n            if (w === \"auto\")\n                w = \"\";\n            this.style.set(\"width\", w ? w : Async_defaultExport.observe(function () { return _this.width; }));\n            this.width = w;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Set the container for this component (overwrites existing value, if any); returns this */\n    ContainerControl.prototype.appendChild = function (c) {\n        this.container = c;\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    ContainerControl.prototype.getChildren = function () {\n        return (this.container instanceof Component_Component) ?\n            [this.container] : [];\n    };\n    ContainerControl___decorate([\n        ComponentFactory_ComponentFactory.applyComponentRef(ComponentFactory_ComponentFactory.CLevel.Container),\n        Async_defaultExport.observable\n    ], ContainerControl.prototype, \"container\", null);\n    ContainerControl___decorate([\n        Async_defaultExport.observable\n    ], ContainerControl.prototype, \"height\", null);\n    ContainerControl___decorate([\n        Async_defaultExport.observable\n    ], ContainerControl.prototype, \"width\", null);\n    ContainerControl = ContainerControl___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.Container)\n    ], ContainerControl);\n    return ContainerControl;\n}(ControlElement_ControlElement));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/ControlStack.js\nvar ControlStack___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ControlStack___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents a stack control containing control elements with equal widths placed from top to bottom */\nvar ControlStack_ControlStack = (function (_super) {\n    ControlStack___extends(ControlStack, _super);\n    /** Create a stack element with given content, if any */\n    function ControlStack(content) {\n        if (content === void 0) { content = []; }\n        var _this = _super.call(this) || this;\n        /** Set to true to shrink this component horizontally such that it occupies as little space as possible; set to false to expand horizontally within row (observed); note that shrinkwrapping a control stack with non-shrinkwrapped controls may lead to unexpected results; by default, this component observes child components and is only shrinkwrapped if all child components are shrinkwrapped */\n        _this.shrinkwrap = Async_defaultExport.observe(function () { return _this.getChildren()\n            .every(function (c) { return ((c instanceof ControlElement_ControlElement) && c.shrinkwrap); }); });\n        _this.content = content;\n        return _this;\n    }\n    /** Append a control to this stack; returns this */\n    ControlStack.prototype.appendChild = function (control) {\n        this.content.push(control);\n        return this;\n    };\n    /** Returns an array of directly contained components (observable) */\n    ControlStack.prototype.getChildren = function () {\n        return this.content.filter(function (c) { return (c instanceof Component_Component); });\n    };\n    ControlStack___decorate([\n        ComponentFactory_ComponentFactory.applyComponentsArray(ComponentFactory_ComponentFactory.CLevel.ControlElement),\n        Async_defaultExport.observable_not_null\n    ], ControlStack.prototype, \"content\", void 0);\n    ControlStack___decorate([\n        Async_defaultExport.observable_string\n    ], ControlStack.prototype, \"spacing\", void 0);\n    ControlStack___decorate([\n        Async_defaultExport.observable\n    ], ControlStack.prototype, \"horzAlign\", void 0);\n    ControlStack = ControlStack___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.ControlElement)\n    ], ControlStack);\n    return ControlStack;\n}(ControlElement_ControlElement));\n\n/** Represents a stack containing control elements with equal width placed from top to bottom, with spacing set to 0 (no margin) */\nvar CloseControlStack = (function (_super) {\n    ControlStack___extends(CloseControlStack, _super);\n    function CloseControlStack() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.spacing = \"0\";\n        return _this;\n    }\n    return CloseControlStack;\n}(ControlStack_ControlStack));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/Icon.js\nvar Icon___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Icon___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n/** Represents an icon control (horizontally centered) */\nvar Icon_Icon = (function (_super) {\n    Icon___extends(Icon, _super);\n    /** Create an icon element */\n    function Icon(icon) {\n        var _this = _super.call(this) || this;\n        /** Set to false to expand horizontally within row (observed) */\n        _this.shrinkwrap = true;\n        _this.icon = icon || \"\";\n        return _this;\n    }\n    /** Initialize an icon control with given icon name */\n    Icon.withIcon = function (icon) {\n        return this.with({ icon: icon });\n    };\n    Icon___decorate([\n        Async_defaultExport.observable_string\n    ], Icon.prototype, \"icon\", void 0);\n    Icon___decorate([\n        Async_defaultExport.observable_string\n    ], Icon.prototype, \"tooltipText\", void 0);\n    return Icon;\n}(ControlElement_ControlElement));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/Image.js\nvar Image___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Image___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Represents an image control */\nvar Image_Image = (function (_super) {\n    Image___extends(Image, _super);\n    /** Create an image element */\n    function Image(imageUrl) {\n        if (imageUrl === void 0) { imageUrl = \"\"; }\n        var _this = _super.call(this) || this;\n        /** Set to false to expand horizontally within row (observed) */\n        _this.shrinkwrap = true;\n        /** Encapsulation of image element style (observed) */\n        _this.style_img = new Style_Style();\n        /** True if a load error occurred (observable) */\n        _this.hasError = false;\n        /** Promise that resolves when the image is loaded, or if an error occurred (see .hasError) */\n        _this.ready = new Async_defaultExport.Promise(function (resolve) {\n            _this.resolveReady = resolve;\n        });\n        _this.imageUrl = imageUrl;\n        return _this;\n    }\n    /** Initialize an image control with given URL */\n    Image.withUrl = function (imageUrl) {\n        return this.with({ imageUrl: imageUrl });\n    };\n    Image___decorate([\n        Async_defaultExport.observable_string\n    ], Image.prototype, \"imageUrl\", void 0);\n    Image___decorate([\n        Async_defaultExport.observable_string\n    ], Image.prototype, \"tooltipText\", void 0);\n    Image___decorate([\n        Async_defaultExport.observable_not_null\n    ], Image.prototype, \"style_img\", void 0);\n    Image___decorate([\n        Async_defaultExport.observable\n    ], Image.prototype, \"hasError\", void 0);\n    return Image;\n}(ControlElement_ControlElement));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/Label.js\nvar Label___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Label___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Represents a minimal text control with icon and badge */\nvar Label_Label = (function (_super) {\n    Label___extends(Label, _super);\n    /** Create a label element */\n    function Label(text, icon, remGutter, badge) {\n        if (text === void 0) { text = \"\"; }\n        var _this = _super.call(this) || this;\n        /** Set to false to expand horizontally within row (default true; observed) */\n        _this.shrinkwrap = true;\n        _this.text = text;\n        _this.icon = icon;\n        _this.badge = badge;\n        if (remGutter !== undefined)\n            _this.remGutter = remGutter;\n        // set focus mode so label is not focusable by default\n        _this.focusMode = Component_Component.FocusMode.None;\n        return _this;\n    }\n    /** Initialize a text control factory with given text and style */\n    Label.withText = function (text, style) {\n        return this.with({ text: text, style: style });\n    };\n    Label___decorate([\n        Async_defaultExport.observable_string\n    ], Label.prototype, \"text\", void 0);\n    Label___decorate([\n        Async_defaultExport.observable_string\n    ], Label.prototype, \"textBefore\", void 0);\n    Label___decorate([\n        Async_defaultExport.observable_string\n    ], Label.prototype, \"textAfter\", void 0);\n    Label___decorate([\n        Async_defaultExport.observable\n    ], Label.prototype, \"icon\", void 0);\n    Label___decorate([\n        Async_defaultExport.observable\n    ], Label.prototype, \"remGutter\", void 0);\n    Label___decorate([\n        Async_defaultExport.observable_string\n    ], Label.prototype, \"badge\", void 0);\n    Label___decorate([\n        Async_defaultExport.observable_string\n    ], Label.prototype, \"tooltipText\", void 0);\n    return Label;\n}(ControlElement_ControlElement));\n\n// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n/** Stretched label control: a label that expands horizontally, while not breaking across lines (uses ellipsis if available) */\nvar WideLabel = (function (_super) {\n    Label___extends(WideLabel, _super);\n    function WideLabel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Set to true to shrink horizontally (default false; observed) */\n        _this.shrinkwrap = false;\n        return _this;\n    }\n    return WideLabel;\n}(Label_Label));\n\n/** Paragraph control: a label that expands horizontally, with text that breaks automatically across lines, and added line spacing for enhanced readability */\nvar Paragraph = (function (_super) {\n    Label___extends(Paragraph, _super);\n    function Paragraph() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Set to true to shrink horizontally (default false; observed) */\n        _this.shrinkwrap = false;\n        /** Automatically break text across lines (default true, observed) */\n        _this.wrapText = true;\n        return _this;\n    }\n    return Paragraph;\n}(Label_Label));\n\n/** H1 label control */\nvar Heading1 = (function (_super) {\n    Label___extends(Heading1, _super);\n    function Heading1() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Heading1;\n}(Label_Label));\n\n/** H2 label control */\nvar Heading2 = (function (_super) {\n    Label___extends(Heading2, _super);\n    function Heading2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Heading2;\n}(Label_Label));\n\n/** H3 label control */\nvar Heading3 = (function (_super) {\n    Label___extends(Heading3, _super);\n    function Heading3() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Heading3;\n}(Label_Label));\n\n/** H4 label control */\nvar Heading4 = (function (_super) {\n    Label___extends(Heading4, _super);\n    function Heading4() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Heading4;\n}(Label_Label));\n\n/** H5 label control */\nvar Heading5 = (function (_super) {\n    Label___extends(Heading5, _super);\n    function Heading5() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Heading5;\n}(Label_Label));\n\n/** H6 label control */\nvar Heading6 = (function (_super) {\n    Label___extends(Heading6, _super);\n    function Heading6() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Heading6;\n}(Label_Label));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/ProgressBar.js\nvar ProgressBar___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar ProgressBar___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Represents a progress bar control (full width by default) */\nvar ProgressBar_ProgressBar = (function (_super) {\n    ProgressBar___extends(ProgressBar, _super);\n    /** Create a progress bar control element */\n    function ProgressBar(progress) {\n        if (progress === void 0) { progress = 0; }\n        var _this = _super.call(this) || this;\n        /** Encapsulation of inner bar style (observed) */\n        _this.style_bar = new Style_Style();\n        _this.progress = progress;\n        return _this;\n    }\n    /** Initialize a progress bar control factory with given progress value (0-1) */\n    ProgressBar.withProgress = function (progress) {\n        return this.with({ progress: progress });\n    };\n    ProgressBar___decorate([\n        Async_defaultExport.observable_number\n    ], ProgressBar.prototype, \"progress\", void 0);\n    ProgressBar___decorate([\n        Async_defaultExport.observable_string\n    ], ProgressBar.prototype, \"tooltipText\", void 0);\n    ProgressBar___decorate([\n        Async_defaultExport.observable_not_null\n    ], ProgressBar.prototype, \"style_bar\", void 0);\n    return ProgressBar;\n}(ControlElement_ControlElement));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/Spacer.js\nvar Spacer___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n/** Represents an empty control element to take up horizontal space within a row */\nvar Spacer = (function (_super) {\n    Spacer___extends(Spacer, _super);\n    /** Create a spacer element with given height (default 1px) */\n    function Spacer(height) {\n        if (height === void 0) { height = \"1px\"; }\n        var _this = _super.call(this) || this;\n        _this.height = height;\n        return _this;\n    }\n    /** Initialize a spacer control factory with given size (CSS lengths); also sets `.shrinkwrap` to true if a width is given */\n    Spacer.withSize = function (width, height) {\n        return this.with(width ?\n            { width: width, height: height, shrinkwrap: true } :\n            { height: height });\n    };\n    return Spacer;\n}(ControlElement_ControlElement));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/InputControls/InputControl.js\nvar InputControl___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar InputControl___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Input field control base class (abstract) */\nvar InputControl_InputControl = (function (_super) {\n    InputControl___extends(InputControl, _super);\n    function InputControl() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Encapsulation of label element style (observed) */\n        _this.style_label = new Style_Style();\n        /** Encapsulation of input element style (observed) */\n        _this.style_input = new Style_Style();\n        return _this;\n    }\n    Object.defineProperty(InputControl.prototype, \"ValueChange\", {\n        /** Signal emitted when the input value is committed (on change); captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"ValueChange\", ComponentSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(InputControl.prototype, \"ValueInput\", {\n        /** Signal emitted immediately before the input value changes (on input); captured from containers down to contained components, not consumed */\n        get: function () {\n            return this[\"@createEventSignal\"](\"ValueInput\", ComponentSignal);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    InputControl___decorate([\n        Async_defaultExport.observable_string\n    ], InputControl.prototype, \"name\", void 0);\n    InputControl___decorate([\n        Async_defaultExport.observable_string\n    ], InputControl.prototype, \"label\", void 0);\n    InputControl___decorate([\n        Async_defaultExport.observable_string\n    ], InputControl.prototype, \"tooltipText\", void 0);\n    InputControl___decorate([\n        Async_defaultExport.observable\n    ], InputControl.prototype, \"disabled\", void 0);\n    InputControl___decorate([\n        Async_defaultExport.observable_not_null\n    ], InputControl.prototype, \"style_label\", void 0);\n    InputControl___decorate([\n        Async_defaultExport.observable_not_null\n    ], InputControl.prototype, \"style_input\", void 0);\n    InputControl___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], InputControl.prototype, \"ValueChange\", null);\n    InputControl___decorate([\n        Async_defaultExport.unobservable_memoize_get\n    ], InputControl.prototype, \"ValueInput\", null);\n    return InputControl;\n}(ControlElement_ControlElement));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/InputControls/Checkbox.js\nvar Checkbox___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Checkbox___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Represents a single checkbox or radio button control */\nvar Checkbox_Checkbox = (function (_super) {\n    Checkbox___extends(Checkbox, _super);\n    /** Create a checkbox element */\n    function Checkbox(name, label, type, checked) {\n        if (name === void 0) { name = \"checkbox\"; }\n        if (type === void 0) { type = Checkbox.Type.Checkbox; }\n        if (checked === void 0) { checked = false; }\n        var _this = _super.call(this) || this;\n        /** Text value used when selected (observed), defaults to \"checked\" */\n        _this.value = \"checked\";\n        /** Set to false to expand horizontally within row (observed) */\n        _this.shrinkwrap = true;\n        /** Encapsulation of inner text element style (observed) */\n        _this.style_text = new Style_Style();\n        _this.label = label;\n        _this.name = name;\n        _this.type = type;\n        _this.checked = checked;\n        return _this;\n    }\n    /** Initialize a checkbox control factory with given values */\n    Checkbox.withName = function (name, label, checked, value) {\n        return this.with({ name: name, label: label, checked: checked, value: value });\n    };\n    /** Initialize a radio button control factory with given values */\n    Checkbox.withRadioName = function (name, label, checked, value) {\n        return this.with({\n            name: name, label: label, checked: checked, value: value,\n            type: Checkbox.Type.Radio\n        });\n    };\n    /** Returns an object containing all current values of input elements (observable) */\n    Checkbox.prototype.getFormValues = function (result) {\n        if (result === void 0) { result = {}; }\n        if (this.name && (this.checked || !this.type))\n            result[this.name] = this.checked ?\n                (this.value !== undefined ? this.value : \"checked\") :\n                undefined;\n        return result;\n    };\n    /** Sets all input values by element name */\n    Checkbox.prototype.setFormValues = function (values) {\n        if (this.name && values &&\n            Object.prototype.hasOwnProperty.call(values, this.name))\n            this.checked = this.type ?\n                (this.value !== undefined ?\n                    values[this.name] === this.value :\n                    !!values[this.name]) :\n                !!values[this.name];\n    };\n    Checkbox___decorate([\n        Async_defaultExport.observable\n    ], Checkbox.prototype, \"type\", void 0);\n    Checkbox___decorate([\n        Async_defaultExport.observable\n    ], Checkbox.prototype, \"value\", void 0);\n    Checkbox___decorate([\n        Async_defaultExport.observable\n    ], Checkbox.prototype, \"checked\", void 0);\n    Checkbox___decorate([\n        Async_defaultExport.observable_not_null\n    ], Checkbox.prototype, \"style_text\", void 0);\n    return Checkbox;\n}(InputControl_InputControl));\n\n(function (Checkbox) {\n    var Type;\n    (function (Type) {\n        Type[Type[\"Checkbox\"] = 0] = \"Checkbox\";\n        Type[Type[\"Radio\"] = 1] = \"Radio\";\n    })(Type = Checkbox.Type || (Checkbox.Type = {}));\n    ;\n})(Checkbox_Checkbox || (Checkbox_Checkbox = {}));\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/InputControls/SelectField.js\nvar SelectField___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar SelectField___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n/** Represents a native dropdown selection field control */\nvar SelectField_SelectField = (function (_super) {\n    SelectField___extends(SelectField, _super);\n    /** Create a select field element */\n    function SelectField(name, label, options) {\n        if (name === void 0) { name = \"select\"; }\n        var _this = _super.call(this) || this;\n        _this.label = label;\n        _this.options = options || [];\n        _this.name = name;\n        return _this;\n    }\n    /** Initialize a select field control factory with given name, label, and options */\n    SelectField.withOptions = function (name, label, options) {\n        if (options === void 0) { options = []; }\n        return this.with({ name: name, label: label, options: options });\n    };\n    /** Returns an object containing all current values of input elements (observable) */\n    SelectField.prototype.getFormValues = function (result) {\n        if (result === void 0) { result = {}; }\n        if (this.name)\n            result[this.name] = this.value;\n        return result;\n    };\n    /** Sets all input values by element name */\n    SelectField.prototype.setFormValues = function (values) {\n        if (this.name && values &&\n            Object.prototype.hasOwnProperty.call(values, this.name))\n            this.value = values[this.name];\n    };\n    SelectField___decorate([\n        Async_defaultExport.observable_not_null\n    ], SelectField.prototype, \"options\", void 0);\n    SelectField___decorate([\n        Async_defaultExport.observable\n    ], SelectField.prototype, \"value\", void 0);\n    return SelectField;\n}(InputControl_InputControl));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/Controls/InputControls/TextField.js\nvar TextField___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar TextField___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n/** Represents a single- or multi-line text input field control */\nvar TextField_TextField = (function (_super) {\n    TextField___extends(TextField, _super);\n    /** Create a text field */\n    function TextField(name, label, textareaLines) {\n        if (name === void 0) { name = \"text\"; }\n        if (textareaLines === void 0) { textareaLines = 0; }\n        var _this = _super.call(this) || this;\n        /** Text field type (text, password, number, etc.; observed) */\n        _this.type = TextField.Type.Text;\n        _this.label = label;\n        _this.name = name;\n        _this.textareaLines = textareaLines;\n        return _this;\n    }\n    /** Initialize a text field control factory with given name, label, and placeholder */\n    TextField.withName = function (name, label, placeholderText) {\n        return this.with({ name: name, label: label, placeholderText: placeholderText });\n    };\n    /** Select (a part of) the text in this text field, returns this */\n    TextField.prototype.selectText = function (start, end) { return this; };\n    /** Returns an object containing all current values of input elements (observable) */\n    TextField.prototype.getFormValues = function (result) {\n        if (result === void 0) { result = {}; }\n        if (this.name)\n            result[this.name] = this.value;\n        return result;\n    };\n    /** Sets all input values by element name */\n    TextField.prototype.setFormValues = function (values) {\n        if (this.name && values &&\n            Object.prototype.hasOwnProperty.call(values, this.name))\n            this.value = values[this.name];\n    };\n    TextField___decorate([\n        Async_defaultExport.observable\n    ], TextField.prototype, \"type\", void 0);\n    TextField___decorate([\n        Async_defaultExport.observable_string\n    ], TextField.prototype, \"value\", void 0);\n    TextField___decorate([\n        Async_defaultExport.observable_string\n    ], TextField.prototype, \"placeholderText\", void 0);\n    TextField___decorate([\n        Async_defaultExport.observable_string\n    ], TextField.prototype, \"immediateValueUpdate\", void 0);\n    TextField___decorate([\n        Async_defaultExport.injectable\n    ], TextField.prototype, \"selectText\", null);\n    return TextField;\n}(InputControl_InputControl));\n\n(function (TextField) {\n    /** Text field type options (e.g. Text, Password, Email etc.) */\n    var Type;\n    (function (Type) {\n        Type[Type[\"Text\"] = 0] = \"Text\";\n        Type[Type[\"Password\"] = 1] = \"Password\";\n        Type[Type[\"DateTime\"] = 2] = \"DateTime\";\n        Type[Type[\"Date\"] = 3] = \"Date\";\n        Type[Type[\"Month\"] = 4] = \"Month\";\n        Type[Type[\"Time\"] = 5] = \"Time\";\n        Type[Type[\"Week\"] = 6] = \"Week\";\n        Type[Type[\"Number\"] = 7] = \"Number\";\n        Type[Type[\"Email\"] = 8] = \"Email\";\n        Type[Type[\"Url\"] = 9] = \"Url\";\n        Type[Type[\"Search\"] = 10] = \"Search\";\n        Type[Type[\"Tel\"] = 11] = \"Tel\";\n        Type[Type[\"Color\"] = 12] = \"Color\";\n    })(Type = TextField.Type || (TextField.Type = {}));\n    ;\n})(TextField_TextField || (TextField_TextField = {}));\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Components/index.js\n// base classes:\n\n\n\n\n\n// containers:\n\n\n\n\n// blocks:\n\n\n\n\n\n\n\n\n\n\n\n// controls:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/Animation.js\n/** Current unique ID, appended to name */\nvar _uid = 0;\n/** Current status: all enabled or disabled */\nvar _enabled = true;\n/** Represents a UI component animation */\nvar Animation = (function () {\n    function Animation(name) {\n        /** Total duration in milliseconds of (the looping segment of) this animation, set by implementation */\n        this.duration = 0;\n        this.name = name;\n        this.id = String(name).replace(/\\W/g, \"_\") + \"__\" + _uid++;\n    }\n    Animation.enableAll = function () { _enabled = true; };\n    Animation.disableAll = function () { _enabled = false; };\n    Object.defineProperty(Animation, \"isEnabled\", {\n        get: function () { return _enabled; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Play the animation once for the entire duration, and then stop it */\n    Animation.prototype.playOnce = function (component) {\n        var anim = this.play(component);\n        anim.done.then(function () { return anim.stop(); });\n        return anim;\n    };\n    return Animation;\n}());\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI/index.js\nvar UI_namespaceObject = {};\n__webpack_require__.d(UI_namespaceObject, \"Style\", function() { return Style_Style; });\n__webpack_require__.d(UI_namespaceObject, \"Page\", function() { return Page_Page; });\n__webpack_require__.d(UI_namespaceObject, \"PageRenderer\", function() { return Page_PageRenderer; });\n__webpack_require__.d(UI_namespaceObject, \"Screen\", function() { return Screen_Screen; });\n__webpack_require__.d(UI_namespaceObject, \"Binding\", function() { return Binding_Binding; });\n__webpack_require__.d(UI_namespaceObject, \"TwoWayBinding\", function() { return TwoWayBinding; });\n__webpack_require__.d(UI_namespaceObject, \"ArrayBinding\", function() { return Binding_ArrayBinding; });\n__webpack_require__.d(UI_namespaceObject, \"bind\", function() { return bind; });\n__webpack_require__.d(UI_namespaceObject, \"bind2\", function() { return bind2; });\n__webpack_require__.d(UI_namespaceObject, \"bindComponents\", function() { return bindComponents; });\n__webpack_require__.d(UI_namespaceObject, \"_getBatchTransformer\", function() { return _getBatchTransformer; });\n__webpack_require__.d(UI_namespaceObject, \"Animation\", function() { return Animation; });\n__webpack_require__.d(UI_namespaceObject, \"Drag\", function() { return Drag_Drag; });\n__webpack_require__.d(UI_namespaceObject, \"Menu\", function() { return Menu; });\n__webpack_require__.d(UI_namespaceObject, \"Component\", function() { return Component_Component; });\n__webpack_require__.d(UI_namespaceObject, \"ComponentSignal\", function() { return ComponentSignal; });\n__webpack_require__.d(UI_namespaceObject, \"ComponentSignalHandler\", function() { return ComponentSignalHandler; });\n__webpack_require__.d(UI_namespaceObject, \"defineComponentSignal\", function() { return defineComponentSignal; });\n__webpack_require__.d(UI_namespaceObject, \"ActionHandler\", function() { return ActionHandler; });\n__webpack_require__.d(UI_namespaceObject, \"KeyEventSignal\", function() { return KeyEventSignal; });\n__webpack_require__.d(UI_namespaceObject, \"KeyHandler\", function() { return KeyHandler; });\n__webpack_require__.d(UI_namespaceObject, \"PointerEventSignal\", function() { return PointerEventSignal; });\n__webpack_require__.d(UI_namespaceObject, \"PointerHandler\", function() { return PointerHandler; });\n__webpack_require__.d(UI_namespaceObject, \"DragEventSignal\", function() { return DragEventSignal; });\n__webpack_require__.d(UI_namespaceObject, \"DragHandler\", function() { return DragHandler; });\n__webpack_require__.d(UI_namespaceObject, \"ComponentFactory\", function() { return ComponentFactory_ComponentFactory; });\n__webpack_require__.d(UI_namespaceObject, \"makeFactory\", function() { return makeFactory; });\n__webpack_require__.d(UI_namespaceObject, \"ComponentRenderer\", function() { return ComponentRenderer_ComponentRenderer; });\n__webpack_require__.d(UI_namespaceObject, \"ComponentRenderHandler\", function() { return ComponentRenderHandler; });\n__webpack_require__.d(UI_namespaceObject, \"mapComponentRenderer\", function() { return mapComponentRenderer; });\n__webpack_require__.d(UI_namespaceObject, \"TextLabelFactory\", function() { return TextLabelFactory_TextLabelFactory; });\n__webpack_require__.d(UI_namespaceObject, \"tl\", function() { return tl; });\n__webpack_require__.d(UI_namespaceObject, \"Container\", function() { return Container_Container; });\n__webpack_require__.d(UI_namespaceObject, \"FlowContainer\", function() { return FlowContainer; });\n__webpack_require__.d(UI_namespaceObject, \"DialogContainer\", function() { return DialogContainer_DialogContainer; });\n__webpack_require__.d(UI_namespaceObject, \"DrawerContainer\", function() { return DrawerContainer; });\n__webpack_require__.d(UI_namespaceObject, \"OppositeDrawerContainer\", function() { return OppositeDrawerContainer; });\n__webpack_require__.d(UI_namespaceObject, \"LayoutContainer\", function() { return LayoutContainer_LayoutContainer; });\n__webpack_require__.d(UI_namespaceObject, \"Block\", function() { return Block_Block; });\n__webpack_require__.d(UI_namespaceObject, \"Card\", function() { return Card_Card; });\n__webpack_require__.d(UI_namespaceObject, \"ContainerBlock\", function() { return ContainerBlock_ContainerBlock; });\n__webpack_require__.d(UI_namespaceObject, \"Divider\", function() { return Divider_Divider; });\n__webpack_require__.d(UI_namespaceObject, \"List\", function() { return List_List; });\n__webpack_require__.d(UI_namespaceObject, \"ListSelectionHandler\", function() { return ListSelectionHandler; });\n__webpack_require__.d(UI_namespaceObject, \"TreeList\", function() { return TreeList_TreeList; });\n__webpack_require__.d(UI_namespaceObject, \"TreeListSelectionHandler\", function() { return TreeListSelectionHandler; });\n__webpack_require__.d(UI_namespaceObject, \"TreeListFoldHandler\", function() { return TreeListFoldHandler; });\n__webpack_require__.d(UI_namespaceObject, \"TreeListRow\", function() { return TreeListRow_TreeListRow; });\n__webpack_require__.d(UI_namespaceObject, \"NavList\", function() { return NavList_NavList; });\n__webpack_require__.d(UI_namespaceObject, \"NavListSelectionHandler\", function() { return NavListSelectionHandler; });\n__webpack_require__.d(UI_namespaceObject, \"Row\", function() { return Row_Row; });\n__webpack_require__.d(UI_namespaceObject, \"CloseRow\", function() { return CloseRow; });\n__webpack_require__.d(UI_namespaceObject, \"OppositeRow\", function() { return OppositeRow; });\n__webpack_require__.d(UI_namespaceObject, \"CenterRow\", function() { return CenterRow; });\n__webpack_require__.d(UI_namespaceObject, \"Table\", function() { return Table_Table; });\n__webpack_require__.d(UI_namespaceObject, \"TableRow\", function() { return TableRow_TableRow; });\n__webpack_require__.d(UI_namespaceObject, \"TableHeader\", function() { return TableRow_TableHeader; });\n__webpack_require__.d(UI_namespaceObject, \"ControlElement\", function() { return ControlElement_ControlElement; });\n__webpack_require__.d(UI_namespaceObject, \"BlockControl\", function() { return BlockControl_BlockControl; });\n__webpack_require__.d(UI_namespaceObject, \"Button\", function() { return Button_Button; });\n__webpack_require__.d(UI_namespaceObject, \"ButtonDropdownClickHandler\", function() { return ButtonDropdownClickHandler; });\n__webpack_require__.d(UI_namespaceObject, \"PrimaryButton\", function() { return PrimaryButton; });\n__webpack_require__.d(UI_namespaceObject, \"ToggleButton\", function() { return Button_ToggleButton; });\n__webpack_require__.d(UI_namespaceObject, \"LinkButton\", function() { return LinkButton; });\n__webpack_require__.d(UI_namespaceObject, \"TextButton\", function() { return TextButton; });\n__webpack_require__.d(UI_namespaceObject, \"RoundButton\", function() { return RoundButton; });\n__webpack_require__.d(UI_namespaceObject, \"ButtonGroup\", function() { return ButtonGroup_ButtonGroup; });\n__webpack_require__.d(UI_namespaceObject, \"ContainerControl\", function() { return ContainerControl_ContainerControl; });\n__webpack_require__.d(UI_namespaceObject, \"ControlStack\", function() { return ControlStack_ControlStack; });\n__webpack_require__.d(UI_namespaceObject, \"CloseControlStack\", function() { return CloseControlStack; });\n__webpack_require__.d(UI_namespaceObject, \"Icon\", function() { return Icon_Icon; });\n__webpack_require__.d(UI_namespaceObject, \"Image\", function() { return Image_Image; });\n__webpack_require__.d(UI_namespaceObject, \"Label\", function() { return Label_Label; });\n__webpack_require__.d(UI_namespaceObject, \"WideLabel\", function() { return WideLabel; });\n__webpack_require__.d(UI_namespaceObject, \"Paragraph\", function() { return Paragraph; });\n__webpack_require__.d(UI_namespaceObject, \"Heading1\", function() { return Heading1; });\n__webpack_require__.d(UI_namespaceObject, \"Heading2\", function() { return Heading2; });\n__webpack_require__.d(UI_namespaceObject, \"Heading3\", function() { return Heading3; });\n__webpack_require__.d(UI_namespaceObject, \"Heading4\", function() { return Heading4; });\n__webpack_require__.d(UI_namespaceObject, \"Heading5\", function() { return Heading5; });\n__webpack_require__.d(UI_namespaceObject, \"Heading6\", function() { return Heading6; });\n__webpack_require__.d(UI_namespaceObject, \"ProgressBar\", function() { return ProgressBar_ProgressBar; });\n__webpack_require__.d(UI_namespaceObject, \"Spacer\", function() { return Spacer; });\n__webpack_require__.d(UI_namespaceObject, \"InputControl\", function() { return InputControl_InputControl; });\n__webpack_require__.d(UI_namespaceObject, \"Checkbox\", function() { return Checkbox_Checkbox; });\n__webpack_require__.d(UI_namespaceObject, \"SelectField\", function() { return SelectField_SelectField; });\n__webpack_require__.d(UI_namespaceObject, \"TextField\", function() { return TextField_TextField; });\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./dist/core/lib/UI.js\nvar lib_UI_namespaceObject = {};\n__webpack_require__.d(lib_UI_namespaceObject, \"default\", function() { return UI_defaultExport; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Style\", function() { return Style_Style; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Page\", function() { return Page_Page; });\n__webpack_require__.d(lib_UI_namespaceObject, \"PageRenderer\", function() { return Page_PageRenderer; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Screen\", function() { return Screen_Screen; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Binding\", function() { return Binding_Binding; });\n__webpack_require__.d(lib_UI_namespaceObject, \"TwoWayBinding\", function() { return TwoWayBinding; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ArrayBinding\", function() { return Binding_ArrayBinding; });\n__webpack_require__.d(lib_UI_namespaceObject, \"bind\", function() { return bind; });\n__webpack_require__.d(lib_UI_namespaceObject, \"bind2\", function() { return bind2; });\n__webpack_require__.d(lib_UI_namespaceObject, \"bindComponents\", function() { return bindComponents; });\n__webpack_require__.d(lib_UI_namespaceObject, \"_getBatchTransformer\", function() { return _getBatchTransformer; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Animation\", function() { return Animation; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Drag\", function() { return Drag_Drag; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Menu\", function() { return Menu; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Component\", function() { return Component_Component; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ComponentSignal\", function() { return ComponentSignal; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ComponentSignalHandler\", function() { return ComponentSignalHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"defineComponentSignal\", function() { return defineComponentSignal; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ActionHandler\", function() { return ActionHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"KeyEventSignal\", function() { return KeyEventSignal; });\n__webpack_require__.d(lib_UI_namespaceObject, \"KeyHandler\", function() { return KeyHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"PointerEventSignal\", function() { return PointerEventSignal; });\n__webpack_require__.d(lib_UI_namespaceObject, \"PointerHandler\", function() { return PointerHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"DragEventSignal\", function() { return DragEventSignal; });\n__webpack_require__.d(lib_UI_namespaceObject, \"DragHandler\", function() { return DragHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ComponentFactory\", function() { return ComponentFactory_ComponentFactory; });\n__webpack_require__.d(lib_UI_namespaceObject, \"makeFactory\", function() { return makeFactory; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ComponentRenderer\", function() { return ComponentRenderer_ComponentRenderer; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ComponentRenderHandler\", function() { return ComponentRenderHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"mapComponentRenderer\", function() { return mapComponentRenderer; });\n__webpack_require__.d(lib_UI_namespaceObject, \"TextLabelFactory\", function() { return TextLabelFactory_TextLabelFactory; });\n__webpack_require__.d(lib_UI_namespaceObject, \"tl\", function() { return tl; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Container\", function() { return Container_Container; });\n__webpack_require__.d(lib_UI_namespaceObject, \"FlowContainer\", function() { return FlowContainer; });\n__webpack_require__.d(lib_UI_namespaceObject, \"DialogContainer\", function() { return DialogContainer_DialogContainer; });\n__webpack_require__.d(lib_UI_namespaceObject, \"DrawerContainer\", function() { return DrawerContainer; });\n__webpack_require__.d(lib_UI_namespaceObject, \"OppositeDrawerContainer\", function() { return OppositeDrawerContainer; });\n__webpack_require__.d(lib_UI_namespaceObject, \"LayoutContainer\", function() { return LayoutContainer_LayoutContainer; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Block\", function() { return Block_Block; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Card\", function() { return Card_Card; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ContainerBlock\", function() { return ContainerBlock_ContainerBlock; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Divider\", function() { return Divider_Divider; });\n__webpack_require__.d(lib_UI_namespaceObject, \"List\", function() { return List_List; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ListSelectionHandler\", function() { return ListSelectionHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"TreeList\", function() { return TreeList_TreeList; });\n__webpack_require__.d(lib_UI_namespaceObject, \"TreeListSelectionHandler\", function() { return TreeListSelectionHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"TreeListFoldHandler\", function() { return TreeListFoldHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"TreeListRow\", function() { return TreeListRow_TreeListRow; });\n__webpack_require__.d(lib_UI_namespaceObject, \"NavList\", function() { return NavList_NavList; });\n__webpack_require__.d(lib_UI_namespaceObject, \"NavListSelectionHandler\", function() { return NavListSelectionHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Row\", function() { return Row_Row; });\n__webpack_require__.d(lib_UI_namespaceObject, \"CloseRow\", function() { return CloseRow; });\n__webpack_require__.d(lib_UI_namespaceObject, \"OppositeRow\", function() { return OppositeRow; });\n__webpack_require__.d(lib_UI_namespaceObject, \"CenterRow\", function() { return CenterRow; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Table\", function() { return Table_Table; });\n__webpack_require__.d(lib_UI_namespaceObject, \"TableRow\", function() { return TableRow_TableRow; });\n__webpack_require__.d(lib_UI_namespaceObject, \"TableHeader\", function() { return TableRow_TableHeader; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ControlElement\", function() { return ControlElement_ControlElement; });\n__webpack_require__.d(lib_UI_namespaceObject, \"BlockControl\", function() { return BlockControl_BlockControl; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Button\", function() { return Button_Button; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ButtonDropdownClickHandler\", function() { return ButtonDropdownClickHandler; });\n__webpack_require__.d(lib_UI_namespaceObject, \"PrimaryButton\", function() { return PrimaryButton; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ToggleButton\", function() { return Button_ToggleButton; });\n__webpack_require__.d(lib_UI_namespaceObject, \"LinkButton\", function() { return LinkButton; });\n__webpack_require__.d(lib_UI_namespaceObject, \"TextButton\", function() { return TextButton; });\n__webpack_require__.d(lib_UI_namespaceObject, \"RoundButton\", function() { return RoundButton; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ButtonGroup\", function() { return ButtonGroup_ButtonGroup; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ContainerControl\", function() { return ContainerControl_ContainerControl; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ControlStack\", function() { return ControlStack_ControlStack; });\n__webpack_require__.d(lib_UI_namespaceObject, \"CloseControlStack\", function() { return CloseControlStack; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Icon\", function() { return Icon_Icon; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Image\", function() { return Image_Image; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Label\", function() { return Label_Label; });\n__webpack_require__.d(lib_UI_namespaceObject, \"WideLabel\", function() { return WideLabel; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Paragraph\", function() { return Paragraph; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Heading1\", function() { return Heading1; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Heading2\", function() { return Heading2; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Heading3\", function() { return Heading3; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Heading4\", function() { return Heading4; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Heading5\", function() { return Heading5; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Heading6\", function() { return Heading6; });\n__webpack_require__.d(lib_UI_namespaceObject, \"ProgressBar\", function() { return ProgressBar_ProgressBar; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Spacer\", function() { return Spacer; });\n__webpack_require__.d(lib_UI_namespaceObject, \"InputControl\", function() { return InputControl_InputControl; });\n__webpack_require__.d(lib_UI_namespaceObject, \"Checkbox\", function() { return Checkbox_Checkbox; });\n__webpack_require__.d(lib_UI_namespaceObject, \"SelectField\", function() { return SelectField_SelectField; });\n__webpack_require__.d(lib_UI_namespaceObject, \"TextField\", function() { return TextField_TextField; });\n\n\n/* harmony default export */ var UI_defaultExport = (UI_namespaceObject);\n\n// CONCATENATED MODULE: ./dist/dom/node_modules/@typescene/core/UI.js\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/DOM/Stylesheet.js\n\n\n/** Last selection class set, default blank */\nvar _selectionClass = \"\";\n/** Unique random identifier for this runtime instance of the library, used as an identifier on page root elements */\nvar uid = \"__a\" + Math.random().toFixed(8).replace(/\\D/, \"\");\n/** Represents a (live updating) style sheet, with an optional base class name; the style sheet consists of one or more CSS selectors that each contain a reference to a `Style` instance */\nvar Stylesheet_Stylesheet = (function () {\n    /** Create a new style sheet, with given base class name(s) (optional) and given selectors and styles; selectors may be written as `\"@... { selector }\"` for e.g. @keyframe and @media nested at-rules; also, `.~~` will be replaced with the full base class name and `.~` with the final part, or if not included then the base class name will be prepended */\n    function Stylesheet(baseClassName, sheet) {\n        this._keys = new ObservableArray_ObservableArray();\n        this._disabled = new Observable_ObservableValue();\n        this.baseClassName = baseClassName;\n        this._selectors = new ObservableObject_ObservableObject();\n        if (sheet) {\n            for (var key in sheet) {\n                if (sheet[key] &&\n                    Object.prototype.hasOwnProperty.call(sheet, key))\n                    this.define(key, sheet[key]);\n            }\n        }\n    }\n    /** Returns true if the pseudo-luminance of given color (in hex format `#112233` or `#123` or rgb format `rgb(255, 255, 255)` or hsl format `hsl(255, 0%, 0%)`) is greater than 55%; can be used e.g. to decide on a contrasting text color for a given background color */\n    Stylesheet.isBrightColor = function (color) {\n        color = String(color);\n        if (color[0] === \"#\") {\n            if (color.length === 4) {\n                color = \"#\" + color[1] + color[1] +\n                    color[2] + color[2] +\n                    color[3] + color[3];\n            }\n            var r = parseInt(color.slice(1, 3), 16);\n            var g = parseInt(color.slice(3, 5), 16);\n            var b = parseInt(color.slice(5, 7), 16);\n            return (0.3 * r + 0.6 * g + 0.1 * b) > 140;\n        }\n        else if (color.slice(0, 4) === \"rgb(\") {\n            var v = color.slice(4).split(\",\").map(parseFloat);\n            return (0.3 * v[0] + 0.6 * v[1] + 0.1 * v[2]) > 140;\n        }\n        else if (color.slice(0, 4) === \"hsl(\") {\n            var lum = parseFloat(color.slice(4).split(\",\")[2]);\n            return lum > 55;\n        }\n        else\n            return false;\n    };\n    /** Returns a color in hex format (e.g. `#112233`) that lies between given colors (in hex format `#112233` or `#123` or rgb format `rgb(255, 255, 255)`) at given point (0-1, with 0 being the same as the first color, 1 being the same as the second color, and 0.5 being an equal mix) */\n    Stylesheet.mixColors = function (color1, color2, p) {\n        function parse(color) {\n            color = String(color);\n            if (color[0] === \"#\") {\n                if (color.length === 4) {\n                    color = \"#\" + color[1] + color[1] +\n                        color[2] + color[2] +\n                        color[3] + color[3];\n                }\n                return [\n                    parseInt(color.slice(1, 3), 16),\n                    parseInt(color.slice(3, 5), 16),\n                    parseInt(color.slice(5, 7), 16)\n                ];\n            }\n            else if (color.slice(0, 4) === \"rgb(\") {\n                return color.slice(4).split(\",\").map(parseFloat);\n            }\n            else\n                return [0, 0, 0];\n        }\n        var q = 1 - p;\n        var c1 = parse(color1);\n        var c2 = parse(color2);\n        var c = [\n            q * c1[0] + p * c2[0],\n            q * c1[1] + p * c2[1],\n            q * c1[2] + p * c2[2]\n        ];\n        var hex2 = function (n) { return (n < 16 ? \"0\" : \"\") + Math.floor(n).toString(16); };\n        return \"#\" + hex2(c[0]) + hex2(c[1]) + hex2(c[2]);\n    };\n    /** Disable all style rules in one go without removing them (use `.enable()` to reverse the effect); returns this */\n    Stylesheet.prototype.disable = function () {\n        this._disabled.value = true;\n        return this;\n    };\n    /** Re-enable all style rules (after using `.disable()` to disable them); returns this */\n    Stylesheet.prototype.enable = function () {\n        this._disabled.value = false;\n        return this;\n    };\n    /** Returns a list of selectors defined in this style sheet (observable) */\n    Stylesheet.prototype.listSelectors = function () {\n        return this._keys.slice(0);\n    };\n    Stylesheet.prototype.define = function (selector, style) {\n        if (!this._selectors.hasObservableProperty(selector)) {\n            // make property observable and set style\n            makePropertyObservable(this._selectors, selector);\n            this._keys.push(selector);\n            this._selectors[selector] = (style instanceof Style_Style) ?\n                style : new Style_Style(style);\n        }\n        else if (style) {\n            // create a new Style instance to combine old and new styles\n            this._selectors[selector] = new Style_Style()\n                .override(this._selectors[selector])\n                .override(style);\n        }\n        return this;\n    };\n    /** Remove defined styles for given selector or pattern; returns this */\n    Stylesheet.prototype.remove = function (selector) {\n        var _this = this;\n        if (selector instanceof RegExp) {\n            // remove all matching selectors\n            this._keys.forEach(function (key) {\n                if (selector.test(key))\n                    _this._selectors[key] = undefined;\n            });\n        }\n        else {\n            // remove selector directly\n            this._selectors[String(selector)] = undefined;\n        }\n        return this;\n    };\n    /** Invoke given function for each selector of this style sheet, including instance identifier class and base class (except for keyframe selectors), if any, and the referenced `Style` instance, if any; to be used in an observable context to watch for changes*/\n    Stylesheet.prototype.forEach = function (callback) {\n        var _this = this;\n        if (this._disabled.value)\n            return;\n        var base = (this.baseClassName || \"\");\n        if (base)\n            base = \".\" + base.trim().replace(/\\s+/, \".\");\n        var baseLast = base.replace(/.*(\\.[^\\.]+)$/, \"$1\");\n        var uidSel = \"#\" + uid + \" \";\n        var kf = /^@keyframes/;\n        this._keys.forEach(function (key) {\n            if (_this._selectors[key]) {\n                var selector;\n                if (!kf.test(key)) {\n                    // add base class where necessary\n                    selector = key.split(/\\s*,\\s*/g).map(function (k) {\n                        // check for .~ and/or @...{ block }\n                        if (k.indexOf(\".~\") >= 0)\n                            return k.replace(/\\.\\~\\~/g, base)\n                                .replace(/\\.\\~/g, baseLast)\n                                .replace(/^((?:[^\\{]*\\{\\s*)?)/, \"$1\" + uidSel);\n                        else\n                            return k.replace(/^((?:[^\\{]*\\{\\s*)?)/, \"$1\" + uidSel + (base && base + \" \"));\n                    }).join(\", \");\n                }\n                else {\n                    // keep keyframe percentage/from/to as is\n                    selector = key;\n                }\n                // pass callback the augmented selector and Style\n                callback(selector, _this._selectors[key]);\n            }\n        });\n    };\n    return Stylesheet;\n}());\n\n/** Define global CSS styles from given style sheet, in the context of the current runtime instance; if the `liveUpdate` argument is set to true, changes to the style sheet and any of its observable properties are observed and reflected in the DOM asynchronously (and the `.disable` method can be used to remove the stylesheet from the DOM temporarily or permanently) */\nfunction applyStylesheet(sheet, liveUpdate) {\n    var styleElt = document.createElement(\"style\");\n    if (!(sheet instanceof Stylesheet_Stylesheet))\n        sheet = new Stylesheet_Stylesheet(undefined, sheet);\n    // helper function to return combined CSS text for all selectors\n    function getCSSText() {\n        var result = \"\";\n        var lastBlockID;\n        sheet.forEach(function (key, style) {\n            var text;\n            if (style) {\n                // get CSS text from style instance\n                var instances = style.getOverrides();\n                text = \"\";\n                instances.forEach(function (s) {\n                    s.forEachProperty(function (key, value) {\n                        if (key[0] !== \".\" && key[0] !== \":\") {\n                            key = key.replace(/([A-Z])/g, \"-$1\").toLowerCase()\n                                .replace(/^(webkit|o|ms|moz)-/, \"-$1-\");\n                            for (var _i = 0, _a = String(value).split(\"||\").reverse(); _i < _a.length; _i++) {\n                                var str = _a[_i];\n                                text += key + \": \" + str + \"; \";\n                            }\n                        }\n                        else if (key === \":shadow\") {\n                            // add box shadow for given depth factor\n                            var boxShadow = getBoxShadowText(Number(value));\n                            text += \"box-shadow: \" + boxShadow + \"; \";\n                        }\n                    });\n                });\n                if (text)\n                    text = \" {\" + text.slice(0, -2) + \"}\";\n            }\n            else {\n                // use key as entire CSS text\n                text = key, key = \"\";\n            }\n            // append selector and CSS text, if any\n            if (text) {\n                var blockMatch = key.match(/^(.*)\\{\\s*(.*)\\s*\\}\\s*$/);\n                if (blockMatch) {\n                    var blockID = blockMatch[1].trim();\n                    if (lastBlockID !== blockID) {\n                        // insert text within defined @...{ block }\n                        result += blockID + \" { \" +\n                            blockMatch[2] + text + \"}\\n\";\n                    }\n                    else {\n                        // append text to same block\n                        result = result.slice(0, -2) + \"\\n\" +\n                            blockMatch[2] + text + \"}\\n\";\n                    }\n                    lastBlockID = blockID;\n                }\n                else {\n                    // insert text after selector\n                    result += key + text + \"\\n\";\n                    lastBlockID = undefined;\n                }\n            }\n        });\n        return result;\n    }\n    if (liveUpdate) {\n        // keep the <style> element updated\n        observe(getCSSText).subscribe(function (text) {\n            styleElt.textContent = text;\n            document.head.appendChild(styleElt);\n        });\n    }\n    else {\n        // insert the <style> element only once\n        styleElt.textContent = getCSSText();\n        document.head.appendChild(styleElt);\n    }\n}\n/** Helper function to apply Style properties to given DOM element; returns the Style object (does not observe styles directly, but can be used in an observable getter, e.g. using `ComponentRenderer#watch` to reapply styles when they change) */\nfunction applyStyleTo(style, element) {\n    if (element instanceof HTMLElement) {\n        // get a list of all overrides recursively\n        var instances = style.getOverrides();\n        var overridesStr = instances.map(function (s) { return s.uid; }).join(\"|\");\n        // clear style if any changes occurred since styles were last applied\n        var lastOverridesStr = (styleElementMap ? styleElementMap.get(element) :\n            element.getAttribute(\"data-ui-style-map\")) || \"\";\n        if (lastOverridesStr !== overridesStr && element.style.length) {\n            var props = [];\n            for (var i = element.style.length - 1; i >= 0; i--)\n                props.push(element.style.item(i));\n            for (i = props.length - 1; i >= 0; i--)\n                element.style.removeProperty(props[i]);\n        }\n        // combine sorted overridden styles\n        var classNames = {};\n        var isHidden = false, isSelected = false;\n        instances.forEach(function (style) {\n            if (!style)\n                return;\n            style.forEachProperty(function (name, value) {\n                if (name === \":hidden\") {\n                    // set hidden status if true or false\n                    if (value !== undefined)\n                        isHidden = !!value;\n                }\n                else if (name === \":selected\") {\n                    // set selection status if true or false\n                    if (value !== undefined) {\n                        isSelected = !!value;\n                        if (_selectionClass) {\n                            // also add/remove selection class\n                            classNames[\".\" + _selectionClass] = value;\n                        }\n                    }\n                }\n                else if (name === \":shadow\") {\n                    // add box shadow for given depth factor\n                    element.style.boxShadow =\n                        getBoxShadowText(Number(value));\n                }\n                else if (name[0] === \".\") {\n                    // add class name (still prefixed with dot)\n                    classNames[name] = value;\n                }\n                else {\n                    // set style property using DOM directly\n                    for (var _i = 0, _a = String(value).split(\"||\").reverse(); _i < _a.length; _i++) {\n                        var str = _a[_i];\n                        element.style[name] = str;\n                    }\n                }\n            });\n        });\n        // collate and set class name\n        var className = \"\";\n        for (var key in classNames) {\n            if (key[0] === \".\" && classNames[key])\n                className += \" \" + key.slice(1);\n        }\n        className = className.slice(1) +\n            ((isSelected && _selectionClass) ? \" \" + _selectionClass : \"\");\n        if (className || element.className)\n            element.className = className;\n        // hide or show the element\n        if (isHidden)\n            element.setAttribute(\"hidden\", \"hidden\");\n        else\n            element.removeAttribute(\"hidden\");\n        // select or deselect the element\n        if (isSelected)\n            element.setAttribute(\"selected\", \"selected\");\n        else\n            element.removeAttribute(\"selected\");\n    }\n}\n/** Get boxShadow property for given shadow height (0-1) */\nfunction getBoxShadowText(d) {\n    d = Math.min(1, Math.max(0, d));\n    return \"0 0 \" + d * 2 + \"rem \" + d * -.25 + \"rem rgba(0,0,0,\" + (d * d * .1 + d * .08) + \"),\" +\n        (\"0 \" + d * .85 + \"rem \" + d * 1 + \"rem \" + d * -.25 + \"rem rgba(0,0,0,\" + (d * .15 + .1) + \"),\") +\n        (\"0 \" + (d * d * .5 + d * .6) + \"rem \" + d * 1 + \"rem \" + d * -1 + \"rem rgba(0,0,0,.4),\") +\n        (\"0 \" + d * d * 1.5 + \"rem \" + d * 3 + \"rem \" + d * -1 + \"rem rgba(0,0,0,.3),\") +\n        (\"0 \" + d * d * 3 + \"rem \" + d * 2.5 + \"rem \" + d * -2 + \"rem rgba(0,0,0,.3)\");\n}\n/** Set the global root-em unit size in pixels or using a CSS value string; the `rem` unit size is defined at the HTML level and should be set to `16px` on all browsers, however some CSS frameworks (e.g. Bootstrap 3) modify this unit; use this method to override the `rem` unit size again */\nfunction setCSSRemSize(px) {\n    var strPx = (typeof px === \"string\") ? px : (px + \"px\");\n    var elt = document.createElement(\"style\");\n    elt.textContent = \"html { font-size: \" + strPx + \" }\";\n    document.head.appendChild(elt);\n}\n/** Set the class name globally applied to selected items (in addition to the `selected` DOM attribute), i.e. those items selected using `Style.select` */\nfunction setSelectionClass(className) {\n    _selectionClass = String(className || \"\");\n}\n/** Get the class name globally applied to selected items (if any) */\nfunction getSelectionClass() {\n    return _selectionClass;\n}\n/** Load external stylesheet(s) by URL; returns a promise that resolves after the style sheet(s) have been applied OR after a 1 second wait (e.g. when offline or browser does not support this function) */\nfunction loadExternalCSS() {\n    var urls = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        urls[_i] = arguments[_i];\n    }\n    return Promise_Promise.race([\n        Promise_Promise.sleep(1000),\n        Promise_Promise.all(urls.map(function (url) {\n            return new Promise_Promise(function (resolve, reject) {\n                // dynamically create link element\n                var linkElt = document.createElement(\"link\");\n                linkElt.addEventListener(\"load\", function () { resolve(); });\n                linkElt.addEventListener(\"error\", function () { reject(new Error()); });\n                // set attributes and append to head\n                linkElt.setAttribute('rel', 'stylesheet');\n                linkElt.setAttribute('type', 'text/css');\n                linkElt.setAttribute('href', url);\n                document.getElementsByTagName('head').item(0)\n                    .appendChild(linkElt);\n            });\n        }))\n    ]);\n}\n/** Weak map (if available) of elements and the Style UIDs that have been applied to them */\nvar styleElementMap = (typeof WeakMap !== \"undefined\") ?\n    new WeakMap() : undefined;\n;\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/DOM/styles/reboot.js\n\n\n\n/* harmony default export */ var reboot_defaultExport = (new Stylesheet_Stylesheet(\"\", {\n    \".__page_wrapper\": {\n        fontFamily: observe(function () { return Styles_Styles.font.family; }),\n        fontSize: observe(function () { return Styles_Styles.size.text; })\n    },\n    \"h1,h2,h3,h4,h5,h6\": {\n        fontFamily: \"inherit\",\n        fontWeight: \"500\",\n        lineHeight: \"1.1em\"\n    },\n    \"h1\": { fontSize: \"2.5rem\" },\n    \"h2\": { fontSize: \"2rem\" },\n    \"h3\": { fontSize: \"1.75rem\" },\n    \"h4\": { fontSize: \"1.5rem\" },\n    \"h5\": { fontSize: \"1.25rem\" },\n    \"h6\": { fontSize: \"1rem\" },\n    \"button,input,select,textarea,label\": {\n        fontFamily: \"inherit\",\n        fontSize: \"1em\",\n        color: \"inherit\",\n        lineHeight: \"normal\",\n        margin: \"0\",\n        padding: \"0\",\n        border: \"none\",\n        outline: \"0\",\n        background: \"transparent\",\n        overflow: \"auto\",\n        touchAction: \"manipulation\"\n    },\n    \"button\": { overflow: \"visible\" },\n    \"input\": { overflow: \"visible\" },\n    \"textarea\": { resize: \"vertical\" },\n    \"a\": {\n        backgroundColor: \"transparent\",\n        cursor: \"pointer\",\n        touchAction: \"manipulation\",\n        textDecoration: \"none\"\n    },\n    \"a:hover\": {\n        outlineWidth: \"0\",\n        textDecoration: \"underline\"\n    },\n    \"a:active\": { outlineWidth: \"0\" },\n    \"img\": { borderStyle: \"none\" }\n}));\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/DOM/styles/controls.js\n\n\n\n/* harmony default export */ var controls_defaultExport = (new Stylesheet_Stylesheet(\"\", {\n    // plain links:\n    \"a\": { color: observe(function () { return Styles_Styles.color.linkText; }) },\n    \"a:active\": { color: observe(function () { return Styles_Styles.color.linkVisitedText; }) },\n    \"a:visited\": { color: observe(function () { return Styles_Styles.color.linkVisitedText; }) },\n    // form labels and checkboxes/radios:\n    \".form-control-label\": {\n        display: \"block\",\n        paddingBottom: \".25rem\"\n    },\n    \".form-check-label\": {\n        marginRight: \"-.5rem !important\",\n    },\n    \".form-check-label > *\": {\n        display: \"inline-block\",\n        cursor: \"pointer\",\n        lineHeight: \"1.4rem\",\n        marginRight: \".5rem\"\n    },\n    \".form-check-input\": {\n        position: \"relative\",\n        top: \".1em\"\n    },\n    // text/select input:\n    \".form-control\": {\n        borderWidth: observe(function () { return Styles_Styles.size.controlBorderWidth; }),\n        borderStyle: \"solid\",\n        borderColor: observe(function () { return Styles_Styles.color.controlBase; }),\n        background: observe(function () { return Styles_Styles.color.background; }),\n        color: observe(function () { return Styles_Styles.color.text; }),\n        padding: \"0 .6rem\",\n        height: \"2.25rem\",\n        borderRadius: observe(function () { return Styles_Styles.size.inputBorderRadius; })\n    },\n    \".form-control:focus\": {\n        borderColor: observe(function () { return Styles_Styles.color.controlFocus; })\n    },\n    \"textarea.form-control\": {\n        padding: \".6rem\",\n        height: \"auto\"\n    },\n    // buttons:\n    \".btn\": {\n        padding: \".4rem .75rem\",\n        margin: \"-.25rem 0\",\n        minWidth: \"6rem\",\n        borderRadius: observe(function () { return Styles_Styles.size.buttonBorderRadius; }),\n        cursor: \"pointer\"\n    },\n    \".btn:focus\": {\n        outlineWidth: \"0\"\n    },\n    \".btn[disabled]\": {\n        cursor: \"default\",\n        opacity: \".5\"\n    },\n    \".btn-group .btn\": {\n        minWidth: \"2rem\"\n    },\n    \".btn-group-vertical .btn\": {\n        display: \"block\"\n    },\n    \".btn-group .btn:not(:first-child)\": {\n        borderTopLeftRadius: \"0\",\n        borderBottomLeftRadius: \"0\"\n    },\n    \".btn-group .btn:not(:last-child)\": {\n        borderTopRightRadius: \"0\",\n        borderBottomRightRadius: \"0\"\n    },\n    \".btn-group-vertical .btn:not(:first-child)\": {\n        borderTopLeftRadius: \"0\",\n        borderTopRightRadius: \"0\",\n        marginTop: \"0\"\n    },\n    \".btn-group-vertical .btn:not(:last-child)\": {\n        borderBottomLeftRadius: \"0\",\n        borderBottomRightRadius: \"0\",\n        marginBottom: \"0\"\n    },\n    // - primary button:\n    \".btn-primary\": {\n        background: observe(function () { return Styles_Styles.color.primary; }),\n        color: observe(function () { return Styles_Styles.color.primaryText; }),\n        borderWidth: observe(function () { return Styles_Styles.size.controlBorderWidth; }),\n        borderStyle: \"solid\",\n        borderColor: observe(function () { return Styles_Styles.color.primary; })\n    },\n    \".btn-primary:hover\": { borderColor: observe(function () { return Styles_Styles.color.primaryDark; }) },\n    \".btn-primary:focus\": { borderColor: observe(function () { return Styles_Styles.color.primaryDark; }) },\n    \".btn-primary:active,.btn-primary.active\": {\n        background: observe(function () { return Styles_Styles.color.background; }),\n        borderColor: observe(function () { return Styles_Styles.color.primary; }),\n        color: observe(function () { return Styles_Styles.color.text; })\n    },\n    // - secondary (default) button:\n    \".btn-secondary\": {\n        background: observe(function () { return Styles_Styles.color.controlBase; }),\n        color: observe(function () { return Styles_Styles.color.controlBaseText; }),\n        borderWidth: observe(function () { return Styles_Styles.size.controlBorderWidth; }),\n        borderStyle: \"solid\",\n        borderColor: observe(function () { return Styles_Styles.color.controlBase; })\n    },\n    \".btn-secondary:hover\": { borderColor: observe(function () { return Styles_Styles.color.controlFocus; }) },\n    \".btn-secondary:focus\": { borderColor: observe(function () { return Styles_Styles.color.controlFocus; }) },\n    \".btn-secondary:active,.btn-secondary.active\": {\n        background: observe(function () { return Styles_Styles.color.controlFocus; }),\n        borderColor: observe(function () { return Styles_Styles.color.controlFocus; }),\n        color: observe(function () { return Styles_Styles.color.controlFocusText; })\n    },\n    // - link button:\n    \".btn-link\": {\n        color: observe(function () { return Styles_Styles.color.linkText; }),\n        borderWidth: observe(function () { return Styles_Styles.size.controlBorderWidth; }),\n        borderStyle: \"solid\",\n        borderColor: \"transparent\"\n    },\n    \".btn-link:hover\": {\n        textDecoration: \"underline\"\n    },\n    \".btn-link:focus\": {\n        borderColor: observe(function () { return Styles_Styles.color.controlBase; })\n    },\n    \".btn-link:active,.btn-link.active\": {\n        borderColor: observe(function () { return Styles_Styles.color.controlBase; })\n    },\n    // tables:\n    \".table\": {\n        borderCollapse: \"collapse\",\n        background: observe(function () { return Styles_Styles.color.background; }),\n        color: observe(function () { return Styles_Styles.color.text; })\n    },\n    \".table thead th\": {\n        fontWeight: \"bold\",\n        borderBottomWidth: \"2px\",\n        borderBottomStyle: \"solid\",\n        borderBottomColor: observe(function () { return Styles_Styles.color.divider; })\n    },\n    \".table th\": {\n        fontWeight: \"bold\",\n        borderTopWidth: \"1px\",\n        borderTopStyle: \"solid\",\n        borderTopColor: observe(function () { return Styles_Styles.color.divider; })\n    },\n    \".table td\": {\n        borderTopWidth: \"1px\",\n        borderTopStyle: \"solid\",\n        borderTopColor: observe(function () { return Styles_Styles.color.divider; })\n    },\n    // badges:\n    \".badge\": {\n        display: \"inline-block\",\n        padding: \".25em .4em\",\n        fontSize: \".8em\",\n        lineHeight: \"1\",\n        whiteSpace: \"nowrap\",\n        verticalAlign: \"baseline\",\n        borderRadius: observe(function () { return Styles_Styles.size.badgeBorderRadius; }),\n        background: observe(function () { return Styles_Styles.color.text; }),\n        color: observe(function () { return Styles_Styles.color.background; })\n    },\n    \".badge:empty\": {\n        display: \"none\"\n    },\n    // cards:\n    \".card\": {\n        background: observe(function () { return Styles_Styles.color.background; }),\n        color: observe(function () { return Styles_Styles.color.text; }),\n        borderWidth: \"1px\",\n        borderStyle: \"solid\",\n        borderColor: observe(function () { return Styles_Styles.color.divider; }),\n        borderRadius: observe(function () { return Styles_Styles.size.cardBorderRadius; })\n    },\n    \".card-header\": {\n        background: observe(function () { return Styles_Styles.color.primary; }),\n        color: observe(function () { return Styles_Styles.color.primaryText; })\n    },\n    \".card-footer\": {\n        background: observe(function () { return Styles_Styles.color.primary; }),\n        color: observe(function () { return Styles_Styles.color.primaryText; })\n    },\n    // dropdowns (menus):\n    \".dropdown-menu\": {\n        display: \"block\",\n        listStyle: \"none\",\n        padding: \".2rem 0\",\n        background: observe(function () { return Styles_Styles.color.background; }),\n        minWidth: \"12rem\",\n        textAlign: \"start || left\"\n    },\n    \".dropdown-divider\": {\n        listStyle: \"none\",\n        height: \"1px\",\n        margin: \".5rem 0\",\n        padding: \"0\",\n        background: observe(function () { return Styles_Styles.color.divider; })\n    },\n    \".dropdown-item\": {\n        display: \"block\",\n        listStyle: \"none\",\n        margin: \"0\",\n        padding: \"0 1rem\",\n        whiteSpace: \"nowrap\",\n        lineHeight: \"2.5em\",\n        color: observe(function () { return Styles_Styles.color.text; })\n    },\n    \".dropdown-item:hover\": {\n        background: observe(function () { return Styles_Styles.color.text; }),\n        color: observe(function () { return Styles_Styles.color.background; }),\n        textDecoration: \"none\",\n    },\n    \".dropdown-item:active\": {\n        background: observe(function () { return Styles_Styles.color.text; }),\n        color: observe(function () { return Styles_Styles.color.background; })\n    },\n    \".dropdown-item:focus\": {\n        outlineWidth: \"2px\",\n        outlineStyle: \"solid\",\n        outlineColor: observe(function () { return Styles_Styles.color.text; })\n    },\n    \".dropdown-item[disabled]\": {\n        opacity: \".5\"\n    },\n    // nav:\n    \".nav\": {\n        listStyle: \"none\",\n        margin: \"0\",\n        padding: \"0\"\n    },\n    \".nav-item\": {\n        display: \"inline-block\",\n        listStyle: \"none\",\n        margin: \"0\",\n        marginRight: \".25rem\",\n        padding: \"0\"\n    },\n    // - pills:\n    \".nav-pills .nav-link\": {\n        display: \"block\",\n        padding: \".5rem 1rem\",\n        minWidth: \"5rem\",\n        textAlign: \"center\",\n        color: \"inherit\",\n        borderRadius: observe(function () { return Styles_Styles.size.buttonBorderRadius; })\n    },\n    \".nav-pills .nav-link:hover\": {\n        textDecoration: \"none\",\n        background: observe(function () { return Styles_Styles.color.controlBase; }),\n        color: observe(function () { return Styles_Styles.color.controlBaseText; })\n    },\n    \".nav-pills .nav-link.active\": {\n        background: observe(function () { return Styles_Styles.color.primary; }),\n        color: observe(function () { return Styles_Styles.color.primaryText; })\n    },\n    \".nav-pills.nav-stacked .nav-item\": {\n        display: \"block\",\n        margin: \"0\"\n    },\n    // - tabs:\n    \".nav-tabs\": {\n        borderBottomWidth: observe(function () { return Styles_Styles.size.controlBorderWidth; }),\n        borderBottomStyle: \"solid\",\n        borderBottomColor: observe(function () { return Styles_Styles.color.divider; })\n    },\n    \".nav-tabs .nav-link\": {\n        display: \"inline-block\",\n        padding: \".5rem\",\n        minWidth: \"5rem\",\n        textAlign: \"center\",\n        borderTopLeftRadius: observe(function () { return Styles_Styles.size.buttonBorderRadius; }),\n        borderTopRightRadius: observe(function () { return Styles_Styles.size.buttonBorderRadius; }),\n        textDecoration: \"none\"\n    },\n    \".nav-tabs .nav-link:hover\": {\n        textDecoration: \"none\",\n        background: observe(function () { return Styles_Styles.color.controlBase; }),\n        color: observe(function () { return Styles_Styles.color.controlBaseText; })\n    },\n    \".nav-tabs .nav-link.active\": {\n        marginBottom: \"-4px\",\n        borderBottomStyle: \"solid\",\n        borderBottomWidth: \"4px\",\n        borderBottomColor: observe(function () { return Styles_Styles.color.primary; })\n    }\n}));\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/DOM/Styles.js\n\n\n\n\n/** A set of predefined styles and style sheets that are used by specific components; these may be modified to apply a \"theme\", which will generally update all styles in the DOM asynchronously; _however_, styles defined here are subject to change for now and it is not guaranteed that selectors and class names will continue to exist across versions */\nvar Styles_Styles;\n(function (Styles) {\n    /** Groups basic component style sheet definitions together, indexed by class name (e.g. \"UI-Container\") */\n    Styles.components = {};\n    /** Contains basic font settings that are applied globally for this instance; to disable, either set value(s) to `inherit`, or disable `cssReset` altogether */\n    Styles.font = observe({\n        /** Base font family (defaults to system font stack) */\n        family: \"-apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, Oxygen-Sans, Ubuntu, \\\"Helvetica Neue\\\", Arial, sans-serif\"\n    });\n    /** Contains basic measurements that determine the sizing of text and certain components; custom observable properties can be added here if required */\n    Styles.size = observe({\n        /** Base font size used for main application layout and dialogs/drawers (defaults to `1rem`) */\n        text: \"1rem\",\n        /** Paragraph label line height (defaults to `1.65em`) */\n        paragraphLineHeight: \"1.65em\",\n        /** Default space around control elements (defaults to `1rem`) */\n        controlSpacing: \"1rem\",\n        /** Outline width of focused selected list elements (defaults to `0`, because background and text coloring is applied instead) */\n        listSelectionFocusOutline: \"0\",\n        /** Default border radius of all dialogs (defaults to `.25rem`) */\n        dialogBorderRadius: \".25rem\",\n        /** Default border radius of card components (defaults to `.25rem`) */\n        cardBorderRadius: \".25rem\",\n        /** Default border radius of badge elements (defaults to `.25rem`) */\n        badgeBorderRadius: \".25rem\",\n        /** Default border radius of all buttons (defaults to `0`) */\n        buttonBorderRadius: \"0\",\n        /** Default border radius of text/select input elements (defaults to `0`) */\n        inputBorderRadius: \"0\",\n        /** Default border width of all controls (e.g. buttons, input elements, defaults to `2px`) */\n        controlBorderWidth: \"2px\"\n    });\n    /** Contains an observable color scheme based on the color wheel, with a selection of primary and accent colors; custom observable properties can be added here if required */\n    Styles.color = observe({\n        /** Darkest black that matches the color scheme */\n        black: \"#000000\",\n        /** Lightest white that matches the color scheme */\n        white: \"#ffffff\",\n        /** Darker gray color that matches the color scheme */\n        darkerGray: \"#333333\",\n        /** Dark to mid-gray color that matches the color scheme */\n        darkGray: \"#777777\",\n        /** Light gray color that matches the color scheme */\n        lightGray: \"#dddddd\",\n        /** Blueish (silver) dark to mid-gray color that matches the color scheme */\n        slate: \"#667788\",\n        /** Blueish (silver) light gray color that matches the color scheme */\n        lightSlate: \"#c0c8d0\",\n        /** Bright red color that matches the color scheme */\n        red: \"#ee3333\",\n        /** Bright orange color that matches the color scheme */\n        orange: \"#ee9922\",\n        /** Bright yellow color that matches the color scheme */\n        yellow: \"#ddcc33\",\n        /** Bright lime green color that matches the color scheme */\n        lime: \"#99bb33\",\n        /** Bright green color that matches the color scheme */\n        green: \"#44aa44\",\n        /** Bright turquoise color that matches the color scheme */\n        turquoise: \"#33aaaa\",\n        /** Bright cyan color that matches the color scheme */\n        cyan: \"#33bbbb\",\n        /** Bright blue color that matches the color scheme */\n        blue: \"#3355aa\",\n        /** Bright violet color that matches the color scheme */\n        violet: \"#5533aa\",\n        /** Bright purple color that matches the color scheme */\n        purple: \"#8833aa\",\n        /** Bright magenta color that matches the color scheme */\n        magenta: \"#dd4488\",\n        /** Background color for main application layout and dialogs/drawers, defaults to pure white */\n        background: \"#ffffff\",\n        /** Text color for main application layout and dialogs/drawers (defaults to 80% opaque black) */\n        text: \"rgba(0,0,0,.8)\",\n        /** Faded text color used for smaller text before/after label text (defaults to 45% opaque black) */\n        textFaded: \"rgba(0,0,0,.45)\",\n        /** Default divider color (defaults to 20% opaque black) */\n        divider: \"rgba(0,0,0,.2)\",\n        /** Primary highlight color (defaults to `.blue`), usually a bright color for e.g. heading row backgrounds; set this property to change all primary* properties, _or_ set those directly as well */\n        get primary() { return this.primary || this.blue; },\n        set primary(v) { this.primary = v; },\n        /** Text color to be used on top of primary-colored backgrounds */\n        get primaryText() {\n            return this.primaryText ||\n                (Stylesheet_Stylesheet.isBrightColor(this.primary) ?\n                    Stylesheet_Stylesheet.mixColors(this.primary, \"#000000\", .8) :\n                    \"#ffffff\");\n        },\n        set primaryText(v) { this.primaryText = v; },\n        /** Darker shade of the primary color */\n        get primaryDark() {\n            return this.primaryDark ||\n                Stylesheet_Stylesheet.mixColors(this.primary, \"#000000\", .2);\n        },\n        set primaryDark(v) { this.primaryDark = v; },\n        /** Lighter shade of the primary color */\n        get primaryLight() {\n            return this.primaryLight ||\n                Stylesheet_Stylesheet.mixColors(this.primary, \"#ffffff\", .2);\n        },\n        set primaryLight(v) { this.primaryLight = v; },\n        /** Accent color (defaults to `.violet`), denotes interactive elements, usually a bright color for e.g. backgrounds of buttons that should stand out; set this property to change `.accentText` as well, _or_ set that directly to override the accent text color */\n        get accent() { return this.accent || this.violet; },\n        set accent(v) { this.accent = v; },\n        /** Text color to be used on top of accent-colored backgrounds */\n        get accentText() {\n            return this.accentText ||\n                (Stylesheet_Stylesheet.isBrightColor(this.accent) ?\n                    Stylesheet_Stylesheet.mixColors(this.accent, \"#000000\", .8) :\n                    \"#ffffff\");\n        },\n        set accentText(v) { this.accentText = v; },\n        /** Darker shade of the accent color */\n        get accentDark() {\n            return this.accentDark ||\n                Stylesheet_Stylesheet.mixColors(this.accent, \"#000000\", .2);\n        },\n        set accentDark(v) { this.accentDark = v; },\n        /** Lighter shade of the accent color */\n        get accentLight() {\n            return this.accentLight ||\n                Stylesheet_Stylesheet.mixColors(this.accent, \"#ffffff\", .2);\n        },\n        set accentLight(v) { this.accentLight = v; },\n        /** Link text color (defaults to `.blue`); set this property to change `.linkVisitedText` as well, _or_ set that directly to override the visited link text color */\n        get linkText() { return this.linkText || this.blue; },\n        set linkText(v) { this.linkText = v; },\n        /** Visited link text color (defaults to a darker version of link text) */\n        get linkVisitedText() {\n            return this.linkVisitedText ||\n                Stylesheet_Stylesheet.mixColors(this.linkText, \"#000000\", .35);\n        },\n        set linkVisitedText(v) { this.linkVisitedText = v; },\n        /** Title bar block color (defaults to `.darkerGray`); set this property to change `.titleBarText` as well, _or_ set that directly to override the title bar text color */\n        get titleBarBackground() { return this.titleBarBackground || this.darkerGray; },\n        set titleBarBackground(v) { this.titleBarBackground = v; },\n        /** Text color to be used on top of title bar blocks */\n        get titleBarText() {\n            return this.titleBarText ||\n                (Stylesheet_Stylesheet.isBrightColor(this.titleBarBackground) ?\n                    Stylesheet_Stylesheet.mixColors(this.titleBarBackground, \"#000000\", .8) :\n                    \"#ffffff\");\n        },\n        set titleBarText(v) { this.titleBarText = v; },\n        /** Selected but non-focused list item block color (defaults to `.darkGray`); set this property to change `.listSelectionText` as well, _or_ set that directly to override the selected list item text color */\n        get listSelectionBackground() { return this.listSelectionBackground || this.darkGray; },\n        set listSelectionBackground(v) { this.listSelectionBackground = v; },\n        /** Text color to be used on top of selected but non-focused list items */\n        get listSelectionText() {\n            return this.listSelectionText ||\n                (Stylesheet_Stylesheet.isBrightColor(this.listSelectionBackground) ?\n                    Stylesheet_Stylesheet.mixColors(this.listSelectionBackground, \"#000000\", .8) :\n                    \"#ffffff\");\n        },\n        set listSelectionText(v) { this.listSelectionText = v; },\n        /** Selected focused list item block color (defaults to darker version of `.listSelectionBackground`); set this property to change `.listSelectionFocusText` as well, _or_ set that directly to override the selected list item text color */\n        get listSelectionFocusBackground() {\n            return this.listSelectionFocusBackground ||\n                Stylesheet_Stylesheet.mixColors(this.listSelectionBackground, \"#000000\", .35);\n        },\n        set listSelectionFocusBackground(v) { this.listSelectionFocusBackground = v; },\n        /** Text color to be used on top of selected focused list items */\n        get listSelectionFocusText() {\n            return this.listSelectionFocusText ||\n                (Stylesheet_Stylesheet.isBrightColor(this.listSelectionFocusBackground) ?\n                    Stylesheet_Stylesheet.mixColors(this.listSelectionFocusBackground, \"#000000\", .8) :\n                    \"#ffffff\");\n        },\n        set listSelectionFocusText(v) { this.listSelectionFocusText = v; },\n        /** Control base color (defaults to `.lightGray`); set this property to change `.controlBaseText` as well, _or_ set that directly to override the control base text color */\n        get controlBase() { return this.controlBase || this.lightGray; },\n        set controlBase(v) { this.controlBase = v; },\n        /** Text color to be used for controls in base color */\n        get controlBaseText() {\n            return this.controlBaseText ||\n                (Stylesheet_Stylesheet.isBrightColor(this.controlBase) ?\n                    Stylesheet_Stylesheet.mixColors(this.controlBase, \"#000000\", .8) :\n                    \"#ffffff\");\n        },\n        set controlBaseText(v) { this.controlBaseText = v; },\n        /** Control focus color (defaults to a darker or lighter version of `.controlBase` depending on its lightness); set this property to change `.controlFocusText` as well, _or_ set that directly to override the text color for controls in focus color */\n        get controlFocus() {\n            return this.controlFocus ||\n                (Stylesheet_Stylesheet.isBrightColor(this.controlBase) ?\n                    Stylesheet_Stylesheet.mixColors(this.controlBase, \"#000000\", .5) :\n                    Stylesheet_Stylesheet.mixColors(this.controlBase, \"#ffffff\", .5));\n        },\n        set controlFocus(v) { this.controlFocus = v; },\n        /** Text color to be used for controls in focus color */\n        get controlFocusText() {\n            return this.controlFocusText ||\n                (Stylesheet_Stylesheet.isBrightColor(this.controlFocus) ?\n                    Stylesheet_Stylesheet.mixColors(this.controlFocus, \"#000000\", .8) :\n                    \"#ffffff\");\n        },\n        set controlFocusText(v) { this.controlFocusText = v; }\n    });\n    /** CSS reboot stylesheet that defines basic styles for common HTML elements (except those already overridden by `Component` renderers), _enabled by default_: applied as a live stylesheet at the page level for this instance; can be modified to adjust or add CSS reset styles, or disabled using the `.disable()` method if an external CSS reset stylesheet is already loaded */\n    Styles.rebootStyles = reboot_defaultExport;\n    /** Basic control theme stylesheet that uses colors from the `.color` object, _enabled by default_: applied as a live stylesheet at the page level for this instance; can be modified to adjust or add CSS reset styles, or disabled using the `.disable()` method if external CSS styles are already loaded */\n    Styles.controlStyles = controls_defaultExport;\n    /** @internal Add a component style sheet to `.components` and apply it to the DOM (using `new Stylesheet(...)` and `.applyStylesheet(...)`) */\n    function define(className, subStyles) {\n        var sheet = new Stylesheet_Stylesheet(className, subStyles);\n        Styles.components[className.replace(/.*\\s/, \"\")] = sheet;\n        applyStylesheet(sheet, true);\n    }\n    Styles.define = define;\n})(Styles_Styles || (Styles_Styles = {}));\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/DOM/DOMPageOptions.js\n/** Options that control page rendering */\nvar PAGE_OPTIONS = {\n    baseZIndex: 1000,\n    shadeTransition: 200,\n    shadeOpacity: .2,\n    shadeColor: \"#000\"\n};\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/UpdateContext.js\n\n\n\n/** Time (ms) to wait before animating appearance of sub-subcomponents */\nvar SUBCOMPONENT_ANIM_CUTOFF_MS = 2000;\n/** Max number of child components to animate */\nvar MAX_N_COMPONENT_ANIM = 100;\n/** @internal Represents the DOM updater context; stored in the component render output object, or in the rendering context owning scope (e.g. page renderer) */\nvar UpdateContext_UpdateContext = (function () {\n    /** Create a new updater context for given HTML parent element */\n    function UpdateContext(root) {\n        /** @internal Update sequence number */\n        this._updateID = 0;\n        if (!root)\n            throw new Error();\n        this.root = root;\n    }\n    /** Update the root element with given content (DOM nodes, render output, or components, which are rendered asynchronously); if the last argument is a string, it is used to select a different DOM node from the `elements` object of all render output instances (e.g. wrapper elements); returns a promise that is resolved when the DOM elements have actually been updated (although sub components may still not have been fully rendered) */\n    UpdateContext.prototype.updateAsync = function (content, useWrapper, animatePositionMS) {\n        var _this = this;\n        var components = this.components = [];\n        var nodes = this.nodes = [];\n        var id = ++this._updateID;\n        this._nAnim = 0;\n        // find Nodes for all given elements\n        var deferRender;\n        var seen = {};\n        for (var i = content.length - 1; i >= 0; i--) {\n            var item = content[i];\n            if (item) {\n                if (item instanceof Component_Component) {\n                    // remember this component, and prepare async rendering\n                    if (seen[item.uid])\n                        continue;\n                    components[i] = item;\n                    seen[item.uid] = true;\n                    var defer = this._renderComponent(item, nodes, i);\n                    if (defer) {\n                        if (!deferRender)\n                            deferRender = [];\n                        deferRender.push(defer);\n                    }\n                }\n                else if (item.isComponentOutput) {\n                    // remember owning component, and store output element\n                    var component = item.component;\n                    if (seen[component.uid])\n                        continue;\n                    seen[component.uid] = true;\n                    components[i] = component;\n                    nodes[i] = useWrapper && item.wrapper ||\n                        item.element;\n                }\n                else if (item instanceof Node) {\n                    // store given DOM node directly\n                    nodes[i] = item;\n                }\n            }\n        }\n        // schedule deferred rendering for components that are not rendered yet\n        if (deferRender) {\n            for (var deferIdx = deferRender.length - 1; deferIdx >= 0; deferIdx--) {\n                Defer_defer(deferRender[deferIdx]);\n            }\n        }\n        // return a Promise that resolves when child nodes have been updated\n        return new Promise_Promise(function (resolve) {\n            Defer_defer(function () {\n                resolve(true);\n                // run update (i.e. add/change/remove child nodes), if no other\n                // update was scheduled in the meantime\n                if (_this._updateID === id)\n                    _this._updateChildNodes(animatePositionMS);\n            });\n        });\n    };\n    /** @internal Acquire the rendered DOM node for given content, and place it in given array at given index; returns a function to be deferred if given component is not rendered yet */\n    UpdateContext.prototype._renderComponent = function (component, nodes, i) {\n        var _this = this;\n        if (component.getLastRenderedOutput() ||\n            component.renderOptions &&\n                component.renderOptions.synchronous) {\n            // store existing output element right away, or force sync render\n            var out = component.out;\n            nodes[i] = out && out.element;\n            return undefined;\n        }\n        else {\n            // store placeholder first, then resolve asynchronously\n            var placeholder = document.createComment(\"placeholder\");\n            nodes[i] = placeholder;\n            // depend on a dummy observable, to make sure the original\n            // .out depends on the nested component's .out eventually;\n            // but do not re-render (because the value remains undefined)\n            var o = unobserved(function () { return new Observable_ObservableValue(); });\n            o.value;\n            // return a callback to render asynchronously\n            return function () {\n                // change getter to add dependencies to existing observable\n                o.getter(function () {\n                    var out = component.out;\n                    var elt = out && out.element;\n                    if (placeholder.parentNode) {\n                        // placeholder is already in place\n                        placeholder.parentNode.replaceChild(elt, placeholder);\n                        unobserved(function () { _this._animateAppear(component); });\n                    }\n                    else {\n                        // rendered before placeholder was added\n                        nodes[i] = elt;\n                    }\n                }).update();\n            };\n        }\n    };\n    /** @internal Update child nodes */\n    UpdateContext.prototype._updateChildNodes = function (animatePositionMS) {\n        this._animateChildComponents(animatePositionMS);\n        // replace existing elements first\n        var nNodes = this.nodes.length;\n        var root = this.root, current = root.firstChild;\n        for (var i = 0; i < nNodes && current; i++) {\n            // skip over unmanaged nodes\n            if (current.hasAttribute &&\n                current.hasAttribute(UpdateContext.UNMANAGED_FLAG)) {\n                current = current.nextSibling;\n                i--;\n                continue;\n            }\n            // replace with target node\n            var node = this.nodes[i];\n            if (!node)\n                node = document.createComment(\"placeholder\");\n            node.removeAttribute &&\n                node.removeAttribute(UpdateContext.UNMANAGED_FLAG);\n            var next = current.nextSibling;\n            if (current !== node)\n                root.replaceChild(node, current);\n            if (next === node)\n                next = next.nextSibling;\n            current = next;\n        }\n        // delete trailing existing elements\n        while (current) {\n            var next = current.nextSibling;\n            if (!current.hasAttribute ||\n                !current.hasAttribute(UpdateContext.UNMANAGED_FLAG))\n                root.removeChild(current);\n            current = next;\n        }\n        // add new elements if needed\n        for (; i < nNodes; i++) {\n            var node = this.nodes[i];\n            if (!node)\n                node = document.createComment(\"placeholder\");\n            root.appendChild(node);\n        }\n        if (animatePositionMS > 0)\n            this._animateChildPositions(animatePositionMS);\n    };\n    /** @internal Animate differences with last update (appear/disappear) */\n    UpdateContext.prototype._animateChildComponents = function (animatePositionMS) {\n        var _this = this;\n        // find appearing and disappearing components using old arrays\n        var oldComponents = this._oldComponents;\n        var oldNodes = this._oldNodes;\n        this._oldComponents = this.components;\n        this._oldNodes = this.nodes;\n        this._timestamp = Date.now();\n        // if animating positions, get current coordinates first\n        if (animatePositionMS > 0)\n            this._saveChildPositions();\n        // animate appearances and disappearances\n        if (Animation.isEnabled) {\n            var cutoffTime = Date.now() - SUBCOMPONENT_ANIM_CUTOFF_MS;\n            for (var _i = 0, _a = this.components; _i < _a.length; _i++) {\n                var c = _a[_i];\n                // animate all items that were not there before\n                if (c && (!oldComponents ||\n                    !oldComponents.some(function (oldc) { return oldc === c; }))) {\n                    this._animateAppear(c);\n                    // animate existing sub components, if added >2s ago\n                    var nestedOut = c.getLastRenderedOutput();\n                    if (nestedOut) {\n                        if (nestedOut &&\n                            (nestedOut[\"@context\"] instanceof UpdateContext) &&\n                            nestedOut[\"@context\"]._timestamp < cutoffTime &&\n                            nestedOut[\"@context\"].components) {\n                            nestedOut[\"@context\"].components.forEach(function (nC) { _this._animateAppear(nC); });\n                        }\n                    }\n                }\n                if (this._nAnim > MAX_N_COMPONENT_ANIM)\n                    break;\n            }\n            if (oldComponents) {\n                var _loop_1 = function () {\n                    // animate and flag all items that are not there anymore\n                    c = oldComponents[i];\n                    if (c && c.animations && c.animations.disappear) {\n                        removeElement = oldNodes && oldNodes[i];\n                        if (removeElement && removeElement.nodeType === 1 &&\n                            !this_1.components.some(function (newc) { return newc === c; })) {\n                            var elt_1 = removeElement;\n                            elt_1.setAttribute(UpdateContext.UNMANAGED_FLAG, \"true\");\n                            this_1._nAnim++;\n                            playing = c.animations.disappear.playOnce(c);\n                            // apply component style manually here, since output\n                            // is no longer watched!\n                            lastOut = c.getLastRenderedOutput();\n                            cElt = lastOut && lastOut.element;\n                            cElt && applyStyleTo(c.style, cElt);\n                            // when done, check if not re-appeared, and remove\n                            playing.done.then(function () {\n                                if (elt_1.parentNode === _this.root &&\n                                    elt_1.hasAttribute(UpdateContext.UNMANAGED_FLAG)) {\n                                    if (animatePositionMS > 0)\n                                        _this._saveChildPositions();\n                                    _this.root.removeChild(elt_1);\n                                    if (animatePositionMS > 0)\n                                        _this._animateChildPositions(animatePositionMS);\n                                }\n                            });\n                        }\n                    }\n                    if (this_1._nAnim > MAX_N_COMPONENT_ANIM)\n                        return \"break\";\n                };\n                var this_1 = this, c, removeElement, playing, lastOut, cElt;\n                for (var i = 0, len = oldComponents.length; i < len; i++) {\n                    var state_1 = _loop_1();\n                    if (state_1 === \"break\")\n                        break;\n                }\n            }\n        }\n    };\n    /** @internal Helper function that plays the \"appear\" animation for given component, if any */\n    UpdateContext.prototype._animateAppear = function (component) {\n        this._nAnim++;\n        if (Animation.isEnabled &&\n            component && component.animations &&\n            component.animations.appear)\n            component.animations.appear.playOnce(component);\n    };\n    /** @internal Helper function to save current child positions, to be used by `_animateChildPositions` */\n    UpdateContext.prototype._saveChildPositions = function () {\n        var _this = this;\n        var oldXPos = this._oldXPos = {};\n        var oldYPos = this._oldYPos = {};\n        this.components.forEach(function (c, i) {\n            var elt = _this.nodes[i];\n            if (c && elt && elt.nodeType == 1) {\n                var rect = elt.getBoundingClientRect();\n                if (!rect || !rect.width || !rect.height)\n                    return;\n                oldXPos[c.uid] = rect.left;\n                oldYPos[c.uid] = rect.top;\n            }\n        });\n    };\n    /** @internal Animate position differences with last update (translate) */\n    UpdateContext.prototype._animateChildPositions = function (animatePositionsMS) {\n        var _this = this;\n        if (!this._oldXPos)\n            return;\n        var callbacks = [];\n        this.components.forEach(function (c, i) {\n            var elt = _this.nodes[i];\n            if (c && elt && elt.nodeType == 1 &&\n                _this._oldXPos[c.uid] >= 0) {\n                // calculate difference with old position before update\n                var rect = elt.getBoundingClientRect();\n                var diffX = _this._oldXPos[c.uid] - rect.left;\n                var diffY = _this._oldYPos[c.uid] - rect.top;\n                if (diffX || diffY) {\n                    elt.style.transition = \"\";\n                    elt.style.transform =\n                        \"translateX(\" + diffX + \"px) translateY(\" + diffY + \"px)\";\n                    callbacks.push(function () {\n                        elt.style.transition = \"transform \" +\n                            animatePositionsMS + \"ms ease\";\n                        elt.style.transform = \"translateX(0) translateY(0)\";\n                    });\n                }\n            }\n        });\n        // animate transition now\n        if (callbacks.length)\n            setTimeout(function () { return callbacks.forEach(function (f) { return f(); }); }, 0);\n        delete this._oldXPos;\n        delete this._oldYPos;\n    };\n    /** @internal DOM attribute used to signal that an element is managed outside the update context, and should be left alone while updating the parent element (e.g. elements being removed, or the modal shade element) */\n    UpdateContext.UNMANAGED_FLAG = \"render-unmanaged\";\n    return UpdateContext;\n}());\n\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Blocks/Block.js\nvar Blocks_Block___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Blocks_Block___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar CSS_CLASS = \"UI-Block\";\n/** @internal DOM-specific component renderer */\nvar Block_Renderer = (function (_super) {\n    Blocks_Block___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component, tagName) {\n        if (tagName === void 0) { tagName = \"div\"; }\n        var _this = _super.call(this, component) || this;\n        // initialize main DOM element(s)\n        _this.element = document.createElement(tagName);\n        // create the element update context\n        _this.context = new UpdateContext_UpdateContext(_this.element);\n        // add watchers for component properties\n        var positionStyle;\n        _this.watch(function () { return applyStyleTo(component.style, _this.element); });\n        _this.watch(function () { return component.focusMode; }, function (focusMode) {\n            if (focusMode === Component_Component.FocusMode.Auto) {\n                // make element focusable through the DOM\n                _this.element.tabIndex = 0;\n            }\n            else if (focusMode === Component_Component.FocusMode.Click) {\n                // make element focusable manually\n                _this.element.tabIndex = -1;\n            }\n            else {\n                // make element no longer focusable in the DOM directly\n                _this.element.removeAttribute(\"tabIndex\");\n            }\n        });\n        _this.watch(function () {\n            // get overlay position and translate ltr/rtl mode values\n            var pos = component.overlayPosition;\n            if (component.flowDirection === \"rtl\") {\n                if (pos === Block_Block.OverlayPosition.TopStart)\n                    return Block_Block.OverlayPosition.TopRight;\n                if (pos === Block_Block.OverlayPosition.TopEnd)\n                    return Block_Block.OverlayPosition.TopLeft;\n                if (pos === Block_Block.OverlayPosition.BottomStart)\n                    return Block_Block.OverlayPosition.BottomRight;\n                if (pos === Block_Block.OverlayPosition.BottomEnd)\n                    return Block_Block.OverlayPosition.BottomLeft;\n            }\n            else {\n                if (pos === Block_Block.OverlayPosition.TopStart)\n                    return Block_Block.OverlayPosition.TopLeft;\n                if (pos === Block_Block.OverlayPosition.TopEnd)\n                    return Block_Block.OverlayPosition.TopRight;\n                if (pos === Block_Block.OverlayPosition.BottomStart)\n                    return Block_Block.OverlayPosition.BottomLeft;\n                if (pos === Block_Block.OverlayPosition.BottomEnd)\n                    return Block_Block.OverlayPosition.BottomRight;\n            }\n            return pos;\n        }, function (pos) {\n            if (pos === undefined) {\n                // clear positioning styles if needed\n                positionStyle && positionStyle.set({\n                    position: \"\", top: \"\", left: \"\",\n                    bottom: \"\", right: \"\",\n                    marginTop: \"\", marginBottom: \"\",\n                    marginLeft: \"\", marginRight: \"\"\n                });\n                return;\n            }\n            if (!positionStyle) {\n                // override styles with positioning styles\n                component.style.override(positionStyle = new Style_Style());\n            }\n            // apply positioning styles (absolute position)\n            var top = \"auto\", bottom = \"auto\", left = \"auto\", right = \"auto\";\n            var marginLeft = \"\", marginRight = \"\";\n            switch (pos) {\n                case Block_Block.OverlayPosition.TopLeft:\n                    marginRight = \"auto\";\n                    top = left = \"0\";\n                    break;\n                case Block_Block.OverlayPosition.TopRight:\n                    marginLeft = \"auto\";\n                    top = right = \"0\";\n                    break;\n                case Block_Block.OverlayPosition.Top:\n                    marginLeft = marginRight = \"auto\";\n                    top = left = right = \"0\";\n                    break;\n                case Block_Block.OverlayPosition.BottomLeft:\n                    marginRight = \"auto\";\n                    bottom = left = \"0\";\n                    break;\n                case Block_Block.OverlayPosition.BottomRight:\n                    marginLeft = \"auto\";\n                    bottom = right = \"0\";\n                    break;\n                case Block_Block.OverlayPosition.Bottom:\n                    marginLeft = marginRight = \"auto\";\n                    bottom = left = right = \"0\";\n                    break;\n            }\n            positionStyle.set({\n                position: \"absolute\",\n                top: top, left: left, bottom: bottom, right: right,\n                marginLeft: marginLeft, marginRight: marginRight\n            });\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this) || new ComponentRenderer_ComponentRenderer.Output(this.component, this.element, this.context);\n        // set or update flow direction mode on context and element\n        this.context.flowDirection = this.component.flowDirection;\n        if (this.component.flowDirection) {\n            this.element.dir = this.component.flowDirection;\n        }\n        return out;\n    };\n    Renderer = Blocks_Block___decorate([\n        mapComponentRenderer(Block_Block)\n    ], Renderer);\n    return Renderer;\n}(ComponentRenderer_ComponentRenderer));\n\n// Add logic for focusing and blurring block components\ninject(Block_Block, {\n    \"@focusLiveComponent\": function () {\n        focus(this);\n    },\n    \"@blurLiveComponent\": function () {\n        blur(this);\n    }\n});\n// Add style override and apply style sheet\nBlock_Block.addStyleOverride(Style_Style.withClass(CSS_CLASS));\nStyles_Styles.define(CSS_CLASS, {\n    \".~~\": {\n        cursor: \"default\",\n        lineHeight: \"normal\",\n        display: \"block\",\n        position: \"relative\",\n        textAlign: \"start || left\",\n        margin: \"auto\",\n        transition: \"box-shadow 100ms ease\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/DOM/DOMBlock.js\nvar DOMBlock___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DOMBlock___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Base class name used for CSS style sheet */\nvar DOMBlock_CSS_CLASS = \"UI-DOMBlock\";\n/** Platform specific Block base class: full-width horizontal block containing DOM element(s) */\nvar DOMBlock_DOMBlock = (function (_super) {\n    DOMBlock___extends(DOMBlock, _super);\n    function DOMBlock() {\n        var elts = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            elts[_i] = arguments[_i];\n        }\n        var _this = _super.call(this) || this;\n        // lift all child nodes from a document fragment\n        if (elts && elts[0] && elts[0].nodeType === 11) {\n            var current = elts[0].firstChild;\n            var nodes = [];\n            while (current) {\n                nodes.push(current);\n                current = current.nextSibling;\n            }\n            _this.nodes = nodes;\n        }\n        else {\n            // just copy array of nodes\n            _this.nodes = elts;\n        }\n        return _this;\n    }\n    DOMBlock___decorate([\n        observable_not_null\n    ], DOMBlock.prototype, \"nodes\", void 0);\n    return DOMBlock;\n}(Block_Block));\n\n/** @internal DOM-specific component renderer */\nvar DOMBlock_Renderer = (function (_super) {\n    DOMBlock___extends(Renderer, _super);\n    function Renderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        // add all DOM nodes\n        out.updated = this.context.updateAsync(this.component.nodes);\n        return out;\n    };\n    Renderer = DOMBlock___decorate([\n        mapComponentRenderer(DOMBlock_DOMBlock)\n    ], Renderer);\n    return Renderer;\n}(Block_Renderer));\n\nDOMBlock_DOMBlock.addStyleOverride(Style_Style.withClass(DOMBlock_CSS_CLASS));\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/DOM/DOMAnimation.js\nvar DOMAnimation___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/** Represents a CSS keyframe animation */\nvar DOMAnimation_DOMAnimation = (function (_super) {\n    DOMAnimation___extends(DOMAnimation, _super);\n    /** Get an animation with given keyframes and given playback options ready for use */\n    function DOMAnimation(name, keyframes, options) {\n        if (keyframes === void 0) { keyframes = []; }\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, name) || this;\n        _this._options = options;\n        // declare all keyframes in the animation\n        _this._keyframesID = options._keyframes || _this.id;\n        if (!options._keyframes) {\n            // get style sheet with all keyframes\n            var sheet = new Stylesheet_Stylesheet();\n            keyframes.forEach(function (frame, i) {\n                var t = frame.t;\n                if (t === undefined)\n                    t = i / (keyframes.length - 1 || 1);\n                var perc = (Math.round(t * 1000) / 10) + \"%\";\n                var style = (frame.style instanceof Style_Style) ?\n                    frame.style : new Style_Style(frame.style);\n                sheet.define(\"@keyframes \" + _this.id + \"{\" + perc + \"}\", style);\n            });\n            applyStylesheet(sheet);\n        }\n        // declare the animation itself\n        var duration = 350, delay = 0, count = \"1\";\n        if (options.duration >= 0)\n            duration = options.duration;\n        if (options.delay >= 0)\n            delay = options.delay;\n        if (options.count === Infinity)\n            count = \"infinite\";\n        else if (options.count !== undefined)\n            count = String(options.count);\n        var cssText = _this._keyframesID + \" \" +\n            (options.specDuration >= 0 ? options.specDuration : duration) + \"ms \" +\n            delay + \"ms \" +\n            count + \" \" +\n            (options.direction || \"normal\") +\n            (options.ease ? \" ease\" : \"\") + \" forwards\";\n        applyStylesheet(new Stylesheet_Stylesheet(_this.id, {\n            \".~_playing\": {\n                animation: cssText,\n                webkitAnimation: cssText\n            }\n        }));\n        _this.duration = duration + delay;\n        _this._playingCSSText = cssText;\n        return _this;\n    }\n    /** Create a combined animation out of given key frame animations */\n    DOMAnimation.together = function () {\n        var animations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            animations[_i] = arguments[_i];\n        }\n        // find maximum duration from given animations, combine CSS\n        var duration = 0, cssTexts = [];\n        animations.forEach(function (a) {\n            cssTexts.push(a._playingCSSText);\n            if (a.duration > duration)\n                duration = a.duration;\n        });\n        var combinedCSSText = cssTexts.join(\", \");\n        // create a combined Animation class\n        var CombinedAnimation = (function (_super) {\n            DOMAnimation___extends(class_1, _super);\n            function class_1(name) {\n                var _this = _super.call(this, name) || this;\n                _this.duration = duration;\n                // define CSS class with combined CSS\n                var s = new Stylesheet_Stylesheet(_this.id, {\n                    \".~_playing\": {\n                        animation: combinedCSSText,\n                        webkitAnimation: combinedCSSText\n                    }\n                });\n                applyStylesheet(s);\n                return _this;\n            }\n            class_1.prototype.play = function (c) {\n                // reuse keyframe animation play method\n                return DOMAnimation.prototype.play.call(this, c);\n            };\n            return class_1;\n        }(Animation));\n        // return a singleton instance\n        return new CombinedAnimation(animations.map(function (a) { return (a && a.name); }).join(\"_and_\"));\n    };\n    /** Clone the animation with the same keyframes but with extra options */\n    DOMAnimation.prototype.clone = function (options) {\n        var clonedOptions = {\n            duration: options.duration >= 0 ?\n                options.duration : this._options.duration,\n            delay: options.delay >= 0 ?\n                options.delay : this._options.delay,\n            count: options.count >= 0 ?\n                options.count : this._options.count,\n            direction: options.direction ?\n                options.direction : this._options.direction,\n            ease: options.ease !== undefined ?\n                options.ease : this._options.ease,\n            _keyframes: this._keyframesID\n        };\n        return new DOMAnimation(this.name, undefined, clonedOptions);\n    };\n    /** Combine this animation with given key frame animations; this does *not* work for animations that use the same CSS property, such as `transform` (rotate, scale, translate...) */\n    DOMAnimation.prototype.togetherWith = function () {\n        var animations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            animations[_i] = arguments[_i];\n        }\n        return DOMAnimation.together.apply(DOMAnimation, [this].concat(animations));\n    };\n    /** Clone this animation and override timings */\n    DOMAnimation.prototype.withTiming = function (msDuration, msDelay) {\n        return this.clone({ duration: msDuration, delay: msDelay });\n    };\n    /** Clone this animation and specify to be played in reverse */\n    DOMAnimation.prototype.reverse = function () {\n        return this.clone({\n            direction: (this._options.direction &&\n                this._options.direction === \"reverse\") ?\n                \"normal\" : \"reverse\"\n        });\n    };\n    /** Play the animation once on given component */\n    DOMAnimation.prototype.play = function (component) {\n        var _this = this;\n        var control = { animation: this };\n        if (!Animation.isEnabled) {\n            // do not start, return bogus object\n            control.done = Promise_Promise.resolve(control);\n            control.stop = function () { };\n        }\n        else {\n            // start the animation\n            component.style.addClass(this.id + \"_playing\");\n            // this is technically not correct but good enough in most cases\n            // where the animation is triggered on an existing element, and\n            // avoids complicated event setup:\n            control.done = sleep(this.duration, control);\n            control.stop = function () {\n                component.style.removeClass(_this.id + \"_playing\");\n            };\n        }\n        return control;\n    };\n    return DOMAnimation;\n}(Animation));\n\n(function (DOMAnimation) {\n    var fadeIn = new DOMAnimation(\"fadeIn\", [\n        { style: { opacity: \"0\" } },\n        { style: { opacity: \"1\" } }\n    ]);\n    var fadeOut = fadeIn.reverse();\n    var slideInUp = new DOMAnimation(\"slideInUp\", [\n        { style: { transform: \"translateY(100%)\" } },\n        { style: { transform: \"translateY(0)\" } }\n    ]);\n    var fadeInUp = new DOMAnimation(\"fadeInUp\", [\n        { style: { opacity: \"0\", transform: \"translateY(50%)\" } },\n        { style: { opacity: \"1\", transform: \"translateY(0)\" } }\n    ]);\n    var slideOutDown = slideInUp.reverse();\n    var fadeOutDown = fadeInUp.reverse();\n    var slideInDown = new DOMAnimation(\"slideInDown\", [\n        { style: { transform: \"translateY(-100%)\" } },\n        { style: { transform: \"translateY(0)\" } }\n    ]);\n    var fadeInDown = new DOMAnimation(\"fadeInDown\", [\n        { style: { opacity: \"0\", transform: \"translateY(-50%)\" } },\n        { style: { opacity: \"1\", transform: \"translateY(0)\" } }\n    ]);\n    var slideOutUp = slideInDown.reverse();\n    var fadeOutUp = fadeInDown.reverse();\n    var slideInLeft = new DOMAnimation(\"slideInLeft\", [\n        { style: { transform: \"translateX(100%)\" } },\n        { style: { transform: \"translateX(0)\" } }\n    ]);\n    var fadeInLeft = new DOMAnimation(\"fadeInLeft\", [\n        { style: { opacity: \"0\", transform: \"translateX(50%)\" } },\n        { style: { opacity: \"1\", transform: \"translateX(0)\" } }\n    ]);\n    var slideOutRight = slideInLeft.reverse();\n    var fadeOutRight = fadeInLeft.reverse();\n    var slideInRight = new DOMAnimation(\"slideInRight\", [\n        { style: { transform: \"translateX(-100%)\" } },\n        { style: { transform: \"translateX(0)\" } }\n    ]);\n    var fadeInRight = new DOMAnimation(\"fadeInRight\", [\n        { style: { opacity: \"0\", transform: \"translateX(-50%)\" } },\n        { style: { opacity: \"1\", transform: \"translateX(0)\" } }\n    ]);\n    var slideOutLeft = slideInRight.reverse();\n    var fadeOutLeft = fadeInRight.reverse();\n    var scaleIn = new DOMAnimation(\"scaleIn\", [\n        { style: { transform: \"scale(0)\" } },\n        { style: { transform: \"scale(1)\" } }\n    ]);\n    var scaleOut = scaleIn.reverse();\n    var scaleInOver = new DOMAnimation(\"scaleInOver\", [\n        { style: { transform: \"scale(0)\" } },\n        { style: { transform: \"scale(1.15)\" }, t: .5 },\n        { style: { transform: \"scale(.95)\" }, t: .8 },\n        { style: { transform: \"scale(1)\" } }\n    ]);\n    var scaleOutOver = scaleInOver.reverse();\n    var turnInX = new DOMAnimation(\"turnInX\", [\n        { style: { transform: \"perspective(1000px) rotateX(90deg)\" } },\n        { style: { transform: \"perspective(1000px)\" } }\n    ]);\n    var turnOutX = new DOMAnimation(\"turnOutX\", [\n        { style: { transform: \"perspective(1000px)\" } },\n        { style: { transform: \"perspective(1000px) rotateX(90deg)\" } }\n    ]);\n    var turnInY = new DOMAnimation(\"turnInY\", [\n        { style: { transform: \"perspective(1000px) rotateY(90deg)\" } },\n        { style: { transform: \"perspective(1000px)\" } }\n    ]);\n    var turnOutY = new DOMAnimation(\"turnOutY\", [\n        { style: { transform: \"perspective(1000px)\" } },\n        { style: { transform: \"perspective(1000px) rotateY(90deg)\" } }\n    ]);\n    var growMaxHeight = new DOMAnimation(\"growMaxHeight\", [\n        { style: { maxHeight: \"0\", animationTimingFunction: \"cubic-bezier(0.5, 0, 1, 0.5)\" } },\n        { style: { maxHeight: \"5000px\", animationTimingFunction: \"cubic-bezier(0.5, 0, 1, 0.5)\" } }\n    ], { duration: 800 });\n    var shrinkMaxHeight = new DOMAnimation(\"shrinkMaxHeight\", [\n        { style: { maxHeight: \"5000px\", animationTimingFunction: \"cubic-bezier(0, 0.5, 0.5, 1)\" } },\n        { style: { maxHeight: \"0\", animationTimingFunction: \"cubic-bezier(0, 0.5, 0.5, 1)\" } },\n    ], { duration: 800 });\n    var growMaxWidth = new DOMAnimation(\"growMaxWidth\", [\n        { style: { maxWidth: \"0\", animationTimingFunction: \"cubic-bezier(0.5, 0, 1, 0.5)\" } },\n        { style: { maxWidth: \"5000px\", animationTimingFunction: \"cubic-bezier(0.5, 0, 1, 0.5)\" } }\n    ], { duration: 800 });\n    var shrinkMaxWidth = new DOMAnimation(\"shrinkMaxWidth\", [\n        { style: { maxWidth: \"5000px\", animationTimingFunction: \"cubic-bezier(0, 0.5, 0.5, 1)\" } },\n        { style: { maxWidth: \"0\", animationTimingFunction: \"cubic-bezier(0, 0.5, 0.5, 1)\" } },\n    ], { duration: 800 });\n    var highlightYellow = new DOMAnimation(\"highlightYellow\", [\n        { style: { background: \"#ffc\" } },\n        { style: { background: \"#ffa\" } },\n        { style: { background: \"transparent\" } }\n    ]);\n    var jumpOut = new DOMAnimation(\"jumpOut\", [\n        { style: { transform: \"scale(.9)\" } },\n        { style: { transform: \"scale(1.2)\" } },\n        { style: { transform: \"scale(.9)\" }, t: .9 },\n        { style: { transform: \"scale(1)\" } }\n    ]);\n    var jumpIn = new DOMAnimation(\"jumpIn\", [\n        { style: { transform: \"scale(1.05)\" } },\n        { style: { transform: \"scale(.9)\" } },\n        { style: { transform: \"scale(1.05)\" }, t: .9 },\n        { style: { transform: \"scale(1)\" } }\n    ]);\n    /** List of basic animations [implementation] */\n    DOMAnimation.basic = {\n        in: {\n            fade: fadeIn,\n            fadeUp: fadeInUp,\n            fadeDown: fadeInDown,\n            fadeLeft: fadeInLeft,\n            fadeRight: fadeInRight,\n            slideUp: slideInUp,\n            slideDown: slideInDown,\n            slideLeft: slideInLeft,\n            slideRight: slideInRight,\n            scale: scaleIn,\n            scaleOver: scaleInOver,\n            turnX: turnInX,\n            turnY: turnInY,\n            maxHeight: growMaxHeight,\n            maxWidth: growMaxWidth\n        },\n        out: {\n            fade: fadeOut,\n            fadeUp: fadeOutUp,\n            fadeDown: fadeOutDown,\n            fadeLeft: fadeOutLeft,\n            fadeRight: fadeOutRight,\n            slideUp: slideOutUp,\n            slideDown: slideOutDown,\n            slideLeft: slideOutLeft,\n            slideRight: slideOutRight,\n            scale: scaleOut,\n            scaleOver: scaleOutOver,\n            turnX: turnOutX,\n            turnY: turnOutY,\n            maxHeight: shrinkMaxHeight,\n            maxWidth: shrinkMaxWidth,\n        },\n        highlight: {\n            yellow: highlightYellow,\n            jumpOut: jumpOut, jumpIn: jumpIn\n        }\n    };\n})(DOMAnimation_DOMAnimation || (DOMAnimation_DOMAnimation = {}));\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/DOM/main.js\n\n\n\n\n/** @internal Create a <div> element with given class name and node */\nfunction main_div(className, node) {\n    var result = document.createElement(\"div\");\n    if (className)\n        result.className = className;\n    if (node)\n        result.appendChild(node);\n    return result;\n}\n/** Returns true if given component contains given DOM node */\nfunction contains(component, node) {\n    // only return true if component output DOM element is equal to the\n    // given DOM element, or logically contains it\n    var out = component.getLastRenderedOutput();\n    return !!(out && out.element && (node === out.element ||\n        node.compareDocumentPosition(out.element) & 8));\n}\n// wait for load event, or 1s after DOMContentLoaded (wait for CSS to load\n// to avoid flash of unstyled content-- but not too long), or resolve right\n// away if everything is already loaded:\nwindow.addEventListener(\"load\", function () { Screen_Screen.resolveReady(true); });\ndocument.addEventListener(\"DOMContentLoaded\", function (event) {\n    sleep(1000).then(function () { Screen_Screen.resolveReady(true); });\n});\nif (document.readyState === \"complete\")\n    Screen_Screen.resolveReady(true);\n// apply CSS reset\nScreen_Screen.ready.then(function () {\n    applyStylesheet({\n        \"[hidden]\": { display: \"none !important\" },\n        \"*\": { boxSizing: \"border-box\" }\n    });\n    applyStylesheet(Styles_Styles.rebootStyles, true);\n    applyStylesheet(Styles_Styles.controlStyles, true);\n});\n// listen for changes in window size:\nvar deferredDimensionsUpdate;\nwindow.addEventListener(\"resize\", function () {\n    if (!deferredDimensionsUpdate) {\n        deferredDimensionsUpdate = setTimeout(function () {\n            deferredDimensionsUpdate = undefined;\n            updateDimensions();\n        }, 50);\n    }\n});\nfunction updateDimensions() {\n    // write to `.dimensions` properties, ignore readonly modifier\n    var width = window.innerWidth;\n    var height = window.innerHeight;\n    if (width && height) {\n        Screen_Screen.dimensions.width = width;\n        Screen_Screen.dimensions.height = height;\n        return true;\n    }\n}\nfunction startUpdateDimensions() {\n    if (!updateDimensions())\n        setTimeout(startUpdateDimensions, 200);\n}\nstartUpdateDimensions();\n// Inject element measurement function into Component class\ninject(Component_Component, {\n    getActualDimensions: function () {\n        var out = this.getLastRenderedOutput();\n        var elt = out && out.element;\n        if (elt) {\n            // take current height & width from actual component\n            return {\n                height: elt.offsetHeight,\n                width: elt.offsetWidth\n            };\n        }\n        else {\n            // return 0x0 since nothing is visible\n            return { height: 0, width: 0 };\n        }\n    }\n});\n// CustomEvent polyfill (source: MDN)\n(function () {\n    try {\n        new CustomEvent(\"test\");\n    }\n    catch (all) {\n        var C = function (event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: undefined };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, !!params.bubbles, !!params.cancelable, params.detail);\n            return evt;\n        };\n        window[\"CustomEvent\"] = C;\n        C.prototype = window.Event.prototype;\n    }\n})();\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/DOM/Focus.js\n\n\n\n// Inject focus state logic\ninject(Component_Component, {\n    \"@getLiveComponentFocusState\": function () {\n        var focused = document.activeElement;\n        return !!(focused && contains(this, focused));\n    }\n});\n/** Element to focus as soon as it becomes available (see `focus(...)`) */\nvar toFocusASAP;\n/** Try to focus given component, its live element (from rendered output), or the first focusable element within given component, as soon as it becomes available */\nfunction focus(component) {\n    component.getRenderedOutputAsync().then(function (out) {\n        if (!out.element)\n            return;\n        // check which element to set focus to\n        var focusable;\n        if (out.element.hasAttribute &&\n            out.element.hasAttribute(\"tabindex\")) {\n            // use element itself\n            focusable = out.element;\n        }\n        else if (out.liveElement) {\n            // use live element from output\n            focusable = out.liveElement;\n        }\n        else {\n            // find focusable elements (not hidden and parent(s) not hidden)\n            var elts = out.element.querySelectorAll(\"[tabindex],a[href],input:not([disabled]),\" +\n                \"button:not([disabled]),textarea:not([disabled]),\" +\n                \"select:not([disabled])\");\n            for (var _i = 0, elts_1 = elts; _i < elts_1.length; _i++) {\n                var element = elts_1[_i];\n                if (!element)\n                    continue;\n                var hidden = false, cur = element;\n                while (cur && !hidden) {\n                    if (cur.hasAttribute && cur.hasAttribute(\"hidden\"))\n                        hidden = true;\n                    cur = cur.parentElement;\n                }\n                if (!hidden) {\n                    focusable = cur;\n                    break;\n                }\n            }\n        }\n        // focus the (first focusable) element found\n        if (focusable) {\n            toFocusASAP = focusable;\n            var tries = 0;\n            var doFocus_1 = function () {\n                if (toFocusASAP !== focusable)\n                    return;\n                if (toFocusASAP && document.activeElement !== toFocusASAP) {\n                    // try to focus the element and keep checking back\n                    toFocusASAP.focus();\n                    if (tries++ < 10)\n                        window.setTimeout(doFocus_1, tries * 2);\n                }\n                else {\n                    // managed to focus the element, forget about it:\n                    toFocusASAP = undefined;\n                }\n            };\n            doFocus_1();\n        }\n    });\n}\n/** Remove focus from given component, or the currently focused element */\nfunction blur(component) {\n    var focused = document.activeElement;\n    if (focused) {\n        // do not blur if not contained by given component\n        if (component && !contains(component, focused))\n            return;\n        // blur the currently focused element\n        focused && focused.blur && focused.blur();\n    }\n}\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/DOM/index.js\nvar DOM_namespaceObject = {};\n__webpack_require__.d(DOM_namespaceObject, \"uid\", function() { return uid; });\n__webpack_require__.d(DOM_namespaceObject, \"Stylesheet\", function() { return Stylesheet_Stylesheet; });\n__webpack_require__.d(DOM_namespaceObject, \"applyStylesheet\", function() { return applyStylesheet; });\n__webpack_require__.d(DOM_namespaceObject, \"applyStyleTo\", function() { return applyStyleTo; });\n__webpack_require__.d(DOM_namespaceObject, \"setCSSRemSize\", function() { return setCSSRemSize; });\n__webpack_require__.d(DOM_namespaceObject, \"setSelectionClass\", function() { return setSelectionClass; });\n__webpack_require__.d(DOM_namespaceObject, \"getSelectionClass\", function() { return getSelectionClass; });\n__webpack_require__.d(DOM_namespaceObject, \"loadExternalCSS\", function() { return loadExternalCSS; });\n__webpack_require__.d(DOM_namespaceObject, \"Styles\", function() { return Styles_Styles; });\n__webpack_require__.d(DOM_namespaceObject, \"PAGE_OPTIONS\", function() { return PAGE_OPTIONS; });\n__webpack_require__.d(DOM_namespaceObject, \"DOMBlock\", function() { return DOMBlock_DOMBlock; });\n__webpack_require__.d(DOM_namespaceObject, \"Renderer\", function() { return DOMBlock_Renderer; });\n__webpack_require__.d(DOM_namespaceObject, \"DOMAnimation\", function() { return DOMAnimation_DOMAnimation; });\n__webpack_require__.d(DOM_namespaceObject, \"focus\", function() { return focus; });\n__webpack_require__.d(DOM_namespaceObject, \"blur\", function() { return blur; });\n__webpack_require__.d(DOM_namespaceObject, \"div\", function() { return main_div; });\n__webpack_require__.d(DOM_namespaceObject, \"contains\", function() { return contains; });\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Drag.js\nvar Drag___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/** The distance to move before the `.moved` promise gets resolved */\nvar PX_MOVE_THRESHOLD = 4;\n/** The pace (ms) at which mouse move events take effect */\nvar MOUSE_MOVE_PACE = 20;\n/** Represents a drag operation in the DOM context */\nvar Drag_DOMDrag = (function (_super) {\n    Drag___extends(DOMDrag, _super);\n    /** Initialize the operation and start tracking mouse movement, sends drag start event to given target DOM element; starts sending drag enter and drag leave events as well */\n    function DOMDrag(event /* TODO: | TouchEvent */) {\n        var _this = _super.call(this) || this;\n        // shadow properties for x and y\n        _this._curX = new Observable_ObservableValue();\n        _this._curY = new Observable_ObservableValue();\n        _this._curX.value = _this._origX = event.clientX;\n        _this._curY.value = _this._origY = event.clientY;\n        var target = event.currentTarget;\n        if (!target)\n            throw new TypeError();\n        target.setCapture && target.setCapture();\n        _this._origTarget = target;\n        _this.moved = new Promise_Promise(function (resolve) {\n            _this._moved_resolve = resolve;\n        });\n        // this function is overridden when constraining movement\n        _this._setCoords = function (x, y) {\n            _this._curX.value = x;\n            _this._curY.value = y;\n        };\n        // this function is overridden when picking up an element\n        _this._getTarget = function (x, y) { return document.elementFromPoint(x, y); };\n        // send event to top level element to wake up listeners\n        var uiDragStart = new CustomEvent(\"uidragstart\", { bubbles: true, cancelable: true, detail: _this.detail });\n        if (target.dispatchEvent(uiDragStart))\n            addListeners();\n        else\n            _this.cancel();\n        return _this;\n    }\n    Object.defineProperty(DOMDrag.prototype, \"x\", {\n        /** Current viewport X coordinate (read-only observable, constrained) */\n        get: function () { return this._curX.value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DOMDrag.prototype, \"y\", {\n        /** Current viewport Y coordinate (read-only observable, constrained) */\n        get: function () { return this._curY.value; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Constrain effective drag coordinates on (original) X and/or Y axis of the viewport, and/or contrain to stay within given element on screen (calling this method twice does not constrain further, but the constraints are replaced) */\n    DOMDrag.prototype.constrain = function (constrainX, constrainY, component) {\n        var _this = this;\n        // find the element to constrain to\n        var baseElt = this._currentTarget || this._origTarget;\n        var constrainElt;\n        if (component) {\n            var out = component.getLastRenderedOutput();\n            if (out && out.element) {\n                constrainElt = baseElt = out.element;\n            }\n        }\n        var origRect = baseElt.getBoundingClientRect ?\n            baseElt.getBoundingClientRect() : { left: 0, top: 0 };\n        var baseX = (this._curX.value - origRect.left) + (baseElt.scrollLeft || 0);\n        var baseY = (this._curY.value - origRect.top) + (baseElt.scrollTop || 0);\n        this._setCoords = function (x, y) {\n            var currentRect = baseElt.getBoundingClientRect();\n            // constrain on X and/or Y axis\n            if (constrainX)\n                x = (baseX - baseElt.scrollLeft) + currentRect.left;\n            if (constrainY)\n                y = (baseY - baseElt.scrollTop) + currentRect.top;\n            // constrain to element on screen\n            if (constrainElt) {\n                if (x < currentRect.left)\n                    x = currentRect.left;\n                if (x > currentRect.right)\n                    x = currentRect.right;\n                if (y < currentRect.top)\n                    y = currentRect.top;\n                if (y > currentRect.bottom)\n                    y = currentRect.bottom;\n            }\n            _this._curX.value = x < 0 ? 0 : x;\n            _this._curY.value = y < 0 ? 0 : y;\n        };\n        // constrain coordinates now\n        this._setCoords(this._curX.value, this._curY.value);\n    };\n    /** Make given component follow the mouse cursor while dragging; if the component does not contain a fixed-position element, the element style will be changed to use fixed absolute positioning, and a placholder will be inserted instead */\n    DOMDrag.prototype.pickUp = function (component, removeWhenDone) {\n        var _this = this;\n        var element;\n        if (component) {\n            var out = component.getLastRenderedOutput();\n            if (out)\n                element = out.element;\n        }\n        if (!element)\n            throw new TypeError();\n        if (!element.parentNode)\n            return;\n        // override component style to move it around\n        var override = component[\"@_DOMDrag_Override\"];\n        if (!override) {\n            override = component[\"@_DOMDrag_Override\"] = new Style_Style({\n                position: \"fixed\",\n                bottom: \"auto\", right: \"auto\"\n            });\n            component.style.override(override);\n        }\n        // figure out (and fix) the element's position\n        var rect = element.getBoundingClientRect();\n        var oX = this._curX.value - rect.left;\n        var oY = this._curY.value - rect.top;\n        var placeholder = document.getElementById(\"__drag_placeholder_\" + component.uid);\n        if (!placeholder) {\n            placeholder = main_div(\"__drag_placeholder\");\n            placeholder.id = \"__drag_placeholder_\" + component.uid;\n            placeholder.style.fontSize = \"0\";\n            placeholder.style.lineHeight = \"0\";\n            placeholder.style.height = rect.height + \"px\";\n            placeholder.style.width = rect.width + \"px\";\n            placeholder.style.margin = element.style.margin;\n            element.parentNode.insertBefore(placeholder, element);\n        }\n        override.set({ left: oX + \"px\", top: oY + \"px\" });\n        // move element while dragging\n        observe(function () { return ({\n            left: (_this._curX.value - oX) + \"px\",\n            top: (_this._curY.value - oY) + \"px\"\n        }); }).subscribe(function (style) {\n            override.set(style);\n        });\n        // look \"through\" element when checking on target\n        this._getTarget = function (x, y) {\n            element.setAttribute(\"hidden\", \"hidden\");\n            var result = document.elementFromPoint(x, y);\n            element.removeAttribute(\"hidden\");\n            return result;\n        };\n        // remove element when done\n        if (removeWhenDone) {\n            var removeElts = function () { return element.parentNode &&\n                element.parentNode.removeChild(element) &&\n                placeholder.parentNode.removeChild(placeholder); };\n            this.Dropped.connect(removeElts);\n            this.Canceled.connect(removeElts);\n        }\n    };\n    /** Stop the current drag operation */\n    DOMDrag.prototype.cancel = function () {\n        this._origTarget.releaseCapture &&\n            this._origTarget.releaseCapture();\n        _super.prototype.cancel.call(this);\n        // also send (bubbling!) uidragleave for symmetry\n        var uiDragLeave = new CustomEvent(\"uidragleave\", { bubbles: true, detail: this.detail });\n        this._currentTarget && this._currentTarget.dispatchEvent(uiDragLeave);\n        // remove mouse listeners if not dragging anymore\n        if (!Drag_Drag.getCurrentInstances().length)\n            removeListeners();\n    };\n    /** Accept the current drop target (i.e. perform the drop, primarily called automatically by mouseup handler but can be called manually); sends drop event to drop target element */\n    DOMDrag.prototype.drop = function () {\n        this._origTarget.releaseCapture &&\n            this._origTarget.releaseCapture();\n        // send event to drop target to confirm\n        var uiDragDrop = new CustomEvent(\"uidragdrop\", { bubbles: true, cancelable: true, detail: this.detail });\n        var canceled = !(this._currentTarget &&\n            this._currentTarget.dispatchEvent(uiDragDrop));\n        if (canceled) {\n            this.cancel();\n            return;\n        }\n        _super.prototype.drop.call(this);\n        // also send (bubbling!) uidragleave for symmetry\n        var uiDragLeave = new CustomEvent(\"uidragleave\", { bubbles: true, detail: this.detail });\n        this._currentTarget && this._currentTarget.dispatchEvent(uiDragLeave);\n        // remove mouse listeners if not dragging anymore\n        if (!Drag_Drag.getCurrentInstances().length)\n            removeListeners();\n    };\n    /** Update mouse cursor screen coordinates (primarily called by mousemove handler); returns true if an element was scrolled - meaning update should be called again after a short time */\n    DOMDrag.prototype.update = function (x, y) {\n        var _this = this;\n        var oldX = this._curX.value;\n        var oldY = this._curY.value;\n        this._setCoords(x, y);\n        var newX = this._curX.value, newY = this._curY.value;\n        // get target element and scroll if needed\n        var target = this._getTarget(newX, newY);\n        var cur = target;\n        var scrolled = false;\n        while (cur && !scrolled) {\n            var curStyle;\n            if (cur.nodeType == 1 &&\n                (curStyle = window.getComputedStyle(cur)) &&\n                curStyle.getPropertyValue(\"overflow\") !== \"hidden\") {\n                var rect = cur.getBoundingClientRect();\n                if (newX < rect.left + 32 && cur.scrollLeft > 0) {\n                    cur.scrollLeft = Math.max(0, cur.scrollLeft - 8);\n                    scrolled = true;\n                }\n                if (newY < rect.top + 32 && cur.scrollTop > 0) {\n                    cur.scrollTop = Math.max(0, cur.scrollTop - 8);\n                    scrolled = true;\n                }\n                if (newX > rect.right - 32 &&\n                    cur.scrollLeft < cur.scrollWidth - cur.clientWidth) {\n                    cur.scrollLeft = cur.scrollLeft + 8;\n                    scrolled = true;\n                }\n                if (newY > rect.bottom - 32 &&\n                    cur.scrollTop < cur.scrollHeight - cur.clientHeight) {\n                    cur.scrollTop = cur.scrollTop + 8;\n                    scrolled = true;\n                }\n            }\n            cur = cur.parentNode;\n        }\n        if (scrolled) {\n            // might have scrolled to a new (child) target\n            target = this._getTarget(newX, newY);\n        }\n        if (oldX !== newX || oldY !== newY) {\n            // check if only now moving far enough\n            if (!this._moved &&\n                (Math.abs(newX - this._origX) > PX_MOVE_THRESHOLD ||\n                    Math.abs(this._origY - newY) > PX_MOVE_THRESHOLD)) {\n                this._moved = true;\n                this._moved_resolve(this);\n            }\n            // inform old and new potential drop target(s)\n            var oldTarget = this._currentTarget;\n            this._currentTarget = target;\n            if (this._currentTarget && this._currentTarget !== oldTarget) {\n                // find old drop targets that do not contain new drop target\n                var leftTargets = [];\n                while (oldTarget) {\n                    // stop if the old target contains the new target\n                    if (target.compareDocumentPosition(oldTarget) & 8)\n                        break;\n                    // otherwise send a non-bubbling \"leave\" event (in reverse)\n                    leftTargets.unshift(oldTarget);\n                    // go up to parent element\n                    do {\n                        oldTarget = oldTarget.parentNode;\n                    } while (oldTarget && !oldTarget.dispatchEvent);\n                }\n                leftTargets.forEach(function (elt) {\n                    elt.dispatchEvent(new CustomEvent(\"uidragleave\", { detail: _this.detail }));\n                });\n                // oldTarget is now the closest old parent, or null;\n                // find new drop targets (child elements, up to shared parent)\n                var enteredTargets = [];\n                while (target && target !== oldTarget) {\n                    // send a non-bubbling \"enter\" event (in reverse)\n                    enteredTargets.unshift(target);\n                    // go up to parent element\n                    do {\n                        target = target.parentNode;\n                    } while (target && !target.dispatchEvent);\n                }\n                enteredTargets.forEach(function (elt) {\n                    elt.dispatchEvent(new CustomEvent(\"uidragenter\", { detail: _this.detail }));\n                });\n            }\n        }\n        return scrolled;\n    };\n    return DOMDrag;\n}(Drag_Drag));\n// use this class as the primary Drag class:\nDrag_Drag.BaseClass = Drag_DOMDrag;\n// mousemove pacer timer (fires only after delay to improve performance)\nvar mouseMovePacer;\nvar lastMouseMove;\n// mousemove event handler, updates current drag coordinates\nfunction onMouseMove(event) {\n    function doUpdate() {\n        if (lastMouseMove) {\n            var x = lastMouseMove.clientX;\n            var y = lastMouseMove.clientY;\n            try {\n                Drag_Drag.getCurrentInstances().forEach(function (drag) {\n                    drag.update(x, y);\n                });\n            }\n            finally {\n                runYield();\n            }\n        }\n    }\n    // pace updates, except for first one to avoid delay\n    var firstUpdate = !lastMouseMove;\n    lastMouseMove = event;\n    if (firstUpdate) {\n        doUpdate();\n    }\n    else if (!mouseMovePacer) {\n        mouseMovePacer = window.setTimeout(function () {\n            var scrolled = doUpdate();\n            mouseMovePacer = undefined;\n            if (scrolled)\n                onMouseMove(lastMouseMove);\n        }, MOUSE_MOVE_PACE);\n    }\n}\n// mouseup handler to capture drop events\nfunction onMouseUp() {\n    Drag_Drag.getCurrentInstances().forEach(function (d) { return d.drop(); });\n    runYield();\n}\n// if mouse moves out of the window while dragging, cancel drag\nfunction onMouseOut(event) {\n    var movedTo = event.relatedTarget;\n    if (!movedTo || movedTo.nodeName == \"HTML\")\n        Drag_Drag.getCurrentInstances().forEach(function (d) { return d.cancel(); });\n}\n// cancel drag when esc key is pressed\nfunction onKeyDown(event) {\n    if (event.keyCode == 27) {\n        Drag_Drag.getCurrentInstances().forEach(function (d) { return d.cancel(); });\n    }\n}\n// cancel text selection\nvar old_onSelectStart;\n// helper used to remove event listeners and pacer timer\nfunction removeListeners() {\n    document.removeEventListener(\"mousemove\", onMouseMove);\n    document.removeEventListener(\"mouseup\", onMouseUp);\n    document.removeEventListener(\"mouseout\", onMouseOut);\n    document.removeEventListener(\"keydown\", onKeyDown);\n    document.onselectstart = old_onSelectStart;\n    mouseMovePacer && window.clearTimeout(mouseMovePacer);\n    mouseMovePacer = undefined;\n    lastMouseMove = undefined;\n}\n// helper used to add event listeners when actually dragging\nfunction addListeners() {\n    document.addEventListener(\"mousemove\", onMouseMove);\n    document.addEventListener(\"mouseup\", onMouseUp);\n    document.addEventListener(\"mouseout\", onMouseOut);\n    document.addEventListener(\"keydown\", onKeyDown);\n    old_onSelectStart = document.onselectstart;\n    document.onselectstart = function () { return false; };\n}\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/PageRenderer.js\nvar PageRenderer___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar PageRenderer___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Contains functionality for rendering a page to the DOM; implementation of the PageRenderer class, used by Page to perform platform dependent tasks */\nvar PageRenderer_DOMPageRenderer = (function (_super) {\n    PageRenderer___extends(DOMPageRenderer, _super);\n    function DOMPageRenderer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** @internal Bound keydown event handler (on the window) */\n        _this._onKeydown = function (event) {\n            if (_this._onEvent(event) !== false) {\n                _this.KeyDown(event);\n                // invoke top component's onEsc handler when escape is pressed\n                if (event.keyCode === 27)\n                    _this.page.handleEsc();\n            }\n        };\n        /** @internal Bound event handler (on the window) */\n        _this._onEvent = function (event) {\n            if (_this._isBlocked) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n                return false;\n            }\n        };\n        return _this;\n    }\n    Object.defineProperty(DOMPageRenderer.prototype, \"domUpdater\", {\n        /** DOM update context for the rendered page (memoized) */\n        get: function () {\n            // create the page root element\n            var root = main_div(\"__page\");\n            root.id = uid;\n            root.style.position = \"absolute\";\n            root.style.zIndex = String(PAGE_OPTIONS.baseZIndex);\n            // create the update context for the page root element\n            return new UpdateContext_UpdateContext(root);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Render and show the page (within an observable getter); returns a promise that is resolved when all content has been rendered */\n    DOMPageRenderer.prototype.updateAsync = function () {\n        var _this = this;\n        // attach keydown handler to the window\n        window.removeEventListener(\"keydown\", this._onKeydown);\n        window.addEventListener(\"keydown\", this._onKeydown);\n        // reset reference to currently shaded wrapper\n        this._shadedWrapper = undefined;\n        // take flow direction from screen if not defined on page\n        if (!this.page.flowDirection && Screen_Screen.defaultFlowDirection) {\n            unobserved(function () {\n                _this.page.flowDirection = Screen_Screen.defaultFlowDirection;\n            });\n        }\n        // render all content into DOM nodes\n        var content = [];\n        var components = this.page.content.slice();\n        components.forEach(function (c) {\n            // copy ltr/rtl flow direction if set at page level\n            if (c && _this.page.flowDirection) {\n                unobserved(function () {\n                    c.flowDirection = _this.page.flowDirection;\n                });\n            }\n            // render component synchronously\n            var out = c && c.out;\n            var element = out && out.element;\n            if (element instanceof HTMLElement) {\n                // update existing wrapper element, or create one\n                var wrapper = out.wrapper;\n                if (!wrapper || wrapper.className !== \"__page_wrapper\")\n                    wrapper = out.wrapper = _this._createWrapper();\n                _this._updateWrapper(element, wrapper, c[\"displayOptions\"], c.style, c instanceof Container_Container);\n                // add the rendered output instance to the list\n                content.push(out);\n            }\n            else {\n                // use a placeholder to stop elements from shifting around\n                content.push(document.createComment(\"placeholder\"));\n                return;\n            }\n        });\n        // append the page element to the document body, if needed\n        var updater = this.domUpdater;\n        if (!updater.root.parentNode)\n            document.body.appendChild(this.domUpdater.root);\n        // add all content to the page element (using generated wrappers)\n        return updater.updateAsync(content, true).then(function () {\n            _this.page.Rendered();\n            _this._moveShadeElement();\n        });\n    };\n    /** Remove the rendered page from the screen */\n    DOMPageRenderer.prototype.remove = function () {\n        // remove the page element itself\n        var root = this.domUpdater.root;\n        if (root.parentNode)\n            root.parentNode.removeChild(root);\n        // remove keydown window event handler\n        window.removeEventListener(\"keydown\", this._onKeydown, true);\n        // clean up references\n        delete this._topOptions;\n        delete this._shadedWrapper;\n    };\n    /** Block all input */\n    DOMPageRenderer.prototype.disableInput = function () {\n        // unfocus and set flag\n        blur();\n        this._isBlocked = true;\n        // add blocking event handlers on the window (on capture)\n        window.addEventListener(\"mousedown\", this._onEvent, true);\n        window.addEventListener(\"focus\", this._onEvent, true);\n        window.addEventListener(\"input\", this._onEvent, true);\n        window.addEventListener(\"selectstart\", this._onEvent, true);\n        // add overlay element to wrap over existing content\n        if (!this._blockElement) {\n            var blocker = this._blockElement = main_div(\"__page_block\");\n            blocker.style.position = \"fixed\";\n            blocker.style.top = \"0\";\n            blocker.style.bottom = \"0\";\n            blocker.style.left = \"0\";\n            blocker.style.right = \"0\";\n            blocker.style.cursor = \"wait\";\n            blocker.style.zIndex = \"1000000000\";\n            blocker.style.background = \"rgba(0,0,0,0)\"; // for IE\n        }\n        document.body.appendChild(this._blockElement);\n    };\n    /** Unblock all input */\n    DOMPageRenderer.prototype.enableInput = function () {\n        this._isBlocked = false;\n        // remove overlay element\n        if (this._blockElement && this._blockElement.parentNode)\n            this._blockElement.parentNode.removeChild(this._blockElement);\n        // remove blocking event handlers on the window\n        window.removeEventListener(\"mousedown\", this._onEvent, true);\n        window.removeEventListener(\"focus\", this._onEvent, true);\n        window.removeEventListener(\"input\", this._onEvent, true);\n        window.removeEventListener(\"selectstart\", this._onEvent, true);\n    };\n    /** Scroll to given component */\n    DOMPageRenderer.prototype.scrollTo = function (component) {\n        component.getRenderedOutputAsync().then(function (out) {\n            var elt = out && out.element;\n            if (!elt)\n                return;\n            // go through all parent elements to scroll them\n            var topOffset = elt.offsetTop;\n            var itemHeight = elt.offsetHeight;\n            while (elt.offsetParent) {\n                var parentElt = elt.offsetParent;\n                if (parentElt.scrollTop + parentElt.offsetHeight <\n                    topOffset + itemHeight) {\n                    // scroll down to bottom of selected element\n                    parentElt.scrollTop =\n                        topOffset + itemHeight - parentElt.offsetHeight;\n                }\n                if (parentElt.scrollTop > topOffset) {\n                    // scroll up to top of selected element\n                    parentElt.scrollTop = topOffset;\n                }\n                topOffset += parentElt.offsetTop - parentElt.scrollTop;\n                elt = parentElt;\n            }\n        });\n    };\n    /** @internal Create an empty shaded backdrop element */\n    DOMPageRenderer.prototype._createShadeElement = function () {\n        var shader = this._shadeElement = main_div(\"__page_backdropshader\");\n        shader.style.position = \"fixed\";\n        shader.style.left = \"0\";\n        shader.style.right = \"0\";\n        shader.style.top = \"0\";\n        shader.style.bottom = \"0\";\n        shader.style.outline = \"0\";\n        shader.style.zIndex = String(PAGE_OPTIONS.baseZIndex);\n        shader.style.background = PAGE_OPTIONS.shadeColor;\n        shader.style.transition = \"opacity \" +\n            PAGE_OPTIONS.shadeTransition + \"ms ease\";\n        shader.style.opacity = \"0\"; // initial\n        shader.setAttribute(UpdateContext_UpdateContext.UNMANAGED_FLAG, \"true\");\n        shader.tabIndex = -1;\n        return shader;\n    };\n    /** @internal Move, remove, or insert the modal backdrop shade */\n    DOMPageRenderer.prototype._moveShadeElement = function () {\n        var _this = this;\n        var root = this.domUpdater.root;\n        if (this._shadedWrapper) {\n            if (!this._shadeElement)\n                this._createShadeElement();\n            var shadeElement = this._shadeElement;\n            var shadedWrapper = this._shadedWrapper;\n            root.insertBefore(shadeElement, this._shadedWrapper);\n            setTimeout(function () {\n                if (_this._shadeElement === shadeElement &&\n                    _this._shadedWrapper === shadedWrapper)\n                    shadeElement.style.opacity =\n                        String(PAGE_OPTIONS.shadeOpacity);\n            }, 0);\n        }\n        else if (this._shadeElement) {\n            // transition and remove the currently displayed shade element\n            var shader_1 = this._shadeElement;\n            shader_1.style.opacity = \"0\";\n            setTimeout(function () {\n                if (shader_1.parentNode && !_this._shadedWrapper)\n                    root.removeChild(shader_1);\n            }, PAGE_OPTIONS.shadeTransition);\n        }\n    };\n    /** @internal Create an empty wrapper element for a component */\n    DOMPageRenderer.prototype._createWrapper = function () {\n        var _this = this;\n        var wrapper = main_div(\"__page_wrapper\");\n        wrapper.style.overflow = \"auto\";\n        wrapper.style.position = \"fixed\";\n        // disallow focus if behind modal shader\n        wrapper.addEventListener(\"focus\", function (event) {\n            if (_this._shadeElement) {\n                var cur = wrapper;\n                while (cur && cur.nextSibling) {\n                    cur = cur.nextSibling;\n                    if (cur === _this._shadeElement) {\n                        event.preventDefault();\n                        _this._shadeElement.focus();\n                        break;\n                    }\n                }\n            }\n        }, true);\n        // make sure IE also listens to clicks in the transparent area:\n        wrapper.style.background = \"rgba(0,0,0,0)\";\n        return wrapper;\n    };\n    /** @internal Position given DOM element inside of its page wrapper */\n    DOMPageRenderer.prototype._updateWrapper = function (element, wrapper, options, style, zeroFontSize) {\n        this._topOptions = options;\n        // fix font size for container wrappers\n        if (zeroFontSize) {\n            wrapper.style.lineHeight = \"0\";\n            wrapper.style.fontSize = \"0\";\n        }\n        else {\n            wrapper.style.lineHeight = \"\";\n            wrapper.style.fontSize = \"\";\n        }\n        // set z-index to follow content order or stay on top\n        wrapper.style.zIndex = String(PAGE_OPTIONS.baseZIndex +\n            ((options && options.stayOnTop) ? 1000 : 0));\n        // remember to insert the backdrop shade here if needed\n        if (options && options.shade)\n            this._shadedWrapper = wrapper;\n        // use \"dir\" attribute if flow direction set\n        if (options && options.flowDirection)\n            wrapper.dir = options.flowDirection;\n        // use .displayOptions to figure out positioning\n        var cell;\n        if (options && (options.modal)) {\n            // position the element inside a full-screen table cell\n            wrapper.style.top = \"0\";\n            wrapper.style.bottom = \"0\";\n            wrapper.style.left = \"0\";\n            wrapper.style.right = \"0\";\n            if (!wrapper.firstChild || wrapper.firstChild === element) {\n                // create the layout wrapper cell first\n                cell = main_div(\"__page_layoutcell\");\n                cell.style.display = \"table-cell\";\n                cell.style.boxSizing = \"border-box\";\n                cell.style.position = \"relative\";\n                cell.style.height = \"100vh\";\n                cell.style.width = \"100vw\";\n                cell.style.overflow = \"hidden\";\n                cell.appendChild(element);\n                wrapper.appendChild(cell);\n                // remove all other elements\n                while (cell.previousSibling)\n                    wrapper.removeChild(cell.previousSibling);\n            }\n            else {\n                // assume that the first child is the cell\n                cell = wrapper.firstChild;\n                cell.appendChild(element);\n                // remove all other elements\n                while (element.previousSibling)\n                    cell.removeChild(element.previousSibling);\n            }\n            // align horizontally and vertically\n            cell.style.textAlign = options.modalHorzAlign || \"center\";\n            cell.style.verticalAlign = options.modalVertAlign || \"middle\";\n            cell.style.paddingTop = options.modalVertAlign === \"top\" ?\n                (options.alignMargin || \"0\") :\n                (options.modalVertAlign && options.outerMargin || \"0\");\n            cell.style.paddingBottom = options.modalVertAlign === \"bottom\" ?\n                (options.alignMargin || \"0\") :\n                (options.modalVertAlign && options.outerMargin || \"0\");\n            var isLeftAligned = options.modalHorzAlign === \"left\" ||\n                options.modalHorzAlign === \"start\";\n            var paddingLeft = isLeftAligned ?\n                (options.alignMargin || \"0\") :\n                (options.modalHorzAlign && options.outerMargin || \"0\");\n            var isRightAligned = options.modalHorzAlign === \"right\" ||\n                options.modalHorzAlign === \"end\";\n            var paddingRight = isRightAligned ?\n                (options.alignMargin || \"0\") :\n                (options.modalHorzAlign && options.outerMargin || \"0\");\n            // flip left/right padding for right-to-left flow\n            if (options.flowDirection === \"rtl\" &&\n                (options.modalHorzAlign === \"start\" ||\n                    options.modalHorzAlign === \"end\")) {\n                cell.style.paddingLeft = paddingRight;\n                cell.style.paddingRight = paddingLeft;\n            }\n            else {\n                cell.style.paddingLeft = paddingLeft;\n                cell.style.paddingRight = paddingRight;\n            }\n        }\n        else {\n            // insert element directly into the wrapper, clear other nodes\n            if (wrapper.firstChild !== element || wrapper.lastChild !== element) {\n                wrapper.appendChild(element);\n                while (element.previousSibling)\n                    wrapper.removeChild(element.previousSibling);\n            }\n            // fix absolutely positioned elements with a \"bottom\" property\n            // to the bottom of the screen ONLY, otherwise to the top ONLY\n            var position, bottom;\n            if (style) {\n                position = style.get(\"position\");\n                bottom = style.get(\"bottom\");\n            }\n            else {\n                position = element.style.position;\n                bottom = element.style.position;\n            }\n            if (position === \"absolute\" || position === \"fixed\") {\n                wrapper.style.overflow = \"\";\n                var margin = options && options.alignMargin || \"0\";\n                if (bottom && bottom !== \"auto\") {\n                    wrapper.style.top = \"auto\";\n                    wrapper.style.bottom = margin;\n                    wrapper.style.left = margin;\n                    wrapper.style.right = margin;\n                }\n                else {\n                    wrapper.style.bottom = \"auto\";\n                    wrapper.style.top = margin;\n                    wrapper.style.left = margin;\n                    wrapper.style.right = margin;\n                }\n            }\n            else {\n                // if positioned relative/static, use full-screen wrapper\n                var margin = options && options.outerMargin || \"0\";\n                wrapper.style.top = margin;\n                wrapper.style.bottom = margin;\n                wrapper.style.left = margin;\n                wrapper.style.right = margin;\n            }\n        }\n        // press outside the element invokes onEsc handler\n        wrapper.onmousedown = function (event) {\n            if ((options && (typeof options.onEsc === \"function\")) &&\n                (event.target === wrapper || event.target === cell)) {\n                options.onEsc.call(undefined);\n            }\n        };\n    };\n    PageRenderer___decorate([\n        unobservable_memoize_get\n    ], DOMPageRenderer.prototype, \"domUpdater\", null);\n    return DOMPageRenderer;\n}(Page_PageRenderer));\n// inject this renderer into Page itself\ninject(Page_Page, { Renderer: PageRenderer_DOMPageRenderer });\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Containers/Container.js\nvar Containers_Container___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Containers_Container___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar Container_CSS_CLASS = \"UI-Container\";\n/** @internal DOM-specific component renderer */\nvar Container_Renderer = (function (_super) {\n    Containers_Container___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component, noScroll) {\n        var _this = _super.call(this, component) || this;\n        // initialize main DOM element(s)\n        _this.cellWrapper = main_div(Container_CSS_CLASS + \"_layoutcell\");\n        _this.mainWrapper = main_div(Container_CSS_CLASS + \"_main\", _this.cellWrapper);\n        _this.element = main_div(undefined, _this.mainWrapper);\n        // create the element update context\n        _this.context = new UpdateContext_UpdateContext(_this.cellWrapper);\n        // add watchers for component properties\n        _this.watch(function () { return applyStyleTo(component.style, _this.element); });\n        _this.watch(function () {\n            // set max content width\n            _this.mainWrapper.style.maxWidth = component.maxContentWidth;\n            // set vertical alignment\n            _this.cellWrapper.style.verticalAlign = component.vertAlign || \"top\";\n            // set horizontal alignment\n            var horzAlign = component.horzAlign;\n            if (component.flowDirection === \"rtl\") {\n                if (horzAlign === \"start\")\n                    horzAlign = \"right\";\n                else if (horzAlign === \"end\")\n                    horzAlign = \"left\";\n            }\n            else if (horzAlign === \"start\")\n                horzAlign = \"left\";\n            else if (horzAlign === \"end\")\n                horzAlign = \"right\";\n            if (horzAlign === \"left\") {\n                _this.mainWrapper.style.marginLeft = \"0\";\n                _this.mainWrapper.style.marginRight = \"auto\";\n            }\n            else if (horzAlign === \"right\") {\n                _this.mainWrapper.style.marginLeft = \"auto\";\n                _this.mainWrapper.style.marginRight = \"0\";\n            }\n            else {\n                _this.mainWrapper.style.marginLeft = \"\";\n                _this.mainWrapper.style.marginRight = \"\";\n            }\n            // do not fix table width if outer width is \"auto\"\n            if (component.style.get(\"width\") === \"auto\") {\n                _this.mainWrapper.style.tableLayout = \"auto\";\n                _this.mainWrapper.style.width = \"auto\";\n            }\n            else {\n                _this.mainWrapper.style.tableLayout = \"fixed\";\n                _this.mainWrapper.style.width = \"100%\";\n            }\n        });\n        // add watcher for scrollable (undesired for e.g. LayoutContainer)\n        if (!noScroll) {\n            _this.watch(function () { return component.scrollable; }, function (scrollable) {\n                // set overflow to scroll or hide overflowing content\n                component.style.set({\n                    overflow: scrollable ? \"auto\" : \"hidden\"\n                });\n            });\n        }\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function (noUpdate) {\n        var component = this.component;\n        // get or create the current output object\n        var out = _super.prototype.render.call(this) || new ComponentRenderer_ComponentRenderer.Output(component, this.element, this.context);\n        // set or update flow direction mode on context and element\n        this.context.flowDirection = this.component.flowDirection;\n        if (this.component.flowDirection) {\n            this.element.dir = this.component.flowDirection;\n        }\n        // add all components\n        if (!noUpdate)\n            out.updated = this.context.updateAsync(component.content);\n        // focus first element if initializer had \"focusFirst\" set\n        if (component.focusFirst) {\n            focus(component);\n            delete component.focusFirst;\n        }\n        return out;\n    };\n    Renderer = Containers_Container___decorate([\n        mapComponentRenderer(Container_Container)\n    ], Renderer);\n    return Renderer;\n}(ComponentRenderer_ComponentRenderer));\n\n// inject scroll monitor method\ninject(Container_Container, {\n    \"@monitorPlatformScroll\": function (callback) {\n        this.getRenderedOutputAsync().then(function (out) {\n            var elt = out.element;\n            if (elt && elt.nodeType === 1) {\n                // use _scroll element for layout containers\n                var scrollElt = elt.getElementsByClassName(\"UI-LayoutContainer_scroll\");\n                if (scrollElt.length)\n                    elt = scrollElt[0];\n                // run the callback on scroll, resize, and first update\n                var doCallback_1 = function () {\n                    var t = elt.scrollTop;\n                    var b = elt.scrollHeight - (t + elt.clientHeight);\n                    var l = elt.scrollLeft;\n                    var r = elt.scrollWidth - (l + elt.clientWidth);\n                    callback(t, b, l, r);\n                };\n                elt.onscroll = doCallback_1;\n                window.addEventListener(\"resize\", doCallback_1);\n                out.updated && out.updated.then(function () {\n                    return sleep(10).then(doCallback_1);\n                });\n                doCallback_1();\n            }\n        });\n    }\n});\n// Add style override and apply style sheet\nContainer_Container.addStyleOverride(Style_Style.withClass(Container_CSS_CLASS));\nFlowContainer.addStyleOverride(Style_Style.withClass(Container_CSS_CLASS + \" \" + Container_CSS_CLASS + \"-Flow\"));\nStyles_Styles.define(Container_CSS_CLASS, {\n    \".~~\": {\n        cursor: \"default\",\n        display: \"inline-block\",\n        position: \"relative\",\n        top: \"0\", bottom: \"0\",\n        left: \"0\", right: \"0\",\n        height: \"100%\",\n        width: \"100%\",\n        textAlign: \"center\",\n        margin: \"0 auto\",\n        overflow: \"hidden\",\n        transition: \"box-shadow 100ms ease\",\n        fontSize: observe(function () { return Styles_Styles.size.text; })\n    },\n    \".~_main\": {\n        position: \"relative\",\n        display: \"table\",\n        borderSpacing: \"0\",\n        height: \"100%\",\n        margin: \"0 auto\"\n    },\n    \".~_layoutcell\": {\n        display: \"table-cell\",\n        height: \"100%\"\n    },\n    \".~-Flow > .~_main > .~_layoutcell > .UI-Block\": {\n        display: \"inline-block\",\n        verticalAlign: \"top\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Containers/DialogContainer.js\nvar Containers_DialogContainer___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Containers_DialogContainer___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar DialogContainer_CSS_CLASS = \"UI-DialogContainer\";\n/** @internal DOM-specific component renderer */\nvar DialogContainer_Renderer = (function (_super) {\n    Containers_DialogContainer___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        // add watcher for width to set max width instead\n        _this.watch(function () { return component.width; }, function (w) {\n            component.style.set({\n                width: w === \"auto\" ? \"auto\" : \"100%\",\n                maxWidth: w === \"auto\" ? \"none\" : w\n            });\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this, true);\n        var component = this.component;\n        // render header block and create wrapper if needed\n        var content = [];\n        if (component.header) {\n            // fix vertical spacing for a more \"native\" look if none set\n            var headerRow = component.header;\n            if (headerRow instanceof Row_Row && !headerRow.verticalSpacing) {\n                unobserved(function () {\n                    headerRow.verticalSpacing = \".65rem\";\n                });\n            }\n            // copy ltr/rtl flow direction if set at component level\n            if (component.flowDirection) {\n                unobserved(function () {\n                    headerRow.flowDirection = component.flowDirection;\n                });\n            }\n            // render header synchronously\n            var out_1 = headerRow.out;\n            var className = DialogContainer_CSS_CLASS + \"_header\";\n            if (out_1 && (!out_1.wrapper || out_1.wrapper.firstChild !== out_1.element ||\n                out_1.wrapper.className !== className)) {\n                var w = out_1.wrapper = main_div(className, out_1.element);\n                w.onselectstart = function (e) { return e.preventDefault(); };\n                w.onmousedown = function (e) { return component.header && component.header.Pressed(e); };\n            }\n            content.push(out_1);\n        }\n        // render content blocks and remove wrappers if needed\n        component.content.forEach(function (c) {\n            // copy ltr/rtl flow direction if set at component level\n            if (c && component.flowDirection) {\n                unobserved(function () {\n                    c.flowDirection = component.flowDirection;\n                });\n            }\n            // render content synchronously\n            var out = c && c.out;\n            if (out)\n                delete out.wrapper;\n            content.push(out);\n        });\n        // render footer block and create wrapper if needed\n        if (component.footer) {\n            // copy ltr/rtl flow direction if set at component level\n            if (component.flowDirection) {\n                unobserved(function () {\n                    component.footer.flowDirection = component.flowDirection;\n                });\n            }\n            // render footer synchronously\n            var out_2 = component.footer.out;\n            var className = DialogContainer_CSS_CLASS + \"_footer\";\n            if (out_2 && (!out_2.wrapper || out_2.wrapper.firstChild !== out_2.element ||\n                out_2.wrapper.className !== className))\n                out_2.wrapper = main_div(className, out_2.element);\n            content.push(out_2);\n        }\n        // add all sub blocks output\n        out.updated = this.context.updateAsync(content, true);\n        return out;\n    };\n    Renderer = Containers_DialogContainer___decorate([\n        mapComponentRenderer(DialogContainer_DialogContainer)\n    ], Renderer);\n    return Renderer;\n}(Container_Renderer));\n\n// Set default animations\nDialogContainer_DialogContainer.APPEAR_ANIMATION = DOMAnimation_DOMAnimation.basic.in.fadeUp.withTiming(200);\nDialogContainer_DialogContainer.DISAPPEAR_ANIMATION = DOMAnimation_DOMAnimation.basic.out.fade.withTiming(200);\n// Add style override for DialogContainer and TopCloseButton\nDialogContainer_DialogContainer.addStyleOverride(Style_Style.withClass(DialogContainer_CSS_CLASS));\nDialogContainer_DialogContainer.TopCloseButton.addStyleOverride(Style_Style.withClass(DialogContainer_CSS_CLASS + \"_topclosebutton\"));\n// Apply style sheet\nStyles_Styles.define(\"UI-Container \" + DialogContainer_CSS_CLASS, {\n    \".~~\": new Style_Style()\n        .addShadowEffect(.75)\n        .set({\n        height: \"auto\",\n        background: observe(function () { return Styles_Styles.color.background; }),\n        color: observe(function () { return Styles_Styles.color.text; }),\n        borderRadius: observe(function () { return Styles_Styles.size.dialogBorderRadius; })\n    }),\n    \".~_header\": {\n        overflow: \"hidden\"\n    },\n    \".~_footer\": {\n        overflow: \"hidden\"\n    },\n    \".~_topclosebutton\": {\n        lineHeight: \"0\"\n    },\n    \".~_topclosebutton.UI-TextButton.UI-Button > button[type]\": {\n        fontSize: \"1.5em\",\n        height: \"auto\",\n        lineHeight: \"1.1rem\",\n        fontFamily: \"initial\",\n        top: \"-.1em\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Containers/DrawerContainer.js\n\n\n\n/** Base class name used for CSS style sheet */\nvar DrawerContainer_CSS_CLASS = \"UI-DrawerContainer\";\n// set default animations\nDrawerContainer.APPEAR_ANIMATION =\n    DOMAnimation_DOMAnimation.basic.in.fadeRight.withTiming(300);\nDrawerContainer.DISAPPEAR_ANIMATION =\n    DOMAnimation_DOMAnimation.basic.out.fadeLeft.withTiming(300);\nOppositeDrawerContainer.APPEAR_ANIMATION =\n    DOMAnimation_DOMAnimation.basic.in.fadeLeft.withTiming(300);\nOppositeDrawerContainer.DISAPPEAR_ANIMATION =\n    DOMAnimation_DOMAnimation.basic.out.fadeRight.withTiming(300);\n// Add style override and apply style sheet\nDrawerContainer.addStyleOverride(Style_Style.withClass(DrawerContainer_CSS_CLASS));\nStyles_Styles.define(\"UI-Container \" + DrawerContainer_CSS_CLASS, {\n    \".~~\": new Style_Style()\n        .addShadowEffect(1)\n        .set({ height: \"100vh\" })\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Containers/LayoutContainer.js\nvar Containers_LayoutContainer___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Containers_LayoutContainer___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar LayoutContainer_CSS_CLASS = \"UI-LayoutContainer\";\n/** @internal DOM-specific component renderer */\nvar LayoutContainer_Renderer = (function (_super) {\n    Containers_LayoutContainer___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = \n        // instantiate container renderer, forget about scrolling\n        _super.call(this, component, true) || this;\n        // create the outer element update context, to be updated with all\n        // containers, and the center wrapper element\n        _this.element.removeChild(_this.element.firstChild);\n        _this.scrollWrapper = main_div(LayoutContainer_CSS_CLASS + \"_scroll\", _this.mainWrapper);\n        _this.outerContext = new UpdateContext_UpdateContext(_this.element);\n        // add watcher for scrollable (overridden)\n        _this.watch(function () { return !!component.scrollable; }, function (scrollable) {\n            // set overflow to scroll or hide overflowing center content\n            _this.scrollWrapper.style.overflow = scrollable ? \"auto\" : \"hidden\";\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object, render main context\n        var out = _super.prototype.render.call(this);\n        var content = [this.scrollWrapper];\n        var component = this.component;\n        var flowDirection = component.flowDirection;\n        var isRTL = flowDirection === \"rtl\";\n        // helper to render and wrap side container\n        function renderSideContainer(c, className, before, above) {\n            // copy ltr/rtl flow direction if set at component level\n            if (c && flowDirection) {\n                unobserved(function () {\n                    c.flowDirection = component.flowDirection;\n                });\n            }\n            // render container synchronously\n            var out = c && c.out;\n            if (out && !(c.hidden)) {\n                if (!out.wrapper || out.wrapper.firstChild !== out.element ||\n                    out.wrapper.className !== className) {\n                    out.wrapper = main_div(className, out.element);\n                    out.wrapper.style.zIndex = PAGE_OPTIONS.baseZIndex\n                        + (above ? 1 : 0);\n                }\n                before ? content.unshift(out) : content.push(out);\n                return out.wrapper;\n            }\n        }\n        // render left gutter container and find its width\n        var leftComponent = isRTL ?\n            component.outsideGutter : component.insideGutter;\n        var leftWrapper = renderSideContainer(leftComponent, LayoutContainer_CSS_CLASS + \"_left\", !isRTL);\n        var leftWidth = leftWrapper && leftComponent.width;\n        leftWidth = leftWidth === \"auto\" ?\n            (isRTL ? LayoutContainer_LayoutContainer.OUTSIDE_GUTTER_WIDTH :\n                LayoutContainer_LayoutContainer.INSIDE_GUTTER_WIDTH) :\n            (leftWidth || \"\");\n        // render right gutter container and find its width\n        var rightComponent = isRTL ?\n            component.insideGutter : component.outsideGutter;\n        var rightWrapper = renderSideContainer(rightComponent, LayoutContainer_CSS_CLASS + \"_right\", isRTL);\n        var rightWidth = rightWrapper && rightComponent.width;\n        rightWidth = rightWidth === \"auto\" ?\n            (isRTL ? LayoutContainer_LayoutContainer.INSIDE_GUTTER_WIDTH :\n                LayoutContainer_LayoutContainer.OUTSIDE_GUTTER_WIDTH) :\n            (rightWidth || \"\");\n        // render header container and find its height\n        var headerWrapper = renderSideContainer(component.header, LayoutContainer_CSS_CLASS + \"_header\", true, true);\n        var headerHeight = headerWrapper && component.header.height;\n        headerHeight = headerHeight === \"auto\" ?\n            LayoutContainer_LayoutContainer.HEADER_HEIGHT : (headerHeight || \"\");\n        // render footer container and find its height\n        var footerWrapper = renderSideContainer(component.footer, LayoutContainer_CSS_CLASS + \"_footer\", false, true);\n        var footerHeight = footerWrapper && component.footer.height;\n        footerHeight = footerHeight === \"auto\" ?\n            LayoutContainer_LayoutContainer.FOOTER_HEIGHT : (footerHeight || \"\");\n        // adjust positions of all wrappers\n        this.scrollWrapper.style.top = headerHeight;\n        this.scrollWrapper.style.bottom = footerHeight;\n        this.scrollWrapper.style.left = leftWidth;\n        this.scrollWrapper.style.right = rightWidth;\n        if (leftWrapper) {\n            leftWrapper.style.top = headerHeight;\n            leftWrapper.style.bottom = footerHeight;\n            leftWrapper.style.width = leftWidth;\n        }\n        if (rightWrapper) {\n            rightWrapper.style.top = headerHeight;\n            rightWrapper.style.bottom = footerHeight;\n            rightWrapper.style.width = rightWidth;\n        }\n        if (headerWrapper) {\n            headerWrapper.style.height = headerHeight;\n        }\n        if (footerWrapper) {\n            footerWrapper.style.height = footerHeight;\n        }\n        // add all sub blocks of output\n        this.outerContext.updateAsync(content, true);\n        return out;\n    };\n    Renderer = Containers_LayoutContainer___decorate([\n        mapComponentRenderer(LayoutContainer_LayoutContainer)\n    ], Renderer);\n    return Renderer;\n}(Container_Renderer));\n\n// Add style override and apply style sheet\nLayoutContainer_LayoutContainer.addStyleOverride(Style_Style.withClass(LayoutContainer_CSS_CLASS));\nStyles_Styles.define(\"UI-Container \" + LayoutContainer_CSS_CLASS, {\n    \".~~\": {\n        display: \"block\"\n    },\n    \".~_scroll\": {\n        position: \"absolute\",\n        top: \"0\", left: \"0\",\n        bottom: \"0\", right: \"0\"\n    },\n    \".~_header\": {\n        position: \"absolute\",\n        top: \"0\", left: \"0\", right: \"0\"\n    },\n    \".~_footer\": {\n        position: \"absolute\",\n        bottom: \"0\", left: \"0\", right: \"0\"\n    },\n    \".~_left\": {\n        position: \"absolute\",\n        top: \"0\", bottom: \"0\", left: \"0\"\n    },\n    \".~_right\": {\n        position: \"absolute\",\n        top: \"0\", bottom: \"0\", right: \"0\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Blocks/Card.js\nvar Blocks_Card___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Blocks_Card___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar Card_CSS_CLASS = \"UI-Card\";\n/** @internal DOM-specific component renderer */\nvar Card_Renderer = (function (_super) {\n    Blocks_Card___extends(Renderer, _super);\n    function Renderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        var component = this.component;\n        // render header block and create wrapper if needed\n        var content = [];\n        if (component.header) {\n            // copy ltr/rtl flow direction if set at component level\n            if (component.flowDirection) {\n                unobserved(function () {\n                    component.header.flowDirection = component.flowDirection;\n                });\n            }\n            // render header synchronously\n            var out_1 = component.header.out;\n            var className = Card_CSS_CLASS + \"_header panel-heading card-header\";\n            if (out_1 && (!out_1.wrapper || out_1.wrapper.firstChild !== out_1.element ||\n                out_1.wrapper.className !== className))\n                out_1.wrapper = main_div(className, out_1.element);\n            content.push(out_1);\n        }\n        // render content blocks and remove wrappers if needed\n        component.content.forEach(function (c) {\n            // copy ltr/rtl flow direction if set at component level\n            if (c && component.flowDirection) {\n                unobserved(function () {\n                    c.flowDirection = component.flowDirection;\n                });\n            }\n            // render content synchronously\n            var out = c && c.out;\n            if (out)\n                delete out.wrapper;\n            content.push(out);\n        });\n        // render footer block and create wrapper if needed\n        if (component.footer) {\n            // copy ltr/rtl flow direction if set at component level\n            if (component.flowDirection) {\n                unobserved(function () {\n                    component.footer.flowDirection = component.flowDirection;\n                });\n            }\n            // render footer synchronously\n            var out_2 = component.footer.out;\n            var className = Card_CSS_CLASS + \"_footer panel-footer card-footer\";\n            if (out_2 && (!out_2.wrapper || out_2.wrapper.firstChild !== out_2.element ||\n                out_2.wrapper.className !== className))\n                out_2.wrapper = main_div(className, out_2.element);\n            content.push(out_2);\n        }\n        // add all sub blocks output\n        out.updated = this.context.updateAsync(content, true);\n        return out;\n    };\n    Renderer = Blocks_Card___decorate([\n        mapComponentRenderer(Card_Card)\n    ], Renderer);\n    return Renderer;\n}(Block_Renderer));\n\n// Add style override and apply style sheet\nCard_Card.addStyleOverride(Style_Style.withClass(Card_CSS_CLASS + \" panel panel-default card\"));\nStyles_Styles.define(\"UI-Block \" + Card_CSS_CLASS, {\n    \".~~\": {\n        margin: observe(function () { return Styles_Styles.size.controlSpacing; }),\n        padding: \"0\",\n        height: \"auto\",\n        width: \"auto\",\n        overflow: \"hidden\"\n    },\n    \".~_header\": {\n        padding: \"0\",\n        overflow: \"hidden\"\n    },\n    \".~_footer\": {\n        padding: \"0\",\n        overflow: \"hidden\"\n    },\n    // do not add margin to cards used within rows\n    \".UI-Control > .~~\": {\n        margin: \"0\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Blocks/ContainerBlock.js\nvar Blocks_ContainerBlock___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Blocks_ContainerBlock___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Base class name used for CSS style sheet */\nvar ContainerBlock_CSS_CLASS = \"UI-ContainerBlock\";\n/** @internal DOM-specific component renderer */\nvar ContainerBlock_Renderer = (function (_super) {\n    Blocks_ContainerBlock___extends(Renderer, _super);\n    function Renderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        // add container to output\n        out.updated = this.context.updateAsync([this.component.container]);\n        return out;\n    };\n    Renderer = Blocks_ContainerBlock___decorate([\n        mapComponentRenderer(ContainerBlock_ContainerBlock)\n    ], Renderer);\n    return Renderer;\n}(Block_Renderer));\n\n// Add style override and apply style sheet\nContainerBlock_ContainerBlock.addStyleOverride(Style_Style.withClass(ContainerBlock_CSS_CLASS));\nStyles_Styles.define(\"UI-Block \" + ContainerBlock_CSS_CLASS, {\n    \".~~\": {\n        fontSize: \"0\",\n        lineHeight: \"0\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Blocks/Divider.js\nvar Blocks_Divider___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Blocks_Divider___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar Divider_CSS_CLASS = \"UI-Divider\";\n/** @internal DOM-specific component renderer */\nvar Divider_Renderer = (function (_super) {\n    Blocks_Divider___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component, \"hr\") || this;\n        // add watcher for component style properties\n        _this.watch(function () { return ({\n            borderWidth: \"0 0 \" + (component.thickness || \"1px\"),\n            borderColor: component.color,\n            marginTop: component.margin || \".5rem\",\n            marginBottom: component.margin || \".5rem\",\n            marginLeft: component.flowDirection === \"rtl\" ?\n                component.insetEnd : component.insetStart,\n            marginRight: component.flowDirection === \"rtl\" ?\n                component.insetStart : component.insetEnd\n        }); }, function (styles) {\n            component.style.set(styles);\n        });\n        return _this;\n    }\n    Renderer = Blocks_Divider___decorate([\n        mapComponentRenderer(Divider_Divider)\n    ], Renderer);\n    return Renderer;\n}(Block_Renderer));\n\n// Add style override and apply style sheet\nDivider_Divider.addStyleOverride(Style_Style.withClass(Divider_CSS_CLASS));\nStyles_Styles.define(\"UI-Block \" + Divider_CSS_CLASS, {\n    \".~~\": {\n        boxSizing: \"content-box\",\n        height: \"0\",\n        lineHeight: \"0\",\n        fontSize: \"0\",\n        padding: \"0\", margin: \"0\",\n        borderStyle: \"solid\",\n        borderColor: observe(function () { return Styles_Styles.color.divider; }),\n        borderWidth: \"0\" // set by render method\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Blocks/List.js\nvar Blocks_List___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Blocks_List___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class names used for CSS style sheet */\nvar List_CSS_CLASS = \"UI-List\";\nvar CSS_CLASS_TREELIST = \"UI-TreeList\";\n/** @internal DOM-specific component renderer */\nvar List_Renderer = (function (_super) {\n    Blocks_List___extends(Renderer, _super);\n    function Renderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        // add all items and dividers, if any\n        out.updated = this.context.updateAsync(this.component.getChildren(), false, this.component.renderOptions &&\n            this.component.renderOptions.animateListItems);\n        return out;\n    };\n    Renderer = Blocks_List___decorate([\n        mapComponentRenderer(List_List),\n        mapComponentRenderer(TreeList_TreeList)\n    ], Renderer);\n    return Renderer;\n}(Block_Renderer));\n\n// Add style override\nList_List.addStyleOverride(Style_Style.withClass(List_CSS_CLASS));\nTreeList_TreeList.addStyleOverride(Style_Style.withClass(List_CSS_CLASS + \" \" + CSS_CLASS_TREELIST));\nStyles_Styles.define(List_CSS_CLASS, {\n    \".~~ > [selected]\": {\n        background: observe(function () { return Styles_Styles.color.listSelectionBackground; }),\n        color: observe(function () { return Styles_Styles.color.listSelectionText; })\n    },\n    \".~~ > [selected]:focus\": {\n        background: observe(function () { return Styles_Styles.color.listSelectionFocusBackground; }),\n        color: observe(function () { return Styles_Styles.color.listSelectionFocusText; }),\n        outlineWidth: observe(function () { return Styles_Styles.size.listSelectionFocusOutline; })\n    },\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/ControlElement.js\nvar Controls_ControlElement___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Controls_ControlElement___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar ControlElement_CSS_CLASS = \"UI-Control\";\n/** @internal DOM-specific component renderer */\nvar ControlElement_Renderer = (function (_super) {\n    Controls_ControlElement___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component, tagName) {\n        if (tagName === void 0) { tagName = \"span\"; }\n        var _this = _super.call(this, component) || this;\n        // initialize main DOM element(s)\n        _this.element = document.createElement(tagName);\n        _this.element.id = component.uid;\n        // create the element update context\n        _this.context = new UpdateContext_UpdateContext(_this.element);\n        // add watchers for component properties\n        _this.watch(function () { return applyStyleTo(component.style, _this.element); });\n        _this.watch(function () {\n            // check width AND shrinkwrap properties to set CSS width\n            var w = component.width;\n            if (w === \"auto\")\n                w = \"\";\n            var isPercentage = (w.slice(-1) === \"%\");\n            if (component.shrinkwrap) {\n                // add shrinkwrap class and set width\n                unobserved(function () {\n                    component.style.addClass(\"shrinkwrap\").set({\n                        width: isPercentage && w || \"\",\n                        minWidth: w,\n                        maxWidth: w\n                    });\n                });\n            }\n            else {\n                // remove shrinkwrap class and set width\n                unobserved(function () {\n                    component.style.removeClass(\"shrinkwrap\").set({\n                        width: isPercentage && w || \"\",\n                        minWidth: w,\n                        maxWidth: \"none\"\n                    });\n                });\n            }\n        });\n        _this.watch(function () { return component.wrapText; }, function (wrapText) {\n            // set white-space property (pre-wrap or pre [default])\n            component.style.set({\n                whiteSpace: wrapText ? \"pre-wrap\" : \"\"\n            });\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this) || new ComponentRenderer_ComponentRenderer.Output(this.component, this.element, this.context);\n        // set or update flow direction mode on context and element\n        this.context.flowDirection = this.component.flowDirection;\n        if (this.component.flowDirection) {\n            this.element.dir = this.component.flowDirection;\n        }\n        return out;\n    };\n    Renderer = Controls_ControlElement___decorate([\n        mapComponentRenderer(ControlElement_ControlElement)\n    ], Renderer);\n    return Renderer;\n}(ComponentRenderer_ComponentRenderer));\n\n// Add logic for focusing and blurring control elements\ninject(ControlElement_ControlElement, {\n    \"@focusLiveComponent\": function () {\n        focus(this);\n    },\n    \"@blurLiveComponent\": function () {\n        blur(this);\n    }\n});\n// Add style override and apply style sheet\nControlElement_ControlElement.addStyleOverride(Style_Style.withClass(ControlElement_CSS_CLASS));\nStyles_Styles.define(\"UI-Control \" + ControlElement_CSS_CLASS, {\n    \".~~\": {\n        position: \"relative\",\n        display: \"table-cell\",\n        verticalAlign: \"middle\",\n        borderSpacing: \"initial\",\n        margin: \"0\",\n        padding: \"0\",\n        lineHeight: \"normal\",\n        height: \"100%\",\n        whiteSpace: \"pre\"\n    },\n    \".~~.shrinkwrap\": {\n        width: \"1px\",\n        maxWidth: \"none\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/Label.js\nvar Controls_Label___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Controls_Label___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar Label_CSS_CLASS = \"UI-Label\";\n/** @internal DOM-specific component renderer */\nvar Label_Renderer = (function (_super) {\n    Controls_Label___extends(Renderer, _super);\n    function Renderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Renderer_1 = Renderer;\n    /** Helper method to replace contents of given node with icon, label, and badge, if any; returns node itself */\n    Renderer.renderInto = function (node, icon, remGutter, label, badge, append, iconRight, smallBefore, smallAfter) {\n        if (!append)\n            while (node.firstChild)\n                node.removeChild(node.firstChild);\n        var beforeLabelText = smallBefore !== undefined && String(smallBefore);\n        if (beforeLabelText) {\n            var beforeLabelElement = document.createElement(\"small\");\n            beforeLabelElement.textContent = beforeLabelText;\n            node.appendChild(beforeLabelElement);\n        }\n        if (icon || remGutter > 0) {\n            var iconElement = document.createElement(\"icon\");\n            if (remGutter >= 0) {\n                iconElement.style.display = \"inline-block\";\n                iconElement.style.textAlign = \"center\";\n                iconElement.style.minWidth = remGutter + \"rem\";\n            }\n            if (icon) {\n                var content = \"\";\n                icon = icon.replace(/\\s+([\\w-]+)\\s*=\\s*(\\\"[^\\\"]*\\\"|[^\\s]+)/g, function (s, prop, val) {\n                    prop = prop.replace(/-\\w/g, function (s) { return s[1].toUpperCase(); });\n                    iconElement.style[prop] = (val[0] === '\"') ?\n                        JSON.parse(val) : val;\n                    return \"\";\n                })\n                    .replace(/\\:(?:\\\"[^\\\"]*\\\"|[^\\s]+)/, function (s) {\n                    s = s.slice(1);\n                    content = (s[0] === '\"') ? JSON.parse(s) : s;\n                    return \"\";\n                });\n                var prefix = icon.split(\"-\", 1)[0];\n                if (prefix !== icon)\n                    icon = prefix + \" \" + icon;\n                iconElement.className = icon;\n                iconElement.textContent = content;\n            }\n            node.appendChild(iconElement);\n        }\n        var labelText = label !== undefined && String(label);\n        if (labelText) {\n            if (icon && !(remGutter > 0))\n                labelText = \" \" + labelText;\n            var labelElement = document.createElement(\"span\");\n            labelElement.textContent = labelText;\n            node.appendChild(labelElement);\n        }\n        var badgeText = badge !== undefined && String(badge);\n        if (badgeText) {\n            var badgeElement = document.createElement(\"badge\");\n            badgeElement.className = \"badge badge-default tag tag-default\";\n            badgeElement.style.marginLeft = \".5rem\";\n            badgeElement.textContent = badgeText;\n            node.appendChild(badgeElement);\n        }\n        var afterLabelText = smallAfter !== undefined && String(smallAfter);\n        if (afterLabelText) {\n            var afterLabelElement = document.createElement(\"small\");\n            afterLabelElement.textContent = afterLabelText;\n            node.appendChild(afterLabelElement);\n        }\n        return node;\n    };\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        var component = this.component;\n        // render text into DOM element\n        Renderer_1.renderInto(this.element, component.icon, component.remGutter, component.text, component.badge, false, false, component.textBefore, component.textAfter);\n        // set tooltip text\n        if (component.tooltipText !== undefined)\n            this.element.title = component.tooltipText;\n        return out;\n    };\n    Renderer = Renderer_1 = Controls_Label___decorate([\n        mapComponentRenderer(Label_Label)\n    ], Renderer);\n    return Renderer;\n    var Renderer_1;\n}(ControlElement_Renderer));\n\n/** @internal */\nvar Label_ParagraphRenderer = (function (_super) {\n    Controls_Label___extends(ParagraphRenderer, _super);\n    function ParagraphRenderer(component) {\n        return _super.call(this, component, \"p\") || this;\n    }\n    ParagraphRenderer = Controls_Label___decorate([\n        mapComponentRenderer(Paragraph)\n    ], ParagraphRenderer);\n    return ParagraphRenderer;\n}(Label_Renderer));\n\n/** @internal */\nvar Label_H1Renderer = (function (_super) {\n    Controls_Label___extends(H1Renderer, _super);\n    function H1Renderer(component) {\n        return _super.call(this, component, \"h1\") || this;\n    }\n    H1Renderer = Controls_Label___decorate([\n        mapComponentRenderer(Heading1)\n    ], H1Renderer);\n    return H1Renderer;\n}(Label_Renderer));\n\n/** @internal */\nvar Label_H2Renderer = (function (_super) {\n    Controls_Label___extends(H2Renderer, _super);\n    function H2Renderer(component) {\n        return _super.call(this, component, \"h2\") || this;\n    }\n    H2Renderer = Controls_Label___decorate([\n        mapComponentRenderer(Heading2)\n    ], H2Renderer);\n    return H2Renderer;\n}(Label_Renderer));\n\n/** @internal */\nvar Label_H3Renderer = (function (_super) {\n    Controls_Label___extends(H3Renderer, _super);\n    function H3Renderer(component) {\n        return _super.call(this, component, \"h3\") || this;\n    }\n    H3Renderer = Controls_Label___decorate([\n        mapComponentRenderer(Heading3)\n    ], H3Renderer);\n    return H3Renderer;\n}(Label_Renderer));\n\n/** @internal */\nvar Label_H4Renderer = (function (_super) {\n    Controls_Label___extends(H4Renderer, _super);\n    function H4Renderer(component) {\n        return _super.call(this, component, \"h4\") || this;\n    }\n    H4Renderer = Controls_Label___decorate([\n        mapComponentRenderer(Heading4)\n    ], H4Renderer);\n    return H4Renderer;\n}(Label_Renderer));\n\n/** @internal */\nvar Label_H5Renderer = (function (_super) {\n    Controls_Label___extends(H5Renderer, _super);\n    function H5Renderer(component) {\n        return _super.call(this, component, \"h5\") || this;\n    }\n    H5Renderer = Controls_Label___decorate([\n        mapComponentRenderer(Heading5)\n    ], H5Renderer);\n    return H5Renderer;\n}(Label_Renderer));\n\n/** @internal */\nvar Label_H6Renderer = (function (_super) {\n    Controls_Label___extends(H6Renderer, _super);\n    function H6Renderer(component) {\n        return _super.call(this, component, \"h6\") || this;\n    }\n    H6Renderer = Controls_Label___decorate([\n        mapComponentRenderer(Heading6)\n    ], H6Renderer);\n    return H6Renderer;\n}(Label_Renderer));\n\n// Add style override and apply style sheet\nLabel_Label.addStyleOverride(Style_Style.withClass(Label_CSS_CLASS));\nWideLabel.addStyleOverride(Style_Style.withClass(Label_CSS_CLASS + \" wide\")\n    .set(\"maxWidth\", \"1px\"));\nStyles_Styles.define(\"UI-Control \" + Label_CSS_CLASS, {\n    \".~~\": {\n        cursor: \"inherit\",\n        overflow: \"hidden\"\n    },\n    \".~~.wide\": {\n        textOverflow: \"ellipsis\"\n    },\n    \".~~ small\": {\n        display: \"block\",\n        color: observe(function () { return Styles_Styles.color.textFaded; })\n    },\n    \"p.~~\": {\n        lineHeight: observe(function () { return Styles_Styles.size.paragraphLineHeight; })\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Blocks/NavList.js\nvar Blocks_NavList___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Blocks_NavList___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar NavList_CSS_CLASS = \"UI-NavList\";\n/** @internal DOM-specific component renderer */\nvar NavList_Renderer = (function (_super) {\n    Blocks_NavList___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component, \"nav\") || this;\n        // create the UL wrapper\n        _this._ul = document.createElement(\"ul\");\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        var component = this.component;\n        // set UL class name depending on nav type\n        var ul = this._ul;\n        var className = \"nav \";\n        if (component.justified)\n            className += \"nav-justified \";\n        switch (component.type) {\n            case NavList_NavList.Type.Tabs:\n                className += \"nav-tabs\";\n                break;\n            case NavList_NavList.Type.Pills:\n                className += \"nav-pills\";\n                break;\n            case NavList_NavList.Type.StackedPills:\n                className += \"nav-pills nav-stacked\";\n                break;\n        }\n        ul.className = className;\n        // create or reuse LI nodes\n        var cur = ul.firstChild;\n        var selectedIndex = component.selectedIndex;\n        component.navItems.forEach(function (item, index) {\n            if (!item)\n                return;\n            if (!cur) {\n                var li = document.createElement(\"li\");\n                var a = document.createElement(\"a\");\n                a.href = \"#\";\n                li.appendChild(a);\n                li.onclick = function (event) {\n                    component.activate(index);\n                    event.preventDefault();\n                    return false;\n                };\n                ul.appendChild(cur = li);\n            }\n            Label_Renderer.renderInto(cur.firstChild, item.icon, component.remGutter, item.label, item.badge);\n            var isSelected = (index === selectedIndex);\n            cur.className = isSelected ?\n                \"nav-item active\" : \"nav-item\";\n            cur.firstChild.className = isSelected ?\n                \"nav-link active\" : \"nav-link\";\n            cur = cur.nextSibling;\n        });\n        // remove additional existing nodes\n        while (cur) {\n            var next = cur.nextSibling;\n            ul.removeChild(cur);\n            cur = next;\n        }\n        // update with UL, and container block if needed\n        out.updated = this.context.updateAsync([ul].concat(component.getChildren()));\n        return out;\n    };\n    Renderer = Blocks_NavList___decorate([\n        mapComponentRenderer(NavList_NavList)\n    ], Renderer);\n    return Renderer;\n}(Block_Renderer));\n\n// inject simple URL-based activation functions\ninject(NavList_NavList.Activation, {\n    activate: function (target) {\n        // set location to given target directly (URL, path or hash)\n        if (typeof target === \"string\")\n            window.location.href = target;\n    },\n    isActive: function (target) {\n        if (typeof target === \"string\") {\n            target = target.replace(/\\/$/, \"\");\n            if (target[0] !== \"#\") {\n                // compare target to partial path name (without host and hash)\n                var path = String(document.location.pathname)\n                    .replace(/#.*/, \"\");\n                if (path === target ||\n                    path.slice(0, target.length + 1) === target + \"/\")\n                    return true;\n            }\n            else {\n                // compare target to partial hash\n                target = target.slice(1);\n                var hash = String(document.location.hash || \"\")\n                    .replace(/^#/, \"\");\n                if (hash === target ||\n                    hash.slice(0, target.length + 1) === target + \"/\")\n                    return true;\n            }\n        }\n        return false;\n    }\n});\n// Add style override\nNavList_NavList.addStyleOverride(Style_Style.withClass(NavList_CSS_CLASS));\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Blocks/Row.js\nvar Blocks_Row___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Blocks_Row___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Base class name used for CSS style sheet */\nvar Row_CSS_CLASS = \"UI-Row\";\n/** @internal DOM-specific component renderer */\nvar Row_Renderer = (function (_super) {\n    Blocks_Row___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        // initialize main DOM element\n        var wrapper = _this.wrapper = main_div(Row_CSS_CLASS + \"_wrapper\");\n        _this.element.appendChild(wrapper);\n        _this.context.root = wrapper;\n        // add watcher to detect if all child components are shrinkwrapped\n        _this.watch(function () {\n            return component.content.every(function (c) { return !c || c.hidden ||\n                (c.shrinkwrap && !(c.width && c.width.slice(-1) === \"%\")); });\n        }, function (allShrunk) {\n            // adjust width to compress around shrinkwrapped components\n            wrapper.style.width = allShrunk ? \"auto\" : \"100%\";\n        });\n        // add watcher for horizontal alignment\n        _this.watch(function () {\n            var horzAlign = component.horzAlign;\n            if (component.flowDirection === \"rtl\") {\n                if (horzAlign === \"start\")\n                    return \"right\";\n                if (horzAlign === \"end\")\n                    return \"left\";\n            }\n            else if (horzAlign === \"start\")\n                return \"\";\n            else if (horzAlign === \"end\")\n                return \"right\";\n            return horzAlign;\n        }, function (horzAlign) {\n            switch (horzAlign) {\n                case \"center\":\n                    _this.wrapper.style.marginLeft = \"auto\";\n                    _this.wrapper.style.marginRight = \"auto\";\n                    break;\n                case \"right\":\n                    _this.wrapper.style.marginLeft = \"auto\";\n                    _this.wrapper.style.marginRight = \"0\";\n                    break;\n                case \"left\":\n                    _this.wrapper.style.marginLeft = \"0\";\n                    _this.wrapper.style.marginRight = \"auto\";\n                    break;\n                default:\n                    _this.wrapper.style.marginLeft = \"\";\n                    _this.wrapper.style.marginRight = \"\";\n                    break;\n            }\n        });\n        // add watchers for height and spacing\n        var heightIsSet = false;\n        _this.watch(function () {\n            var spacing = component.spacing || Styles_Styles.size.controlSpacing;\n            _this.wrapper.style.borderSpacing = spacing + \" 0\";\n            var h = component.height;\n            if (!h || h === \"auto\") {\n                var space = (component.verticalSpacing || spacing);\n                _this.wrapper.style.marginTop = space;\n                _this.wrapper.style.marginBottom = space;\n                return undefined;\n            }\n            else {\n                _this.wrapper.style.marginTop = \"0\";\n                _this.wrapper.style.marginBottom = \"0\";\n                _this.wrapper.style.height = h;\n                return h;\n            }\n        }, function (h) {\n            if (h) {\n                heightIsSet = true;\n                component.style.set({\n                    maxHeight: h,\n                    overflow: \"hidden\"\n                });\n            }\n            else if (heightIsSet) {\n                heightIsSet = false;\n                component.style.set({\n                    maxHeight: \"\",\n                    overflow: \"\"\n                });\n            }\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        // add all components\n        out.updated = this.context.updateAsync(this.component.content);\n        return out;\n    };\n    Renderer = Blocks_Row___decorate([\n        mapComponentRenderer(Row_Row)\n    ], Renderer);\n    return Renderer;\n}(Block_Renderer));\n\n// Add style override(s) and apply style sheet\nRow_Row.addStyleOverride(Style_Style.withClass(Row_CSS_CLASS));\nStyles_Styles.define(\"UI-Block \" + Row_CSS_CLASS, {\n    \".~~\": {\n        lineHeight: \"0\",\n        maxHeight: \"none\",\n        overflow: \"visible\"\n    },\n    \".~_wrapper\": {\n        display: \"table\",\n        verticalAlign: \"middle\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Blocks/Table.js\nvar Blocks_Table___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Blocks_Table___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar Table_CSS_CLASS = \"UI-Table\";\n/** @internal DOM-specific component renderer */\nvar Table_Renderer = (function (_super) {\n    Blocks_Table___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component, \"table\") || this;\n        // create main DOM elements\n        _this.thead = document.createElement(\"thead\");\n        _this.tbody = document.createElement(\"tbody\");\n        _this.element.appendChild(_this.tbody);\n        _this.context.root = _this.tbody;\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        var component = this.component;\n        // remove (old) header element first\n        while (this.element.firstChild !== this.tbody)\n            this.element.removeChild(this.element.firstChild);\n        // add header if needed (just render synchronously)\n        if (component.header && component.header.columns.length &&\n            component.rows.length) {\n            // copy ltr/rtl flow direction if set at component level\n            if (component.header && component.flowDirection) {\n                unobserved(function () {\n                    component.header.flowDirection = component.flowDirection;\n                });\n            }\n            var headerOut = component.header && component.header.out;\n            if (headerOut && headerOut.element) {\n                var theadTR = headerOut.element;\n                this.thead.appendChild(theadTR);\n                while (theadTR.previousSibling)\n                    this.thead.removeChild(theadTR.previousSibling);\n                this.element.insertBefore(this.thead, this.tbody);\n            }\n        }\n        // set row index on rendered rows\n        var rows = unobserved(function () {\n            return component.rows.map(function (r, i) { return r && (r.rowIndex = i, r); });\n        });\n        // add all table rows, if any\n        out.updated = this.context.updateAsync(rows, false, this.component.renderOptions &&\n            this.component.renderOptions.animateListItems);\n        return out;\n    };\n    Renderer = Blocks_Table___decorate([\n        mapComponentRenderer(Table_Table)\n    ], Renderer);\n    return Renderer;\n}(Block_Renderer));\n\n// Add style override and apply style sheet\nTable_Table.addStyleOverride(Style_Style.withClass(Table_CSS_CLASS + \" table\"));\nStyles_Styles.define(\"UI-Block \" + Table_CSS_CLASS, {\n    \".~~\": {\n        display: \"table\",\n        margin: \"0\",\n        borderSpacing: \"initial\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Blocks/TableRow.js\nvar Blocks_TableRow___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Blocks_TableRow___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar TableRow_CSS_CLASS = \"UI-TableRow\";\n/** @internal DOM-specific component renderer */\nvar TableRow_Renderer = (function (_super) {\n    Blocks_TableRow___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        return _super.call(this, component, \"tr\") || this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        var component = this.component;\n        // add all columns (using renderer wrappers), if any\n        var columns = [];\n        var isHeader = (component instanceof TableRow_TableHeader);\n        component.columns.forEach(function (col, i) {\n            var cell;\n            // check column content type: component or scalar\n            if (col instanceof Component_Component) {\n                // copy ltr/rtl flow direction if set at component level\n                if (component.flowDirection) {\n                    unobserved(function () {\n                        col.flowDirection = component.flowDirection;\n                    });\n                }\n                // render component synchronously, check wrapper\n                var out = col.out;\n                if (!out) {\n                    columns.push(undefined);\n                    return;\n                }\n                cell = out.wrapper;\n                var nodeName = String(cell && cell.nodeName).toLowerCase();\n                if (isHeader ? (nodeName !== \"td\") : (nodeName !== \"th\")) {\n                    // create (double) wrapper around component\n                    cell = document.createElement(isHeader ? \"th\" : \"td\");\n                    cell.style.verticalAlign = \"baseline\";\n                    cell.style.lineHeight = \"normal\";\n                    var div = document.createElement(\"div\");\n                    div.style.display = \"inline-block\";\n                    div.style.width = \"100%\";\n                    div.appendChild(out.element);\n                    cell.appendChild(div);\n                    out.wrapper = cell;\n                }\n                // add column output (with wrapper) to content list\n                columns.push(out);\n            }\n            else {\n                // create cell with text content\n                cell = document.createElement(isHeader ? \"th\" : \"td\");\n                cell.textContent = (col || col === 0) ? String(col) : \"\";\n                cell.style.whiteSpace = \"pre-wrap\";\n                // add cell element itself to content list\n                columns.push(cell);\n            }\n            // apply additional styles\n            if (component.styles[i]) {\n                var style = component.styles[i];\n                applyStyleTo((style instanceof Style_Style) ?\n                    style : new Style_Style(style), cell);\n            }\n            if (component.widths[i]) {\n                cell.style.width = component.widths[i];\n            }\n        });\n        // update TR content\n        out.updated = this.context.updateAsync(columns, true);\n        return out;\n    };\n    Renderer = Blocks_TableRow___decorate([\n        mapComponentRenderer(TableRow_TableRow)\n    ], Renderer);\n    return Renderer;\n}(Block_Renderer));\n\n// Add style override and apply style sheet\nTableRow_TableRow.addStyleOverride(Style_Style.withClass(TableRow_CSS_CLASS));\nStyles_Styles.define(\"UI-Block \" + TableRow_CSS_CLASS, {\n    \".~~\": {\n        display: \"table-row\",\n        cursor: \"inherit\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/BlockControl.js\nvar Controls_BlockControl___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Controls_BlockControl___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n/** @internal DOM-specific component renderer */\nvar BlockControl_Renderer = (function (_super) {\n    Controls_BlockControl___extends(Renderer, _super);\n    function Renderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        // update with current block component\n        out.updated = this.context.updateAsync([this.component.block]);\n        return out;\n    };\n    Renderer = Controls_BlockControl___decorate([\n        mapComponentRenderer(BlockControl_BlockControl)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/Button.js\nvar Controls_Button___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Controls_Button___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar Button_CSS_CLASS = \"UI-Button\";\n/** Overrides for predefined button styles */\nvar linkBtnOverride = Style_Style.withClass(\"btn-link\")\n    .removeClass(\"btn-secondary\", \"btn-default\");\nvar textBtnOverride = Style_Style.withClass(\"btn-text-only\")\n    .removeClass(\"btn-secondary\", \"btn-default\");\n/** @internal DOM-specific component renderer */\nvar Button_Renderer = (function (_super) {\n    Controls_Button___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        if (component instanceof LinkButton) {\n            // create link element\n            var a = _this.button = document.createElement(\"a\");\n            a.href = \"#\";\n            a.onclick = function (e) { return e.preventDefault(); };\n            _this.element.appendChild(a);\n            _this.watch(function () { return component.target; }, function (target) {\n                a.href = (typeof target === \"string\") ? target : \"#\";\n            });\n        }\n        else {\n            // create button element\n            var button = _this.button = document.createElement(\"button\");\n            button.type = \"button\";\n            _this.element.appendChild(button);\n            _this.watch(function () { return component.disabled; }, function (disabled) {\n                button.disabled = disabled;\n            });\n        }\n        // override btn styles\n        component.style_button.addClass(\"btn\");\n        if (component instanceof LinkButton)\n            component.style_button.override(linkBtnOverride);\n        if (component instanceof TextButton)\n            component.style_button.override(textBtnOverride);\n        // add watchers for component properties\n        _this.watch(function () { return applyStyleTo(component.style_button, _this.button); });\n        _this.watch(function () { return component.primary; }, function (primary) {\n            if (primary) {\n                component.style_button.addClass(\"btn-primary\");\n                component.style_button.removeClass(\"btn-secondary\", \"btn-default\");\n            }\n            else {\n                component.style_button.removeClass(\"btn-primary\");\n                component.style_button.addClass(\"btn-secondary\", \"btn-default\");\n            }\n        });\n        _this.watch(function () { return component.selected; }, function (selected) {\n            if (selected)\n                component.style_button.addClass(\"active\");\n            else\n                component.style_button.removeClass(\"active\");\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        out.liveElement = this.button;\n        var component = this.component;\n        // render text into DOM element\n        Label_Renderer.renderInto(this.button, component.icon, component.icon ? component.remGutter : 0, component.label, component.badge);\n        if (component.iconAfter) {\n            // also append iconAfter\n            Label_Renderer.renderInto(this.button, component.iconAfter, component.remGutter, \"\", \"\", true, true);\n        }\n        // set tooltip text\n        if (component.tooltipText !== undefined)\n            this.button.title = component.tooltipText;\n        return out;\n    };\n    Renderer = Controls_Button___decorate([\n        mapComponentRenderer(Button_Button)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n// inject simple URL-based activation function\ninject(Button_Button.Activation, {\n    activate: function (target) {\n        // set location to given target directly (URL, path or hash)\n        if (typeof target === \"string\")\n            window.location.href = target;\n    }\n});\n// Add style override and apply style sheet\nButton_Button.addStyleOverride(Style_Style.withClass(Button_CSS_CLASS));\nPrimaryButton.addStyleOverride(Style_Style.withClass(Button_CSS_CLASS + \" UI-PrimaryButton\"));\nButton_ToggleButton.addStyleOverride(Style_Style.withClass(Button_CSS_CLASS + \" UI-ToggleButton\"));\nLinkButton.addStyleOverride(Style_Style.withClass(Button_CSS_CLASS + \" UI-LinkButton\"));\nTextButton.addStyleOverride(Style_Style.withClass(Button_CSS_CLASS + \" UI-TextButton\"));\nRoundButton.addStyleOverride(Style_Style.withClass(Button_CSS_CLASS + \" UI-RoundButton\"));\nStyles_Styles.define(\"UI-Control \" + Button_CSS_CLASS, {\n    \".~~\": {\n        width: \"100%\"\n    },\n    \".~~ > button\": {\n        width: \"100%\",\n        whiteSpace: \"pre\"\n    },\n    \".~~.UI-TextButton > button\": {\n        border: \"0\",\n        boxShadow: \"none\",\n        outline: \"0\",\n        background: \"transparent\",\n        padding: \"0\",\n        margin: \"0\",\n        width: \"auto\",\n        minWidth: \"0\",\n        fontSize: \"inherit\",\n        fontWeight: \"inherit\",\n        fontFamily: \"inherit\",\n        fontStyle: \"inherit\",\n        height: \"auto\",\n        lineHeight: \"1em\",\n        verticalAlign: \"baseline\",\n        color: \"inherit\"\n    },\n    \".~~.UI-RoundButton > button\": {\n        padding: \"0\",\n        border: \"0\",\n        outline: \"0\",\n        borderRadius: \"50%\",\n        boxShadow: \"none\",\n        overflow: \"hidden\",\n        minWidth: \"2.2em\",\n        maxWidth: \"2.2em\",\n        height: \"2.2em\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/ButtonGroup.js\nvar Controls_ButtonGroup___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Controls_ButtonGroup___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Base class name used for CSS style sheet */\nvar ButtonGroup_CSS_CLASS = \"UI-ButtonGroup\";\n/** @internal DOM-specific component renderer */\nvar ButtonGroup_Renderer = (function (_super) {\n    Controls_ButtonGroup___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        _this.watch(function () { return component.vertical; }, function (vertical) {\n            // set appropriate class name\n            if (vertical)\n                component.style.removeClass(\"btn-group\")\n                    .addClass(\"btn-group-vertical\");\n            else\n                component.style.removeClass(\"btn-group-vertical\")\n                    .addClass(\"btn-group\");\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        var component = this.component;\n        // add all button elements\n        var elements = component.buttons.map(function (button) {\n            var buttonOut = button && button.out;\n            return buttonOut && buttonOut.liveElement;\n        });\n        out.updated = this.context.updateAsync(elements);\n        return out;\n    };\n    Renderer = Controls_ButtonGroup___decorate([\n        mapComponentRenderer(ButtonGroup_ButtonGroup)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n// Add style override and apply style sheet\nButtonGroup_ButtonGroup.addStyleOverride(Style_Style.withClass(ButtonGroup_CSS_CLASS));\nStyles_Styles.define(\"UI-Control \" + ButtonGroup_CSS_CLASS, {\n    \".~~ button\": {\n        float: \"none\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/ContainerControl.js\nvar Controls_ContainerControl___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Controls_ContainerControl___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n/** @internal DOM-specific component renderer */\nvar ContainerControl_Renderer = (function (_super) {\n    Controls_ContainerControl___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        // override line-height for this element\n        component.style.set({ lineHeight: \"0\" });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        // update with current container component\n        out.updated = this.context.updateAsync([this.component.container]);\n        return out;\n    };\n    Renderer = Controls_ContainerControl___decorate([\n        mapComponentRenderer(ContainerControl_ContainerControl)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/ControlStack.js\nvar Controls_ControlStack___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Controls_ControlStack___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar ControlStack_CSS_CLASS = \"UI-ControlStack\";\n/** @internal DOM-specific component renderer */\nvar ControlStack_Renderer = (function (_super) {\n    Controls_ControlStack___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        // add a watcher for content alignment\n        _this.watch(function () { return component.horzAlign; }, function (align) {\n            component.style.set(\"textAlign\", align || \"\");\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        var component = this.component;\n        // add all controls (using renderer wrappers), if any\n        var content = [];\n        component.content.forEach(function (c) {\n            // add spacers in between wrapper tables to stack them up\n            if (content.length) {\n                var spacer = main_div(ControlStack_CSS_CLASS + \"_spacer\");\n                spacer.style.height =\n                    (component.spacing || Styles_Styles.size.controlSpacing);\n                content.push(spacer);\n            }\n            // copy ltr/rtl flow direction if set at component level\n            if (c && component.flowDirection) {\n                unobserved(function () {\n                    c.flowDirection = component.flowDirection;\n                });\n            }\n            // add wrapper tables (inline) for all controls\n            var out = c && c.out;\n            content.push(out);\n            if (out) {\n                var wrapper = out.wrapper;\n                if (!wrapper || wrapper.className !== ControlStack_CSS_CLASS + \"_wrapper\") {\n                    wrapper = main_div(ControlStack_CSS_CLASS + \"_wrapper\", out.element);\n                    out.wrapper = wrapper;\n                }\n                // shrink table itself if component is shrinkwrapped\n                wrapper.style.width = c.shrinkwrap ? \"auto\" : \"\";\n            }\n        });\n        // update stack control element content\n        out.updated = this.context.updateAsync(content, true);\n        return out;\n    };\n    Renderer = Controls_ControlStack___decorate([\n        mapComponentRenderer(ControlStack_ControlStack)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n// Add style override and apply style sheet\nControlStack_ControlStack.addStyleOverride(Style_Style.withClass(ControlStack_CSS_CLASS));\nStyles_Styles.define(\"UI-Control \" + ControlStack_CSS_CLASS, {\n    \".~~\": {\n        lineHeight: \"0\"\n    },\n    \".~_wrapper\": {\n        display: \"inline-table\",\n        tableLayout: \"fixed\",\n        borderSpacing: \"0\",\n        width: \"100%\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/Icon.js\nvar Controls_Icon___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Controls_Icon___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar Icon_CSS_CLASS = \"UI-Icon\";\n/** @internal DOM-specific component renderer */\nvar Icon_Renderer = (function (_super) {\n    Controls_Icon___extends(Renderer, _super);\n    function Renderer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        var component = this.component;\n        // render text into DOM element\n        Label_Renderer.renderInto(this.element, component.icon);\n        // set tooltip text\n        if (component.tooltipText !== undefined)\n            this.element.title = component.tooltipText;\n        return out;\n    };\n    Renderer = Controls_Icon___decorate([\n        mapComponentRenderer(Icon_Icon)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n// Add style override and apply style sheet\nIcon_Icon.addStyleOverride(Style_Style.withClass(Icon_CSS_CLASS));\nStyles_Styles.define(\"UI-Control \" + Icon_CSS_CLASS, {\n    \".~~\": {\n        cursor: \"inherit\",\n        textAlign: \"center\",\n        lineHeight: \"1em\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/Image.js\nvar Controls_Image___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Controls_Image___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar Image_CSS_CLASS = \"UI-Image\";\n/** @internal DOM-specific component renderer */\nvar Image_Renderer = (function (_super) {\n    Controls_Image___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        // create image element\n        var img = _this.img = document.createElement(\"img\");\n        _this.element.appendChild(img);\n        // add style watcher\n        _this.watch(function () { return applyStyleTo(component.style_img, img); });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        out.liveElement = this.img;\n        var component = this.component;\n        // create a new promise if needed\n        if (!component.resolveReady) {\n            component.ready = new Promise_Promise(function (resolve) {\n                component.resolveReady = resolve;\n            });\n        }\n        // set image event handlers and then set (new) URL\n        this.img.onload = function () {\n            component.hasError = false;\n            component.resolveReady && component.resolveReady();\n            component.resolveReady = undefined;\n        };\n        this.img.onerror = function () {\n            component.hasError = true;\n            component.resolveReady && component.resolveReady();\n            component.resolveReady = undefined;\n        };\n        this.img.src = component.imageUrl;\n        // set tooltip text\n        if (component.tooltipText !== undefined)\n            this.img.title = component.tooltipText;\n        return out;\n    };\n    Renderer = Controls_Image___decorate([\n        mapComponentRenderer(Image_Image)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n// Add style override and apply style sheet\nImage_Image.addStyleOverride(Style_Style.withClass(Image_CSS_CLASS));\nStyles_Styles.define(\"UI-Control \" + Image_CSS_CLASS, {\n    \".~~ > img\": {\n        margin: \"0\",\n        outline: \"0\",\n        maxWidth: \"100%\",\n        height: \"auto\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/ProgressBar.js\nvar Controls_ProgressBar___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Controls_ProgressBar___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar ProgressBar_CSS_CLASS = \"UI-ProgressBar\";\n/** @internal DOM-specific component renderer */\nvar ProgressBar_Renderer = (function (_super) {\n    Controls_ProgressBar___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        // create inner element\n        var bar = _this.bar = document.createElement(\"span\");\n        component.style_bar.addClass(ProgressBar_CSS_CLASS + \"_bar\");\n        _this.element.appendChild(bar);\n        // add watchers for component properties\n        _this.watch(function () { return (component.flowDirection === \"rtl\"); }, function (rtl) {\n            component.style_bar.set(\"float\", rtl ? \"right\" : \"\");\n        });\n        _this.watch(function () { return applyStyleTo(component.style_bar, bar); });\n        _this.watch(function () { return component.progress; }, function (progress) {\n            component.style_bar.set(\"width\", (Math.max(0, Math.min(100, progress * 100)) || 0) + \"%\");\n        });\n        _this.watch(function () { return component.tooltipText; }, function (tooltip) {\n            if (tooltip !== undefined)\n                _this.element.title = tooltip;\n        });\n        return _this;\n    }\n    Renderer = Controls_ProgressBar___decorate([\n        mapComponentRenderer(ProgressBar_ProgressBar)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n// Add style override and apply style sheet\nProgressBar_ProgressBar.addStyleOverride(Style_Style.withClass(ProgressBar_CSS_CLASS));\nStyles_Styles.define(\"UI-Control \" + ProgressBar_CSS_CLASS, {\n    \".~~\": {\n        background: \"#f2f2f2\",\n        height: observe(function () { return Styles_Styles.size.text; }),\n        boxShadow: \"inset 0 1px 3px rgba(0,0,0,.2)\"\n    },\n    \".~_bar\": {\n        display: \"block\",\n        float: \"left\",\n        height: \"100%\",\n        background: \"rgba(0,0,0,.5)\",\n        margin: \"0\",\n        transition: \"width 250ms ease\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/Spacer.js\nvar Controls_Spacer___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Spacer___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n/** @internal DOM-specific component renderer */\nvar Spacer_Renderer = (function (_super) {\n    Controls_Spacer___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        // set element content to a single zero-width space character\n        _this.element.innerHTML = \"&#8203;\";\n        // watch height and adjust line-height along with it\n        _this.watch(function () { return component.height; }, function (height) {\n            component.style.set({ lineHeight: height });\n        });\n        return _this;\n    }\n    Renderer = Spacer___decorate([\n        mapComponentRenderer(Spacer)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/InputControls/Checkbox.js\nvar InputControls_Checkbox___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar InputControls_Checkbox___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Base class name used for CSS style sheet */\nvar Checkbox_CSS_CLASS = \"UI-CheckBox\";\n/** @internal DOM-specific component renderer */\nvar Checkbox_Renderer = (function (_super) {\n    InputControls_Checkbox___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        // add label and input classes\n        component.style_label.addClass(\"form-check-label\");\n        component.style_input.addClass(\"form-check-input\");\n        // create label, input, and text elements\n        var label = _this.label = document.createElement(\"label\");\n        var input = _this.input = document.createElement(\"input\");\n        var span = _this.span = document.createElement(\"span\");\n        label.appendChild(input);\n        label.appendChild(span);\n        _this.element.appendChild(label);\n        label.onclick = function () {\n            // send event to unchecked radios as well\n            var radios = document.querySelectorAll(\"input[type=\\\"radio\\\"][name=\\\"\" + component.name + \"\\\"]\");\n            var evt = document.createEvent(\"Events\");\n            evt.initEvent(\"change\", true, false);\n            for (var _i = 0, _a = radios; _i < _a.length; _i++) {\n                var radio = _a[_i];\n                radio.dispatchEvent(evt);\n            }\n        };\n        input.onchange = function () { component.checked = input.checked; };\n        input.onblur = function () { component.checked = input.checked; };\n        // add watchers for component properties\n        _this.watch(function () { return applyStyleTo(component.style_label, label); });\n        _this.watch(function () { return applyStyleTo(component.style_input, input); });\n        _this.watch(function () { return applyStyleTo(component.style_text, span); });\n        _this.watch(function () { return component.disabled; }, function () {\n            _this.input.disabled = component.disabled;\n        });\n        _this.watch(function () { return component.type; }, function (type) {\n            _this.input.type = type ? \"radio\" : \"checkbox\";\n            if (type)\n                component.style.removeClass(\"checkbox\").addClass(\"radio\");\n            else\n                component.style.removeClass(\"radio\").addClass(\"checkbox\");\n        });\n        _this.watch(function () { return component.checked; }, function () {\n            _this.input.checked = !!component.checked;\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        out.liveElement = this.input;\n        var component = this.component;\n        // set properties\n        this.label.appendChild(this.input);\n        this.input.value = component.value;\n        this.input.name = component.name;\n        // render text into DOM element\n        var text = this.span.textContent = component.label;\n        if (!text) {\n            // move input inside of span, along with zero-width space\n            // to make sure the label has the height of 1 line at minimum\n            this.span.innerHTML = \"&#8203;\";\n            this.span.insertBefore(this.input, this.span.firstChild);\n        }\n        this.label.appendChild(this.span);\n        // set tooltip text\n        if (component.tooltipText !== undefined)\n            this.label.title = component.tooltipText;\n        return out;\n    };\n    Renderer = InputControls_Checkbox___decorate([\n        mapComponentRenderer(Checkbox_Checkbox)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n// Add style override and apply style sheet\nCheckbox_Checkbox.addStyleOverride(Style_Style.withClass(Checkbox_CSS_CLASS));\nStyles_Styles.define(\"UI-Control \" + Checkbox_CSS_CLASS, {\n    \".~~\": {},\n    \".~~ > label\": {\n        margin: \"0\",\n        paddingTop: \"0\", paddingBottom: \"0\",\n        display: \"inline\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/InputControls/SelectField.js\nvar InputControls_SelectField___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar InputControls_SelectField___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar SelectField_CSS_CLASS = \"UI-SelectField\";\n/** @internal DOM-specific component renderer */\nvar SelectField_Renderer = (function (_super) {\n    InputControls_SelectField___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        // add label and input classes\n        component.style_label.addClass(\"form-control-label\", \"control-label\");\n        component.style_input.addClass(\"form-control\");\n        // create label and input elements\n        var label = _this.label = document.createElement(\"label\");\n        var select = _this.select = document.createElement(\"select\");\n        label.htmlFor = select.id = component.uid + \"_select\";\n        _this.element.appendChild(label);\n        _this.element.appendChild(select);\n        select.onchange = function () { component.value = select.value; };\n        select.onblur = function () { component.value = select.value; };\n        // add watchers for component properties\n        var valueChanged = false;\n        _this.watch(function () { return applyStyleTo(component.style_label, label); });\n        _this.watch(function () { return applyStyleTo(component.style_input, select); });\n        _this.watch(function () { return component.disabled; }, function () {\n            _this.select.disabled = component.disabled;\n        });\n        _this.watch(function () { return component.value; }, function () {\n            var value = component.value;\n            if (value === undefined)\n                value = \"\";\n            else\n                value = String(value);\n            if (value != select.value) {\n                _this.select.value = value;\n                valueChanged = true;\n            }\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        var _this = this;\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        out.liveElement = this.select;\n        var component = this.component;\n        // remove all options and add current options\n        while (this.select.firstChild)\n            this.select.removeChild(this.select.firstChild);\n        component.options.forEach(function (option) {\n            if (option) {\n                var optionElt = document.createElement(\"option\");\n                var text = optionElt.textContent = String(option.text);\n                optionElt.value = option.value !== undefined ? option.value : text;\n                _this.select.appendChild(optionElt);\n            }\n        });\n        this.select.name = component.name;\n        // show or hide label\n        var labelText = this.label.textContent = component.label;\n        unobserved(function () {\n            component.style_label.hide(!labelText);\n        });\n        // set tooltip text\n        if (component.tooltipText !== undefined)\n            this.label.title = component.tooltipText;\n        return out;\n    };\n    Renderer = InputControls_SelectField___decorate([\n        mapComponentRenderer(SelectField_SelectField)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n// Add style override and apply style sheet\nSelectField_SelectField.addStyleOverride(Style_Style.withClass(SelectField_CSS_CLASS));\nStyles_Styles.define(\"UI-Control \" + SelectField_CSS_CLASS, {\n    \".~~\": {},\n    \".~~ > label\": {\n        font: \"inherit\"\n    },\n    \".~~ > select\": {\n        boxSizing: \"border-box\",\n        width: \"100%\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/Controls/InputControls/TextField.js\nvar InputControls_TextField___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar InputControls_TextField___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Base class name used for CSS style sheet */\nvar TextField_CSS_CLASS = \"UI-TextField\";\n/** @internal DOM-specific component renderer */\nvar TextField_Renderer = (function (_super) {\n    InputControls_TextField___extends(Renderer, _super);\n    /** Instantiate the renderer for given component */\n    function Renderer(component) {\n        var _this = _super.call(this, component) || this;\n        // add label and input classes\n        component.style_label.addClass(\"form-control-label\", \"control-label\");\n        component.style_input.addClass(\"form-control\");\n        // create label and input elements\n        var label = _this.label = document.createElement(\"label\");\n        var input = _this.input = document.createElement(component.textareaLines > 0 ? \"textarea\" : \"input\");\n        label.htmlFor = input.id = component.uid + \"_input\";\n        _this.element.appendChild(label);\n        _this.element.appendChild(input);\n        input.onchange = function () { component.value = input.value; };\n        input.onblur = function () { component.value = input.value; };\n        input.oninput = function () {\n            if (component.immediateValueUpdate)\n                component.value = input.value;\n        };\n        input.onkeydown = function (event) {\n            if (event.keyCode == 13)\n                component.value = input.value;\n        };\n        // add watchers for component properties\n        var valueChanged = false;\n        _this.watch(function () { return applyStyleTo(component.style_label, label); });\n        _this.watch(function () { return applyStyleTo(component.style_input, input); });\n        _this.watch(function () { return component.disabled; }, function () {\n            _this.input.disabled = component.disabled;\n        });\n        _this.watch(function () { return component.value; }, function () {\n            var value = component.value;\n            if (value != input.value) {\n                _this.input.value = value;\n                valueChanged = true;\n            }\n        });\n        return _this;\n    }\n    /** Generate rendered component output */\n    Renderer.prototype.render = function () {\n        // get or create the current output object\n        var out = _super.prototype.render.call(this);\n        out.liveElement = this.input;\n        var component = this.component;\n        // set properties\n        this.input.name = component.name;\n        this.input.placeholder = component.placeholderText;\n        if (component.textareaLines) {\n            // set number of rows\n            this.input.rows = component.textareaLines;\n        }\n        else {\n            // set specific text input type\n            this.input.setAttribute(\"type\", TextField_TextField.Type[component.type].toLowerCase());\n        }\n        // show or hide label\n        var labelText = this.label.textContent = component.label;\n        unobserved(function () {\n            component.style_label.hide(!labelText);\n        });\n        // set tooltip text\n        if (component.tooltipText !== undefined)\n            this.label.title = component.tooltipText;\n        return out;\n    };\n    Renderer = InputControls_TextField___decorate([\n        mapComponentRenderer(TextField_TextField)\n    ], Renderer);\n    return Renderer;\n}(ControlElement_Renderer));\n\n// inject text selection function\ninject(TextField_TextField, {\n    selectText: function (start, end) {\n        var _this = this;\n        if (start === void 0) { start = 0; }\n        var out = this.getLastRenderedOutput();\n        if (!out) {\n            // select only when rendered\n            this.Rendered.connect(function () { return _this.selectText(start, end); });\n            return;\n        }\n        // find the input element and focus it\n        var input = out.liveElement;\n        input.focus();\n        if (!end && end !== 0) {\n            // select all the way through to the end if end is undefined\n            end = input.value.length;\n        }\n        // use whatever method is available to select text\n        if (input.createTextRange) {\n            var range = input.createTextRange();\n            range.collapse(true);\n            range.moveStart('character', start);\n            range.moveEnd('character', end);\n            range.select();\n        }\n        else if (input.setSelectionRange) {\n            input.setSelectionRange(start, end);\n        }\n        else if (input.selectionStart) {\n            input.selectionStart = start;\n            input.selectionEnd = end;\n        }\n        return this;\n    }\n});\n// Add style override and apply style sheet\nTextField_TextField.addStyleOverride(Style_Style.withClass(TextField_CSS_CLASS));\nStyles_Styles.define(\"UI-Control \" + TextField_CSS_CLASS, {\n    \".~~\": {},\n    \".~~ > input\": {\n        width: \"100%\"\n    },\n    \".~~ > textarea\": {\n        width: \"100%\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Renderers/index.js\n// containers:\n\n\n\n\n// blocks:\n\n\n\n\n\n\n\n\n\n// controls:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Menu.js\nvar Menu___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n/** Mouse hover timeout after which to show/hide sub menu */\nvar HOVER_TIMEOUT = 200;\n/** Current hover timeout ID */\nvar _hoverTimer;\n/** Item height, in pixels, of one menu item; used for calculating whether the menu fits on screen vertically, before displaying the menu below or above the mouse cursor or control element */\nvar _itemHeight = 28;\n/** Display a modal context menu */\nMenu.displayContextMenu = function (options, event) {\n    return new Menu_DOMMenuComponent(options).display(event.clientX, event.clientY);\n};\n/** Display a modal dropdown menu */\nMenu.displayDropdown = function (options, ref) {\n    var out = ref.getLastRenderedOutput();\n    if (out && out.element) {\n        var r = out.element.getBoundingClientRect();\n        return new Menu_DOMMenuComponent(options)\n            .display(r.right, r.bottom, true, r.bottom - r.top);\n    }\n    return Promise_Promise.reject(new Error());\n};\n/** Remove current menu */\nMenu.dismiss = function () {\n    var page = Page_Page.getCurrentPage();\n    page && page.getComponentsByType(Menu_DOMMenuComponent)\n        .forEach(function (c) { return Screen_Screen.remove(c); });\n};\n/** Component that contains a menu DOM element */\nvar Menu_DOMMenuComponent = (function (_super) {\n    Menu___extends(DOMMenuComponent, _super);\n    /** Create DOM dropdown menu */\n    function DOMMenuComponent(options) {\n        if (options === void 0) { options = []; }\n        var _this = _super.call(this) || this;\n        _this.options = options;\n        // create UL node\n        var menu = document.createElement(\"ul\");\n        menu.style.cssFloat = \"none\";\n        menu.style.position = \"static\";\n        menu.style.boxShadow = \"none\";\n        menu.style.margin = \"0\";\n        menu.className = \"dropdown-menu show\"; // v3\n        _this._menu = menu;\n        _this.nodes.push(menu);\n        // set display options\n        _this.displayOptions = {\n            modal: true,\n            onEsc: function () {\n                // onEsc: reject promise and remove menu\n                Screen_Screen.remove(_this);\n                _this._rejector(new Error());\n            }\n        };\n        // add mouseout handler to stop sub menus from showing\n        menu.onmouseout = function (event) {\n            if (_hoverTimer)\n                window.clearTimeout(_hoverTimer);\n            _hoverTimer = undefined;\n            if (event.target === menu && !_this._subMenuShown) {\n                _hoverTimer = window.setTimeout(function () {\n                    _this._clearSubMenus();\n                    _hoverTimer = undefined;\n                }, HOVER_TIMEOUT);\n            }\n        };\n        return _this;\n    }\n    /** Display this menu at the given location on screen, either below or above; vert/horz push define the amount to displace the menu if showing on top/left; appended as child of given DOM node, or displayed on screen in its own layer */\n    DOMMenuComponent.prototype.display = function (x, y, force, vertPush, horizPush, parent) {\n        var _this = this;\n        this._isBase = !parent;\n        while (this._menu.firstChild)\n            this._menu.removeChild(this._menu.firstChild);\n        var result = new Promise_Promise(function (resolve, reject) {\n            _this._resolver = resolve;\n            _this._rejector = reject;\n        });\n        // set position around given x, y + displacement coordinates\n        this._setPosition(x, y, force, vertPush, horizPush);\n        // add options from array\n        var hasIcon = this.options.some(function (option) { return option && !!option.icon; });\n        this.options.forEach(function (option, i) {\n            if (!option)\n                return;\n            // create list item element with divider or option link\n            var li = document.createElement(\"li\");\n            _this._menu.appendChild(li);\n            if (option.disabled)\n                li.className = \"disabled\";\n            if (option.divider) {\n                // create a divider\n                li.className = \"divider dropdown-divider\";\n            }\n            else {\n                // create a text option, add click handler\n                var a = document.createElement(\"a\");\n                a.className = \"dropdown-item\";\n                a.href = \"#\";\n                if (option.disabled) {\n                    a.className += \" disabled\";\n                    a.style.cursor = \"default\";\n                    a.onclick = function (event) { event.preventDefault(); };\n                }\n                else {\n                    a.tabIndex = 0;\n                    a.style.cursor = \"pointer\";\n                    if (!option.subMenu)\n                        _this._addLinkClickHandler(a, i);\n                }\n                _this._addLinkHoverHandler(a, i);\n                li.appendChild(a);\n                // render text into link\n                var iw = hasIcon ? 1.5 : 0;\n                Label_Renderer.renderInto(a, option.icon, iw, option.label);\n                if (hasIcon)\n                    a.style.paddingLeft = \".5rem\";\n                // render far side icon\n                if (option.sideIcon) {\n                    var r = document.createElement(\"span\");\n                    r.className = \"bidi_floatEnd\";\n                    Label_Renderer.renderInto(r, option.sideIcon);\n                    a.appendChild(r);\n                }\n            }\n        });\n        // update element height estimate after display\n        this.Rendered.connectOnce(function (out) {\n            sleep(30).then(function () {\n                var elt = out.element;\n                if (elt) {\n                    var max = 0;\n                    for (var _i = 0, _a = elt.querySelectorAll(\"li\"); _i < _a.length; _i++) {\n                        var li = _a[_i];\n                        max = Math.max(max, li.offsetHeight);\n                    }\n                    if (max && _itemHeight !== max) {\n                        _itemHeight = max;\n                        _this._setPosition(x, y, force, vertPush, horizPush);\n                    }\n                }\n            });\n        });\n        // add menu as a child or display as new modal layer\n        var out = this.out;\n        if (parent && out)\n            parent.appendChild(out.element);\n        else\n            Screen_Screen.displayAsync(this);\n        return result;\n    };\n    DOMMenuComponent.prototype._setPosition = function (x, y, forceLeft, vertPush, horizPush) {\n        var _this = this;\n        // position menu on left or right of given coordinates\n        if (x + 200 < window.innerWidth && (!forceLeft || x < 200)) {\n            this.style.set({ left: x + \"px\", right: \"auto\" });\n        }\n        else {\n            var right = (window.innerWidth - x + (horizPush || 0)) + \"px\";\n            this.style.set({ left: \"auto\", right: right });\n        }\n        // position menu on top or bottom of given coordinates\n        if (y + this.options.length * _itemHeight + 10 < window.innerHeight) {\n            this.style.set({ top: y + \"px\", bottom: \"auto\" });\n        }\n        else {\n            var bottom = (window.innerHeight - y + (vertPush || 0)) + \"px\";\n            this.style.set({ top: \"auto\", bottom: bottom });\n            var checkTop = function () {\n                // if pushed above window top, move to very top\n                if (_this._menu.offsetTop < 0)\n                    _this.style.set({ top: \"0\", bottom: \"auto\" });\n            };\n            window.setTimeout(checkTop, 10);\n            window.setTimeout(checkTop, 50);\n            window.setTimeout(checkTop, 100);\n        }\n    };\n    DOMMenuComponent.prototype._clearSubMenus = function () {\n        this._subMenuShown = undefined;\n        var out = this.getLastRenderedOutput();\n        var elt = out && out.element;\n        while (elt && elt.nextSibling)\n            elt.parentNode.removeChild(elt.nextSibling);\n    };\n    DOMMenuComponent.prototype._addLinkClickHandler = function (elt, i) {\n        var _this = this;\n        var option = this.options[i];\n        elt.onclick = function (event) {\n            event.preventDefault();\n            if (_this._isBase)\n                Screen_Screen.remove(_this);\n            _this._resolver(option.key || (i + 1));\n        };\n    };\n    DOMMenuComponent.prototype._addLinkHoverHandler = function (elt, i) {\n        var _this = this;\n        var option = this.options[i];\n        elt.onmouseover = function () {\n            // clear timer to show/hide (other) sub menu\n            if (_hoverTimer) {\n                window.clearTimeout(_hoverTimer);\n                _hoverTimer = undefined;\n            }\n            // set timer to show current sub menu, if not already shown\n            if (_this._subMenuShown !== option) {\n                _hoverTimer = window.setTimeout(function () {\n                    _this._clearSubMenus();\n                    _hoverTimer = undefined;\n                    if (!option.subMenu)\n                        return;\n                    _this._subMenuShown = option;\n                    // create and display sub menu\n                    var r = elt.parentNode.getBoundingClientRect();\n                    var out = _this.getLastRenderedOutput();\n                    var parentNode = out && out.element.parentNode;\n                    var p = new DOMMenuComponent(option.subMenu)\n                        .display(r.right - 5, r.top, false, -_itemHeight, r.right - r.left - 10, parentNode);\n                    p.then(function (choice) {\n                        if (_this._isBase)\n                            Screen_Screen.remove(_this);\n                        if (typeof choice == \"number\" && choice > 0) {\n                            var base = 100;\n                            while (base <= choice)\n                                base *= 100;\n                            choice = (i + 1) * base + choice;\n                        }\n                        _this._resolver(choice);\n                    });\n                }, HOVER_TIMEOUT);\n            }\n        };\n    };\n    return DOMMenuComponent;\n}(DOMBlock_DOMBlock));\n// Add style override and apply style sheet\nMenu_DOMMenuComponent.addStyleOverride(Style_Style.withClass(\"UI-Menu dropdown open\")\n    .addShadowEffect(.75));\nStyles_Styles.define(\"UI-Block UI-Menu\", {\n    \".~~\": {\n        position: \"absolute\",\n        fontSize: observe(function () { return Styles_Styles.size.text; }),\n        lineHeight: \"normal\"\n    }\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/Events.js\n\n\n// lookup table for custom event names\nvar customEventNames = {\n    DoubleClick: \"dblclick\",\n    Press: \"mousedown\",\n    MouseEnter: \"mouseover\",\n    MouseLeave: \"mouseout\",\n    FnKeyPressed: \"keydown\",\n    DragStart: \"uidragstart\",\n    DragEnter: \"uidragenter\",\n    DragLeave: \"uidragleave\",\n    DragDrop: \"uidragdrop\",\n    FocusGained: \"uicustomfocusin\",\n    Clicked: \"uiasyncclick\",\n    DoubleClicked: \"uiasyncdblclick\",\n    Pressed: \"uiasyncpress\",\n    ValueChange: \"change\",\n    ValueInput: \"input\"\n};\n/** Helper function to get the DOM event name for given signal name */\nfunction _getName(signalName) {\n    return customEventNames[signalName] || signalName.toLowerCase();\n}\n/** Called when a first handler is added (mixin) */\nfunction onHandlerConnected() {\n    var _this = this;\n    // when connected: add event handler when element is known\n    this.component.getRenderedOutputAsync().then(function (out) {\n        var addHandler = function () {\n            _this.domEventHandler = function (event) {\n                var test = (_this.isConnected() || undefined) &&\n                    (!_this.domEventFilter || _this.domEventFilter(event));\n                if (test !== undefined) {\n                    // consume the event if not in capture mode\n                    if (!_this.useCapture)\n                        event.stopPropagation();\n                    // emit signal now and wait for handlers to be called\n                    // (unless filter function returned false)\n                    if (test) {\n                        _this(event);\n                        runYield(true);\n                    }\n                }\n            };\n            (out.liveElement || out.element).addEventListener(_this.domEventName, _this.domEventHandler, _this.useCapture);\n        };\n        if (!_this.domEventHandler) {\n            // add handler only after rendering, if possible\n            if (out.updated)\n                out.updated.then(addHandler);\n            else\n                addHandler();\n        }\n    });\n}\n/** Called when all handlers have been disconnected (mixin) */\nfunction onHandlersDisconnected() {\n    var _this = this;\n    // when disconnected: remove event handler\n    this.component.getRenderedOutputAsync().then(function (out) {\n        if (_this.domEventHandler && !_this.isConnected) {\n            (out.liveElement || out.element).removeEventListener(_this.domEventName, _this.domEventHandler);\n            delete _this.domEventHandler;\n        }\n    });\n}\n// inject a method to create DOM event signals into the Component class\ninject(Component_Component, {\n    \"@createEventSignal\": function (id, signalClass, opt) {\n        var _this = this;\n        var result;\n        var domEventFilter;\n        var useCapture = true;\n        switch (id) {\n            case \"Press\":\n            case \"Click\":\n            case \"DoubleClick\":\n            case \"MouseContextMenu\":\n                // only emit if the element is not disabled (e.g. button)\n                domEventFilter = function (event) {\n                    return !(event.currentTarget.disabled);\n                };\n                result = defineComponentSignal(signalClass, this, {\n                    domEventName: _getName(id), useCapture: useCapture, domEventFilter: domEventFilter,\n                    onHandlerConnected: onHandlerConnected, onHandlersDisconnected: onHandlersDisconnected\n                });\n                break;\n            case \"Pressed\":\n            case \"Clicked\":\n            case \"DoubleClicked\":\n                // only emit if the element is not disabled (e.g. button)\n                domEventFilter = function (event) {\n                    return !(event.currentTarget.disabled);\n                };\n                result = defineComponentSignal(signalClass, this, {\n                    domEventName: _getName(id), domEventFilter: domEventFilter,\n                    onHandlerConnected: onHandlerConnected, onHandlersDisconnected: onHandlersDisconnected\n                });\n                break;\n            case \"MouseEnter\":\n            case \"MouseLeave\":\n                // only emit if there is no source/destination target, or\n                // if the source/destination target is the current element, or\n                // if the source/destination is outside of the current element\n                // (i.e. current element does not contain source/destination)\n                domEventFilter = function (event) { return (!event.relatedTarget ||\n                    //event.relatedTarget === event.currentTarget ||\n                    event.relatedTarget !== event.currentTarget &&\n                        !(event.relatedTarget.compareDocumentPosition(event.currentTarget) & 8)); };\n                result = defineComponentSignal(signalClass, this, {\n                    domEventName: _getName(id),\n                    domEventFilter: domEventFilter, useCapture: useCapture,\n                    onHandlerConnected: onHandlerConnected, onHandlersDisconnected: onHandlersDisconnected\n                });\n                break;\n            case \"FnKeyPressed\":\n                domEventFilter = function (event) { return (event.keyCode == opt || undefined); };\n                useCapture = false;\n            case \"KeyDown\":\n            case \"KeyPress\":\n                result = defineComponentSignal(signalClass, this, {\n                    domEventName: _getName(id),\n                    domEventFilter: domEventFilter, useCapture: useCapture,\n                    onHandlerConnected: onHandlerConnected, onHandlersDisconnected: onHandlersDisconnected,\n                });\n                break;\n            case \"Focus\":\n            case \"Blur\":\n            case \"ValueChange\":\n            case \"ValueInput\":\n                result = defineComponentSignal(signalClass, this, {\n                    domEventName: _getName(id), useCapture: useCapture,\n                    onHandlerConnected: onHandlerConnected, onHandlersDisconnected: onHandlersDisconnected\n                });\n                break;\n            case \"FocusGained\":\n                domEventFilter = function (event) {\n                    if (!result.domAsyncFocus) {\n                        result.domAsyncFocus = true;\n                        // add a re-focus listener to the list\n                        var componentElt = event.currentTarget;\n                        onRefocusCallbacks.push(function (elt) {\n                            // ignore if not blurred and not focused self or child\n                            if (elt && (elt === componentElt ||\n                                event.target.compareDocumentPosition(componentElt) & 8))\n                                return true;\n                            // otherwise, emit FocusLost and remove listener\n                            result.domAsyncFocus = false;\n                            _this.FocusLost(_lastBlurEvent);\n                            return false;\n                        });\n                        // emit the FocusGained signal now\n                        return true;\n                    }\n                    // if already focused, do not emit but consume the event\n                    return false;\n                };\n                result = defineComponentSignal(signalClass, this, {\n                    domEventName: _getName(id), domEventFilter: domEventFilter,\n                    onHandlerConnected: onHandlerConnected, onHandlersDisconnected: onHandlersDisconnected\n                });\n                break;\n            case \"FocusLost\":\n                // do not listen to DOM events at all; this signal is emitted\n                // from the callback added to onRefocusCallbacks by FocusGained\n                result = defineComponentSignal(signalClass, this);\n                break;\n            case \"DragEnter\":\n            case \"DragLeave\":\n                useCapture = false;\n            case \"DragStart\":\n            case \"DragDrop\":\n                result = defineComponentSignal(signalClass, this, {\n                    domEventName: _getName(id), useCapture: useCapture,\n                    onHandlerConnected: onHandlerConnected, onHandlersDisconnected: onHandlersDisconnected\n                });\n                break;\n            default:\n                throw new TypeError();\n        }\n        return result;\n    }\n});\n/** List of callbacks that are called with a newly focused element, or undefined if none; to dispatch a non-bubbling FocusLost event if the focus moved outside of the originally focused component; callbacks return true if focus was not lost (callback stays in the list) or false otherwise */\nvar onRefocusCallbacks = [];\n/** Last blur event that occurred, waiting for another focus event or timeout */\nvar _lastBlurEvent;\n/** Current timer ID for blur event listener callback */\nvar _blurTimeout;\n// listen for focus/blur events to manage FocusGained/Lost behavior\ndocument.addEventListener(\"focus\", function (event) {\n    // check if blur timeout is active (waiting for re-focus)\n    if (_lastBlurEvent) {\n        // pass newly focused element to listeners, stop waiting\n        onRefocusCallbacks = onRefocusCallbacks.filter(function (f) { return f(event.target); });\n        clearTimeout(_blurTimeout);\n        _lastBlurEvent = undefined;\n    }\n    // dispatch custom event to trigger FocusGained on newly focused element\n    // (bubbles so that it can be consumed normally by connecting to signal)\n    var canceled = !event.target.dispatchEvent(new CustomEvent(customEventNames[\"FocusGained\"], { bubbles: true, cancelable: true }));\n    if (canceled)\n        event.preventDefault();\n}, true);\ndocument.addEventListener(\"blur\", function (event) {\n    if (!onRefocusCallbacks.length)\n        return;\n    // set a timeout to wait for possible focus events\n    _blurTimeout = setTimeout(function () {\n        // no re-focus occurred, inform all listeners\n        onRefocusCallbacks.forEach(function (f) { return f(); });\n        onRefocusCallbacks.length = 0;\n        _lastBlurEvent = undefined;\n    }, 0);\n    _lastBlurEvent = event;\n}, true);\n// listen to click/dblclick/press and dispatch asynchronous events\nfunction addAsyncEvent(origEvent, asyncEvent) {\n    document.addEventListener(origEvent, function (event) {\n        var target = event.target;\n        setTimeout(function () {\n            var toDispatch = new CustomEvent(asyncEvent, { bubbles: true, cancelable: true });\n            toDispatch.button = event.button;\n            toDispatch.clientX = event.clientX;\n            toDispatch.clientY = event.clientY;\n            toDispatch.altKey = event.altKey;\n            toDispatch.ctrlKey = event.ctrlKey;\n            toDispatch.metaKey = event.metaKey;\n            toDispatch.shiftKey = event.shiftKey;\n            target.dispatchEvent(toDispatch);\n        }, 0);\n    }, true);\n}\naddAsyncEvent(\"click\", customEventNames[\"Clicked\"]);\naddAsyncEvent(\"dblclick\", customEventNames[\"DblClicked\"]);\naddAsyncEvent(\"mousedown\", customEventNames[\"Pressed\"]);\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI/index.js\nvar dom_lib_UI_namespaceObject = {};\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"DOM\", function() { return DOM_namespaceObject; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Style\", function() { return Style_Style; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Page\", function() { return Page_Page; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"PageRenderer\", function() { return Page_PageRenderer; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Screen\", function() { return Screen_Screen; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Binding\", function() { return Binding_Binding; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"TwoWayBinding\", function() { return TwoWayBinding; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ArrayBinding\", function() { return Binding_ArrayBinding; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"bind\", function() { return bind; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"bind2\", function() { return bind2; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"bindComponents\", function() { return bindComponents; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"_getBatchTransformer\", function() { return _getBatchTransformer; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Animation\", function() { return Animation; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Drag\", function() { return Drag_Drag; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Menu\", function() { return Menu; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Component\", function() { return Component_Component; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ComponentSignal\", function() { return ComponentSignal; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ComponentSignalHandler\", function() { return ComponentSignalHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"defineComponentSignal\", function() { return defineComponentSignal; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ActionHandler\", function() { return ActionHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"KeyEventSignal\", function() { return KeyEventSignal; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"KeyHandler\", function() { return KeyHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"PointerEventSignal\", function() { return PointerEventSignal; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"PointerHandler\", function() { return PointerHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"DragEventSignal\", function() { return DragEventSignal; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"DragHandler\", function() { return DragHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ComponentFactory\", function() { return ComponentFactory_ComponentFactory; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"makeFactory\", function() { return makeFactory; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ComponentRenderer\", function() { return ComponentRenderer_ComponentRenderer; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ComponentRenderHandler\", function() { return ComponentRenderHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"mapComponentRenderer\", function() { return mapComponentRenderer; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"TextLabelFactory\", function() { return TextLabelFactory_TextLabelFactory; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"tl\", function() { return tl; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Container\", function() { return Container_Container; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"FlowContainer\", function() { return FlowContainer; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"DialogContainer\", function() { return DialogContainer_DialogContainer; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"DrawerContainer\", function() { return DrawerContainer; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"OppositeDrawerContainer\", function() { return OppositeDrawerContainer; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"LayoutContainer\", function() { return LayoutContainer_LayoutContainer; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Block\", function() { return Block_Block; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Card\", function() { return Card_Card; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ContainerBlock\", function() { return ContainerBlock_ContainerBlock; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Divider\", function() { return Divider_Divider; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"List\", function() { return List_List; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ListSelectionHandler\", function() { return ListSelectionHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"TreeList\", function() { return TreeList_TreeList; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"TreeListSelectionHandler\", function() { return TreeListSelectionHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"TreeListFoldHandler\", function() { return TreeListFoldHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"TreeListRow\", function() { return TreeListRow_TreeListRow; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"NavList\", function() { return NavList_NavList; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"NavListSelectionHandler\", function() { return NavListSelectionHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Row\", function() { return Row_Row; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"CloseRow\", function() { return CloseRow; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"OppositeRow\", function() { return OppositeRow; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"CenterRow\", function() { return CenterRow; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Table\", function() { return Table_Table; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"TableRow\", function() { return TableRow_TableRow; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"TableHeader\", function() { return TableRow_TableHeader; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ControlElement\", function() { return ControlElement_ControlElement; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"BlockControl\", function() { return BlockControl_BlockControl; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Button\", function() { return Button_Button; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ButtonDropdownClickHandler\", function() { return ButtonDropdownClickHandler; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"PrimaryButton\", function() { return PrimaryButton; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ToggleButton\", function() { return Button_ToggleButton; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"LinkButton\", function() { return LinkButton; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"TextButton\", function() { return TextButton; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"RoundButton\", function() { return RoundButton; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ButtonGroup\", function() { return ButtonGroup_ButtonGroup; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ContainerControl\", function() { return ContainerControl_ContainerControl; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ControlStack\", function() { return ControlStack_ControlStack; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"CloseControlStack\", function() { return CloseControlStack; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Icon\", function() { return Icon_Icon; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Image\", function() { return Image_Image; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Label\", function() { return Label_Label; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"WideLabel\", function() { return WideLabel; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Paragraph\", function() { return Paragraph; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Heading1\", function() { return Heading1; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Heading2\", function() { return Heading2; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Heading3\", function() { return Heading3; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Heading4\", function() { return Heading4; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Heading5\", function() { return Heading5; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Heading6\", function() { return Heading6; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"ProgressBar\", function() { return ProgressBar_ProgressBar; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Spacer\", function() { return Spacer; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"InputControl\", function() { return InputControl_InputControl; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"Checkbox\", function() { return Checkbox_Checkbox; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"SelectField\", function() { return SelectField_SelectField; });\n__webpack_require__.d(dom_lib_UI_namespaceObject, \"TextField\", function() { return TextField_TextField; });\n\n// platform specifics:\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./dist/dom/lib/UI.js\nvar dist_dom_lib_UI_namespaceObject = {};\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"default\", function() { return lib_UI_defaultExport; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"DOM\", function() { return DOM_namespaceObject; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Style\", function() { return Style_Style; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Page\", function() { return Page_Page; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"PageRenderer\", function() { return Page_PageRenderer; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Screen\", function() { return Screen_Screen; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Binding\", function() { return Binding_Binding; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"TwoWayBinding\", function() { return TwoWayBinding; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ArrayBinding\", function() { return Binding_ArrayBinding; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"bind\", function() { return bind; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"bind2\", function() { return bind2; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"bindComponents\", function() { return bindComponents; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"_getBatchTransformer\", function() { return _getBatchTransformer; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Animation\", function() { return Animation; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Drag\", function() { return Drag_Drag; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Menu\", function() { return Menu; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Component\", function() { return Component_Component; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ComponentSignal\", function() { return ComponentSignal; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ComponentSignalHandler\", function() { return ComponentSignalHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"defineComponentSignal\", function() { return defineComponentSignal; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ActionHandler\", function() { return ActionHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"KeyEventSignal\", function() { return KeyEventSignal; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"KeyHandler\", function() { return KeyHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"PointerEventSignal\", function() { return PointerEventSignal; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"PointerHandler\", function() { return PointerHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"DragEventSignal\", function() { return DragEventSignal; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"DragHandler\", function() { return DragHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ComponentFactory\", function() { return ComponentFactory_ComponentFactory; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"makeFactory\", function() { return makeFactory; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ComponentRenderer\", function() { return ComponentRenderer_ComponentRenderer; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ComponentRenderHandler\", function() { return ComponentRenderHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"mapComponentRenderer\", function() { return mapComponentRenderer; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"TextLabelFactory\", function() { return TextLabelFactory_TextLabelFactory; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"tl\", function() { return tl; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Container\", function() { return Container_Container; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"FlowContainer\", function() { return FlowContainer; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"DialogContainer\", function() { return DialogContainer_DialogContainer; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"DrawerContainer\", function() { return DrawerContainer; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"OppositeDrawerContainer\", function() { return OppositeDrawerContainer; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"LayoutContainer\", function() { return LayoutContainer_LayoutContainer; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Block\", function() { return Block_Block; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Card\", function() { return Card_Card; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ContainerBlock\", function() { return ContainerBlock_ContainerBlock; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Divider\", function() { return Divider_Divider; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"List\", function() { return List_List; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ListSelectionHandler\", function() { return ListSelectionHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"TreeList\", function() { return TreeList_TreeList; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"TreeListSelectionHandler\", function() { return TreeListSelectionHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"TreeListFoldHandler\", function() { return TreeListFoldHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"TreeListRow\", function() { return TreeListRow_TreeListRow; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"NavList\", function() { return NavList_NavList; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"NavListSelectionHandler\", function() { return NavListSelectionHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Row\", function() { return Row_Row; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"CloseRow\", function() { return CloseRow; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"OppositeRow\", function() { return OppositeRow; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"CenterRow\", function() { return CenterRow; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Table\", function() { return Table_Table; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"TableRow\", function() { return TableRow_TableRow; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"TableHeader\", function() { return TableRow_TableHeader; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ControlElement\", function() { return ControlElement_ControlElement; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"BlockControl\", function() { return BlockControl_BlockControl; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Button\", function() { return Button_Button; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ButtonDropdownClickHandler\", function() { return ButtonDropdownClickHandler; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"PrimaryButton\", function() { return PrimaryButton; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ToggleButton\", function() { return Button_ToggleButton; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"LinkButton\", function() { return LinkButton; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"TextButton\", function() { return TextButton; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"RoundButton\", function() { return RoundButton; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ButtonGroup\", function() { return ButtonGroup_ButtonGroup; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ContainerControl\", function() { return ContainerControl_ContainerControl; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ControlStack\", function() { return ControlStack_ControlStack; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"CloseControlStack\", function() { return CloseControlStack; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Icon\", function() { return Icon_Icon; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Image\", function() { return Image_Image; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Label\", function() { return Label_Label; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"WideLabel\", function() { return WideLabel; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Paragraph\", function() { return Paragraph; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Heading1\", function() { return Heading1; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Heading2\", function() { return Heading2; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Heading3\", function() { return Heading3; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Heading4\", function() { return Heading4; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Heading5\", function() { return Heading5; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Heading6\", function() { return Heading6; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"ProgressBar\", function() { return ProgressBar_ProgressBar; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Spacer\", function() { return Spacer; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"InputControl\", function() { return InputControl_InputControl; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"Checkbox\", function() { return Checkbox_Checkbox; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"SelectField\", function() { return SelectField_SelectField; });\n__webpack_require__.d(dist_dom_lib_UI_namespaceObject, \"TextField\", function() { return TextField_TextField; });\n\n\n/* harmony default export */ var lib_UI_defaultExport = (dom_lib_UI_namespaceObject);\n\n// CONCATENATED MODULE: ./dist/core/lib/App/View/ViewLayout.js\n\n/** @internal */\nvar FRAG_ID_PROP = \"@_fragment_id\";\n/** @internal */\nvar FRAG_HASH_PREFIX = \"#frag:\";\n;\nfunction isLayoutFragment(component, layout) {\n    // the component must include a fragment ID property, which must also be\n    // referenced by the view layout class (with matching class reference)\n    var id = component && component[FRAG_ID_PROP];\n    if (id && layout) {\n        return !!layout[FRAG_HASH_PREFIX + id] &&\n            (component instanceof layout[FRAG_HASH_PREFIX + id]);\n    }\n    return !!id;\n}\n/** *Property decorator*, defines the UI Component class (or factory) referenced by the decorated static property as a layout fragment, for use with layout views (i.e. classes defined on `Layout` namespace and derived classes), such that instances of the referenced component class are added to the `fragments` object on layout view instances [decorator] */\nfunction layoutFragment(target, id) {\n    var componentClass = target[id];\n    if (typeof componentClass !== \"function\" ||\n        !(componentClass.prototype instanceof Component_Component))\n        throw new Error(\"Invalid layout fragment component class for \" + id);\n    if (componentClass.prototype[FRAG_ID_PROP] &&\n        componentClass.prototype[FRAG_ID_PROP] !== id)\n        throw new Error(\"Cannot reuse fragment component class \" +\n            componentClass.prototype[FRAG_ID_PROP] + \" as \" + id);\n    componentClass.prototype[FRAG_ID_PROP] = id;\n    componentClass.isFragmentFactory = true;\n    target.prototype[FRAG_HASH_PREFIX + id] = componentClass;\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/App/View/Layout/Base.js\nvar Base___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Base___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Helper function to initialize layout view instances: add a `.fragments` object with observable properties for all fragments that have been declared using `@layoutFragment` */\nfunction _initLayout(target) {\n    target.fragments = new Async_defaultExport.ObservableObject();\n    for (var id in target) {\n        if (id[0] === \"#\" && id.slice(0, 6) === FRAG_HASH_PREFIX)\n            Async_defaultExport.makePropertyObservable(target.fragments, id.slice(6));\n    }\n}\n/** Helper function to implement `.appendChild` method on layout view classes */\nfunction _appendChild(target, child, recurse) {\n    if (!recurse && child instanceof Async_defaultExport.ObservableValue) {\n        return child.map(function (v) { return _appendChild(target, v, true); });\n    }\n    // check for fragments with a fragment ID\n    var id = child && child[FRAG_ID_PROP];\n    if (id) {\n        // check if target defines same ID with matching component class\n        if (!target[FRAG_HASH_PREFIX + id] || !(child instanceof target[FRAG_HASH_PREFIX + id]))\n            throw new Error(\"Invalid fragment type for this layout: \" + id);\n        target.fragments[id] = child;\n        return undefined;\n    }\n    return child;\n}\n/** Represents a container layout, can be extended to define container-based layouts and their associated layout fragments (using `layoutFragment` on static properties) */\nvar Base_BaseLayout = (function (_super) {\n    Base___extends(BaseLayout, _super);\n    /** Create a new instance of this layout view */\n    function BaseLayout() {\n        var _this = _super.call(this) || this;\n        _initLayout(_this);\n        return _this;\n    }\n    /** Add a child component to this component, or store a view fragment in the `.fragments` object; returns this */\n    BaseLayout.prototype.appendChild = function (child) {\n        child = _appendChild(this, child);\n        if (child !== undefined)\n            _super.prototype.appendChild.call(this, child);\n        return this;\n    };\n    /** Set given observable property of this component to given named fragment (observed property of `.fragments` object), with optional transformation function (run inside the observable context, for e.g. conditional assignment) */\n    BaseLayout.prototype.bindFragment = function (propertyName, fragmentName, transform) {\n        var _this = this;\n        if (!this.hasObservableProperty(propertyName))\n            throw new Error(\"Property \" + propertyName + \" is not observable\");\n        this[propertyName] = Async_defaultExport.observe(function () {\n            var fragment = _this.fragments[fragmentName];\n            return transform ? transform(fragment) : fragment;\n        });\n    };\n    /** Dummy property for duck typing of layout classes */\n    BaseLayout.isLayoutClass = true;\n    BaseLayout = Base___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.Block, true)\n    ], BaseLayout);\n    return BaseLayout;\n}(LayoutContainer_LayoutContainer));\n\n/** Represents a dialog layout, can be extended to define dialog container-based layouts and their associated layout fragments (using `layoutFragment` on static properties) */\nvar Base_BaseDialogLayout = (function (_super) {\n    Base___extends(BaseDialogLayout, _super);\n    /** Create a new instance of this layout view */\n    function BaseDialogLayout() {\n        var _this = _super.call(this) || this;\n        _initLayout(_this);\n        return _this;\n    }\n    /** Add a child component to this component, or store a view fragment in the `.fragments` object; returns this */\n    BaseDialogLayout.prototype.appendChild = function (child) {\n        child = _appendChild(this, child);\n        if (child !== undefined)\n            _super.prototype.appendChild.call(this, child);\n        return this;\n    };\n    /** Set given observable property of this component to given named fragment (observed property of `.fragments` object), with optional transformation function (run inside the observable context, for e.g. conditional assignment) */\n    BaseDialogLayout.prototype.bindFragment = function (propertyName, fragmentName, transform) {\n        var _this = this;\n        if (!this.hasObservableProperty(propertyName))\n            throw new Error(\"Property \" + propertyName + \" is not observable\");\n        this[propertyName] = Async_defaultExport.observe(function () {\n            var fragment = _this.fragments[fragmentName];\n            return transform ? transform(fragment) : fragment;\n        });\n    };\n    /** Dummy property for duck typing of layout classes */\n    BaseDialogLayout.isLayoutClass = true;\n    BaseDialogLayout = Base___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.Block, true)\n    ], BaseDialogLayout);\n    return BaseDialogLayout;\n}(DialogContainer_DialogContainer));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/App/View/Layout/Single.js\nvar Single___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Single___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Represents a strictly vertical layout that contains a header container fragment and a footer container fragment; all other content will be added to the main content area */\nvar Single_VerticalLayout = (function (_super) {\n    Single___extends(VerticalLayout, _super);\n    function VerticalLayout() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** Layout fragment for the container's fixed header */\n    VerticalLayout.Header = Container_Container.with();\n    /** Layout fragment for the container's fixed footer */\n    VerticalLayout.Footer = Container_Container.with();\n    Single___decorate([\n        layoutFragment\n    ], VerticalLayout, \"Header\", void 0);\n    Single___decorate([\n        layoutFragment\n    ], VerticalLayout, \"Footer\", void 0);\n    return VerticalLayout;\n}(Base_BaseLayout.with(function (self) {\n    self.bindFragment(\"header\", \"Header\");\n    self.bindFragment(\"footer\", \"Footer\");\n})));\n\n/** Represents a strictly vertical layout that contains a header container fragment and a footer container fragment, all other content will be added to the _scrollable_ main content container */\nvar ScrollableLayout = (function (_super) {\n    Single___extends(ScrollableLayout, _super);\n    function ScrollableLayout() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ScrollableLayout;\n}(Single_VerticalLayout.with({\n    scrollable: true\n})));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/App/View/Layout/App.js\nvar App___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar App___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Represents the top header row of an application page, contains only one Row instance; all content passed into the initializer is automatically added to this row, not the container itself */\nvar App_AppBarLayout = (function (_super) {\n    App___extends(AppBarLayout, _super);\n    function AppBarLayout() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AppBarLayout.prototype.appendChild = function (child) {\n        // find (first) Row instance and append there if possible\n        if (this.content.length && (child instanceof ControlElement_ControlElement)) {\n            var row = this.getComponentsByType(Row_Row)[0];\n            if (row)\n                row.appendChild(child);\n        }\n        else if (child instanceof Row_Row) {\n            // add the Row itself\n            _super.prototype.appendChild.call(this, child);\n        }\n        return this;\n    };\n    AppBarLayout = App___decorate([\n        ComponentFactory_ComponentFactory.appendChildComponents(ComponentFactory_ComponentFactory.CLevel.ControlElement, true)\n    ], AppBarLayout);\n    return AppBarLayout;\n}(Container_Container.with(Row_Row.with({ height: \"100%\" }))));\n\n/** Represents a full-page application layout that contains a header app bar fragment and a footer container fragment */\nvar App_AppViewLayout = (function (_super) {\n    App___extends(AppViewLayout, _super);\n    function AppViewLayout() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /** Layout fragment for the application bar at the top of the screen, contains only one Row instance; all content passed into the initializer is automatically added to this row, not the container itself */\n    AppViewLayout.Header = App_AppBarLayout.with();\n    App___decorate([\n        layoutFragment\n    ], AppViewLayout, \"Header\", void 0);\n    return AppViewLayout;\n}(Single_VerticalLayout));\n\n/** Represents a full-page application layout that contains a header app bar fragment and a footer container fragment, as well as a scrollable navigation sidebar; the sidebar is automatically collapsed while `.sidebarCollapsed` is set (defaults to true on small screens, observable) but is also wrapped in a drawer container in the `.drawer` property, which can be opened using its `openAsync()` method (e.g. from a click handler on a button available in the `.AppBar` fragment) */\nvar App_HubViewLayout = (function (_super) {\n    App___extends(HubViewLayout, _super);\n    /** Create a view instance and initialize the sidebar/drawer combination */\n    function HubViewLayout() {\n        var _this = _super.call(this) || this;\n        // prepare a drawer factory in advance\n        _this._drawerIsOpen = new Async_defaultExport.ObservableValue();\n        _this.drawer = new (DrawerContainer.with(Async_defaultExport.observe(function () { return _this.fragments[\"Sidebar\"]; })));\n        _this.drawer.Opening.connect(function () {\n            // remove sidebar to avoid component redisplay\n            _this.insideGutter = undefined;\n            _this._drawerIsOpen.value = true;\n        });\n        _this.drawer.Closed.connect(function () {\n            // put sidebar back if (by now) supposed to\n            _this._drawerIsOpen.value = false;\n        });\n        // add the (inside, i.e. left by default) sidebar if not on a small screen\n        _this.bindFragment(\"insideGutter\", \"Sidebar\", function (sidebar) {\n            return (_this.sidebarCollapsed || _this._drawerIsOpen.value) ?\n                undefined : sidebar;\n        });\n        return _this;\n    }\n    Object.defineProperty(HubViewLayout.prototype, \"sidebarCollapsed\", {\n        /** True if the sidebar should be hidden, normally only on small screens but can be overridden by defining a getter for this property (observed, readonly) */\n        get: function () { return Screen_Screen.dimensions.isSmall; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Layout fragment for sidebar content */\n    HubViewLayout.Sidebar = ScrollableLayout.with({ height: \"100%\" });\n    App___decorate([\n        Async_defaultExport.observable\n    ], HubViewLayout.prototype, \"sidebarCollapsed\", null);\n    App___decorate([\n        layoutFragment\n    ], HubViewLayout, \"Sidebar\", void 0);\n    return HubViewLayout;\n}(App_AppViewLayout));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/App/View/Layout/index.js\n\n\n\n\n// CONCATENATED MODULE: ./dist/core/lib/App/Service/Service.js\nvar Service___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nvar INSTANCE_PROTO_PROP = \"@_service_instance\";\nvar SERVICE_REG_ID_PREFIX = \"+\";\n/** Service classes registered by ID, and others waiting to be mapped */\nvar registry = new Async_defaultExport.ObservableObject();\n/** Helper function to add an ID to the registry */\nfunction register(serviceId, serviceClass) {\n    var prop = SERVICE_REG_ID_PREFIX + serviceId;\n    if (!registry.hasObservableProperty(prop)) {\n        // add an observable property for this service\n        registry.addObservableProperty(prop, serviceClass);\n    }\n    else if (serviceClass) {\n        // (re)set the observable property\n        registry[prop] = serviceClass;\n    }\n}\n/** Helper function to inject a service instance */\nfunction doInject(classObj, propertyId, serviceId) {\n    // make sure a key in the registry exists\n    var prop = SERVICE_REG_ID_PREFIX + serviceId;\n    if (!registry.hasObservableProperty(prop)) {\n        // add an observable property for this service\n        registry.addObservableProperty(prop, undefined);\n    }\n    // inject the observable reference\n    Async_defaultExport.inject(classObj, (_a = {},\n        _a[propertyId] = Async_defaultExport.observe(function () { return registry[prop]; })\n            .map(function (serviceClass) { return serviceClass && serviceClass.getInstance(); }),\n        _a));\n    var _a;\n}\n/** Service base class, to be extended to represent a service of which a singleton instance can be injected as a property of any other class (e.g. a view or activity class, or another service); service classes must be registered by ID, using the `mapService` decorator */\nvar Service = (function (_super) {\n    Service___extends(Service, _super);\n    /** Singleton constructor; do not use directly, use `getInstance` instead */\n    function Service() {\n        var _this = _super.call(this) || this;\n        if (Object.prototype.hasOwnProperty.call(_this.constructor.prototype, INSTANCE_PROTO_PROP))\n            throw new Error(\"Service has already been constructed\");\n        _this.constructor.prototype[INSTANCE_PROTO_PROP] = _this;\n        return _this;\n    }\n    /** Get the singleton instance of this service class, can be overridden; by default returns a single instance, constructed without parameters only when needed, and never dereferenced */\n    Service.getInstance = function () {\n        if (Object.prototype.hasOwnProperty.call(this.prototype, INSTANCE_PROTO_PROP)) {\n            // already constructed\n            return this.prototype[INSTANCE_PROTO_PROP];\n        }\n        if (this === Service)\n            throw new TypeError();\n        return new this();\n    };\n    return Service;\n}(Async_defaultExport.ObservableObject));\n\n/** *Class decorator*, registers the decorated `Service` class using given UpperCamelCase ID(s), so that injected properties (see `injectService`) decorated with a matching service ID automatically contain a reference to a singleton instance of the decorated `Service` [decorator] */\nfunction mapService() {\n    var id = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        id[_i] = arguments[_i];\n    }\n    return function (target) {\n        for (var _i = 0, id_1 = id; _i < id_1.length; _i++) {\n            var s = id_1[_i];\n            register(s, target);\n        }\n    };\n}\n/** Add an alias for the given service by ID, so that the aliased service *also* becomes available using the given alias; the aliased service does not need to have been mapped yet */\nfunction addServiceAlias(newId, serviceId) {\n    var serviceRefProp = SERVICE_REG_ID_PREFIX + serviceId;\n    if (!registry.hasObservableProperty(serviceRefProp)) {\n        // add an observable property for this service\n        registry.addObservableProperty(serviceRefProp, undefined);\n    }\n    register(newId, Async_defaultExport.observe(function () { return registry[serviceRefProp]; }));\n}\nfunction injectService(idOrTarget, key, desc) {\n    if (typeof idOrTarget === \"string\") {\n        return function (target, propertyKey, desc) {\n            // create an injectable property first\n            var result = Async_defaultExport.injectable(target, propertyKey, desc);\n            Object.defineProperty(target, propertyKey, result);\n            // register the service if needed, and create an observable reference\n            doInject(target.constructor, propertyKey, idOrTarget);\n            return result;\n        };\n    }\n    else if (typeof idOrTarget === \"object\" &&\n        typeof idOrTarget.constructor === \"function\" &&\n        typeof key === \"string\") {\n        // create an injectable property first\n        var result = Async_defaultExport.injectable(idOrTarget, key, desc);\n        Object.defineProperty(idOrTarget, key, result);\n        // register the service if needed, and create an observable reference\n        var id = String(key);\n        id = id[0].toUpperCase() + id.slice(1);\n        doInject(idOrTarget.constructor, key, id);\n        return result;\n    }\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/App/Service/index.js\n\n\n// CONCATENATED MODULE: ./dist/core/lib/App/Application.js\nvar Application___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Application___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** RegExp to parse a URL */\nvar urlRE = /^(?:([^:/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(\\?[^#]*)?(#.*)?/;\n/** Helper to check if given reference refers to an Activity class */\nfunction isActivityClass(a) {\n    return (typeof a === \"function\" && a.prototype instanceof Activity_Activity);\n}\n/** Encapsulates the application as a singleton object; to be overridden with a platform-specific implementation, do not instantiate directly */\nvar Application_Application = (function (_super) {\n    Application___extends(Application, _super);\n    /** Create the application instance (from a derived class); can be called only once */\n    function Application(title) {\n        var _this = _super.call(this) || this;\n        /** The application name to be displayed in the window title bar (observed) */\n        _this.title = \"\";\n        /** Signal that is emitted when no activity is found for a location */\n        _this.PageNotFound = Signal_Signal.create();\n        /** Signal that is emitted when all activities have been dropped and none have been started */\n        _this.NoActivity = Signal_Signal.create();\n        /** Activity stack instance */\n        _this.activities = new ActivityStack_ActivityStack();\n        if (Application.current || !Application._resolve_ready)\n            throw new Error(\"Cannot construct more than one Application instance\");\n        Application.current = _this.constructor.current = _this;\n        _this.title = title;\n        // initialize page view\n        Screen_Screen.ready.then(function () {\n            Application._resolve_ready(_this);\n            Application._resolve_ready = undefined;\n        });\n        // install handlers for NavList and Button activation\n        var activate = function (target) { _this.startActivityAsync(target); };\n        var isActive = function (target) { _this.isActive(target); };\n        Async_defaultExport.inject(Button_Button.Activation, { activate: activate });\n        Async_defaultExport.inject(NavList_NavList.Activation, { activate: activate, isActive: isActive });\n        return _this;\n    }\n    /** Returns the activity that is currently in the foreground (observable) */\n    Application.prototype.getTopActivity = function () {\n        return this.activities.top;\n    };\n    /** Start given activity as foreground activity (push/replace, same as calling `.activities.push/replace(...)` directly), or start activity using given resource path or string (`#/...` or `/...`, or relative path as `#./...`, `#../...`, `./...` or `../...`); if `navigateIfNotFound` is not false, then the browser/app will navigate to the new location if no matching activity is found (automatic for external URLs), otherwise invokes onPageNotFound handler; note that activities transition asynchronously and any updates will not be reflected until a few milliseconds after calling this method */\n    Application.prototype.startActivityAsync = function (activatable, replace, navigateIfNotFound) {\n        var _this = this;\n        if (isActivityClass(activatable)) {\n            activatable = activatable.getInstance();\n            if (!(activatable instanceof Activity_Activity))\n                throw new Error(\"Invalid activity instance\");\n        }\n        if (activatable instanceof Activation_Activation) {\n            return activatable.getActivityAsync().then(function (activity) {\n                if (activity)\n                    return _this.startActivityAsync(activity);\n                _this.PageNotFound(activatable.getPath());\n                return undefined;\n            });\n        }\n        if (activatable instanceof Activity_Activity) {\n            // check if background activity\n            if (activatable.options.isBackgroundActivity)\n                throw new Error(\"Cannot start background activity directly\");\n            // push or replace directly\n            return replace ? this.activities.replaceAsync(activatable) :\n                this.activities.pushAsync(activatable);\n        }\n        // normalize given path/URL to absolute path, if possible\n        var path = this.normalizePath(activatable);\n        // check if path already active\n        var currentActivityPath = this.activities.top &&\n            this.activities.top.activation.getPath();\n        if (currentActivityPath && currentActivityPath === path) {\n            return Async_defaultExport.Promise.resolve(undefined);\n        }\n        // route based on the resulting path\n        var activation = Activation_Activation.route(path);\n        if (activation) {\n            // recurse for activation object\n            return this.startActivityAsync(activation);\n        }\n        else if (navigateIfNotFound !== false) {\n            // if no route/activity mapped, navigate directly\n            this.navigateToUrl(activatable);\n        }\n        else {\n            // if not supposed to navigate, emit signal\n            this.PageNotFound(path);\n        }\n        return Async_defaultExport.Promise.resolve(undefined);\n    };\n    /** Go back in activity history; either to previous activity or to activity of given class; returns promise that resolves to the new foreground activity, or undefined if activity was not found; the NoActivity signal is emitted if all activities have been dropped and there is no current activity anymore */\n    Application.prototype.dropActivityAsync = function (ActivityClass) {\n        var _this = this;\n        if (ActivityClass) {\n            // go up to given activity, and stay put for 2ms to allow\n            // platform to catch up\n            return this.activities.upAsync(ActivityClass)\n                .then(function (a) { return Async_defaultExport.sleep(2, a); });\n        }\n        else if (this.activities.length) {\n            // pop current activity\n            var resolve_1 = function () {\n                var top = _this.activities.top;\n                // pop again if top activity is now a background activity\n                if (top && top.options.isBackgroundActivity)\n                    return _this.activities.popAsync(top).then(resolve_1);\n                // emit NoActivity if none left after 10ms\n                if (!top) {\n                    return Async_defaultExport.sleep(10).then(function () {\n                        if (!_this.activities.length)\n                            _this.NoActivity();\n                        return undefined;\n                    });\n                }\n                return top;\n            };\n            return this.activities.popAsync().then(resolve_1);\n        }\n        else {\n            // nothing to pop, emit NoActivity and return empty promise\n            this.NoActivity();\n            return Async_defaultExport.Promise.resolve(undefined);\n        }\n    };\n    Application.prototype.isActive = function (pathOrActivity) {\n        if ((pathOrActivity instanceof Activity_Activity) ||\n            typeof pathOrActivity === \"function\") {\n            // only check top activity and its parent activities\n            var current = this.activities.top;\n            while (current) {\n                if (current === pathOrActivity ||\n                    (current instanceof pathOrActivity))\n                    return true;\n                var parent = current.options.parentActivity;\n                if (parent instanceof Activity_Activity) {\n                    // check parent activity itself\n                    current = parent;\n                }\n                else if (parent) {\n                    // find parent activity in the stack\n                    current = this.activities.getParent(parent, current);\n                }\n            }\n            return false;\n        }\n        else {\n            // normalize given path and check against current URL\n            var path = this.normalizePath(pathOrActivity);\n            if (!path)\n                return false;\n            var cur = this.getCurrentUrl();\n            if (path[0] === \"#\") {\n                // looking for hash: trim everything except hash path\n                cur = cur.replace(/[^#]*/, \"\").replace(/\\/$/, \"\");\n            }\n            else {\n                // looking for base path: keep path and hash\n                cur = cur.replace(/^(?:([^:/?#]+):)?(?:\\/\\/([^\\/?#]*))/, \"\")\n                    .replace(/\\/?\\?[^#]*/, \"/\").replace(/\\/$/, \"\");\n            }\n            var l = path.length;\n            return (cur.slice(0, l) === path &&\n                (cur.length === l || cur[l] === \"/\"));\n        }\n    };\n    /** Remove the activity that is currently in the foreground, and reinstantiate a new activity using the `Activation` object that was used to instantiate the current activity; this also re-displays the view, if any; also increments the `.activationIndex` property; returns a promise that is fulfilled after the activity has been started */\n    Application.prototype.reactivate = function () {\n        var _this = this;\n        if (!this.activities.top)\n            return Async_defaultExport.Promise.resolve(undefined);\n        var activation = this.activities.top.activation;\n        if (!this._activationIndex)\n            this._activationIndex = 0;\n        this._activationIndex++;\n        return this.dropActivityAsync().then(function () { return _this.startActivityAsync(activation); });\n    };\n    Object.defineProperty(Application.prototype, \"activationIndex\", {\n        /** Counter that is incremented every time `.reactivate` is called */\n        get: function () { return this._activationIndex; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Returns a normalized version of given path/URL, i.e. either `/...` or `#/...`, or undefined if given path/URL cannot be normalized; relative paths are also supported (e.g. `../foo` or `#../foo`) */\n    Application.prototype.normalizePath = function (path) {\n        if (path === void 0) { path = \"\"; }\n        var _a = String(path).match(urlRE) || [], _ = _a[0], proto = _a[1], host = _a[2], targetPath = _a[3], query = _a[4], targetHash = _a[5];\n        // if path is empty, force home and use either `/` or `#/`\n        if (!_)\n            return (this.getCurrentUrl().indexOf(\"#\") >= 0) ? \"#/\" : \"/\";\n        // check if given a full URL that is actually on the same domain\n        if (proto || host) {\n            var _b = this.getCurrentUrl().match(urlRE) || [], _1 = _b[0], curProto = _b[1], curHost = _b[2], curPath = _b[3], curQuery = _b[4];\n            if (!_1 || curProto !== proto || curHost !== host) {\n                // domain does not match\n                return undefined;\n            }\n            curPath = curPath.replace(/\\/$/, \"\");\n            targetPath = targetPath.replace(/\\/$/, \"\");\n            if (targetHash && curPath === targetPath && curQuery == query) {\n                // use hash part only\n                path = targetHash;\n            }\n            else {\n                // use full path\n                targetPath += (targetHash ? \"/\" + targetHash : \"\");\n                path = targetPath || \"/\";\n            }\n        }\n        // check target type\n        if (/^#?\\//.test(path)) {\n            // full path or hash path: stop here\n            return path;\n        }\n        else if (path[0] === \"#\") {\n            // relative hash path: resolve against current URL\n            var current = this.getCurrentUrl();\n            current = current.replace(/[^#]*/, \"\").replace(/\\/$/, \"\").slice(1);\n            path = (current + \"/\" + path.slice(1)).replace(/\\.\\//g, \"\");\n            for (var oldPath = path; oldPath !== (path = path.replace(/[^\\/]+\\/\\.\\.\\//, \"\"));)\n                ;\n            return \"#\" + path;\n        }\n        else {\n            // relative path: resolve against current URL\n            var current = this.getCurrentUrl();\n            current = current.replace(/^(?:([^:/?#]+):)?(?:\\/\\/([^\\/?#]*))/, \"\")\n                .replace(/\\#.*/, \"\").replace(/\\/$/, \"\");\n            path = (current + \"/\" + path).replace(/\\.\\//g, \"\");\n            for (var oldPath = path; oldPath !== (path = path.replace(/[^\\/]+\\/\\.\\.\\//, \"\"));)\n                ;\n            return path;\n        }\n    };\n    /** Returns the (browser/app) platform's current URI as a string, if available */\n    Application.prototype.getCurrentUrl = function () { return \"\"; };\n    /** Directs the (browser/app) platform to given URL, e.g. a full URL to navigate away from the current application */\n    Application.prototype.navigateToUrl = function (url) { /* platform defined */ url; };\n    /** Promise that resolves to the application instance after it has been created */\n    Application.ready = new Async_defaultExport.Promise(function (resolve) { Application._resolve_ready = resolve; });\n    Application___decorate([\n        Async_defaultExport.observable_string\n    ], Application.prototype, \"title\", void 0);\n    Application___decorate([\n        injectService(\"culture\")\n    ], Application.prototype, \"culture\", void 0);\n    return Application;\n}(Async_defaultExport.ObservableObject));\n\n/** Alias for `Application#startActivityAsync` on the current `Application` instance; if there is no current instance, this function waits for an Application instance to be created first */\nfunction startActivityAsync(activityOrPath, replace, navigateIfNotFound) {\n    var go = function (app) {\n        return app.startActivityAsync(activityOrPath, replace, navigateIfNotFound);\n    };\n    if (Application_Application.current)\n        return go(Application_Application.current);\n    return Application_Application.ready.then(function (app) { return go(app); });\n}\n/** Get the activity closest to the foreground of given type, if any */\nfunction findActivity(ActivityClass) {\n    if (!Application_Application.current)\n        return undefined;\n    if (Application_Application.current.activities.top instanceof ActivityClass)\n        return Application_Application.current.activities.top;\n    return Application_Application.current.activities.getParent(ActivityClass);\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/App/View/ViewMapping.js\n\n\n\n\nvar VIEW_INITIALIZED_PROP = \"@_view_\";\nvar VIEW_MAP_PREFIX = \"#view:\";\n/** Next UID to be used by mapViewActivity */\nvar ViewMapping__nextUID = 0;\n/** Represents a mapping between an activity and a view class */\nvar ViewMapping_ViewMapping = (function () {\n    /** Private constructor, do not use directly: use static method `.mapView` instead */\n    function ViewMapping() {\n        this._ref = 0;\n    }\n    /** Map the given activity to given view class, with given dereference timeout (or 0 to disable dereferencing); also connects to the activity's Resumed signal, once per activity instance */\n    ViewMapping.mapView = function (activity, View, timeout) {\n        var _this = this;\n        // create and store the view mapping in the activity object\n        var mapping = activity[VIEW_MAP_PREFIX + ViewMapping__nextUID++] = new ViewMapping;\n        mapping._activity = activity;\n        mapping._View = View;\n        mapping._timeout = timeout;\n        // connect to the Resumed signal to display (parent) view(s)\n        // and add layout(s) -- but only once for each activity instance\n        if (!activity[VIEW_INITIALIZED_PROP]) {\n            activity[VIEW_INITIALIZED_PROP] = true;\n            activity.Resumed.connect(function (t) {\n                // wait just a bit to see if stack will skip over\n                Async_defaultExport.sleep(2).then(function () {\n                    var cursor = t.activityStack.getCursor();\n                    if (cursor.activity === activity) {\n                        try {\n                            _this._display(cursor);\n                        }\n                        catch (err) {\n                            t.activityStack.popAsync(activity);\n                            throw err;\n                        }\n                    }\n                });\n            });\n        }\n    };\n    /** Display views for the activity at the top of the stack; throws an error if there is nothing to display */\n    ViewMapping._display = function (cursor) {\n        var activity = cursor.activity;\n        var views = this._findViews(activity, cursor);\n        if (!views.length) {\n            // back up if nothing to display\n            throw new Error(\"No view mapped for this activity\");\n        }\n        else if (views.some(function (v) { return (v instanceof Page_Page); })) {\n            // displaying a (new) page, let Screen figure it out\n            views.forEach(function (v) { return Screen_Screen.displayAsync(v); });\n        }\n        else {\n            // try to use existing page if it features the same content\n            var current = Page_Page.getCurrentPage();\n            if (current && current.content[0] === views[0]) {\n                // just replace content array\n                current.content = views;\n            }\n            else {\n                // create a new page and display everything in one go\n                new Page_Page(views).displayAsync();\n            }\n        }\n    };\n    /** Find (parent) views up to the first full (non-modal) view instance, and add layout fragments on the way back up; returns an array of views to be displayed */\n    ViewMapping._findViews = function (fg, cursor, seen, traceParents) {\n        if (seen === void 0) { seen = {}; }\n        var activity = cursor.activity;\n        while (activity &&\n            (!activity[VIEW_INITIALIZED_PROP] || seen[activity.uid])) {\n            if (traceParents)\n                activity = cursor.goParent().activity;\n            else\n                activity = cursor.goBack().activity;\n        }\n        if (activity) {\n            // make sure this activity is not checked again\n            seen[activity.uid] = true;\n            // found a mapped activity, get instances for all views\n            var result = [];\n            var fragments = [];\n            var hasFullView;\n            for (var id in activity) {\n                if (id[0] === \"#\" && id.slice(0, 6) === VIEW_MAP_PREFIX) {\n                    var view = activity[id]._getInstance(fg);\n                    if (view instanceof Page_Page) {\n                        // found a page, use it as a full view (sort to front)\n                        hasFullView = true;\n                        result.unshift(view);\n                        if (result[1] && (result[1] instanceof Page_Page)) {\n                            // keep only one page instance\n                            result.splice(1, 1);\n                        }\n                    }\n                    else if (isLayoutFragment(view)) {\n                        // found a fragment only, try to use it later\n                        fragments.push(view);\n                    }\n                    else if (view.displayOptions && view.displayOptions.modal) {\n                        // found a modal view, use it on top of other views\n                        result.push(view);\n                        // connect to Closed signal to pop activity automatically\n                        var Closed = view.Closed;\n                        if (Closed && typeof Closed.connectOnce === \"function\") {\n                            Closed.connectOnce(function () {\n                                cursor.activityStack.popAsync(activity);\n                            });\n                        }\n                    }\n                    else {\n                        // found a full view component\n                        hasFullView = true;\n                        result.push(view);\n                    }\n                }\n            }\n            // keep looking if no full view component was found\n            if (!hasFullView && fragments.length) {\n                // got a fragment: check with parents first\n                var parentViews = this._findViews(fg, cursor.clone().goParent(), seen, true);\n                for (var i = parentViews.length - 1; i >= 0; i--) {\n                    var parentView = parentViews[i];\n                    if ((parentView instanceof Page_Page) ||\n                        !parentView.displayOptions ||\n                        !parentView.displayOptions.modal)\n                        hasFullView = true;\n                    result.unshift(parentView);\n                }\n            }\n            if (!hasFullView) {\n                // check with previous activities\n                result = this._findViews(fg, cursor.goBack(), seen)\n                    .concat(result);\n            }\n            // add fragments to full views where possible\n            fragments.forEach(function (frag) {\n                for (var i = result.length - 1; i >= 0; i--) {\n                    var view_1 = result[i];\n                    if ((view_1 instanceof Component_Component) &&\n                        isLayoutFragment(frag, view_1)) {\n                        view_1.appendChild(frag);\n                        break;\n                    }\n                }\n            });\n            return result;\n        }\n        return [];\n    };\n    /** Create a view instance (or use the existing instance), and watch given foreground activity for suspension to dereference the view instance */\n    ViewMapping.prototype._getInstance = function (fg) {\n        var _this = this;\n        var instance;\n        if (this._timeout > 0) {\n            var ref = ++this._ref;\n            fg.Suspended.connectOnce(function () {\n                // check if reactivated application activity\n                if (_this._instanceIndex !== Application_Application.current.activationIndex) {\n                    // dereference immediately\n                    delete _this._instance;\n                    return;\n                }\n                // dereference after timeout, unless overtaken\n                // by another call to getInstance\n                Async_defaultExport.sleep(_this._timeout).then(function () {\n                    if (ref === _this._ref && instance === _this._instance)\n                        delete _this._instance;\n                });\n            });\n        }\n        if (this._instanceIndex !== Application_Application.current.activationIndex) {\n            delete this._instance;\n            this._instanceIndex = Application_Application.current.activationIndex;\n        }\n        return instance = this._instance || (this._instance =\n            new this._View(this._activity));\n    };\n    return ViewMapping;\n}());\n/** *Class decorator*, maps the decorated view class to an `Activity` class; the view class should be a UI `Component` or `Page` class with a constructor that has a single matching activity argument, possibly a view layout or fragment class that derives from the types in the `Layout` namespace; if the view class is a fragment, it is automatically added to the (parent) activity's matching view; re-uses view instances when possible, but views are dereferenced within given timeout when no longer in use (in ms, defaults to 2s, set to 0 to disable) [decorator] */\nfunction mapViewActivity(activityClass, dereferenceTimeout) {\n    if (dereferenceTimeout === void 0) { dereferenceTimeout = 2000; }\n    return function (target) {\n        // inject initializer into the activity class\n        var current = Async_defaultExport.inject(activityClass, {\n            \"@initialize\": function () {\n                ViewMapping_ViewMapping.mapView(this, target, dereferenceTimeout);\n                current[\"@initialize\"].call(this);\n            }\n        });\n    };\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/App/View/MessageBox.js\nvar MessageBox___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MessageBox___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Modal dialog layout view used by `showMessageBox` that contains a title row fragment and a button row fragment, and all messages as separate rows in the main content area */\nvar MessageBox_MessageBoxLayout = (function (_super) {\n    MessageBox___extends(MessageBoxLayout, _super);\n    /** Create a new message box (without content); use `showMessageBox` function instead, to initialize and display a message box with a title, message, and predefined buttons */\n    function MessageBoxLayout() {\n        var _this = _super.call(this) || this;\n        _this.bindFragment(\"header\", \"TitleRow\");\n        _this.bindFragment(\"footer\", \"ButtonRow\");\n        return _this;\n    }\n    /** Layout fragment for the message box title row, used by `showMessageBox` as the header of message box dialogs that contain a title; can be used to apply global style overrides */\n    MessageBoxLayout.TitleRow = Row_Row.with();\n    /** Layout fragment for the message box button row, used by `showMessageBox` as a footer row on message box dialogs; can be used to apply global style overrides */\n    MessageBoxLayout.ButtonRow = Row_Row.with();\n    /** Message row component factory (NOT a fragment), used by `showMessageBox` to construct the _first_ message row; can be used to apply global style overrides */\n    MessageBoxLayout.FirstMessageRow = Row_Row.with();\n    /** Message row component factory (NOT a fragment), used by `showMessageBox` to construct the all message rows _other than the first row_; can be used to apply global style overrides */\n    MessageBoxLayout.MessageRow = Row_Row.with();\n    /** Label used for the default \"Dismiss\" button when the arguments to `showMessageBox` do not include a single button; can be changed but must be a `UI.TextLabelFactory` (i.e. result of `UI.tl`) */\n    MessageBoxLayout.DISMISS_LABEL = new TextLabelFactory_TextLabelFactory(\"Dismiss\");\n    MessageBox___decorate([\n        layoutFragment\n    ], MessageBoxLayout, \"TitleRow\", void 0);\n    MessageBox___decorate([\n        layoutFragment\n    ], MessageBoxLayout, \"ButtonRow\", void 0);\n    return MessageBoxLayout;\n}(Base_BaseDialogLayout));\n\n// implementation:\nfunction showMessageBox() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var layoutArgs = [];\n    // check for title text\n    if (args[1] && !args[1].isComponentFactory) {\n        // first argument is not the only text: it is the title text\n        var titleArg = args.shift();\n        if (typeof titleArg === \"string\") {\n            // use a wide label by default\n            titleArg = new TextLabelFactory_TextLabelFactory(\"{}\" + titleArg, undefined, false, WideLabel);\n        }\n        layoutArgs.push(MessageBox_MessageBoxLayout.TitleRow.with(titleArg, DialogContainer_DialogContainer.TopCloseButton));\n    }\n    // append message text\n    if (args.length) {\n        var textArg = args.shift();\n        if (!(textArg instanceof Array))\n            textArg = [textArg];\n        textArg.forEach(function (t, i) {\n            if (typeof t === \"string\") {\n                // use a paragraph label by default\n                t = new TextLabelFactory_TextLabelFactory(\"{}\" + (t || \"\"), undefined, false, Paragraph);\n            }\n            layoutArgs.push(i ?\n                MessageBox_MessageBoxLayout.MessageRow.with(t) :\n                MessageBox_MessageBoxLayout.FirstMessageRow.with(t));\n        });\n    }\n    // if no button passed in, use a default \"Dismiss\" button\n    if (!args.length) {\n        args.push(Button_Button.withLabel(MessageBox_MessageBoxLayout.DISMISS_LABEL));\n    }\n    // remaining args should be Button component factories at this point\n    var buttons = args.map(function (arg) { return new arg(); });\n    layoutArgs.push(new MessageBox_MessageBoxLayout.ButtonRow(buttons));\n    // create and show the dialog\n    var dialog = new (MessageBox_MessageBoxLayout.with.apply(MessageBox_MessageBoxLayout, layoutArgs))();\n    dialog.openAsync();\n    return new Async_defaultExport.Promise(function (resolve) {\n        // resolve with button index when clicked, and close dialog\n        buttons.forEach(function (b, i) {\n            b.Click.connectOnce(function () {\n                resolve(i);\n                dialog.close();\n            });\n        });\n        // resolve with undefined value if dismissed otherwise\n        dialog.Closed.connectOnce(function () {\n            resolve(undefined);\n        });\n    });\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/App/View/index.js\n\n\n\n\n\n// CONCATENATED MODULE: ./dist/core/lib/App/Activity/Activity.js\nvar Activity___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Activity___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Current unique ID for Activity instances */\nvar Activity__nextUID = 0;\n/** Activity base class, represents a UI activity; to be extended by application code, and registered using an activation decorator (i.e. `mapActivation` or `mapRoute`); can be linked to a view class to be displayed by decorating the view (`UI.Component` or `UI.Page` class using `mapViewActivity`) */\nvar Activity_Activity = (function (_super) {\n    Activity___extends(Activity, _super);\n    /** Create an activity instance, using given activation object if any; if the activation object is the result of a route mapping, it contains all routing parameters as string properties; otherwise the activation object may contain any type of data that can be used to initialize the new activity, and replace it with a new instance (following `Application.reactivate`) */\n    function Activity(activation) {\n        if (activation === void 0) { activation = {}; }\n        var _this = _super.call(this) || this;\n        /** Globally unique activity identifier */\n        _this.uid = \"A\" + Activity__nextUID++;\n        /** Object that contains options for this activity (observable, never null or undefined) */\n        _this.options = {};\n        /** Signal that is emitted before this activity is pushed to foreground, if any handler throws an error then the activity is not activated */\n        _this.Starting = Signal_Signal.create();\n        /** Signal that is emitted after this activity is pushed to foreground (note that `.Resumed` will also always be emitted) */\n        _this.Started = Signal_Signal.create();\n        /** Signal that is emitted before another activity is pushed to foreground, if any handler throws an error then the activity is not suspended */\n        _this.Suspending = Signal_Signal.create();\n        /** Signal that is emitted after this activity is no longer in foreground */\n        _this.Suspended = Signal_Signal.create();\n        /** Signal that is emitted before this activity is put back in foreground, if any handler throws an error then the previous activity is not suspended */\n        _this.Resuming = Signal_Signal.create();\n        /** Signal that is emitted after this activity is in foreground (emitted after `.Resuming`, or after `.Starting` together with `.Started`) */\n        _this.Resumed = Signal_Signal.create();\n        /** Signal that is emitted after this activity is removed from history, and will not be resumed anymore */\n        _this.Deactivated = Signal_Signal.create();\n        if (activation instanceof Activation_Activation) {\n            // use given activation object\n            _this.activation = activation;\n        }\n        else {\n            // no object specified, create class on the fly\n            var DirectActivation = (function (_super) {\n                Activity___extends(DirectActivation, _super);\n                function DirectActivation() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return DirectActivation;\n            }(Activation_Activation));\n            _this.activation = new DirectActivation(activation);\n        }\n        _this[\"@initialize\"]();\n        Async_defaultExport.defer(function () {\n            var p = _this.onCreateAsync();\n            if (p)\n                _this.Starting.connectOnce(function () { return p; });\n        });\n        return _this;\n    }\n    /** Get an instance of this activity class, can be overridden to alter behavior when e.g. pushing a parent activity by class; by default simply constructs the instance without parameters */\n    Activity.getInstance = function (activation) {\n        if (this === Activity)\n            throw new TypeError();\n        return new this(activation);\n    };\n    /** Method that is called asynchronously after this activity is created; override this method to perform any initialization that must be completed before the activity is started; if this method returns a promise, it must be fulfilled _before_ the activity can be pushed to the foreground */\n    Activity.prototype.onCreateAsync = function () {\n        /* nothing here */\n    };\n    /** @internal Injectable method called by the constructor, used by activity decorators */\n    Activity.prototype[_a = \"@initialize\"] = function () { };\n    Activity___decorate([\n        Async_defaultExport.injectable\n    ], Activity.prototype, _a, null);\n    Activity___decorate([\n        Async_defaultExport.observable_string\n    ], Activity.prototype, \"title\", void 0);\n    Activity___decorate([\n        Async_defaultExport.observable_not_null\n    ], Activity.prototype, \"options\", void 0);\n    return Activity;\n    var _a;\n}(Async_defaultExport.ObservableObject));\n\n/** Represents an activity that should be created only once and re-used if required (overrides .getInstance static method); abstract class, to be overridden */\nvar Activity_SingletonActivity = (function (_super) {\n    Activity___extends(SingletonActivity, _super);\n    /** Create a new activity; can be used only once */\n    function SingletonActivity(activation) {\n        var _this = _super.call(this, activation) || this;\n        var self = _this.constructor;\n        if (self._instance)\n            throw new Error(\"Cannot create another instance of this activity\");\n        self._instance = _this;\n        return _this;\n    }\n    /** Get the instance of this activity class, constructs the instance without parameters once and returns this instance every time */\n    SingletonActivity.getInstance = function (activation) {\n        if (this._instanceIndex !== Application_Application.current.activationIndex) {\n            delete this._instance;\n            this._instanceIndex = Application_Application.current.activationIndex;\n        }\n        return this._instance || new this(activation);\n    };\n    return SingletonActivity;\n}(Activity_Activity));\n\n/** Represents a singleton activity that may only exist in the background (i.e. it should not be started directly, and it should be skipped when navigating back in history, enforced by `Application`), created only once and re-used if required (overrides .getInstance static method); abstract class, needs to be overridden */\nvar SupportActivity = (function (_super) {\n    Activity___extends(SupportActivity, _super);\n    function SupportActivity(activation) {\n        var _this = _super.call(this, activation) || this;\n        _this.options.isBackgroundActivity = true;\n        return _this;\n    }\n    return SupportActivity;\n}(Activity_SingletonActivity));\n\n/** Represents a singleton activity that is both a root activity (i.e. may exist only once on the activity stack, starting/replacing the activity again transitions the stack up to the existing activity instead), and a hub activity (i.e. starting any activity that specifies this activity as its parent activity, transitions the stack up to the hub activity first, suspending all other activities that used to be in the foreground), created only once and re-used if required (overrides .getInstance static method); abstract class, to be overridden */\nvar RootActivity = (function (_super) {\n    Activity___extends(RootActivity, _super);\n    function RootActivity(activation) {\n        var _this = _super.call(this, activation) || this;\n        _this.options.isHubActivity = true;\n        _this.options.isRootActivity = true;\n        return _this;\n    }\n    return RootActivity;\n}(Activity_SingletonActivity));\n\n/** *Class decorator*, associates a parent activity class with the decorated `Activity` class: whenever an activity instance of the class decorated with this decorator is started, an instance of the given parent activity class must already exist on the stack, or a (new) instance will be started in advance [decorator] */\nfunction mapParentActivity(parentActivityClass) {\n    return function (target) {\n        var current = Async_defaultExport.inject(target, {\n            \"@initialize\": function () {\n                current[\"@initialize\"].call(this);\n                // set parent activity class reference\n                if (!(parentActivityClass.prototype instanceof Activity_Activity))\n                    throw new TypeError(\"Invalid parent activity\");\n                if (this.options.parentActivity &&\n                    this.options.parentActivity !== parentActivityClass)\n                    throw new Error(\"Cannot add more than one parent activity\");\n                this.options.parentActivity = parentActivityClass;\n            }\n        });\n    };\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/App/Activity/Activation.js\nvar Activation___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Activation___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n/** Name for the property on activation objects, set by `ActivationRouter#match` and used by the `getPath` method injected by `mapRoute`, that holds the path that actually lead to the activation */\nvar MAPROUTE_PATH_PROPERTY = \"@mapRoute.path\";\n/** Functions that return an Activation instance if a given path matches the stored route; hashed by route string to avoid duplication */\nvar routersByRoute = {};\n/** List of routes currently mapped (with matchers in `routersByRoute`) */\nvar routesList = [];\n/** Lookup table of known named routes */\nvar namedRoutes = {};\n/** Encapsulates a command to start an activity; should be extended into unique classes that `Activity` classes can be mapped to using `mapActivation`, and which can be mapped to routes using `mapRoute`; the latter will enable saving parts of a path (URL) to properties on the activation object */\nvar Activation_Activation = (function () {\n    /** Create a new activation object, which can be used (with a derived class) to start an activity based on the Activation class type, and stored property values; copies all properties from the given object, if any */\n    function Activation(properties) {\n        if (properties) {\n            // copy all given properties to this instance\n            for (var p in properties)\n                if (Object.prototype.hasOwnProperty.call(properties, p))\n                    this[p] = properties[p];\n        }\n    }\n    /** Returns a new activation object for the given route path (must start with `/` or `#/`), or undefined if none of the currently mapped routes match */\n    Activation.route = function (path) {\n        // go through the list of mapped routes and run matchers one by one\n        if (typeof path === \"string\" && /^#?\\//.test(path)) {\n            for (var _i = 0, routesList_1 = routesList; _i < routesList_1.length; _i++) {\n                var r = routesList_1[_i];\n                var result = routersByRoute[r].match(path);\n                if (result)\n                    return result;\n            }\n        }\n        return undefined;\n    };\n    /** Returns a promise for an activity instance, or for undefined if no `Activity` class is mapped to this activation type; this method is injected by `mapActivation`, but can also be overridden directly to customize the behavior of creating activities for activation objects (e.g. testing for valid IDs, or lazy loading) */\n    Activation.prototype.getActivityAsync = function () {\n        // (injected by mapActivation)\n        return Async_defaultExport.Promise.resolve(undefined);\n    };\n    /** Returns the full path that will route to this activation object (or the path that this object was actually created for, using `mapRoute`), or undefined if no route has been mapped to this activation class or if one of the route parameters is missing */\n    Activation.prototype.getPath = function () {\n        // (injected by mapRoute)\n        return undefined;\n    };\n    Activation___decorate([\n        Async_defaultExport.injectable\n    ], Activation.prototype, \"getActivityAsync\", null);\n    Activation___decorate([\n        Async_defaultExport.injectable\n    ], Activation.prototype, \"getPath\", null);\n    return Activation;\n}());\n\n/** Activation router (internal), created for a mapped route */\nvar ActivationRouter = (function () {\n    function ActivationRouter(route, target) {\n        this.target = target;\n        // dissect given route for faster matching later\n        this._routeSegments = route.split(\"/\").filter(function (s) { return !!s; });\n        this._isHashRoute = this._routeSegments[0] === \"#\";\n        if (this._isHashRoute)\n            this._routeSegments.shift();\n        if (this._routeSegments.length &&\n            this._routeSegments[0][0] === \"&\") {\n            // this is a sub route, remove & store first segment\n            this._isSubRoute = true;\n            this._parentRouteName = this._routeSegments.shift().slice(1);\n        }\n    }\n    /** Returns the full path that will route to given activation object (or the path that the object was actually created for, using `mapRoute`), or undefined if no route has been mapped to the activation class or if one of the route parameters is missing */\n    ActivationRouter.prototype.getPathFor = function (activation) {\n        if (activation[MAPROUTE_PATH_PROPERTY]) {\n            // use actual path used\n            return activation[MAPROUTE_PATH_PROPERTY];\n        }\n        var result = \"\";\n        if (this._isSubRoute) {\n            // get path from parent activation router first\n            var parent = namedRoutes[this._parentRouteName];\n            if (!parent)\n                return undefined;\n            result = parent.getPathFor(activation);\n            if (result === undefined)\n                return undefined;\n        }\n        else if (this._isHashRoute) {\n            result = \"#\";\n        }\n        // add all path segments for this route\n        for (var _i = 0, _a = this._routeSegments; _i < _a.length; _i++) {\n            var segment = _a[_i];\n            if (segment[0] === \"*\" || segment[0] === \":\") {\n                // substitute activation property\n                var value = activation[segment.slice(1)];\n                if (value === undefined || value === null)\n                    return undefined;\n                result += \"/\" + value;\n            }\n            else {\n                // include segment literally\n                result += \"/\" + segment;\n            }\n        }\n        return result;\n    };\n    /** Returns a new activation object if the given path matches the mapped route */\n    ActivationRouter.prototype.match = function (path) {\n        var idx = (path[0] === \"#\") ? 1 : 0;\n        var segments = this._routeSegments;\n        if (!segments.length && this._isHashRoute && /^[^#]*#?$/) {\n            // always match home path #/ for a hashless path\n            return new this.target();\n        }\n        if (this._isSubRoute) {\n            // look for parent route first, prepend segments\n            var parent = namedRoutes[this._parentRouteName];\n            if (!parent)\n                return undefined;\n            if (!!idx !== parent._isHashRoute)\n                return undefined;\n            segments = parent._routeSegments.slice(0);\n            segments.push.apply(segments, this._routeSegments);\n        }\n        else {\n            // give up early if not hash route and path\n            if (!!idx !== this._isHashRoute)\n                return undefined;\n        }\n        // match route segments one by one\n        var segmentIdx = 0, parameters = {};\n        while (segmentIdx < segments.length) {\n            if (path[idx++] !== \"/\")\n                return undefined;\n            if (path.length <= idx)\n                return undefined;\n            var spec = segments[segmentIdx++];\n            if (spec[0] === \"*\") {\n                // match glob: store remainder in a parameter\n                parameters[spec.slice(1)] = path.slice(idx);\n                idx = path.length;\n                continue;\n            }\n            // find next segment in given path\n            var end = path.indexOf(\"/\", idx);\n            if (end < 0)\n                end = path.length;\n            if (spec[0] === \":\") {\n                // match parameter: store next segment in a parameter\n                parameters[spec.slice(1)] = path.slice(idx, end);\n            }\n            else if (spec !== path.slice(idx, end)) {\n                // segment does not match\n                return undefined;\n            }\n            idx = end;\n        }\n        // all segments matched, if path is fully consumed then create the activation\n        if (idx >= path.length || path.slice(idx) === \"/\") {\n            parameters[MAPROUTE_PATH_PROPERTY] = path;\n            return new this.target(parameters);\n        }\n        // no match: path is longer than route\n        return undefined;\n    };\n    return ActivationRouter;\n}());\n/** *Class decorator*, maps the decorated `Activation` (sub) class OR `Activity` class OR `Component` (ui module) class to the given route (e.g `dashboard`, `/users/:userID/post/:postID` or `#/docs/*docName`); if a name is provided, it can be used at the start of sub routes, using `&name/sub/route` (without leading hash/slash chars); multiple routes can be added per class; if the decorated class is an `Activity` class, a unique `Activation` sub class is generated automatically, and if the decorated class is a UI `Component` or `Page` class, a unique `Activity` class is also generated [decorator] */\nfunction mapRoute(route, name) {\n    return function (target) {\n        // if target is a view class, generate unique Activity class\n        if (target.prototype instanceof Component_Component ||\n            target.prototype instanceof Page_Page) {\n            var ViewActivity = (function (_super) {\n                Activation___extends(MappedViewActivity, _super);\n                function MappedViewActivity() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return MappedViewActivity;\n            }(Activity_Activity));\n            mapViewActivity(ViewActivity)(target);\n            target = ViewActivity;\n        }\n        // if target is an activity class, generate unique Activation class\n        if (target.prototype instanceof Activity_Activity) {\n            var activation = (function (_super) {\n                Activation___extends(MappedActivation, _super);\n                function MappedActivation() {\n                    return _super !== null && _super.apply(this, arguments) || this;\n                }\n                return MappedActivation;\n            }(Activation_Activation));\n            mapActivation(activation)(target);\n            target = activation;\n        }\n        // store activation route for use while matching paths to routes\n        if (routesList.indexOf(route) < 0)\n            routesList.unshift(route);\n        var router = new ActivationRouter(route, target);\n        routersByRoute[route] = router;\n        if (name)\n            namedRoutes[name] = router;\n        // inject method for generating a full path for an activation object\n        Async_defaultExport.inject(target, {\n            getPath: function () { return router.getPathFor(this); }\n        });\n    };\n}\n/** *Class decorator*, maps the decorated `Activity` class to given `Activation` type, so that routed (path/URL) and manual activations (using an activation object) lead to the instantiation of the decorated `Activity` [decorator] */\nfunction mapActivation(activationType) {\n    return function (target) {\n        // inject method to obtain an activity for instances of this activation type\n        Async_defaultExport.inject(activationType, {\n            getActivityAsync: function () {\n                return Async_defaultExport.Promise.resolve(target.getInstance(this));\n            }\n        });\n    };\n}\n\n// CONCATENATED MODULE: ./dist/core/lib/App/Activity/ActivityStack.js\n\n\nvar currentHistoryIDBase = \"_A\" + String(Math.random()).slice(-5);\nvar currentHistoryID = 0;\nvar nextTransitionID = 0;\nvar previousTransition;\n/** Represents a stack of activated activities (like browser history) */\nvar ActivityStack_ActivityStack = (function () {\n    function ActivityStack() {\n        /** Signal that is emitted when a transition occurs (after Starting/Resuming/Suspending but before Started/Resumed) */\n        this.Transition = Signal_Signal.create();\n        this._idx = Async_defaultExport.ObservableValue.fromValue(-1);\n        this._stack = new Async_defaultExport.ObservableArray();\n        this._ids = [];\n    }\n    /** Add an activity to the foreground asynchronously, does nothing if given activity was already in the foreground; returns Promise that resolves to the completed transition */\n    ActivityStack.prototype.pushAsync = function (activity) {\n        var _this = this;\n        if (!(activity instanceof Activity_Activity))\n            throw new Error(\"Invalid activity\");\n        // push activity and its parents on the stack\n        this._popTransient();\n        this._upToHubOrRoot(activity);\n        return this._transitionP = (this._transitionP || Async_defaultExport.Promise.resolve(undefined))\n            .then(function (t) {\n            previousTransition = undefined;\n            var result;\n            _this._findParents(activity).forEach(function (a) {\n                var p = function () { return _this._processTransition(a, ActivityTransition.Operation.Push); };\n                result = result ? result.then(p) : p();\n            });\n            return result || t;\n        });\n    };\n    /** Replace the current activity asynchronously (throws error if none), or remove current activity if given activity was already directly below current activity in the activity stack; returns Promise that resolves to the completed transition */\n    ActivityStack.prototype.replaceAsync = function (activity) {\n        var _this = this;\n        if (!(activity instanceof Activity_Activity))\n            throw new Error(\"Invalid activity\");\n        // process replace transaction\n        this._popTransient();\n        this._upToHubOrRoot(activity);\n        return this._transitionP = (this._transitionP || Async_defaultExport.Promise.resolve(undefined))\n            .then(function (t) {\n            previousTransition = undefined;\n            var lonely = (_this.topIndex < 0);\n            // pop if already directly below, otherwise replace or push\n            if (!lonely && _this._stack[_this.topIndex - 1] === activity)\n                return _this._processTransition(activity, ActivityTransition.Operation.Pop);\n            else {\n                // replace/push activity and its parents on the stack\n                var result;\n                _this._findParents(activity, true).forEach(function (a) {\n                    var p = function () { return _this._processTransition(a, (result || lonely) ?\n                        ActivityTransition.Operation.Push :\n                        ActivityTransition.Operation.Replace); };\n                    result = result ? result.then(p) : p();\n                });\n                return result || t;\n            }\n        });\n    };\n    ActivityStack.prototype.popAsync = function (activity) {\n        var _this = this;\n        return this._transitionP = (this._transitionP || Async_defaultExport.Promise.resolve(undefined))\n            .then(function () {\n            previousTransition = undefined;\n            if (_this.topIndex < 0)\n                throw new Error(\"No activity to suspend\");\n            if (activity !== undefined && _this.top !== activity)\n                return Async_defaultExport.Promise.resolve(undefined);\n            // send signals and return promise\n            return _this._processTransition(_this._stack[_this.topIndex - 1], ActivityTransition.Operation.Pop);\n        });\n    };\n    /** Remove foreground activities until given activity or activity of given type is in the foreground; returns Promise that resolves to activity, or undefined if there was no matching activity on the stack */\n    ActivityStack.prototype.upAsync = function (activityOrClass) {\n        var _this = this;\n        var isActivity = (activityOrClass instanceof Activity_Activity);\n        var recurse = function () {\n            if (isActivity ?\n                (_this.top === activityOrClass) :\n                (_this.top instanceof activityOrClass))\n                return Async_defaultExport.Promise.resolve(_this.top);\n            if (_this._stack.some(function (activity) { return isActivity ?\n                (activity === activityOrClass) :\n                (activity instanceof activityOrClass); }))\n                return _this._processTransition(_this._stack[_this.topIndex - 1], ActivityTransition.Operation.Pop)\n                    .then(function () { return recurse(); });\n            else\n                return Async_defaultExport.Promise.resolve(undefined);\n        };\n        return this._transitionP = (this._transitionP || Async_defaultExport.Promise.resolve(undefined))\n            .then(function () {\n            previousTransition = undefined;\n            return recurse();\n        });\n    };\n    /** Reload state using given history ID, if possible (i.e. not yet deactivated relevant activities in the meantime); returns a promise that resolves when the state has been reached */\n    ActivityStack.prototype.restoreHistoryStateAsync = function (historyID) {\n        var _this = this;\n        var idx = this._ids.lastIndexOf(historyID);\n        if (idx < 0 && historyID !== \"0\")\n            throw new Error(\"Cannot resume activities\");\n        if (idx === this.topIndex)\n            return Async_defaultExport.Promise.resolve(undefined);\n        // either go back or go forward and check again\n        return (idx < this.topIndex ?\n            this.popAsync() :\n            this.pushAsync(this._stack[this.topIndex + 1]))\n            .then(function () { return _this.restoreHistoryStateAsync(historyID); });\n    };\n    /** Get an ID that represents the current state, for use with `.restoreHistoryStateAsync` */\n    ActivityStack.prototype.getHistoryState = function () {\n        return this._ids[this.topIndex] || \"0\";\n    };\n    /** Get the activity closest to the foreground of the given type, if any (excluding foreground activity itself, and before given activity in second parameter, if any) */\n    ActivityStack.prototype.getParent = function (ActivityClass, before) {\n        var seenBefore = (this._stack[this.topIndex] === before);\n        for (var i = this.topIndex - 1; i >= 0; i--) {\n            if ((seenBefore || !before) &&\n                this._stack[i] instanceof ActivityClass)\n                return this._stack[i];\n            if (this._stack[i] === before)\n                seenBefore = true;\n        }\n        return undefined;\n    };\n    /** Returns true if the stack contains given activity */\n    ActivityStack.prototype.contains = function (activity) {\n        for (var i = this.topIndex; i >= 0; i--)\n            if (this._stack[i] === activity)\n                return true;\n        return false;\n    };\n    Object.defineProperty(ActivityStack.prototype, \"top\", {\n        /** The current foreground activity (top of stack, if any; observable) */\n        get: function () {\n            if (this.topIndex < 0)\n                return undefined;\n            return this._stack[this.topIndex];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivityStack.prototype, \"length\", {\n        /** The number of activities on the stack (observable) */\n        get: function () {\n            return this.topIndex + 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ActivityStack.prototype, \"title\", {\n        /** The title of the topmost activity that has a title defined (observable) */\n        get: function () {\n            for (var i = this.topIndex; i >= 0; i--)\n                if (this._stack[i].title !== undefined)\n                    return this._stack[i].title;\n            return \"\";\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Create an activity cursor that starts at the top of this stack, and can move back on the stack and to parent activities; if the `activity` property is undefined, the cursor has reached the end; note that any changes to the stack while the cursor is in use may yield unexpected results */\n    ActivityStack.prototype.getCursor = function () {\n        var _this = this;\n        var cursor = function (idx, stack) { return ({\n            activityStack: _this,\n            clone: function () { return cursor(idx, stack); },\n            get activity() {\n                if (idx >= stack.length)\n                    idx = stack.length - 1;\n                if (idx < 0)\n                    return undefined;\n                return stack[idx];\n            },\n            goBack: function () { idx--; return this; },\n            goParent: function () {\n                var current = this.activity;\n                if (current) {\n                    var parent = current.options.parentActivity;\n                    var isClass = (typeof parent === \"function\");\n                    for (idx--; idx >= 0; idx--) {\n                        current = stack[idx];\n                        if (current === parent || isClass &&\n                            (current instanceof parent))\n                            return this;\n                    }\n                }\n                return this;\n            }\n        }); };\n        return cursor(this.topIndex, this._stack);\n    };\n    /** Helper method to find parent activity/ies for given activity; returns an array of activities to be pushed (including activity itself) */\n    ActivityStack.prototype._findParents = function (activity, excludeTop) {\n        var result = [activity];\n        while (result[0].options.parentActivity) {\n            // ensure parent is on stack somewhere\n            var parent = result[0].options.parentActivity;\n            if (parent instanceof Activity_Activity) {\n                if (this.contains(parent) &&\n                    (!excludeTop || this.top !== parent))\n                    break;\n                result.unshift(parent);\n            }\n            else {\n                if ((!excludeTop && (this.top instanceof parent)) ||\n                    this.getParent(parent))\n                    break;\n                result.unshift(parent.getInstance());\n            }\n        }\n        return result;\n    };\n    /** Helper method to move up to existing root activity, or hub parent activity if needed */\n    ActivityStack.prototype._upToHubOrRoot = function (activity) {\n        // check if activity is a root activity and move up if possible\n        if (activity.options.isRootActivity && this.contains(activity)) {\n            this.upAsync(activity);\n            // wait until browser history is synchronized\n            this._transitionP =\n                (this._transitionP || Async_defaultExport.Promise.resolve(undefined))\n                    .then(function () { return Async_defaultExport.sleep(2); });\n        }\n        else {\n            // find out if existing parent activity is a hub activity\n            var parent;\n            if (parent = activity.options.parentActivity) {\n                if (!(parent instanceof Activity_Activity))\n                    parent = this.getParent(parent);\n                if (parent && parent.options.isHubActivity)\n                    this.upAsync(parent);\n                // wait until browser history is synchronized\n                this._transitionP =\n                    (this._transitionP || Async_defaultExport.Promise.resolve(undefined))\n                        .then(function () { return Async_defaultExport.sleep(2); });\n            }\n        }\n    };\n    /** Helper method to remove a transient activity if needed */\n    ActivityStack.prototype._popTransient = function () {\n        if (this.top && this.top.options.isTransient) {\n            var current = this.getCursor();\n            while (current.activity && current.activity.options.isTransient) {\n                current.goBack();\n            }\n            if (current.activity)\n                this.upAsync(current.activity);\n        }\n    };\n    /** Helper method for sending signals and creating promise */\n    ActivityStack.prototype._processTransition = function (to, op) {\n        var _this = this;\n        // create transition operation\n        var t = Object.freeze({\n            id: \"T\" + nextTransitionID++,\n            activityStack: this,\n            op: op, to: to, from: this.top,\n            previous: previousTransition\n        });\n        previousTransition = t;\n        // check if anything to do at all\n        if (this.top === to) {\n            if (op === ActivityTransition.Operation.Pop)\n                this.topIndex--;\n            return Async_defaultExport.Promise.resolve(t);\n        }\n        // gather promises for Suspending results\n        var top = this.top;\n        var suspense = top ? new top.Suspending(t).emit().results : [];\n        // try to activate/resume new activity and return promise\n        var resuming = !!to && this.contains(to);\n        return Async_defaultExport.Promise.all(suspense)\n            .then(function () {\n            // signal that transition is about to happen\n            return Async_defaultExport.Promise.all(resuming ?\n                new t.to.Resuming(t).emit().results :\n                t.to ? new t.to.Starting(t).emit().results : []);\n        })\n            .then(function () {\n            // when all handlers are OK, go ahead:\n            _this.Transition(t);\n            switch (t.op) {\n                case ActivityTransition.Operation.Pop:\n                    // just decrease stack top\n                    _this.topIndex--;\n                    break;\n                case ActivityTransition.Operation.Replace:\n                    // decrease stack top and then push\n                    _this.topIndex--;\n                case ActivityTransition.Operation.Push:\n                    // only move stack top if same activity above\n                    if (_this._stack.length > _this.topIndex + 1 &&\n                        _this._stack[_this.topIndex + 1] === t.to) {\n                        _this.topIndex++;\n                    }\n                    else {\n                        // deactivate overwritten stack top\n                        while (_this._stack.length > _this.topIndex + 1) {\n                            var oldTop = _this._stack.pop();\n                            if (!_this.contains(oldTop))\n                                oldTop.Deactivated(t);\n                        }\n                        // push new activity\n                        _this.topIndex = _this._stack.push(t.to) - 1;\n                        _this._ids.length = _this._stack.length;\n                        _this._ids[_this.topIndex] =\n                            currentHistoryIDBase + currentHistoryID++;\n                    }\n            }\n            // signal that transition has happened\n            if (t.to) {\n                if (!resuming)\n                    t.to.Started(t);\n                t.to.Resumed(t);\n            }\n            top && top.Suspended(t);\n            return t;\n        });\n    };\n    Object.defineProperty(ActivityStack.prototype, \"topIndex\", {\n        /** @internal */\n        get: function () { return this._idx.value; },\n        set: function (v) { this._idx.value = v; },\n        enumerable: true,\n        configurable: true\n    });\n    return ActivityStack;\n}());\n\nvar ActivityTransition;\n(function (ActivityTransition) {\n    /** Operation type that triggered a transition */\n    var Operation;\n    (function (Operation) {\n        /** Push operation */\n        Operation[Operation[\"Push\"] = 0] = \"Push\";\n        /** Replace operation */\n        Operation[Operation[\"Replace\"] = 1] = \"Replace\";\n        /** Pop operation */\n        Operation[Operation[\"Pop\"] = 2] = \"Pop\";\n    })(Operation = ActivityTransition.Operation || (ActivityTransition.Operation = {}));\n    ;\n})(ActivityTransition || (ActivityTransition = {}));\n\n// CONCATENATED MODULE: ./dist/core/lib/App/Activity/index.js\n\n\n\n\n// CONCATENATED MODULE: ./dist/core/lib/App/Culture/CultureService.js\nvar CultureService___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar CultureService___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/** Quick 2-digit number padding implementation for date/time formatting */\nvar d2 = function (n) { return n < 10 ? \"0\" + n : String(n); };\n/** Quick 4-digit number padding implementation for year formatting */\nfunction d4(n) {\n    var s = String(d4);\n    return \"000\".slice(0, Math.max(3 - s.length, 0)) + s;\n}\n;\n/** String splitter for day/month names */\nvar capSplit = function (s) { return s.split(/(?=[A-Z])/); };\n/** English weekday names */\nvar dayNames = capSplit(\"SundayMondayTuesdayWednesdayThursdayFridaySaturday\");\n/** English abbreviated weekday names */\nvar dayNamesAbbr = capSplit(\"SunMonTueWedThuFriSat\");\n/** English month names */\nvar monthNames = capSplit(\"JanuaryFebruaryMarchAprilMayJuneJulyAugustSeptemberOctoberNovemberDecember\");\n/** English abbreviated month names */\nvar monthNamesAbbr = capSplit(\"JanFebMarAprMayJunJulAugSepOctNovDec\");\n/** Base culture service (mapped on `culture-neutral` and `culture` initially); to be overridden with a language and region specific culture service, mapped as `culture-xx-YY/zz`, and aliased as `culture` using `addServiceAlias` to set as the current culture */\nvar CultureService_CultureService = (function (_super) {\n    CultureService___extends(CultureService, _super);\n    function CultureService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** The name of this culture, defaults to \"none\" but should be set to _languagecode-countrycode/regioncode_ and/or shorter forms such as _languagecode-countrycode_ and _languagecode_ */\n        _this.name = \"neutral\";\n        /** Collection of date/time formatters specific to this culture, used by `.formatDateTime`; defaults to a mostly international English format; replacement algorithm requires inclusion of all lengths of possible placeholders (including e.g. `yyy` and `%`) */\n        _this.dateTimeFormatters = {\n            \"d\": function (d) { return d.getDate().toString(); },\n            \"dd\": function (d) { return d2(d.getDate()); },\n            \"ddd\": function (d) { return dayNamesAbbr[d.getDay()]; },\n            \"dddd\": function (d) { return dayNames[d.getDay()]; },\n            \"h\": function (d) { return (d.getHours() % 12 || 12).toString(); },\n            \"hh\": function (d) { return d2(d.getHours() % 12 || 12); },\n            \"H\": function (d) { return d.getHours().toString(); },\n            \"HH\": function (d) { return d2(d.getHours()); },\n            \"m\": function (d) { return d.getMinutes().toString(); },\n            \"mm\": function (d) { return d2(d.getMinutes()); },\n            \"M\": function (d) { return String(d.getMonth() + 1); },\n            \"MM\": function (d) { return d2(d.getMonth() + 1); },\n            \"MMM\": function (d) { return monthNamesAbbr[d.getMonth()]; },\n            \"MMMM\": function (d) { return monthNames[d.getMonth()]; },\n            \"s\": function (d) { return d.getSeconds().toString(); },\n            \"ss\": function (d) { return d2(d.getSeconds()); },\n            \"t\": function (d) { return (d.getHours() < 12 ? \"a\" : \"p\"); },\n            \"tt\": function (d) { return (d.getHours() < 12 ? \"AM\" : \"PM\"); },\n            \"y\": function (d) { return String(d.getFullYear() % 100); },\n            \"yy\": function (d) { return d2(d.getFullYear() % 100); },\n            \"yyy\": function (d) { return d2(d.getFullYear() % 100); },\n            \"yyyy\": function (d) { return d.getFullYear().toString(); },\n            \"/\": function () { return \"/\"; },\n            \":\": function () { return \":\"; },\n            \"%\": function () { return \"\"; },\n            \"%d\": function (d, s) { return s.formatDateTime(d, \"d/M/y\"); },\n            \"%dd\": function (d, s) { return s.formatDateTime(d, \"d MMM yyyy\"); },\n            \"%ddd\": function (d, s) { return s.formatDateTime(d, \"d MMMM yyyy\"); },\n            \"%dddd\": function (d, s) { return s.formatDateTime(d, \"dddd, d MMMM yyyy\"); },\n            \"%t\": function (d, s) { return s.formatDateTime(d, \"h:mm tt\"); },\n            \"%tt\": function (d, s) { return s.formatDateTime(d, \"h:mm:ss tt\"); },\n            \"%T\": function (d, s) { return s.formatDateTime(d, \"H:mm\"); },\n            \"%TT\": function (d, s) { return s.formatDateTime(d, \"H:mm:ss\"); },\n        };\n        return _this;\n    }\n    /** Translate given text (may include placeholders and prefixes used by `UI.tl`) */\n    CultureService.prototype.translateText = function (text) {\n        return text;\n    };\n    /** Pluralize text based on given number and substitution form(s); defaults to English singular/plural rules without automatic pluralization (i.e. both singular and plural forms need to be specified in the placeholder) */\n    CultureService.prototype.pluralizeText = function (n, forms) {\n        return (n > 1 || n < -1) ? (forms[1] || forms[0]) : forms[0];\n    };\n    /** Returns given number formatted using culture specific rules, and using given precision (i.e. fixed number of decimals to display e.g. `2.00`, and/or rounding at given number of decimals, default 8, to avoid binary-to-decimal rounding errors such as `1.99999999`...); default implementation uses decimal point (`.`) and no thousands separators, but may revert to scientific notation for numbers with more than 20 digits (platform default) */\n    CultureService.prototype.formatNumber = function (n, fixedDecimals, roundDecimals) {\n        if (roundDecimals === void 0) { roundDecimals = 8; }\n        if (typeof n !== \"number\")\n            n = parseFloat(n);\n        if (roundDecimals >= 0) {\n            var factor = 1;\n            while (roundDecimals--)\n                factor *= 10;\n            n = Math.round(n * factor) / factor;\n        }\n        return fixedDecimals >= 0 ? n.toFixed(fixedDecimals) : String(n);\n    };\n    /** Returns given number formatted as a currency, with given currency symbol and fixed number of decimals; defaults to \"$\", non-breaking space, and number with 2 fixed decimals; specific culture implementations should override defaults but still accept the same arguments */\n    CultureService.prototype.formatCurrency = function (n, currencySymbol, fixedDecimals) {\n        if (currencySymbol === void 0) { currencySymbol = \"$\"; }\n        if (fixedDecimals === void 0) { fixedDecimals = 2; }\n        return currencySymbol + \"\\xa0\" + this.formatNumber(n, fixedDecimals);\n    };\n    /** Returns given number formatted as a percentage, with given percentage symbol and fixed number of decimals; defaults to number without fixed decimals and \"%\" character; specific culture implementations should override defaults but still accept the same arguments */\n    CultureService.prototype.formatPercentage = function (n, percSymbol, fixedDecimals) {\n        if (percSymbol === void 0) { percSymbol = \"%\"; }\n        return this.formatNumber(n, fixedDecimals) + percSymbol;\n    };\n    /** Returns given date/time formatted using given format string (e.g. `dd/MMM/yyyy HH:mm`) using the following default placeholders, which may be (re-) defined by the culture service (defaults to `%dd %t`):\n     * * `%d`: short date, e.g. 20/1/17,\n     * * `%dd`: medium date, e.g. 20 Jan 2017\n     * * `%ddd`: long date, e.g. 20 January 2017\n     * * `%dddd`: full date, e.g. Friday, 20 January 2017\n     * * `%t`: time, e.g. 2:20 PM\n     * * `%tt`: time with seconds, e.g. 2:20:00 PM\n     * * `%T`: 24-hour time, e.g. 14:20\n     * * `%TT`: 24-hour time with seconds, e.g. 14:20:00\n     * * `d`: date 0-31,\n     * * `dd`: date 00-31,\n     * * `ddd`: abbreviated weekday name,\n     * * `dddd`: full weekday name,\n     * * `h`: hours 0-12,\n     * * `hh`: hours 00-12,\n     * * `H`: hours 0-23,\n     * * `HH`: hours 00-23,\n     * * `m`: minutes 0-59,\n     * * `mm`: minutes 00-59,\n     * * `M`: month 0-12,\n     * * `MM`: month 00-12,\n     * * `MMM`: abbreviated month name,\n     * * `MMMM`: full month name,\n     * * `s`: seconds 0-59,\n     * * `ss`: seconds 00-59,\n     * * `t`: a/p,\n     * * `tt`: AM/PM,\n     * * `y`: year 0-99,\n     * * `yy`: year 00-99,\n     * * `yyyy`: year 0000-9999,\n     * * `/`: date separator,\n     * * `:`: time separator\n     */\n    CultureService.prototype.formatDateTime = function (d, format) {\n        if (format === void 0) { format = \"%dd %t\"; }\n        var result = \"\";\n        for (var i = 0, len = format.length; i < len; i++) {\n            if (format[i] === \"\\\\\") {\n                result += format[i + 1] || \"\";\n                continue;\n            }\n            for (var j = i, buf = \"\"; j < len && this.dateTimeFormatters[buf + format[j]];)\n                buf += format[j++];\n            if (buf) {\n                result += this.dateTimeFormatters[buf](d, this);\n                i = j - 1;\n                continue;\n            }\n            result += format[i];\n        }\n        return result;\n    };\n    CultureService = CultureService___decorate([\n        mapService(\"culture-neutral\", \"culture\")\n    ], CultureService);\n    return CultureService;\n}(Service));\n\n\n// CONCATENATED MODULE: ./dist/core/lib/App/Culture/Observer.js\nvar Observer___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n/** Helper class used to subscribe to culture changes and update UI module properties */\nvar Observer_Observer = (function () {\n    function Observer() {\n        var _this = this;\n        var currentCulture;\n        Async_defaultExport.observe(function () { return _this.culture; }).subscribe(function (culture) {\n            if (currentCulture && currentCulture !== culture) {\n                // emit global signal\n                CultureChanged(culture);\n            }\n            if (culture) {\n                // update global flow direction\n                Screen_Screen.defaultFlowDirection = culture.textFlowDirection;\n            }\n            currentCulture = culture;\n        });\n        Async_defaultExport.inject(TextLabelFactory_TextLabelFactory, (_a = {},\n            _a[\"@translateText\"] = function (text) {\n                // translate according to current culture (set above)\n                return currentCulture ? currentCulture.translateText(text) : \"\";\n            },\n            _a[\"@pluralizeText\"] = function (n, forms) {\n                // pluralize according to current culture (set above)\n                return currentCulture ? currentCulture.pluralizeText(n, forms) : \"\";\n            },\n            _a));\n        var _a;\n    }\n    Observer___decorate([\n        injectService(\"culture\")\n    ], Observer.prototype, \"culture\", void 0);\n    return Observer;\n}());\n// create an instance to start observing\nAsync_defaultExport.defer(function () { new Observer_Observer(); });\n/** Signal that is emitted when the global i18n culture changes (through `CultureService`) */\nvar CultureChanged = Signal_Signal.create();\n\n// CONCATENATED MODULE: ./dist/core/lib/App/Culture/index.js\n\n\n\n// CONCATENATED MODULE: ./dist/core/lib/App/index.js\nvar lib_App_namespaceObject = {};\n__webpack_require__.d(lib_App_namespaceObject, \"Application\", function() { return Application_Application; });\n__webpack_require__.d(lib_App_namespaceObject, \"startActivityAsync\", function() { return startActivityAsync; });\n__webpack_require__.d(lib_App_namespaceObject, \"findActivity\", function() { return findActivity; });\n__webpack_require__.d(lib_App_namespaceObject, \"Activation\", function() { return Activation_Activation; });\n__webpack_require__.d(lib_App_namespaceObject, \"mapRoute\", function() { return mapRoute; });\n__webpack_require__.d(lib_App_namespaceObject, \"mapActivation\", function() { return mapActivation; });\n__webpack_require__.d(lib_App_namespaceObject, \"Activity\", function() { return Activity_Activity; });\n__webpack_require__.d(lib_App_namespaceObject, \"SingletonActivity\", function() { return Activity_SingletonActivity; });\n__webpack_require__.d(lib_App_namespaceObject, \"SupportActivity\", function() { return SupportActivity; });\n__webpack_require__.d(lib_App_namespaceObject, \"RootActivity\", function() { return RootActivity; });\n__webpack_require__.d(lib_App_namespaceObject, \"mapParentActivity\", function() { return mapParentActivity; });\n__webpack_require__.d(lib_App_namespaceObject, \"ActivityStack\", function() { return ActivityStack_ActivityStack; });\n__webpack_require__.d(lib_App_namespaceObject, \"ActivityTransition\", function() { return ActivityTransition; });\n__webpack_require__.d(lib_App_namespaceObject, \"FRAG_ID_PROP\", function() { return FRAG_ID_PROP; });\n__webpack_require__.d(lib_App_namespaceObject, \"FRAG_HASH_PREFIX\", function() { return FRAG_HASH_PREFIX; });\n__webpack_require__.d(lib_App_namespaceObject, \"isLayoutFragment\", function() { return isLayoutFragment; });\n__webpack_require__.d(lib_App_namespaceObject, \"layoutFragment\", function() { return layoutFragment; });\n__webpack_require__.d(lib_App_namespaceObject, \"mapViewActivity\", function() { return mapViewActivity; });\n__webpack_require__.d(lib_App_namespaceObject, \"MessageBoxLayout\", function() { return MessageBox_MessageBoxLayout; });\n__webpack_require__.d(lib_App_namespaceObject, \"showMessageBox\", function() { return showMessageBox; });\n__webpack_require__.d(lib_App_namespaceObject, \"Service\", function() { return Service; });\n__webpack_require__.d(lib_App_namespaceObject, \"mapService\", function() { return mapService; });\n__webpack_require__.d(lib_App_namespaceObject, \"addServiceAlias\", function() { return addServiceAlias; });\n__webpack_require__.d(lib_App_namespaceObject, \"injectService\", function() { return injectService; });\n__webpack_require__.d(lib_App_namespaceObject, \"CultureService\", function() { return CultureService_CultureService; });\n__webpack_require__.d(lib_App_namespaceObject, \"CultureChanged\", function() { return CultureChanged; });\n__webpack_require__.d(lib_App_namespaceObject, \"BaseLayout\", function() { return Base_BaseLayout; });\n__webpack_require__.d(lib_App_namespaceObject, \"BaseDialogLayout\", function() { return Base_BaseDialogLayout; });\n__webpack_require__.d(lib_App_namespaceObject, \"VerticalLayout\", function() { return Single_VerticalLayout; });\n__webpack_require__.d(lib_App_namespaceObject, \"ScrollableLayout\", function() { return ScrollableLayout; });\n__webpack_require__.d(lib_App_namespaceObject, \"AppBarLayout\", function() { return App_AppBarLayout; });\n__webpack_require__.d(lib_App_namespaceObject, \"AppViewLayout\", function() { return App_AppViewLayout; });\n__webpack_require__.d(lib_App_namespaceObject, \"HubViewLayout\", function() { return App_HubViewLayout; });\n\n\n\n\n\n\n// CONCATENATED MODULE: ./dist/core/lib/App.js\nvar core_lib_App_namespaceObject = {};\n__webpack_require__.d(core_lib_App_namespaceObject, \"default\", function() { return App_defaultExport; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"Application\", function() { return Application_Application; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"startActivityAsync\", function() { return startActivityAsync; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"findActivity\", function() { return findActivity; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"Activation\", function() { return Activation_Activation; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"mapRoute\", function() { return mapRoute; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"mapActivation\", function() { return mapActivation; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"Activity\", function() { return Activity_Activity; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"SingletonActivity\", function() { return Activity_SingletonActivity; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"SupportActivity\", function() { return SupportActivity; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"RootActivity\", function() { return RootActivity; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"mapParentActivity\", function() { return mapParentActivity; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"ActivityStack\", function() { return ActivityStack_ActivityStack; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"ActivityTransition\", function() { return ActivityTransition; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"FRAG_ID_PROP\", function() { return FRAG_ID_PROP; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"FRAG_HASH_PREFIX\", function() { return FRAG_HASH_PREFIX; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"isLayoutFragment\", function() { return isLayoutFragment; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"layoutFragment\", function() { return layoutFragment; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"mapViewActivity\", function() { return mapViewActivity; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"MessageBoxLayout\", function() { return MessageBox_MessageBoxLayout; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"showMessageBox\", function() { return showMessageBox; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"Service\", function() { return Service; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"mapService\", function() { return mapService; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"addServiceAlias\", function() { return addServiceAlias; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"injectService\", function() { return injectService; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"CultureService\", function() { return CultureService_CultureService; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"CultureChanged\", function() { return CultureChanged; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"BaseLayout\", function() { return Base_BaseLayout; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"BaseDialogLayout\", function() { return Base_BaseDialogLayout; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"VerticalLayout\", function() { return Single_VerticalLayout; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"ScrollableLayout\", function() { return ScrollableLayout; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"AppBarLayout\", function() { return App_AppBarLayout; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"AppViewLayout\", function() { return App_AppViewLayout; });\n__webpack_require__.d(core_lib_App_namespaceObject, \"HubViewLayout\", function() { return App_HubViewLayout; });\n\n\n/* harmony default export */ var App_defaultExport = (lib_App_namespaceObject);\n\n// CONCATENATED MODULE: ./dist/dom/node_modules/@typescene/core/App.js\n\n// CONCATENATED MODULE: ./dist/dom/lib/App/DOMApplication.js\nvar DOMApplication___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n/** True if browser history is enabled */\nvar useBrowserHistory = true;\n/** Platform specific encapsulation of the application as a singleton object */\nvar DOMApplication_DOMApplication = (function (_super) {\n    DOMApplication___extends(DOMApplication, _super);\n    /** Create the application instance (either from a derived class or from the Application class itself); can be called only once */\n    function DOMApplication(title) {\n        var _this = _super.call(this, title) || this;\n        // initialize page view\n        Screen_Screen.ready.then(function () {\n            // listen for events and activity transitions\n            _this._listen();\n            // start initial page view\n            Defer_defer(function () {\n                if (!_this.activities.length)\n                    _this._startLocationActivity();\n            });\n            // set title and keep it updated\n            observe(function () {\n                var activityTitle = _this.activities.title;\n                return [\n                    activityTitle,\n                    _this.title !== activityTitle ? _this.title : \"\"\n                ].filter(function (s) { return !!s; }).join(\" - \");\n            }).subscribe(function (title) {\n                // apply to DOM document window\n                document.title = title;\n            });\n        });\n        return _this;\n    }\n    /** Disable synchronization of activity stack with browser history */\n    DOMApplication.disableBrowserHistory = function () {\n        useBrowserHistory = false;\n    };\n    /** Returns the full URL from `window.location.href`; used to resolve relative URLs to start routed activities */\n    DOMApplication.prototype.getCurrentUrl = function () { return String(window.location.href); };\n    /** Sets the browser's current URL (using `window.location.href`), to navigate to another page or website */\n    DOMApplication.prototype.navigateToUrl = function (url) { window.location.href = url; };\n    /** @internal Helper that sets event handlers and listens for activity transitions */\n    DOMApplication.prototype._listen = function () {\n        var _this = this;\n        // true if external trigger caused activity changes\n        var externalTrigger = false;\n        function withExternal(f) {\n            externalTrigger = true;\n            try {\n                return f().then(function () { externalTrigger = false; }, function () { externalTrigger = false; });\n            }\n            catch (err) {\n                externalTrigger = false;\n                throw err;\n            }\n        }\n        // listen for hash changes (triggered by user)\n        window.addEventListener(\"hashchange\", function () {\n            if (!useBrowserHistory)\n                return;\n            var hash = String(window.location.hash || \"#\");\n            // return if this is a known state\n            if (window.history.state && window.history.state.activityID)\n                return;\n            // check if activity history ID (no pushState support)\n            if (hash.slice(0, 3) === \"#__\") {\n                withExternal(function () { return _this.activities.restoreHistoryStateAsync(hash.slice(3)); });\n                return;\n            }\n            // push activities\n            if (hash[1] !== \"/\")\n                hash = \"#/\" + hash.slice(1);\n            withExternal(function () { return _this.startActivityAsync(hash, false, false); });\n        });\n        // listen for browser history movement (either triggered by user,\n        // or by function below after popping an activity): reset state\n        var lastPopStateID = null;\n        window.addEventListener(\"popstate\", function (event) {\n            if (!useBrowserHistory)\n                return;\n            var id = lastPopStateID = event.state && event.state.activityID;\n            // defer reset to process only latest popstate event\n            id && Defer_defer(function () {\n                if (id === lastPopStateID && id !== _this.activities.getHistoryState()) {\n                    try {\n                        withExternal(function () { return _this.activities.restoreHistoryStateAsync(id); })\n                            .then(undefined, function () {\n                            // if not successful, try to revert again\n                            _this._updateHistoryState(ActivityTransition.Operation.Push);\n                        });\n                    }\n                    catch (err) {\n                        // if cannot reset activity, just use location\n                        _this._startLocationActivity(true);\n                    }\n                }\n            });\n        });\n        // connect to activity manager\n        this.activities.Transition.connect(function (t) {\n            if (externalTrigger) {\n                // triggered by above, replace state if currrently no ID\n                if (window.history.state && !window.history.state.activityID)\n                    _this._updateHistoryState(ActivityTransition.Operation.Replace);\n            }\n            else {\n                // triggered by application: update browser history\n                var op = t.op;\n                _this._updateHistoryState(op);\n            }\n        });\n    };\n    // start activity based on current location\n    DOMApplication.prototype._startLocationActivity = function (replace) {\n        if (window.location.hash && window.location.hash !== \"#\")\n            this.startActivityAsync(window.location.hash, replace, false)\n                .then(undefined, function () { window.location.hash = \"\"; });\n        else\n            this.startActivityAsync(window.location.href, replace, false);\n    };\n    // update browser history following an activity transition\n    DOMApplication.prototype._updateHistoryState = function (op) {\n        var current = this.activities.top;\n        if (current && current.options.isBackgroundActivity)\n            return;\n        if (!useBrowserHistory)\n            return;\n        // change first push to a replace to avoid lingering initial state\n        if (op === ActivityTransition.Operation.Push &&\n            window.history.pushState &&\n            (!window.history.state || !window.history.state.activityID))\n            op = ActivityTransition.Operation.Replace;\n        // check what to do: push, replace, or pop history state\n        if (op === ActivityTransition.Operation.Push) {\n            var path = current && current.activation.getPath();\n            var activityID = this.activities.getHistoryState();\n            if (path) {\n                if (window.history.pushState) {\n                    window.history.pushState({ activityID: activityID, path: path }, this.title, path);\n                }\n                else {\n                    window.location.hash = \"#__\" + activityID;\n                }\n            }\n            else {\n                if (window.history.pushState) {\n                    window.history.pushState({ activityID: activityID }, this.title);\n                }\n                else {\n                    window.location.hash = \"#__\" + activityID;\n                }\n            }\n        }\n        else if (op === ActivityTransition.Operation.Replace) {\n            var path = current && current.activation.getPath();\n            var activityID = this.activities.getHistoryState();\n            if (path) {\n                if (window.history.replaceState) {\n                    window.history.replaceState({ activityID: activityID, path: path }, this.title, path);\n                }\n            }\n            else {\n                if (window.history.replaceState) {\n                    window.history.replaceState({ activityID: activityID }, this.title);\n                }\n            }\n        }\n        else if (op === ActivityTransition.Operation.Pop) {\n            window.history.pushState && window.history.back();\n        }\n    };\n    return DOMApplication;\n}(Application_Application));\n\n\n// CONCATENATED MODULE: ./dist/dom/lib/App/Http.js\n\n// declare fetch function if not defined\nvar _hasNativeFetch = (typeof window.fetch === \"function\");\nvar _canBlob = (function () {\n    try {\n        if (typeof Blob !== \"undefined\" &&\n            typeof FileReader !== \"undefined\" &&\n            new Blob([]))\n            return true;\n    }\n    catch (all) { }\n    return false;\n})();\n/** Namespace that encapsulates `.fetch` and related functionality */\nvar Http_Http;\n(function (Http) {\n    /** Configuration options */\n    Http.config = {\n        FORCE_XHR_FETCH: false,\n        FETCH_INCLUDE_CREDENTIALS: true\n    };\n    ;\n    /** Signal that is emitted before sending a request; can be used to intercept requests, modify request options, and provide an alternate response; if one of the connected handlers returns a (promise for) an alternate response, i.e. an object that implements `FetchResponse`, then the request will not be sent, and the (first) resulting alternate response is used instead; if one of the connected handlers throws an exception, the original promise for the request is rejected; otherwise the request is sent as per normal */\n    Http.Requesting = Signal_Signal.create();\n    /** Signal that is emitted after obtaining a remote response (from an actual request, not an alternate response provided by a connected handler of `.Requesting`) */\n    Http.Responded = Signal_Signal.create();\n    /** Implements the FetchResponse interface, can be used to mock responses or initialize a response from an XMLHttpRequest */\n    var MockResponse = (function () {\n        /** Create a response with given properties (an XMLHttpRequest object can be passed in directly, along with a native fetch `Headers` instance or a MockResponseHeaders instance); the response itself is taken from `.responseText` if it is not undefined, or from `.response` if it is a Blob */\n        function MockResponse(init, headers) {\n            if (!init)\n                init = { responseText: \"\" };\n            this._init = init;\n            this.status = (init.status !== undefined ? init.status : 200);\n            this.ok = this.status >= 200 && this.status < 300;\n            this.statusText = init.statusText || \"OK\";\n            this.headers = headers || new MockResponseHeaders();\n        }\n        /** Create a response with given data encoded as JSON, the `application/json` content type, and status 200 */\n        MockResponse.withJSONContent = function (data) {\n            return new MockResponse({ responseText: JSON.stringify(data) }, new MockResponseHeaders(\"Content-Type: application/json\"));\n        };\n        /** Returns a promise for the response body read into a Blob, if supported */\n        MockResponse.prototype.blob = function () {\n            if (!_canBlob)\n                return Promise_Promise.reject(new TypeError());\n            else if (!(this._init.response instanceof Blob))\n                return Promise_Promise.resolve(new Blob([this._init.responseText || \"\"], { type: this.headers.get(\"content-type\") || \"text/plain\" }));\n            else\n                return Promise_Promise.resolve(this._init.response);\n        };\n        /** Returns a promise for the response body */\n        MockResponse.prototype.text = function () { return this._readText(); };\n        /** Returns a promise for the response body, parsed as JSON */\n        MockResponse.prototype.json = function () { return this._readText().then(function (s) { return JSON.parse(s); }); };\n        /** Helper method that returns a Promise with the text from the constructor initializer (with text in `.responseText`, or a blob in `.response`) */\n        MockResponse.prototype._readText = function () {\n            var _this = this;\n            try {\n                // try to use reponseText property first\n                if (this._init.responseType !== \"blob\" &&\n                    this._init.responseText !== undefined)\n                    return Promise_Promise.resolve(this._init.responseText);\n            }\n            catch (all) { }\n            // ... otherwise read from response blob\n            if (this._init.response instanceof Blob) {\n                return new Promise_Promise(function (resolve, reject) {\n                    var fileReader = new FileReader();\n                    fileReader.onload = function () { return resolve(fileReader.result); };\n                    fileReader.onerror = function () { return reject(fileReader.error); };\n                    fileReader.readAsText(_this._init.response);\n                });\n            }\n            return Promise_Promise.reject(new Error(\"Response is neither text nor blob\"));\n        };\n        return MockResponse;\n    }());\n    Http.MockResponse = MockResponse;\n    /** Implements the FetchResponse interface, can be used to mock response headers or initialize response headers from an XMLHttpRequest */\n    var MockResponseHeaders = (function () {\n        /** Initialize the list of headers using given HTTP header text (i.e. one or more lines with header name, colon, and header value; strips all whitespace around names and values) */\n        function MockResponseHeaders(allResponseHeaders) {\n            var _this = this;\n            this._headers = {};\n            // parse all response headers from text\n            if (allResponseHeaders) {\n                allResponseHeaders.split(/\\r\\n|\\n\\r|\\r|\\n/).forEach(function (s) {\n                    var match = s.match(/^\\s+([^:]+):\\s*(.*)/);\n                    if (match) {\n                        var key = match[0], value = match[1];\n                        key = key.toLowerCase();\n                        value = value.replace(/\\s+$/, \"\");\n                        if (!_this._headers[key])\n                            _this._headers[key] = [];\n                        _this._headers[key].push(value);\n                    }\n                });\n            }\n        }\n        MockResponseHeaders.prototype.get = function (name) {\n            name = name.toLowerCase();\n            return this._headers[name] && this._headers[name][0];\n        };\n        MockResponseHeaders.prototype.getAll = function (name) {\n            name = name.toLowerCase();\n            return this._headers[name];\n        };\n        MockResponseHeaders.prototype.has = function (name) {\n            name = name.toLowerCase();\n            return !!(this._headers[name]);\n        };\n        MockResponseHeaders.prototype.keys = function () {\n            var keys = [], idx = 0;\n            for (var name in this._headers) {\n                if (Object.prototype.hasOwnProperty.call(this._headers, name))\n                    keys.push(name);\n            }\n            return {\n                next: function () {\n                    if (idx >= keys.length)\n                        return { done: true };\n                    else\n                        return { done: false, value: keys[idx] };\n                }\n            };\n        };\n        return MockResponseHeaders;\n    }());\n    Http.MockResponseHeaders = MockResponseHeaders;\n    function fetch(input, init) {\n        var props;\n        if (typeof input === \"string\") {\n            // use init or create new options instance\n            props = init || {};\n            props.url = input;\n        }\n        else {\n            // use options/Request instance directly\n            props = input;\n        }\n        // include credentials by default\n        if (_hasNativeFetch && !props.credentials &&\n            Http.config.FETCH_INCLUDE_CREDENTIALS)\n            props.credentials = \"same-origin\";\n        // return a promise for the remote/mock response\n        return new Http.Requesting(props).emit().then(function (results) {\n            // use resulting response, if any\n            for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {\n                var r = results_1[_i];\n                if (r)\n                    return r;\n            }\n            // start request\n            if (!props.headers)\n                props.headers = {};\n            return ((_hasNativeFetch && !Http.config.FORCE_XHR_FETCH) ?\n                window.fetch(props.url, props) : _xhr(props))\n                .then(function (response) { return (Http.Responded(response), response); });\n        });\n    }\n    Http.fetch = fetch;\n    /** Helper function for sending a simple request through XMLHttpRequest, returns a promise for the XHR responseText */\n    function _xhr(options) {\n        return new Promise_Promise(function (resolve, reject) {\n            try {\n                // create request and send data\n                var xhr = new XMLHttpRequest();\n                if (_canBlob)\n                    xhr.responseType = \"blob\";\n                xhr.open(options.method || \"GET\", options.url, true);\n                if (options.headers) {\n                    if (typeof options.headers.keys ===\n                        \"function\") {\n                        // get all headers from the native/polyfill Headers object\n                        var it = options.headers.keys();\n                        var r;\n                        while ((r = it.next()) && !r.done) {\n                            options.headers.getAll(r.value)\n                                .forEach(function (v) { return xhr.setRequestHeader(r.value, v); });\n                        }\n                    }\n                    else {\n                        // use headers from a plain object\n                        var headers = options.headers;\n                        for (var key in headers) {\n                            if (Object.prototype.hasOwnProperty.call(headers, key))\n                                xhr.setRequestHeader(key, headers[key]);\n                        }\n                    }\n                }\n                // await response and resolve or reject promise\n                xhr.onload = function () {\n                    var h = new MockResponseHeaders(xhr.getAllResponseHeaders());\n                    resolve(new MockResponse(xhr, h));\n                };\n                xhr.onerror = function () { reject(new Error(\"HTTP error\")); };\n                xhr.ontimeout = function () { reject(new Error(\"HTTP timeout\")); };\n                xhr.send(options.body);\n            }\n            catch (all) {\n                reject(all);\n            }\n        });\n    }\n    /** Helper function to add an \"Accept\" header */\n    function _headersWithAccept(headers, accept, type) {\n        if (headers === void 0) { headers = {}; }\n        if (accept === void 0) { accept = \"application/json\"; }\n        if (type === void 0) { type = \"application/json\"; }\n        if ((typeof headers.has === \"function\") &&\n            !headers.has(\"accept\")) {\n            if (accept)\n                headers.append(\"accept\", accept);\n            if (type)\n                headers.append(\"content-Type\", type);\n        }\n        else if (!headers[\"accept\"] && !headers[\"Accept\"]) {\n            if (accept)\n                headers[\"accept\"] = accept;\n            if (type)\n                headers[\"content-type\"] = type;\n        }\n        return headers;\n    }\n    /** Helper function to add query parameters to a URL */\n    function _addQueryParams(url, params) {\n        if (params) {\n            var first = (url.indexOf(\"?\") < 0);\n            for (var key in params) {\n                if (Object.prototype.hasOwnProperty.call(params, key)) {\n                    url += (first ? \"?\" : \"&\") + encodeURIComponent(key)\n                        + \"=\" + encodeURIComponent(params[key]);\n                    first = false;\n                }\n            }\n        }\n        return url;\n    }\n    /** Helper function to make a request with a JSON body, that only accepts JSON */\n    function _fetchJSON(options, data) {\n        options.headers = _headersWithAccept(options.headers || {});\n        if (data === undefined)\n            data = {};\n        options.body = JSON.stringify(data);\n        return fetch(options).then(function (response) {\n            if (!response.ok)\n                throw new Error(\"HTTP \" + response.status);\n            return response.text().then(function (s) { return s.length ? JSON.parse(s) : undefined; });\n        });\n    }\n    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to the response text, or gets rejected if the request fails or response status is not in 2xx range */\n    function getTextAsync(url, params, headers) {\n        url = _addQueryParams(url, params);\n        return fetch(url, { method: \"GET\", headers: headers }).then(function (response) {\n            if (!response.ok)\n                throw new Error(\"HTTP \" + response.status);\n            return response.text();\n        });\n    }\n    Http.getTextAsync = getTextAsync;\n    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to a blob, or gets rejected if the request fails or response status is not in 2xx range; requires a browser that supports Blob constructors */\n    function getBlobAsync(url, params, headers) {\n        if (!_canBlob)\n            throw new TypeError();\n        url = _addQueryParams(url, params);\n        return fetch(url, { method: \"GET\", headers: headers }).then(function (response) {\n            if (!response.ok)\n                throw new Error(\"HTTP \" + response.status);\n            return response.blob();\n        });\n    }\n    Http.getBlobAsync = getBlobAsync;\n    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to the parsed HTML result body as a document fragment (ignores everything before and after body tag, if any; inserts everything if no body tag is found, i.e. partial HTML), or gets rejected if the request fails or response status is not in 2xx range */\n    function getHtmlContentAsync(url, params, headers) {\n        return getTextAsync(url, params, _headersWithAccept(headers, \"text/html\", \"\"))\n            .then(function (responseText) {\n            // find body tag and keep only its content\n            responseText = String(responseText || \"\");\n            var startTag = responseText.match(/<body(?:>|\\s[^>]+>)/m);\n            if (startTag) {\n                responseText = responseText.slice(startTag.index + startTag[0].length);\n                var endTagPos = responseText.lastIndexOf(\"</body>\");\n                if (endTagPos >= 0)\n                    responseText = responseText.slice(0, endTagPos);\n            }\n            // set inner HTML of a placeholder element\n            var placeholder = document.createElement(\"div\");\n            placeholder.innerHTML = responseText;\n            // transfer resulting elements to document fragment\n            var result = document.createDocumentFragment();\n            while (placeholder.firstChild)\n                result.appendChild(placeholder.firstChild);\n            return result;\n        });\n    }\n    Http.getHtmlContentAsync = getHtmlContentAsync;\n    /** Perform a GET request with given parameters and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */\n    function getAsync(url, params, headers) {\n        return getTextAsync(url, params, _headersWithAccept(headers, undefined, \"\"))\n            .then(function (s) { return s.length ? JSON.parse(s) : undefined; });\n    }\n    Http.getAsync = getAsync;\n    /** Perform a POST request with given object (sent as JSON) and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */\n    function postAsync(url, data, headers) {\n        return _fetchJSON({ url: url, method: \"POST\", headers: headers }, data);\n    }\n    Http.postAsync = postAsync;\n    /** Perform a PUT request with given object (sent as JSON) and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */\n    function putAsync(url, data, headers) {\n        return _fetchJSON({ url: url, method: \"PUT\", headers: headers }, data);\n    }\n    Http.putAsync = putAsync;\n    /** Perform a DELETE request with given object (sent as JSON) and headers, if any; returns a promise that resolves to the parsed JSON response (or undefined if response was empty), or gets rejected if the request fails or response status is not in 2xx range */\n    function deleteAsync(url, data, headers) {\n        return _fetchJSON({ url: url, method: \"DELETE\", headers: headers }, data);\n    }\n    Http.deleteAsync = deleteAsync;\n})(Http_Http || (Http_Http = {}));\n\n// CONCATENATED MODULE: ./dist/dom/lib/App/Layout.js\n\n\n\n// override MessageBox appearance\nMessageBox_MessageBoxLayout.TitleRow.override({\n    height: \"2.4rem\",\n    style: {\n        background: observe(function () { return DOM_namespaceObject.Styles.color.titleBarBackground; }),\n        color: observe(function () { return DOM_namespaceObject.Styles.color.titleBarText; })\n    }\n});\nMessageBox_MessageBoxLayout.ButtonRow.override({\n    height: \"4rem\",\n    horzAlign: \"end\"\n});\nMessageBox_MessageBoxLayout.FirstMessageRow.override({\n    verticalSpacing: \"1.5rem\"\n});\n// override AppLayout colors\nApp_AppViewLayout.override({\n    background: observe(function () { return DOM_namespaceObject.Styles.color.background; }),\n    color: observe(function () { return DOM_namespaceObject.Styles.color.text; })\n});\n// override AppBar appearance\nApp_AppBarLayout.override({\n    height: \"3.5rem\",\n    shadowEffect: .3,\n});\nApp_AppBarLayout.addStyleOverride(Style_Style.withClass(\"App-Layout-AppBar\"));\nDOM_namespaceObject.applyStylesheet(new DOM_namespaceObject.Stylesheet(\"App-Layout-AppBar\", {\n    \".~~\": {\n        backgroundColor: observe(function () { return DOM_namespaceObject.Styles.color.primary; }),\n        color: observe(function () { return DOM_namespaceObject.Styles.color.primaryText; })\n    },\n    \".~~ .UI-Button a\": {\n        color: observe(function () { return DOM_namespaceObject.Styles.color.primaryText; })\n    }\n}), true);\n// override HubView sidebar width\nApp_HubViewLayout.override({\n    leftGutterWidth: \"19rem\"\n});\n\n// CONCATENATED MODULE: ./dist/dom/lib/App/index.js\nvar dom_lib_App_namespaceObject = {};\n__webpack_require__.d(dom_lib_App_namespaceObject, \"DOMApplication\", function() { return DOMApplication_DOMApplication; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"Http\", function() { return Http_Http; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"Application\", function() { return Application_Application; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"startActivityAsync\", function() { return startActivityAsync; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"findActivity\", function() { return findActivity; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"Activation\", function() { return Activation_Activation; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"mapRoute\", function() { return mapRoute; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"mapActivation\", function() { return mapActivation; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"Activity\", function() { return Activity_Activity; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"SingletonActivity\", function() { return Activity_SingletonActivity; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"SupportActivity\", function() { return SupportActivity; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"RootActivity\", function() { return RootActivity; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"mapParentActivity\", function() { return mapParentActivity; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"ActivityStack\", function() { return ActivityStack_ActivityStack; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"ActivityTransition\", function() { return ActivityTransition; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"FRAG_ID_PROP\", function() { return FRAG_ID_PROP; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"FRAG_HASH_PREFIX\", function() { return FRAG_HASH_PREFIX; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"isLayoutFragment\", function() { return isLayoutFragment; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"layoutFragment\", function() { return layoutFragment; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"mapViewActivity\", function() { return mapViewActivity; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"MessageBoxLayout\", function() { return MessageBox_MessageBoxLayout; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"showMessageBox\", function() { return showMessageBox; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"Service\", function() { return Service; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"mapService\", function() { return mapService; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"addServiceAlias\", function() { return addServiceAlias; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"injectService\", function() { return injectService; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"CultureService\", function() { return CultureService_CultureService; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"CultureChanged\", function() { return CultureChanged; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"BaseLayout\", function() { return Base_BaseLayout; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"BaseDialogLayout\", function() { return Base_BaseDialogLayout; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"VerticalLayout\", function() { return Single_VerticalLayout; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"ScrollableLayout\", function() { return ScrollableLayout; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"AppBarLayout\", function() { return App_AppBarLayout; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"AppViewLayout\", function() { return App_AppViewLayout; });\n__webpack_require__.d(dom_lib_App_namespaceObject, \"HubViewLayout\", function() { return App_HubViewLayout; });\n\n// platform specifics:\n\n\n\n\n// CONCATENATED MODULE: ./dist/dom/lib/App.js\nvar dist_dom_lib_App_namespaceObject = {};\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"default\", function() { return lib_App_defaultExport; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"DOMApplication\", function() { return DOMApplication_DOMApplication; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"Http\", function() { return Http_Http; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"Application\", function() { return Application_Application; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"startActivityAsync\", function() { return startActivityAsync; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"findActivity\", function() { return findActivity; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"Activation\", function() { return Activation_Activation; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"mapRoute\", function() { return mapRoute; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"mapActivation\", function() { return mapActivation; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"Activity\", function() { return Activity_Activity; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"SingletonActivity\", function() { return Activity_SingletonActivity; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"SupportActivity\", function() { return SupportActivity; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"RootActivity\", function() { return RootActivity; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"mapParentActivity\", function() { return mapParentActivity; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"ActivityStack\", function() { return ActivityStack_ActivityStack; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"ActivityTransition\", function() { return ActivityTransition; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"FRAG_ID_PROP\", function() { return FRAG_ID_PROP; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"FRAG_HASH_PREFIX\", function() { return FRAG_HASH_PREFIX; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"isLayoutFragment\", function() { return isLayoutFragment; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"layoutFragment\", function() { return layoutFragment; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"mapViewActivity\", function() { return mapViewActivity; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"MessageBoxLayout\", function() { return MessageBox_MessageBoxLayout; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"showMessageBox\", function() { return showMessageBox; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"Service\", function() { return Service; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"mapService\", function() { return mapService; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"addServiceAlias\", function() { return addServiceAlias; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"injectService\", function() { return injectService; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"CultureService\", function() { return CultureService_CultureService; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"CultureChanged\", function() { return CultureChanged; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"BaseLayout\", function() { return Base_BaseLayout; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"BaseDialogLayout\", function() { return Base_BaseDialogLayout; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"VerticalLayout\", function() { return Single_VerticalLayout; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"ScrollableLayout\", function() { return ScrollableLayout; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"AppBarLayout\", function() { return App_AppBarLayout; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"AppViewLayout\", function() { return App_AppViewLayout; });\n__webpack_require__.d(dist_dom_lib_App_namespaceObject, \"HubViewLayout\", function() { return App_HubViewLayout; });\n\n\n/* harmony default export */ var lib_App_defaultExport = (dom_lib_App_namespaceObject);\n\n// CONCATENATED MODULE: ./dist/core/lib/index.js\n\n\n\n\n/* harmony default export */ var lib_defaultExport = ({ Async: Async_defaultExport, UI: lib_UI_namespaceObject, App: core_lib_App_namespaceObject });\nconst version = \"0.9.11\"\n\n// CONCATENATED MODULE: ./dist/dom/node_modules/@typescene/core/index.js\nvar core_namespaceObject = {};\n__webpack_require__.d(core_namespaceObject, \"Async\", function() { return Async_defaultExport; });\n__webpack_require__.d(core_namespaceObject, \"UI\", function() { return lib_UI_namespaceObject; });\n__webpack_require__.d(core_namespaceObject, \"App\", function() { return core_lib_App_namespaceObject; });\n__webpack_require__.d(core_namespaceObject, \"version\", function() { return version; });\n\n// CONCATENATED MODULE: ./dist/dom/lib/index.js\n\n\n\n\n/* harmony default export */ var dom_lib_defaultExport = ({ Async: dom_lib_Async_namespaceObject, UI: dist_dom_lib_UI_namespaceObject, App: dist_dom_lib_App_namespaceObject });\n\n// export all modules as global variables\nvar lib_w = window;\nlib_w[\"typescene\"] = { Async: dom_lib_Async_namespaceObject, UI: dist_dom_lib_UI_namespaceObject, App: dist_dom_lib_App_namespaceObject, core: core_namespaceObject };\n// export Promise polyfill if needed\nif (!lib_w[\"Promise\"])\n    lib_w[\"Promise\"] = Promise_Promise;\n\n// CONCATENATED MODULE: ./src/docs-viewer/DocumentService.ts\nvar DocumentService___extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar DocumentService___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n;\r\nvar DocumentService_DocumentService = (function (_super) {\r\n    DocumentService___extends(DocumentService, _super);\r\n    function DocumentService() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /** True if the documentation data was loaded */\r\n        _this.isLoaded = false;\r\n        /** Signal that is emitted when the document data has been loaded successfully */\r\n        _this.Loaded = dom_lib_Async_namespaceObject.Signal.create();\r\n        /** All documentation items indexed by ID and slug */\r\n        _this._itemsById = {};\r\n        return _this;\r\n    }\r\n    DocumentService_1 = DocumentService;\r\n    /** Load the documentation JSON data (or make sure it has been loaded already); returns a promise that resolves to true when the data is loaded successfully */\r\n    DocumentService.prototype.loadAsync = function () {\r\n        var _this = this;\r\n        if (this.isLoaded)\r\n            return dom_lib_Async_namespaceObject.Promise.resolve(true);\r\n        if (DocumentService_1._loadingP)\r\n            return DocumentService_1._loadingP;\r\n        return DocumentService_1._loadingP = dist_dom_lib_App_namespaceObject.Http.getAsync(\"/\" + 0.9 + \"/documentation.json\")\r\n            .then(function (json) {\r\n            _this.fromJSON(json);\r\n            return true;\r\n        });\r\n    };\r\n    /** Initialize with given JSON data */\r\n    DocumentService.prototype.fromJSON = function (jsonData) {\r\n        var _this = this;\r\n        this._data = jsonData;\r\n        this.isLoaded = true;\r\n        // go through all items and add them to the instance\r\n        var itemsToIndex = this._data.items;\r\n        var itemsWithTOC = [];\r\n        while (itemsToIndex.length) {\r\n            var item = itemsToIndex.pop();\r\n            this._itemsById[item.id] = item;\r\n            // populate icon name (TODO: separate this out)\r\n            if (item.isClass || item.isNamespace)\r\n                item.icon = \"fa-cubes\";\r\n            else if (item.isInterface)\r\n                item.icon = \"fa-cubes opacity=.7\";\r\n            else if (item.isCtor)\r\n                item.icon = \"fa-magic\";\r\n            else if (item.isSignal)\r\n                item.icon = \"fa-bolt\";\r\n            else if (item.isDecorator)\r\n                item.icon = \"fa-tag\";\r\n            else if (item.isMethod || item.isFunction)\r\n                item.icon = \"fa-dot-circle-o\";\r\n            else if (item.isType || item.isEnum)\r\n                item.icon = \"fa-square-o\";\r\n            else if (!item.code)\r\n                item.icon = \"fa-file-text-o\";\r\n            else\r\n                item.icon = \"fa-cube\";\r\n            // clean up slug's leading/trailing slashes\r\n            if (item.textSlug) {\r\n                var slug = item.textSlug;\r\n                slug = slug.replace(/^\\/|\\/$/g, \"\");\r\n                this._itemsById[slug] = item;\r\n            }\r\n            // recurse for child items\r\n            if (item.items) {\r\n                item.items.forEach(function (z) {\r\n                    z.parentItem = item;\r\n                    itemsToIndex.push(z);\r\n                });\r\n            }\r\n            else if (item.toc) {\r\n                // keep track of TOC parent items\r\n                itemsWithTOC.push(item);\r\n            }\r\n        }\r\n        // reference TOC parent items from child items too\r\n        for (var _i = 0, itemsWithTOC_1 = itemsWithTOC; _i < itemsWithTOC_1.length; _i++) {\r\n            var item = itemsWithTOC_1[_i];\r\n            item.toc.forEach(function (subId) {\r\n                var subItem = _this._itemsById[subId];\r\n                if (subItem && !subItem.parentItem)\r\n                    subItem.parentItem = item;\r\n            });\r\n        }\r\n    };\r\n    /** Returns the version number loaded from the doc JSON */\r\n    DocumentService.prototype.getVersion = function () {\r\n        return this._data && this._data.version;\r\n    };\r\n    /** Returns the documentation title */\r\n    DocumentService.prototype.getTitle = function () {\r\n        return this._data && (this._data.title + \" (\" + this._data.version + \")\");\r\n    };\r\n    /** Returns an (absolute) item ID based on the given (potentially relative) ID in the context of given item */\r\n    DocumentService.prototype.find = function (id, context) {\r\n        var current = context;\r\n        while (current) {\r\n            if (this._itemsById[current.id + \".\" + id]) {\r\n                // found a matching item\r\n                return current.id + \".\" + id;\r\n            }\r\n            current = current.parentItem;\r\n        }\r\n        if (this._itemsById[id])\r\n            return id;\r\n        return undefined;\r\n    };\r\n    /** Returns true if item with given ID exists */\r\n    DocumentService.prototype.exists = function (id) {\r\n        return !!this._itemsById[id] && this._itemsById[id].id === id;\r\n    };\r\n    /** Find item data by unique ID or slug */\r\n    DocumentService.prototype.getItemById = function (id) {\r\n        var result = this._itemsById[id];\r\n        if (result)\r\n            return result;\r\n        throw new Error(\"Item does not exist: \" + id);\r\n    };\r\n    /** Returns display text for cross-references and TOC */\r\n    DocumentService.prototype.getDisplayNameFor = function (id) {\r\n        var item = this.getItemById(id);\r\n        if (item.textTopic)\r\n            return item.textTopic;\r\n        // if no text topic defined, use code identifier\r\n        var result = item.name;\r\n        if (item.isMethod || item.isFunction || item.isCtor) {\r\n            result += item.hasParams ? \"(...)\" : \"()\";\r\n        }\r\n        if (item.isDecorator)\r\n            result = \"@\" + result;\r\n        else if (item.isStatic)\r\n            result = \".\" + result;\r\n        return result;\r\n    };\r\n    /** Returns a list of items that make up the sub TOC below the item with given ID, or the root TOC if no ID is given */\r\n    DocumentService.prototype.getTOCItems = function (id) {\r\n        var _this = this;\r\n        var result = [];\r\n        var item = id ? this.getItemById(id) : undefined;\r\n        var toc = item ? item.toc : (this._data && this._data.toc);\r\n        if (toc)\r\n            toc.forEach(function (s) { return result.push(_this.getItemById(s)); });\r\n        item && item.items && result.push.apply(result, item.items);\r\n        return result;\r\n    };\r\n    DocumentService___decorate([\r\n        dom_lib_Async_namespaceObject.observable\r\n    ], DocumentService.prototype, \"isLoaded\", void 0);\r\n    DocumentService = DocumentService_1 = DocumentService___decorate([\r\n        dist_dom_lib_App_namespaceObject.mapService(\"DocumentService\")\r\n    ], DocumentService);\r\n    return DocumentService;\r\n    var DocumentService_1;\r\n}(dist_dom_lib_App_namespaceObject.Service));\r\n\r\n\n// CONCATENATED MODULE: ./src/docs-viewer/MainActivity.ts\nvar MainActivity___extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar MainActivity___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n/** Activity that should be on the stack before all others */\r\nvar MainActivity_MainActivity = (function (_super) {\r\n    MainActivity___extends(MainActivity, _super);\r\n    function MainActivity(activation) {\r\n        var _this = _super.call(this, activation) || this;\r\n        /** True if documentation is loading (observable) */\r\n        _this.loading = true;\r\n        /** True if an error occurred while loading documentation (observable) */\r\n        _this.error = false;\r\n        _this.title = \"Typescene\";\r\n        _this.Starting.connect(function () {\r\n            _this.documentService.loadAsync().then(function () {\r\n                _this.loading = false;\r\n                _this.error = false;\r\n                _this.title = _this.documentService.getTitle();\r\n            }, function (err) {\r\n                _this.error = true;\r\n            });\r\n        });\r\n        return _this;\r\n    }\r\n    MainActivity___decorate([\r\n        dist_dom_lib_App_namespaceObject.injectService\r\n    ], MainActivity.prototype, \"documentService\", void 0);\r\n    MainActivity___decorate([\r\n        dom_lib_Async_namespaceObject.observable\r\n    ], MainActivity.prototype, \"loading\", void 0);\r\n    MainActivity___decorate([\r\n        dom_lib_Async_namespaceObject.observable\r\n    ], MainActivity.prototype, \"error\", void 0);\r\n    return MainActivity;\r\n}(dist_dom_lib_App_namespaceObject.SupportActivity));\r\n\r\n/** Activity that is mapped to root URLs and forwards to first article */\r\nvar MainActivity_HomeActivity = (function (_super) {\r\n    MainActivity___extends(HomeActivity, _super);\r\n    function HomeActivity() {\r\n        var _this = _super.call(this) || this;\r\n        _this.Starting.connect(function () {\r\n            _this.documentService.loadAsync().then(function () {\r\n                var first = _this.documentService.getTOCItems()[0];\r\n                if (first)\r\n                    dist_dom_lib_App_namespaceObject.Application.current.startActivityAsync(\"/doc/\" + (first.textSlug || first.id), true);\r\n            });\r\n        });\r\n        return _this;\r\n    }\r\n    MainActivity___decorate([\r\n        dist_dom_lib_App_namespaceObject.injectService\r\n    ], HomeActivity.prototype, \"documentService\", void 0);\r\n    HomeActivity = MainActivity___decorate([\r\n        dist_dom_lib_App_namespaceObject.mapRoute(\"/\"),\r\n        dist_dom_lib_App_namespaceObject.mapRoute(\"/doc/\"),\r\n        dist_dom_lib_App_namespaceObject.mapParentActivity(MainActivity_MainActivity)\r\n    ], HomeActivity);\r\n    return HomeActivity;\r\n}(dist_dom_lib_App_namespaceObject.Activity));\r\n\r\n\n// CONCATENATED MODULE: ./src/docs-viewer/MainView.ts\nvar MainView___extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar MainView___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\nvar MainView_MainView = (function (_super) {\r\n    MainView___extends(MainView, _super);\r\n    function MainView(activity) {\r\n        var _this = _super.call(this) || this;\r\n        _this.activity = activity;\r\n        return _this;\r\n    }\r\n    /** Show the TOC drawer (on small screens) */\r\n    MainView.prototype.showDrawer = function () {\r\n        var _this = this;\r\n        this.drawer.openAsync();\r\n        dist_dom_lib_App_namespaceObject.Application.current.activities.Transition.connectOnce(function () {\r\n            _this.drawer.close();\r\n        });\r\n    };\r\n    MainView.TOCView = dist_dom_lib_App_namespaceObject.ScrollableLayout.with({ id: \"toc\", height: \"100%\" });\r\n    MainView.DocView = dist_dom_lib_UI_namespaceObject.Container.with({ id: \"doc\" });\r\n    MainView___decorate([\r\n        dist_dom_lib_App_namespaceObject.layoutFragment\r\n    ], MainView, \"TOCView\", void 0);\r\n    MainView___decorate([\r\n        dist_dom_lib_App_namespaceObject.layoutFragment\r\n    ], MainView, \"DocView\", void 0);\r\n    MainView = MainView___decorate([\r\n        dist_dom_lib_App_namespaceObject.mapViewActivity(MainActivity_MainActivity)\r\n    ], MainView);\r\n    return MainView;\r\n}(dist_dom_lib_App_namespaceObject.HubViewLayout.with({ horzAlign: \"center\", maxContentWidth: \"calc(40vw + 20rem)\" }, dist_dom_lib_App_namespaceObject.HubViewLayout.Header.with({ style: { background: \"linear-gradient(284deg, #2bf 0%, #509 100%) || #4ae\" } }, dist_dom_lib_UI_namespaceObject.TextButton.with({\r\n    hidden: dist_dom_lib_UI_namespaceObject.bind(\"!sidebarCollapsed\"),\r\n    label: \"\",\r\n    icon: \"fa-bars\",\r\n    Click: \"showDrawer\"\r\n}), dist_dom_lib_UI_namespaceObject.Image.with({\r\n    imageUrl: \"/logo.png\",\r\n    width: \"1.5rem\",\r\n    style_img: { verticalAlign: \"middle\" }\r\n}), (MainView__a = [\"{h1|1.5rem|600}Documentation\"], MainView__a.raw = [\"{h1|1.5rem|600}Documentation\"], dist_dom_lib_UI_namespaceObject.tl(MainView__a)), dist_dom_lib_UI_namespaceObject.Spacer, dist_dom_lib_UI_namespaceObject.LinkButton.with({\r\n    hidden: dist_dom_lib_UI_namespaceObject.bind(\"sidebarCollapsed\"),\r\n    label: \"Typescene home\",\r\n    target: \"http://typescene.org\"\r\n}), dist_dom_lib_UI_namespaceObject.LinkButton.with({\r\n    hidden: dist_dom_lib_UI_namespaceObject.bind(\"sidebarCollapsed\"),\r\n    label: \"Github\",\r\n    target: \"https://www.github.com/typescene/typescene\"\r\n})), dist_dom_lib_App_namespaceObject.HubViewLayout.Sidebar.with({\r\n    style: {\r\n        borderRight: \"1px solid #eee\",\r\n        background: \"#f8f8f8\"\r\n    },\r\n    scrollable: false\r\n}, dist_dom_lib_App_namespaceObject.HubViewLayout.Sidebar.Header.with({\r\n    hidden: dist_dom_lib_UI_namespaceObject.bind(\"!sidebarCollapsed\"),\r\n    height: \"7rem\",\r\n    style: { background: \"#333\", color: \"#fff\" },\r\n    vertAlign: \"bottom\"\r\n}, (MainView__b = [\"{h4}Table of Contents\"], MainView__b.raw = [\"{h4}Table of Contents\"], dist_dom_lib_UI_namespaceObject.tl(MainView__b))), dist_dom_lib_UI_namespaceObject.bind(\"fragments.TOCView\")), dist_dom_lib_UI_namespaceObject.bind(\"fragments.DocView\"))));\r\n\r\nvar MainView__a, MainView__b;\r\n\n// CONCATENATED MODULE: ./src/docs-viewer/DocActivity.ts\nvar DocActivity___extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar DocActivity___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\nvar DocActivity_DocActivation = (function (_super) {\r\n    DocActivity___extends(DocActivation, _super);\r\n    function DocActivation() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    DocActivation = DocActivity___decorate([\r\n        dist_dom_lib_App_namespaceObject.mapRoute(\"/doc/*glob\")\r\n    ], DocActivation);\r\n    return DocActivation;\r\n}(dist_dom_lib_App_namespaceObject.Activation));\r\nvar DocActivity_DocActivity = (function (_super) {\r\n    DocActivity___extends(DocActivity, _super);\r\n    function DocActivity() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this._scrollTop = 0;\r\n        return _this;\r\n    }\r\n    DocActivity.prototype.onCreateAsync = function () {\r\n        var _this = this;\r\n        // find main activity and get data\r\n        var glob = this.activation[\"glob\"];\r\n        this.Started.connect(function () {\r\n            _this.documentService.loadAsync().then(function () {\r\n                _this.populate();\r\n            });\r\n        });\r\n        // TODO: do this in a more structural way...\r\n        // save & restore scroll positions when moving back/forward\r\n        var withScrollElt = function (f) { return function () {\r\n            var page = dist_dom_lib_UI_namespaceObject.Page.getCurrentPage();\r\n            if (page && (page.content[0] instanceof dist_dom_lib_UI_namespaceObject.LayoutContainer)) {\r\n                page.content[0].getRenderedOutputAsync().then(function (out) {\r\n                    var elt = out && out.element && out.element.firstChild;\r\n                    while (elt) {\r\n                        if (String(elt.className).split(/\\s+/)\r\n                            .some(function (s) { return s === \"UI-LayoutContainer_scroll\"; })) {\r\n                            return f(elt);\r\n                        }\r\n                        elt = elt.nextSibling;\r\n                    }\r\n                });\r\n            }\r\n        }; };\r\n        this.Suspending.connect(withScrollElt(function (elt) {\r\n            _this._scrollTop = elt.scrollTop;\r\n        }));\r\n        this.Resumed.connect(withScrollElt(function (elt) {\r\n            elt.scrollTop = 0;\r\n            var reset = function () {\r\n                if (dist_dom_lib_App_namespaceObject.Application.current.getTopActivity() === _this)\r\n                    elt.scrollTop = _this._scrollTop;\r\n            };\r\n            dom_lib_Async_namespaceObject.sleep(10).then(reset);\r\n            dom_lib_Async_namespaceObject.sleep(100).then(reset);\r\n        }));\r\n    };\r\n    DocActivity.prototype.populate = function () {\r\n        try {\r\n            var item = this.documentService.getItemById(this.activation[\"glob\"]);\r\n            this.item = item;\r\n            this.title = this.item.name;\r\n        }\r\n        catch (err) {\r\n            dist_dom_lib_App_namespaceObject.startActivityAsync(\"/\");\r\n            return;\r\n        }\r\n    };\r\n    DocActivity___decorate([\r\n        dist_dom_lib_App_namespaceObject.injectService\r\n    ], DocActivity.prototype, \"documentService\", void 0);\r\n    DocActivity___decorate([\r\n        dom_lib_Async_namespaceObject.observable_shallow\r\n    ], DocActivity.prototype, \"item\", void 0);\r\n    DocActivity = DocActivity___decorate([\r\n        dist_dom_lib_App_namespaceObject.mapActivation(DocActivity_DocActivation),\r\n        dist_dom_lib_App_namespaceObject.mapParentActivity(MainActivity_MainActivity)\r\n    ], DocActivity);\r\n    return DocActivity;\r\n}(dist_dom_lib_App_namespaceObject.Activity));\r\n\r\n\n// CONCATENATED MODULE: ./src/docs-viewer/MonacoEditor.ts\nvar MonacoEditor___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n/// <reference path=\"../../node_modules/monaco-editor/monaco.d.ts\" />\r\n\r\nvar VS_PATH = \"/\" + 0.9 + \"/monaco-editor/min/vs\";\r\n/** Wrapper around the MS Monaco editor, configured for TypeScript code (es5) */\r\nvar MonacoEditor_MonacoEditor = (function () {\r\n    /** Create an instance of the editor, inside given HTML element */\r\n    function MonacoEditor(elt, code) {\r\n        if (code === void 0) { code = \"\"; }\r\n        var _this = this;\r\n        /** Cursor position as a string (line:column) */\r\n        this.position = \"1:1\";\r\n        this.element = elt;\r\n        var editor = this._editor = monaco.editor.create(elt, {\r\n            theme: \"vs-dark\",\r\n            value: code,\r\n            language: \"typescript\",\r\n            folding: true,\r\n            scrollBeyondLastLine: false,\r\n            formatOnType: true,\r\n            formatOnPaste: true,\r\n            wordBasedSuggestions: false,\r\n            minimap: { enabled: false }\r\n        });\r\n        monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\r\n            target: monaco.languages.typescript.ScriptTarget.ES2015,\r\n            module: monaco.languages.typescript.ModuleKind.CommonJS,\r\n            allowNonTsExtensions: true,\r\n            experimentalDecorators: true,\r\n            strictNullChecks: true\r\n        });\r\n        editor.onDidChangeCursorPosition(function () {\r\n            var pos = editor.getPosition();\r\n            _this.position = pos.lineNumber + \":\" + pos.column;\r\n        });\r\n    }\r\n    /** Load the editor script, returns promise that resolves when everything is loaded */\r\n    MonacoEditor.load = function () {\r\n        // load the Monaco editor AMD loader script\r\n        return this._isLoaded || (this._isLoaded = new dom_lib_Async_namespaceObject.Promise(function (resolve) {\r\n            var script = document.createElement(\"script\");\r\n            script.src = VS_PATH + \"/loader.js\";\r\n            script.async = false;\r\n            document.body.appendChild(script);\r\n            // poll to see if the script has run yet\r\n            var intv = setInterval(function () {\r\n                if (typeof AMDLoader !== \"undefined\") {\r\n                    clearInterval(intv);\r\n                    var r = window[\"require\"];\r\n                    r.config({ paths: { vs: VS_PATH } });\r\n                    r([\"vs/editor/editor.main\"], function () { return resolve(true); });\r\n                }\r\n            }, 100);\r\n        }));\r\n    };\r\n    /** Load a .d.ts file into the typescript context */\r\n    MonacoEditor.loadDeclarations = function (fileName, source) {\r\n        monaco.languages.typescript.typescriptDefaults.addExtraLib(source, fileName);\r\n    };\r\n    /** Returns the current text contents of the editor */\r\n    MonacoEditor.prototype.getCode = function () {\r\n        return this._editor.getValue();\r\n    };\r\n    /** Overwrites the current text contents of the editor, and focuses element */\r\n    MonacoEditor.prototype.setCode = function (source) {\r\n        this._editor.setValue(source);\r\n        this._editor.setPosition({ lineNumber: 1, column: 1 });\r\n        this.position = \"1:1\";\r\n        this._editor.focus();\r\n    };\r\n    /** Update layout and re-focus the editor */\r\n    MonacoEditor.prototype.focus = function () {\r\n        this._editor.layout();\r\n        this._editor.focus();\r\n    };\r\n    /** Dispose the editor */\r\n    MonacoEditor.prototype.destroy = function () {\r\n        this._editor.dispose();\r\n    };\r\n    MonacoEditor___decorate([\r\n        dom_lib_Async_namespaceObject.observable\r\n    ], MonacoEditor.prototype, \"position\", void 0);\r\n    return MonacoEditor;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/docs-viewer/CodeOutput.ts\nvar CodeOutput___extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar CodeOutput___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n\r\n/** Global TypeScript compiler instance */\r\nvar ts;\r\n/** Modules by ID */\r\nvar typescene = window.typescene;\r\nvar modules = {\r\n    \"@typescene/core\": typescene.core,\r\n    \"@typescene/core/Async\": typescene.core.Async,\r\n    \"@typescene/core/UI\": typescene.core.UI,\r\n    \"@typescene/core/App\": typescene.core.App,\r\n    \"@typescene/dom\": typescene,\r\n    \"@typescene/dom/Async\": typescene.Async,\r\n    \"@typescene/dom/UI\": typescene.UI,\r\n    \"@typescene/dom/App\": typescene.App\r\n};\r\n/** Code modified by user, by example ID */\r\nvar modifiedCode = {};\r\n/** Last opened example code ID */\r\nvar lastEditedExampleID;\r\n/** Last open editor (should be destroyed when opening a new editor */\r\nvar lastEditor;\r\n// start with a fresh hidden editor to load typescript\r\nvar _loaded = dist_dom_lib_UI_namespaceObject.Screen.ready.then(function () {\r\n    return MonacoEditor_MonacoEditor.load().then(function () {\r\n        new MonacoEditor_MonacoEditor(document.createElement(\"div\"));\r\n        var svc = DocumentService_DocumentService.getInstance();\r\n        return svc.loadAsync().then(function () {\r\n            return dist_dom_lib_App_namespaceObject.Http.getTextAsync(\"/\" + 0.9 + \"/typescene.d.ts.txt\");\r\n        }).then(function (defs) {\r\n            MonacoEditor_MonacoEditor.loadDeclarations(\"typescene.d.ts\", defs);\r\n            MonacoEditor_MonacoEditor.loadDeclarations(\"editor.d.ts\", \"declare var displayResult: (value: any) => void\");\r\n            var doPollTypescript = function () {\r\n                return dom_lib_Async_namespaceObject.sleep(100).then(function () {\r\n                    ts = window[\"ts\"];\r\n                    if (ts)\r\n                        return true;\r\n                    else\r\n                        return doPollTypescript();\r\n                });\r\n            };\r\n            return doPollTypescript();\r\n        });\r\n    });\r\n});\r\nvar CodeOutput_CodeOutputContainer = (function (_super) {\r\n    CodeOutput___extends(CodeOutputContainer, _super);\r\n    function CodeOutputContainer(cID, code, outputIdentifier, hasEditButton) {\r\n        if (hasEditButton === void 0) { hasEditButton = true; }\r\n        var _this = _super.call(this) || this;\r\n        _this.cID = cID;\r\n        _this.code = code;\r\n        _this.hasEditButton = hasEditButton;\r\n        /** Number of times updated */\r\n        _this.count = 0;\r\n        _this.appendChild(new (dist_dom_lib_UI_namespaceObject.CloseRow.with(dist_dom_lib_UI_namespaceObject.tl(\"{i|#555}Starting TypeScript environment...\"))));\r\n        // wrap code in a full program\r\n        _this.code =\r\n            (/^import/.test(code) ? \"\" :\r\n                \"import { Async, UI, App } from \\\"@typescene/dom\\\";\\n\\n\") +\r\n                code;\r\n        if (outputIdentifier)\r\n            _this.code += \"\\ndisplayResult(\" + outputIdentifier + \");\";\r\n        else if (!/console\\.log/.test(code))\r\n            _this.code += \"\\nconsole.log(\\\"OK\\\")\";\r\n        // wait for Typescript environment to be loaded\r\n        _loaded.then(function () {\r\n            _this.style.addClass(\"doc-text-example-output\")\r\n                .addShadowEffect(.2);\r\n            _this.updateOutput();\r\n        });\r\n        return _this;\r\n    }\r\n    /** Revert changes and update output */\r\n    CodeOutputContainer.prototype.revertChanges = function () {\r\n        delete modifiedCode[this.cID];\r\n        this.updateOutput();\r\n    };\r\n    /** Show editor for current example code */\r\n    CodeOutputContainer.prototype.showEditor = function () {\r\n        new CodeOutput_CodeEditor(this).openAsync();\r\n    };\r\n    /** Update the output within this container, for current example code */\r\n    CodeOutputContainer.prototype.updateOutput = function () {\r\n        var _this = this;\r\n        // make the factory that creates the byline and buttons on top\r\n        var isModified = !!(modifiedCode[this.cID]);\r\n        var dd = new Date();\r\n        var ddMins = dd.getMinutes();\r\n        var ddSecs = dd.getSeconds();\r\n        var ddStr = \"Updated \" + dd.getHours() + \":\" +\r\n            (ddMins < 10 ? \"0\" + ddMins : ddMins) + \":\" +\r\n            (ddSecs < 10 ? \"0\" + ddSecs : ddSecs);\r\n        var byline = dist_dom_lib_UI_namespaceObject.Row.with({\r\n            content: [\r\n                dist_dom_lib_UI_namespaceObject.tl((this.count++ ? ddStr : \"Output\")\r\n                    + (isModified ? \" (modified)\" : \"\")),\r\n                dist_dom_lib_UI_namespaceObject.Spacer,\r\n                dist_dom_lib_UI_namespaceObject.TextButton.with({\r\n                    label: \"Edit this example\",\r\n                    Clicked: \"showEditor\",\r\n                    hidden: dom_lib_Async_namespaceObject.observe(function () {\r\n                        return !_this.hasEditButton || dist_dom_lib_UI_namespaceObject.Screen.dimensions.isSmall;\r\n                    })\r\n                }),\r\n                isModified ?\r\n                    dist_dom_lib_UI_namespaceObject.TextButton.withLabel(\"Revert changes\", \"revertChanges\") :\r\n                    undefined,\r\n            ],\r\n            height: \"1.75rem\",\r\n            style: dist_dom_lib_UI_namespaceObject.Style.withClass(\"doc-text-example-byline\"),\r\n            animations: { appear: dist_dom_lib_UI_namespaceObject.DOM.DOMAnimation.basic.in.slideDown }\r\n        });\r\n        // transpile the program\r\n        try {\r\n            var code = modifiedCode[this.cID] || this.code;\r\n            var t = ts.transpileModule(code, {\r\n                reportDiagnostics: true,\r\n                compilerOptions: {\r\n                    target: \"es5\",\r\n                    module: \"commonjs\",\r\n                    experimentalDecorators: true,\r\n                    strictNullChecks: true,\r\n                    lib: [\"es2015\", \"dom\"]\r\n                }\r\n            });\r\n            var mockConsole = {\r\n                log: function () {\r\n                    var args = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        args[_i] = arguments[_i];\r\n                    }\r\n                    dom_lib_Async_namespaceObject.unobserved(function () {\r\n                        // try to convert all output to text\r\n                        var output = args.map(function (v) {\r\n                            try {\r\n                                if (typeof v === \"string\")\r\n                                    return v;\r\n                                if (v === undefined)\r\n                                    return \"undefined\";\r\n                                else\r\n                                    return JSON.stringify(v);\r\n                            }\r\n                            catch (all) {\r\n                                try {\r\n                                    return String(v);\r\n                                }\r\n                                catch (err) {\r\n                                    return String(err);\r\n                                }\r\n                            }\r\n                        });\r\n                        if (!_this.content.length) {\r\n                            _this.initializeWith({ content: [byline] });\r\n                            _this.getComponentsByType(dist_dom_lib_UI_namespaceObject.Row)[0].content\r\n                                .unshift(new dist_dom_lib_UI_namespaceObject.Icon(\"fa-terminal color=green fontSize=1rem\"));\r\n                        }\r\n                        // add all logged text in a row with a single label\r\n                        var label = new dist_dom_lib_UI_namespaceObject.Label(output.join(\" \"));\r\n                        label.wrapText = true;\r\n                        label.shrinkwrap = false;\r\n                        _this.content.push(new dist_dom_lib_UI_namespaceObject.Row([label]));\r\n                    });\r\n                }\r\n            };\r\n            try {\r\n                Object.setPrototypeOf(mockConsole, console);\r\n            }\r\n            catch (all) { }\r\n            // run the (modified) program with function parameters\r\n            this.content.length = 0;\r\n            (new Function(\"exports\", \"require\", \"displayResult\", \"console\", t.outputText))\r\n                .call(void 0, \r\n            // exports (ignored)\r\n            {}, \r\n            // require function:\r\n            function (name) {\r\n                if (modules[name])\r\n                    return modules[name];\r\n                throw new Error(\"Cannot find module: \" + name);\r\n            }, \r\n            // displayResult function:\r\n            function (value) {\r\n                _this.initializeWith({ content: [byline, value] });\r\n                if (isModified) {\r\n                    _this.getComponentsByType(dist_dom_lib_UI_namespaceObject.Row)[0]\r\n                        .content.unshift(new dist_dom_lib_UI_namespaceObject.Icon(\"fa-check color=green\"));\r\n                }\r\n            }, \r\n            // console with own `log` method\r\n            mockConsole);\r\n            dom_lib_Async_namespaceObject.sleep(1000).then(function () {\r\n                // force display of empty result after 1s\r\n                if (_this.content.length === 0)\r\n                    mockConsole.log();\r\n            });\r\n        }\r\n        catch (err) {\r\n            // display error instead\r\n            console.error(err);\r\n            var label = dist_dom_lib_UI_namespaceObject.tl(\"{i|#c30}\" + String(err));\r\n            this.initializeWith({ content: [byline, label] });\r\n        }\r\n    };\r\n    return CodeOutputContainer;\r\n}(dist_dom_lib_UI_namespaceObject.Container));\r\n\r\nvar CodeOutput_CodeEditor = (function (_super) {\r\n    CodeOutput___extends(CodeEditor, _super);\r\n    function CodeEditor(codeOutput) {\r\n        var _this = _super.call(this) || this;\r\n        _this.codeOutput = codeOutput;\r\n        _this.displayOptions.modalHorzAlign = \"left\";\r\n        var code = modifiedCode[codeOutput.cID] || codeOutput.code;\r\n        // create the editor, or use last editor\r\n        if (lastEditedExampleID === codeOutput.cID) {\r\n            // re-use\r\n            _this.editor = lastEditor;\r\n            if (!modifiedCode[_this.codeOutput.cID])\r\n                _this.editor.setCode(_this.codeOutput.code);\r\n        }\r\n        else {\r\n            // dispose of old editor\r\n            lastEditor && lastEditor.destroy();\r\n            // create new editor\r\n            var elt = document.createElement(\"div\");\r\n            elt.style.height = \"100%\";\r\n            _this.editor = new MonacoEditor_MonacoEditor(elt, code);\r\n            lastEditedExampleID = codeOutput.cID;\r\n            lastEditor = _this.editor;\r\n        }\r\n        // add the editor inside of a DOM block component\r\n        var domBlock = new dist_dom_lib_UI_namespaceObject.DOM.DOMBlock(_this.editor.element);\r\n        domBlock.height = \"100vh\";\r\n        domBlock.style.set(\"paddingTop\", \"5.5rem\");\r\n        _this.initialize();\r\n        _this.content.unshift(domBlock);\r\n        // ignore ESC presses within editor\r\n        domBlock.EscapeKeyPressed.connect(function () { });\r\n        // focus the editor when rendering finishes\r\n        _this.Rendered.connect(function (out) {\r\n            out.updated && out.updated.then(function () { return _this.editor.focus(); });\r\n        });\r\n        // save the code when user closes this dialog (e.g. clicking outside)\r\n        _this.Closed.connect(function () {\r\n            modifiedCode[_this.codeOutput.cID] = _this.editor.getCode();\r\n        });\r\n        return _this;\r\n    }\r\n    /** Close the dialog and update original output */\r\n    CodeEditor.prototype.closeAndRun = function () {\r\n        var _this = this;\r\n        this.close();\r\n        modifiedCode[this.codeOutput.cID] = this.editor.getCode();\r\n        dom_lib_Async_namespaceObject.sleep(10).then(function () {\r\n            _this.codeOutput.updateOutput();\r\n        });\r\n    };\r\n    CodeOutput___decorate([\r\n        dom_lib_Async_namespaceObject.observable\r\n    ], CodeEditor.prototype, \"editor\", void 0);\r\n    return CodeEditor;\r\n}(dist_dom_lib_UI_namespaceObject.DialogContainer.with({\r\n    height: \"100vh\",\r\n    width: \"55vw\",\r\n    scrollable: false,\r\n    style: {\r\n        overflow: \"visible\",\r\n        minWidth: \"45rem\",\r\n        background: \"#333\"\r\n    },\r\n    shadowEffect: 1,\r\n    animations: {\r\n        appear: dist_dom_lib_UI_namespaceObject.DOM.DOMAnimation.basic.in.slideRight\r\n    }\r\n}, \r\n// toolbar row\r\ndist_dom_lib_UI_namespaceObject.Row.with({\r\n    height: \"2rem\",\r\n    overlayPosition: dist_dom_lib_UI_namespaceObject.Row.OverlayPosition.Top,\r\n    style: {\r\n        marginTop: \"3.5rem\",\r\n        background: \"#333\", color: \"#ccc\"\r\n    }\r\n}, dist_dom_lib_UI_namespaceObject.TextButton.with({\r\n    label: \"Save and run\",\r\n    icon: \"fa-play\",\r\n    remGutter: 2,\r\n    style: { cursor: \"pointer\" },\r\n    style_button: { color: \"\" },\r\n    Clicked: \"closeAndRun\"\r\n}), dist_dom_lib_UI_namespaceObject.Spacer, dist_dom_lib_UI_namespaceObject.tl(dist_dom_lib_UI_namespaceObject.bind(\"editor.position\", function (s) { return (s || \"\"); }))), \r\n// top row with back button:\r\ndist_dom_lib_UI_namespaceObject.Row.with({\r\n    height: \"3.5rem\",\r\n    overlayPosition: dist_dom_lib_UI_namespaceObject.Row.OverlayPosition.Top,\r\n    style: { background: \"#555\", color: \"#fff\" },\r\n    shadowEffect: .5\r\n}, dist_dom_lib_UI_namespaceObject.RoundButton.withIcon(\"fa-arrow-left\", \"close\"), (CodeOutput__a = [\"{1rem}Live code editor\"], CodeOutput__a.raw = [\"{1rem}Live code editor\"], dist_dom_lib_UI_namespaceObject.tl(CodeOutput__a))), \r\n// \"Play\" button to close and run code\r\ndist_dom_lib_UI_namespaceObject.CenterRow.with({\r\n    width: \"3.5rem\",\r\n    height: \"3.5rem\",\r\n    style: {\r\n        cursor: \"pointer\",\r\n        position: \"absolute\",\r\n        top: \"40%\",\r\n        right: \"-1.75rem\",\r\n        background: \"#fd3\",\r\n        color: \"#333\",\r\n        borderRadius: \"1.75rem\",\r\n        zIndex: \"1\"\r\n    },\r\n    shadowEffect: 1,\r\n    Clicked: \"closeAndRun\"\r\n}, dist_dom_lib_UI_namespaceObject.Icon.with({\r\n    icon: \"fa-play fa-2x\",\r\n    tooltipText: \"Close & run\",\r\n    style: {\r\n        // optically center the triangle:\r\n        paddingLeft: \".2rem\"\r\n    }\r\n})))));\r\nvar CodeOutput__a;\r\n\n// CONCATENATED MODULE: ./src/docs-viewer/DocArticle.ts\nvar DocArticle___extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar DocArticle___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\nvar TAG_BG_CLASSTYPE = \"#333\";\r\nvar TAG_BG_INTFTYPE = \"#888\";\r\nvar TAG_BG_CTOR = \"#c3e\";\r\nvar TAG_BG_MEMBERTYPE = \"#38e\";\r\nvar TAG_BG_ASYNC = \"#ac6\";\r\nvar TAG_BG_DECORATOR = \"#555\";\r\nvar TAG_BG_OTHRTYPE = \"#aaa\";\r\nvar TAG_BG_STATIC = \"#eb6\";\r\nvar TAG_BG_ACCESS = \"#c63\";\r\n/** Helper function to replace code tags with links if applicable */\r\nfunction linkifyCode(root, svc, base) {\r\n    var aElts = root.querySelectorAll(\"a\");\r\n    var _loop_1 = function () {\r\n        var elt = aElts[i];\r\n        var href = elt.href;\r\n        if (href.indexOf(\"~/\") >= 0) {\r\n            // change href from ~/foo to /doc/foo\r\n            href = href.replace(/.*~\\//, \"/doc/\");\r\n            elt.href = href;\r\n            elt.onclick = function () {\r\n                dist_dom_lib_App_namespaceObject.startActivityAsync(href);\r\n                return false;\r\n            };\r\n        }\r\n    };\r\n    for (var i = 0; i < aElts.length; i++) {\r\n        _loop_1();\r\n    }\r\n    var codeElts = root.querySelectorAll(\"code\");\r\n    var _loop_2 = function () {\r\n        var elt = codeElts[i];\r\n        if (elt.parentNode.nodeName.toUpperCase() === \"A\")\r\n            return \"continue\";\r\n        var text = elt.innerText;\r\n        text = text.replace(/\\(\\.*\\)$/, \"\").replace(/\\#(\\w+)$/, \"/$1\");\r\n        if (base && (text[0] === \".\" || text[0] === \"/\")) {\r\n            // use relative ID\r\n            text = base.id + (svc.exists(base.id + text) ?\r\n                text : text.replace(/\\./g, \"/\"));\r\n        }\r\n        id = svc.find(text, base);\r\n        if (id) {\r\n            // wrap <code> element into <a> element\r\n            item = svc.getItemById(id);\r\n            a = document.createElement(\"a\");\r\n            var href_1 = \"/doc/\" + (item.textSlug || item.id);\r\n            a.href = href_1;\r\n            elt.parentNode.insertBefore(a, elt);\r\n            a.appendChild(elt);\r\n            a.onclick = function () {\r\n                dist_dom_lib_App_namespaceObject.startActivityAsync(href_1);\r\n                return false;\r\n            };\r\n        }\r\n    };\r\n    var id, item, a;\r\n    for (var i = 0; i < codeElts.length; i++) {\r\n        _loop_2();\r\n    }\r\n}\r\n/** Helper function to perform syntax highlighting */\r\nfunction highlightCode(elt) {\r\n    var preElts = elt.querySelectorAll(\"pre code\");\r\n    for (var i = 0; i < preElts.length; i++) {\r\n        var elt_1 = preElts[i];\r\n        if (typeof hljs !== \"undefined\")\r\n            hljs.highlightBlock(elt_1);\r\n    }\r\n}\r\n/** Container with a full article about a documentation item/topic */\r\nvar DocArticle_DocArticle = (function (_super) {\r\n    DocArticle___extends(DocArticle, _super);\r\n    function DocArticle(item) {\r\n        var _this = _super.call(this) || this;\r\n        _this.item = item;\r\n        _this.style.set(\"fontSize\", \"1.125rem\");\r\n        // add row with the item heading, and a divider\r\n        if (!item.textSkipTitle) {\r\n            _this.content.push(new (dist_dom_lib_UI_namespaceObject.Row.with({ verticalSpacing: \".5rem\" }, dist_dom_lib_UI_namespaceObject.Heading2.with({\r\n                text: item.name,\r\n                shrinkwrap: false,\r\n                style: {\r\n                    whiteSpace: \"pre-wrap\",\r\n                    fontSize: \"2rem\",\r\n                    fontWeight: \"300\",\r\n                    lineHeight: \"1.4em\"\r\n                }\r\n            }))), new dist_dom_lib_UI_namespaceObject.Divider(undefined, undefined, \"0\"));\r\n        }\r\n        // build up the article with HTML elements,\r\n        // starting from a code declaration if any\r\n        if (item.code) {\r\n            var codeElt = document.createElement(\"code\");\r\n            codeElt.innerText = item.code;\r\n            var codeBlock = new dist_dom_lib_UI_namespaceObject.DOM.DOMBlock(codeElt);\r\n            codeBlock.style.addClass(\"doc-code\");\r\n            codeBlock.style.set({ margin: \"1rem\" });\r\n            _this.content.push(codeBlock);\r\n        }\r\n        // append JSDoc text\r\n        if (item.doc) {\r\n            var docElt = document.createElement(\"div\");\r\n            docElt.innerHTML = item.doc;\r\n            linkifyCode(docElt, _this.documentService, item.parentItem);\r\n            var docBlock = new dist_dom_lib_UI_namespaceObject.DOM.DOMBlock(docElt);\r\n            docBlock.style.addClass(\"doc-text-article\");\r\n            docBlock.style.set({ margin: \"1rem\" });\r\n            _this.content.push(docBlock);\r\n        }\r\n        // append more text\r\n        var frag = document.createDocumentFragment();\r\n        item.text && item.text.forEach(function (textItem, i) {\r\n            var textElt = document.createElement(\"div\");\r\n            if (textItem.type)\r\n                textElt.className = \"doc-text-type-\" + textItem.type;\r\n            // populate text content\r\n            textElt.innerHTML = textItem.content;\r\n            linkifyCode(textElt, _this.documentService, (item.isClass || item.isInterface || item.isNamespace) ? item : item.parentItem);\r\n            highlightCode(textElt);\r\n            // show examples with code output\r\n            if (textItem.type === \"example\" || textItem.type === \"playground\") {\r\n                var code = \"\", outID = textItem.displayResult;\r\n                for (var _i = 0, _a = textElt.querySelectorAll(\"pre\"); _i < _a.length; _i++) {\r\n                    var elt = _a[_i];\r\n                    code += (code ? \"\\n\" : \"\") + elt.textContent;\r\n                }\r\n                var outElt = document.createComment(\"output\");\r\n                textElt.appendChild(outElt);\r\n                // use the result of the first expression in the example if\r\n                // displayResult is \"*\"\r\n                if (outID === \"*\") {\r\n                    outID = \"result\";\r\n                    code = \"var result = \" + code;\r\n                }\r\n                // add observable to watch code output while block\r\n                // is displayed, but show output as an element inside\r\n                // of the text element itself\r\n                var exampleID = item.id + \"|ex\" + i;\r\n                var c = new CodeOutput_CodeOutputContainer(exampleID, code, outID, textItem.type !== \"playground\");\r\n                _this.content.push(dom_lib_Async_namespaceObject.observe(function () {\r\n                    var out = c.out;\r\n                    if (out) {\r\n                        outElt.parentNode.replaceChild(out.element, outElt);\r\n                        outElt = out.element;\r\n                    }\r\n                }));\r\n                // for playground \"example\", show a separate button to open the editor\r\n                if (textItem.type === \"playground\") {\r\n                    textElt.className += \" doc-text-type-example\";\r\n                    var row = new (dist_dom_lib_UI_namespaceObject.Row.with({ verticalSpacing: \"1rem\", spacing: \"0\" }, dist_dom_lib_UI_namespaceObject.PrimaryButton.with({\r\n                        hidden: dom_lib_Async_namespaceObject.observe(function () { return dist_dom_lib_UI_namespaceObject.Screen.dimensions.isSmall; }),\r\n                        icon: \"fa-pencil\",\r\n                        remGutter: 2,\r\n                        label: (_b = [\"Open code editor\"], _b.raw = [\"Open code editor\"], dist_dom_lib_UI_namespaceObject.tl(_b)),\r\n                        Clicked: new dist_dom_lib_UI_namespaceObject.ActionHandler(function () {\r\n                            c.showEditor();\r\n                            for (var _i = 0, _a = textElt.querySelectorAll(\"pre\"); _i < _a.length; _i++) {\r\n                                var elt = _a[_i];\r\n                                textElt.removeChild(elt);\r\n                            }\r\n                        }),\r\n                        shrinkwrap: false\r\n                    }), dist_dom_lib_UI_namespaceObject.Label.with({\r\n                        hidden: dom_lib_Async_namespaceObject.observe(function () { return !dist_dom_lib_UI_namespaceObject.Screen.dimensions.isSmall; }),\r\n                        text: \"(Not available on mobile devices)\",\r\n                        shrinkwrap: false,\r\n                        style: { textAlign: \"center\" }\r\n                    })));\r\n                    var playgroundButtonRowElt = document.createComment(\"\");\r\n                    textElt.insertBefore(playgroundButtonRowElt, textElt.firstChild);\r\n                    _this.content.push(dom_lib_Async_namespaceObject.observe(function () {\r\n                        var out = row.out;\r\n                        if (out) {\r\n                            playgroundButtonRowElt.parentNode\r\n                                .replaceChild(out.element, playgroundButtonRowElt);\r\n                            playgroundButtonRowElt = out.element;\r\n                        }\r\n                    }));\r\n                }\r\n            }\r\n            // show title, collapsed or normal\r\n            if (textItem.title && textItem.title[0] !== \"_\") {\r\n                var headingElt = document.createElement(textItem.subHeading ? \"h4\" : \"h3\");\r\n                headingElt.className = \"doc-heading doc-heading-\" +\r\n                    (textItem.type ? textItem.type : \"section\");\r\n                headingElt.textContent = textItem.title;\r\n                if (textItem.type === \"task\") {\r\n                    // insert \"task\" icon in heading\r\n                    var iconElt = document.createElement(\"i\");\r\n                    iconElt.className = \"fa fa-arrow-circle-right\";\r\n                    headingElt.insertBefore(iconElt, headingElt.firstChild);\r\n                }\r\n                if (textItem.collapse === \"heading\") {\r\n                    // insert icon in heading, and set event handler\r\n                    var iconElt = document.createElement(\"i\");\r\n                    headingElt.insertBefore(iconElt, headingElt.firstChild);\r\n                    headingElt.style.cursor = \"pointer\";\r\n                    var setIconClass_1 = function (open) {\r\n                        iconElt.className = open ?\r\n                            \"fa fa-chevron-down fa-fw\" :\r\n                            \"fa fa-chevron-right fa-fw\";\r\n                    };\r\n                    setIconClass_1();\r\n                    var wrapper = document.createElement(\"div\");\r\n                    while (textElt.firstChild)\r\n                        wrapper.appendChild(textElt.removeChild(textElt.firstChild));\r\n                    var open = false;\r\n                    headingElt.onclick = function () {\r\n                        open = !open;\r\n                        setIconClass_1(open);\r\n                        if (open)\r\n                            textElt.appendChild(wrapper);\r\n                        else\r\n                            textElt.removeChild(wrapper);\r\n                    };\r\n                }\r\n                textElt.insertBefore(headingElt, textElt.firstChild);\r\n            }\r\n            frag.appendChild(textElt);\r\n            var _b;\r\n        });\r\n        if (frag.firstChild || item.doc || item.code) {\r\n            var textBlock = new dist_dom_lib_UI_namespaceObject.DOM.DOMBlock(frag);\r\n            textBlock.style.addClass(\"doc-text-article\");\r\n            textBlock.style.set({ margin: \"1rem 1rem 2rem\" });\r\n            _this.content.push(textBlock);\r\n        }\r\n        // append lists of sub items, if any, including inherited ones\r\n        if (item.toc && !item.textSkipTOC) {\r\n            _this.content.push(new dist_dom_lib_UI_namespaceObject.Row([new dist_dom_lib_UI_namespaceObject.Heading3(\"In this section\")]));\r\n            _this.content.push(new DocArticle_ItemListPanel(\"\", item.toc.map(function (id) {\r\n                return _this.documentService.getItemById(id);\r\n            })));\r\n        }\r\n        if (item.items && item.items.length ||\r\n            item.extends && item.extends.length) {\r\n            var staticPanel = new DocArticle_ItemListPanel(item.isEnum ? \"Enum members\" : \"Static members\", item.items && item.items.filter(function (z) { return z.isStatic; }), item.inherits && item.inherits.filter(function (id) {\r\n                return /\\.[^\\/]+$/.test(id) && !/\\.constructor/.test(id);\r\n            }));\r\n            var constrPanel = new DocArticle_ItemListPanel(\"Constructors\", item.items && item.items.filter(function (z) { return z.isCtor; }), item.inherits && item.inherits.filter(function (id) {\r\n                return /\\.constructor/.test(id);\r\n            }));\r\n            var membersPanel = new DocArticle_ItemListPanel(\"Instance members\", item.items && item.items.filter(function (z) { return !z.isCtor && !z.isStatic; }), item.inherits && item.inherits.filter(function (id) {\r\n                return !/\\.[^\\/]+$/.test(id);\r\n            }));\r\n            if (staticPanel.docItems.length || constrPanel.docItems.length ||\r\n                membersPanel.docItems.length) {\r\n                _this.content.push(new dist_dom_lib_UI_namespaceObject.Row([new dist_dom_lib_UI_namespaceObject.Heading3(\"Members\")]), staticPanel, constrPanel, membersPanel);\r\n            }\r\n        }\r\n        if (item.declType) {\r\n            var valueTypes = [];\r\n            item.declType.split(/\\s*[&|,\\<\\>]\\s*/).forEach(function (typeName) {\r\n                typeName = typeName.replace(/^\\s*typeof /, \"\").trim();\r\n                var typeId = _this.documentService.find(typeName, item);\r\n                if (typeId) {\r\n                    var typeItem = _this.documentService.getItemById(typeId);\r\n                    if (!valueTypes.some(function (z) { return z.id === typeItem.id; }))\r\n                        valueTypes.push(typeItem);\r\n                }\r\n            });\r\n            if (valueTypes.length) {\r\n                // link (return) type(s)\r\n                _this.content.push(new dist_dom_lib_UI_namespaceObject.Row([new dist_dom_lib_UI_namespaceObject.Heading3((item.isFunction || item.isMethod) ?\r\n                        \"Return type\" : \"Value type\")]));\r\n                _this.content.push(new DocArticle_ItemListPanel(\"\", valueTypes));\r\n            }\r\n        }\r\n        if (item.textSeeAlso) {\r\n            // show a \"See also\" section\r\n            _this.content.push(new dist_dom_lib_UI_namespaceObject.Row([new dist_dom_lib_UI_namespaceObject.Heading3(\"See also\")]));\r\n            _this.content.push(new DocArticle_ItemListPanel(\"References\", item.textSeeAlso.split(/,|;|\\|/).map(function (id) {\r\n                id = _this.documentService.find(id.trim(), item);\r\n                return id ? _this.documentService.getItemById(id) :\r\n                    undefined;\r\n            }).filter(function (z) { return !!z; })));\r\n        }\r\n        if (item.parentItem && item.parentItem.items) {\r\n            // link parent item\r\n            _this.content.push(new dist_dom_lib_UI_namespaceObject.Row([new dist_dom_lib_UI_namespaceObject.Heading3(\"Declared on\")]));\r\n            _this.content.push(new DocArticle_ItemListPanel(\"\", [item.parentItem]));\r\n            // show a list of related/sibling/instance items\r\n            if (item.isStatic) {\r\n                var heading = new dist_dom_lib_UI_namespaceObject.Row([new dist_dom_lib_UI_namespaceObject.Heading3(\"Related members\")]);\r\n                var panel = new DocArticle_ItemListPanel(\"Members (static)\", item.parentItem.items.filter(function (z) {\r\n                    return z.isStatic && z.id !== item.id;\r\n                }), item.parentItem.inherits &&\r\n                    item.parentItem.inherits.filter(function (id) {\r\n                        return /\\.[^\\/]+$/.test(id) && !/\\.constructor/.test(id);\r\n                    }));\r\n                if (panel.itemRows.length)\r\n                    _this.content.push(heading, panel);\r\n            }\r\n            else {\r\n                var heading = new dist_dom_lib_UI_namespaceObject.Row([new dist_dom_lib_UI_namespaceObject.Heading3(item.isCtor ?\r\n                        \"Instance members\" : \"Related members\")]);\r\n                var panel = new DocArticle_ItemListPanel(\"Instance members\", item.parentItem.items.filter(function (z) {\r\n                    return !z.isCtor && !z.isStatic && z.id !== item.id;\r\n                }), item.parentItem.inherits && item.parentItem.inherits.filter(function (id) { return !/\\.[^\\/]+$/.test(id); }));\r\n                if (panel.itemRows.length)\r\n                    _this.content.push(heading, panel);\r\n            }\r\n        }\r\n        // add final space below all content\r\n        var bottomSpacer = new dist_dom_lib_UI_namespaceObject.Block();\r\n        bottomSpacer.height = \"5rem\";\r\n        _this.content.push(bottomSpacer);\r\n        return _this;\r\n    }\r\n    DocArticle___decorate([\r\n        dist_dom_lib_App_namespaceObject.injectService\r\n    ], DocArticle.prototype, \"documentService\", void 0);\r\n    return DocArticle;\r\n}(dist_dom_lib_UI_namespaceObject.Container));\r\n\r\n/** Spacer that is always exactly .5rem wide */\r\nvar HalfSpacer = (function (_super) {\r\n    DocArticle___extends(HalfSpacer, _super);\r\n    function HalfSpacer() {\r\n        var _this = _super.call(this) || this;\r\n        _this.width = \".5rem\";\r\n        _this.shrinkwrap = true;\r\n        return _this;\r\n    }\r\n    return HalfSpacer;\r\n}(dist_dom_lib_UI_namespaceObject.Spacer));\r\n/** A row with labels that describe a code documentation item */\r\nvar DocArticle_TagLabelRow = (function (_super) {\r\n    DocArticle___extends(TagLabelRow, _super);\r\n    function TagLabelRow(item, isInherited, omitIcon) {\r\n        var _this = _super.call(this) || this;\r\n        _this.icon = item.icon;\r\n        if (isInherited) {\r\n            // dim all tags\r\n            _this.style.set({ opacity: \".5\" });\r\n            // add an icon and the inherited label\r\n            var inheritedIcon = new dist_dom_lib_UI_namespaceObject.Icon();\r\n            inheritedIcon.icon = \"fa-clone\";\r\n            inheritedIcon.tooltipText = \"Inherited\";\r\n            inheritedIcon.style.set({\r\n                color: \"#888\"\r\n            });\r\n            _this.content.push(inheritedIcon, new HalfSpacer());\r\n        }\r\n        if (item.code) {\r\n            // add the icon and a small space\r\n            if (!omitIcon)\r\n                _this.content.push(new dist_dom_lib_UI_namespaceObject.Icon(_this.icon), new HalfSpacer());\r\n            // add all appropriate tags\r\n            var add = function (text, bg, italic) {\r\n                var label = new dist_dom_lib_UI_namespaceObject.Label(text);\r\n                label.style.set({\r\n                    background: bg,\r\n                    color: \"#fff\",\r\n                    borderRadius: \".5rem\",\r\n                    padding: \"0 .5rem\",\r\n                    lineHeight: \"1.5em\",\r\n                    fontSize: \".75rem\",\r\n                    fontStyle: italic ? \"italic\" : \"normal\"\r\n                });\r\n                _this.content.push(label, new HalfSpacer());\r\n            };\r\n            if (item.isClass)\r\n                add(\"class\", TAG_BG_CLASSTYPE);\r\n            else if (item.isNamespace)\r\n                add(\"namespace\", TAG_BG_CLASSTYPE);\r\n            else if (item.isInterface)\r\n                add(\"interface\", TAG_BG_INTFTYPE);\r\n            else if (item.isCtor)\r\n                add(\"constructor\", TAG_BG_CTOR);\r\n            else if (item.isMethod)\r\n                add(\"method\", TAG_BG_MEMBERTYPE);\r\n            else if (item.isSignal)\r\n                add(\"signal\", TAG_BG_ASYNC);\r\n            else if (item.isProperty)\r\n                add(\"property\", TAG_BG_MEMBERTYPE);\r\n            else if (item.isDecorator)\r\n                add(\"decorator\", TAG_BG_DECORATOR);\r\n            else if (item.isFunction)\r\n                add(\"function\", TAG_BG_OTHRTYPE);\r\n            else if (item.isConst)\r\n                add(\"const\", TAG_BG_OTHRTYPE);\r\n            else if (item.isVar)\r\n                add(\"var\", TAG_BG_OTHRTYPE);\r\n            else if (item.isEnum)\r\n                add(\"enum\", TAG_BG_OTHRTYPE);\r\n            else if (item.isType)\r\n                add(\"type\", TAG_BG_OTHRTYPE);\r\n            if (item.isProtected)\r\n                add(\"protected\", TAG_BG_ACCESS, true);\r\n            if (item.isReadOnly)\r\n                add(\"read-only\", TAG_BG_ACCESS, true);\r\n            if (item.isStatic)\r\n                add(\"static\", TAG_BG_STATIC, true);\r\n            if (item.isAsync)\r\n                add(\"async\", TAG_BG_ASYNC, true);\r\n        }\r\n        return _this;\r\n    }\r\n    return TagLabelRow;\r\n}(dist_dom_lib_UI_namespaceObject.CloseRow));\r\n\r\n/** A list of annotated item links */\r\nvar DocArticle_ItemListPanel = (function (_super) {\r\n    DocArticle___extends(ItemListPanel, _super);\r\n    function ItemListPanel(title, items, inherited) {\r\n        if (items === void 0) { items = []; }\r\n        var _this = _super.call(this) || this;\r\n        _this.title = title;\r\n        _this.items = items;\r\n        _this.inherited = inherited;\r\n        /** Factories used to populate this block */\r\n        _this.itemRows = [];\r\n        // concatenate all given items\r\n        var allItems = items.slice();\r\n        if (inherited) {\r\n            inherited.forEach(function (s) {\r\n                allItems.push(_this.documentService.getItemById(s));\r\n            });\r\n        }\r\n        _this.docItems = allItems = allItems.filter(function (item) { return !!item; });\r\n        if (!allItems.length)\r\n            _this.hidden = true;\r\n        // populate item rows\r\n        var p = dom_lib_Async_namespaceObject.Promise.resolve(true);\r\n        allItems.forEach(function (item, i) {\r\n            if (i % 4 === 0)\r\n                p = p.then(function () { return dom_lib_Async_namespaceObject.sleep(0); });\r\n            p.then(function () {\r\n                // collect properties\r\n                var isInherited = !items.some(function (z) { return z.id === item.id; });\r\n                var displayName = _this.documentService.getDisplayNameFor(item.id);\r\n                var labelRow = new DocArticle_TagLabelRow(item, isInherited, true);\r\n                // pull JSDoc as text from a live DOM element\r\n                var docText = item.textSummary || \"\";\r\n                if (!docText && item.doc) {\r\n                    var tempDiv = document.createElement(\"div\");\r\n                    tempDiv.innerHTML = item.doc;\r\n                    docText = tempDiv.innerText.replace(/\\r|\\n/g, \" \");\r\n                }\r\n                // create a new row factory for this item\r\n                _this.itemRows.push(dist_dom_lib_UI_namespaceObject.Row.with({\r\n                    spacing: \".5rem\",\r\n                    content: [\r\n                        // adjust left alignment\r\n                        dist_dom_lib_UI_namespaceObject.Spacer.with({ width: \"0\", shrinkwrap: true }),\r\n                        // label with icon in front\r\n                        dist_dom_lib_UI_namespaceObject.Label.with({\r\n                            text: displayName,\r\n                            icon: labelRow.icon + \" fa-fw\",\r\n                            style: { fontWeight: isInherited ? \"400\" : \"600\" }\r\n                        }),\r\n                        // label row (shrinkwrapped) and JSDoc start\r\n                        dist_dom_lib_UI_namespaceObject.BlockControl.with({\r\n                            block: labelRow,\r\n                            shrinkwrap: true\r\n                        }),\r\n                        (_a = [\"{w|#aaa|300}\", \"\"], _a.raw = [\"{w|#aaa|300}\", \"\"], dist_dom_lib_UI_namespaceObject.tl(_a, docText))\r\n                    ],\r\n                    style: {\r\n                        fontSize: \"1rem\",\r\n                        cursor: \"pointer\"\r\n                    },\r\n                    Click: new dist_dom_lib_UI_namespaceObject.ActionHandler(function () {\r\n                        dist_dom_lib_App_namespaceObject.startActivityAsync(\"/doc/\" +\r\n                            (item.textSlug || item.id));\r\n                    })\r\n                }));\r\n                var _a;\r\n            });\r\n        });\r\n        return _this;\r\n    }\r\n    DocArticle___decorate([\r\n        dist_dom_lib_App_namespaceObject.injectService\r\n    ], ItemListPanel.prototype, \"documentService\", void 0);\r\n    DocArticle___decorate([\r\n        dom_lib_Async_namespaceObject.observable\r\n    ], ItemListPanel.prototype, \"itemRows\", void 0);\r\n    return ItemListPanel;\r\n}(dist_dom_lib_UI_namespaceObject.ContainerBlock.with({\r\n    style: {\r\n        margin: \"0 0 1.5rem\",\r\n        borderTop: \"2px solid \" + dist_dom_lib_UI_namespaceObject.DOM.Styles.color.divider,\r\n        borderBottom: \"1px solid \" + dist_dom_lib_UI_namespaceObject.DOM.Styles.color.divider\r\n    }\r\n}, dist_dom_lib_UI_namespaceObject.Container.with({ hidden: dist_dom_lib_UI_namespaceObject.bind(\"!itemRows.length\") }, dist_dom_lib_UI_namespaceObject.Row.with({\r\n    hidden: dist_dom_lib_UI_namespaceObject.bind(\"!title\"),\r\n    height: \"1.75rem\",\r\n    content: [dist_dom_lib_UI_namespaceObject.Heading5.withText(dist_dom_lib_UI_namespaceObject.bind(\"title\"))],\r\n    style: {\r\n        background: \"#eee\",\r\n        color: \"#333\"\r\n    }\r\n}), dist_dom_lib_UI_namespaceObject.List.with({\r\n    items: dist_dom_lib_UI_namespaceObject.bind(\"itemRows\"),\r\n    divider: { margin: \"0\" }\r\n})))));\r\n\n// CONCATENATED MODULE: ./src/docs-viewer/DocView.ts\nvar DocView___extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar DocView___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n\r\n\r\nvar DocView_DocView = (function (_super) {\r\n    DocView___extends(DocView, _super);\r\n    function DocView(activity) {\r\n        var _this = _super.call(this) || this;\r\n        _this.activity = activity;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DocView.prototype, \"item\", {\r\n        get: function () { return this.activity.item; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DocView.prototype, \"parentItem\", {\r\n        get: function () {\r\n            return this.item && this.item.parentItem;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DocView___decorate([\r\n        dom_lib_Async_namespaceObject.observable\r\n    ], DocView.prototype, \"item\", null);\r\n    DocView___decorate([\r\n        dom_lib_Async_namespaceObject.observable\r\n    ], DocView.prototype, \"parentItem\", null);\r\n    DocView = DocView___decorate([\r\n        dist_dom_lib_App_namespaceObject.mapViewActivity(DocActivity_DocActivity)\r\n    ], DocView);\r\n    return DocView;\r\n}(MainView_MainView.DocView.with({\r\n    style: dom_lib_Async_namespaceObject.observe(function () { return dist_dom_lib_UI_namespaceObject.Screen.dimensions.isSmall ?\r\n        { padding: \"0\" } :\r\n        { padding: \"0 2.5rem 0 2.5rem\" }; })\r\n}, \r\n// row that describes the (code) item, and a link to parent\r\ndist_dom_lib_UI_namespaceObject.Row.with({\r\n    height: dom_lib_Async_namespaceObject.observe(function () {\r\n        return dist_dom_lib_UI_namespaceObject.Screen.dimensions.isSmall ? \"auto\" : \"4rem\";\r\n    }),\r\n    spacing: \".5rem\",\r\n    verticalSpacing: \"1rem\"\r\n}, dist_dom_lib_UI_namespaceObject.Spacer.with({ width: \"0\", shrinkwrap: true }), dist_dom_lib_UI_namespaceObject.TextButton.with({\r\n    hidden: dist_dom_lib_UI_namespaceObject.bind(\"!parentItem\"),\r\n    label: dist_dom_lib_UI_namespaceObject.bind(\"parentItem\", function (parent) {\r\n        return (parent && (parent.textTopic || parent.name) || \"\");\r\n    }),\r\n    iconAfter: \"fa-caret-right\",\r\n    remGutter: 1.75,\r\n    target: dist_dom_lib_UI_namespaceObject.bind(\"parentItem.id\", function (id) { return \"/doc/\" + id; }),\r\n    style_button: {\r\n        color: \"#666\",\r\n        fontWeight: \"600\"\r\n    }\r\n}), dist_dom_lib_UI_namespaceObject.bind(\"item\", function (item) { return item && new DocArticle_TagLabelRow(item); })), \r\n// loading indicator\r\ndom_lib_Async_namespaceObject.sleep(50).then(function () {\r\n    return dist_dom_lib_UI_namespaceObject.CenterRow.with({\r\n        hidden: dist_dom_lib_UI_namespaceObject.bind(\"item\"),\r\n        height: \"10rem\",\r\n        content: [(_a = [\"Loading documentation...\"], _a.raw = [\"Loading documentation...\"], dist_dom_lib_UI_namespaceObject.tl(_a))]\r\n    });\r\n    var _a;\r\n}), \r\n// container with the article itself\r\ndist_dom_lib_UI_namespaceObject.bind(\"item\", function (item) { return item && new DocArticle_DocArticle(item); }))));\r\n\n// CONCATENATED MODULE: ./src/docs-viewer/TOCView.ts\nvar TOCView___extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar TOCView___decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n\r\n\r\nvar TOCView_TOCView = (function (_super) {\r\n    TOCView___extends(TOCView, _super);\r\n    function TOCView(activity) {\r\n        var _this = _super.call(this) || this;\r\n        _this.activity = activity;\r\n        _this.filterText = \"\";\r\n        // observe top doc activity\r\n        _this.Rendered.connectOnce(function () {\r\n            var count = 0;\r\n            dom_lib_Async_namespaceObject.observe(function () {\r\n                if (_this.tocTreeList && _this.tocTreeList.items.length &&\r\n                    !_this.filterTerms && !activity.loading) {\r\n                    var docActivity = dist_dom_lib_App_namespaceObject.findActivity(DocActivity_DocActivity);\r\n                    if (docActivity)\r\n                        return docActivity.item;\r\n                }\r\n                return undefined;\r\n            }).subscribe(function (item) {\r\n                if (item) {\r\n                    // select the currently shown document using the item ID\r\n                    dom_lib_Async_namespaceObject.sleep(10).then(function () {\r\n                        _this.tocTreeList.selectedKey = item.id;\r\n                    });\r\n                }\r\n            });\r\n            // auto focus selected items to bring them into view\r\n            _this.tocTreeList.SelectionChange.connect(function (data) {\r\n                if (_this.hasFocus)\r\n                    return;\r\n                if (data.item && !_this.filterTerms)\r\n                    data.item.hasFocus = true;\r\n            });\r\n            // observe search filter and update terms after a delay\r\n            var timer;\r\n            dom_lib_Async_namespaceObject.observe(function () { return _this.filterText; }).subscribe(function () {\r\n                if (timer)\r\n                    clearTimeout(timer);\r\n                timer = setTimeout(function () {\r\n                    timer = 0;\r\n                    _this._updateFilter();\r\n                }, 50);\r\n            });\r\n        });\r\n        return _this;\r\n    }\r\n    /** Returns a list of items for the TOC tree list */\r\n    TOCView.prototype.getTreeItems = function () {\r\n        var _this = this;\r\n        if (!this.documentService || !this.documentService.isLoaded)\r\n            return [];\r\n        var makeItemData = function (tocItem) {\r\n            var subItems = _this.documentService.getTOCItems(tocItem.id);\r\n            return {\r\n                name: tocItem.textTopic || tocItem.name,\r\n                key: tocItem.id,\r\n                icon: tocItem.icon,\r\n                autoExpand: !!tocItem.textAutoOpen,\r\n                items: subItems.length ?\r\n                    subItems.map(makeItemData) : undefined\r\n            };\r\n        };\r\n        var result = this.documentService.getTOCItems().map(makeItemData);\r\n        if (this.filterTerms && this.filterTerms.length) {\r\n            var terms_1 = this.filterTerms.map(function (s) { return s.toLowerCase(); });\r\n            var f_1 = function (item) {\r\n                if (!terms_1.some(function (s) {\r\n                    return (item.name.toLowerCase().indexOf(s) < 0) &&\r\n                        item.key.toLowerCase().indexOf(s) !== 0;\r\n                }))\r\n                    return true;\r\n                if (item.items) {\r\n                    item.items = item.items.filter(f_1);\r\n                    if (item.items.length) {\r\n                        item.autoExpand = true;\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            };\r\n            result = result.filter(f_1);\r\n        }\r\n        return result;\r\n    };\r\n    /** Show newly selected TOC topic */\r\n    TOCView.prototype.showTocTopic = function () {\r\n        var _this = this;\r\n        dom_lib_Async_namespaceObject.sleep(10).then(function () {\r\n            var id = _this.tocTreeList.selectedKey;\r\n            var data = id && _this.documentService.getItemById(id);\r\n            if (data)\r\n                dist_dom_lib_App_namespaceObject.startActivityAsync(\"/doc/\"\r\n                    + (data.textSlug || data.id));\r\n        });\r\n    };\r\n    /** Reset the search filter */\r\n    TOCView.prototype.resetFilter = function () {\r\n        this.filterText = \"\";\r\n    };\r\n    /** Take the current filter input value and apply the filter */\r\n    TOCView.prototype._updateFilter = function () {\r\n        var terms = this.filterText\r\n            .replace(/[^\\w\\s\\.]+/, \" \").trim()\r\n            .split(/\\s+/)\r\n            .filter(function (s) { return !!s; });\r\n        // set terms only if any found\r\n        this.filterTerms = terms.some(function (s) { return s.length > 2; }) ?\r\n            terms : undefined;\r\n    };\r\n    TOCView___decorate([\r\n        dist_dom_lib_App_namespaceObject.injectService\r\n    ], TOCView.prototype, \"documentService\", void 0);\r\n    TOCView___decorate([\r\n        dom_lib_Async_namespaceObject.observable\r\n    ], TOCView.prototype, \"tocTreeList\", void 0);\r\n    TOCView___decorate([\r\n        dom_lib_Async_namespaceObject.observable\r\n    ], TOCView.prototype, \"filterText\", void 0);\r\n    TOCView___decorate([\r\n        dom_lib_Async_namespaceObject.observable_shallow\r\n    ], TOCView.prototype, \"filterTerms\", void 0);\r\n    TOCView = TOCView___decorate([\r\n        dist_dom_lib_App_namespaceObject.mapViewActivity(MainActivity_MainActivity)\r\n    ], TOCView);\r\n    return TOCView;\r\n}(MainView_MainView.TOCView.with(\r\n// add header with search field\r\nMainView_MainView.TOCView.Header.with({\r\n    height: \"4.5rem\",\r\n    vertAlign: \"middle\",\r\n    style: { padding: \"0 .5rem\" },\r\n    shadowEffect: dist_dom_lib_UI_namespaceObject.bind(\"scrolledToTop\", function (atTop) {\r\n        return atTop ? 0 : .35;\r\n    })\r\n}, dist_dom_lib_UI_namespaceObject.CloseRow.with({\r\n    style: {\r\n        background: \"#fff\",\r\n        border: \"2px solid #eee\"\r\n    }\r\n}, dist_dom_lib_UI_namespaceObject.TextField.with({\r\n    name: \"filter\",\r\n    value: dist_dom_lib_UI_namespaceObject.bind2(\"filterText\"),\r\n    placeholderText: \"Filter\",\r\n    style_input: {\r\n        border: \"0\",\r\n        boxShadow: \"none\",\r\n        outline: \"0\"\r\n    },\r\n    immediateValueUpdate: true\r\n}), dist_dom_lib_UI_namespaceObject.TextButton.withIcon(\"fa-times\", \"resetFilter\"), dist_dom_lib_UI_namespaceObject.Spacer.with({\r\n    width: \".5rem\",\r\n    shrinkwrap: true\r\n}))), \r\n// add a label for this documentation file\r\ndist_dom_lib_UI_namespaceObject.CloseRow.with({ height: \"2rem\", style: { marginTop: \"1rem\" } }, dist_dom_lib_UI_namespaceObject.Icon.with({\r\n    icon: \"fa-chevron-down\",\r\n    width: \"2rem\",\r\n    style: { paddingLeft: \".75rem\" }\r\n}), dist_dom_lib_UI_namespaceObject.Label.with({\r\n    text: dist_dom_lib_UI_namespaceObject.bind(\"activity.title\"),\r\n    icon: \"fa-book\",\r\n    remGutter: 1.5,\r\n    style: { fontWeight: \"600\" }\r\n})), dist_dom_lib_UI_namespaceObject.Divider.with({ margin: \".25rem\" }), \r\n// add the actual TOC tree list\r\ndist_dom_lib_UI_namespaceObject.TreeList.with({\r\n    id: \"tocTreeList\",\r\n    items: dist_dom_lib_UI_namespaceObject.TreeListRow.arrayFromBinding(\"getTreeItems()\", \"fa-chevron-down\", \"fa-chevron-right\", 1.5, \"2rem\", 10),\r\n    focusMode: dist_dom_lib_UI_namespaceObject.Component.FocusMode.Items,\r\n    selectionMode: dist_dom_lib_UI_namespaceObject.Component.SelectionMode.ItemFocus,\r\n    style: dist_dom_lib_UI_namespaceObject.Style.withClass(\"toc_tree\"),\r\n    EnterKeyPressed: \"showTocTopic\",\r\n    Click: \"showTocTopic\",\r\n}))));\r\n\r\ndist_dom_lib_UI_namespaceObject.DOM.applyStylesheet({\r\n    \".toc_tree > .UI-Row\": {\r\n        cursor: \"pointer\"\r\n    },\r\n    \".toc_tree [selected]\": {\r\n        cursor: \"default\"\r\n    }\r\n});\r\n\n// CONCATENATED MODULE: ./src/docs-viewer/style.ts\n\r\n// apply style directly to the body element\r\ndist_dom_lib_UI_namespaceObject.Screen.ready.then(function () {\r\n    document.body.style.background = \"#fff\";\r\n    document.body.style.height = \"100%\";\r\n    document.body.style.margin = \"0\";\r\n});\r\n// Apply style sheet (copied from CSS... TODO: make this less messy)\r\ndist_dom_lib_UI_namespaceObject.DOM.applyStylesheet({\r\n    \"h1\": {\r\n        fontSize: \"3.8rem\",\r\n        fontWeight: \"600\"\r\n    },\r\n    \"h2\": {\r\n        fontSize: \"2.25rem\",\r\n        fontWeight: \"600\"\r\n    },\r\n    \"h3\": {\r\n        fontSize: \"1.5rem\",\r\n        fontWeight: \"600\",\r\n        fontStyle: \"normal\",\r\n        padding: \"0\",\r\n        margin: \"2.5rem 0 1rem\"\r\n    },\r\n    \"h4\": {\r\n        fontSize: \"1.125rem\",\r\n        fontWeight: \"600\",\r\n        fontStyle: \"normal\",\r\n        padding: \"0\",\r\n        margin: \"1.5rem 0 .5rem\"\r\n    },\r\n    \"h5\": {\r\n        fontSize: \".85rem\",\r\n        fontWeight: \"600\",\r\n        fontStyle: \"normal\",\r\n        textTransform: \"uppercase\",\r\n        margin: \"1.75rem 0 .75rem\"\r\n    },\r\n    \".fa\": {\r\n        fontSize: \".875em\" // 16px (1rem) => 14px native size\r\n    },\r\n    \"code\": {\r\n        fontFamily: \"Menlo,Monaco,Consolas,\\\"Liberation Mono\\\",\\\"Courier New\\\",monospace\",\r\n        fontSize: \".8em\"\r\n    },\r\n    \".doc-code\": {\r\n        color: \"#63e\"\r\n    },\r\n    \".doc-code > code\": {\r\n        lineHeight: \"1.5em\",\r\n    },\r\n    \".doc-text-article .fa:first-child\": {\r\n        paddingRight: \".5rem\"\r\n    },\r\n    \".doc-text-article a, .doc-text-article a:visited\": {\r\n        color: \"#39e\"\r\n    },\r\n    \".doc-text-article a > .fa\": {\r\n        color: \"#333 !important\",\r\n        textDecoration: \"none\"\r\n    },\r\n    \".doc-text-article code\": {\r\n        background: \"rgba(0,64,128,.05)\",\r\n        padding: \".125rem\",\r\n        borderRadius: \"2px\"\r\n    },\r\n    \".doc-text-article pre\": {\r\n        fontSize: \"1rem\",\r\n        background: \"rgba(0,64,128,.05)\",\r\n        borderTop: \"2px solid rgba(0,64,128,.2)\",\r\n        padding: \".75rem .5rem\",\r\n        margin: \"1rem 0\",\r\n        color: \"#555\",\r\n        overflow: \"auto\"\r\n    },\r\n    \".doc-text-article pre > code\": {\r\n        lineHeight: \"1.5em\",\r\n        background: \"transparent\",\r\n        whiteSpace: \"pre !important\"\r\n    },\r\n    \".doc-text-article blockquote\": {\r\n        fontSize: \"inherit\",\r\n        borderColor: \"#e80\"\r\n    },\r\n    \".doc-text-article p, .doc-text-article li, .doc-text-article dl\": {\r\n        lineHeight: \"1.65em\",\r\n        margin: \"0 0 1rem\",\r\n        padding: \"0\"\r\n    },\r\n    \".doc-text-article dt\": {\r\n        margin: \"1rem 0 0\",\r\n        padding: \"0\",\r\n        fontSize: \"1.2rem\",\r\n        fontWeight: \"300\"\r\n    },\r\n    \".doc-text-article dt code\": {\r\n        background: \"transparent\"\r\n    },\r\n    \".doc-text-article dt .fa\": {\r\n        fontSize: \"14px\"\r\n    },\r\n    \".doc-text-article dd\": {\r\n        margin: \".25rem 0 .75rem\",\r\n        padding: \"0 0 .5rem 2.8rem\"\r\n    },\r\n    \".doc-text-article li\": {\r\n        margin: \".25rem 0\"\r\n    },\r\n    \".doc-text-article h3.doc-heading-section\": {\r\n        padding: \".75rem 0\",\r\n        borderTop: \"1px solid rgba(0,0,0,.15)\"\r\n    },\r\n    \".doc-text-article hr\": {\r\n        border: \"0\",\r\n        borderBottom: \"1px solid rgba(0,0,0,.2)\",\r\n        padding: \"0\",\r\n        margin: \"2rem -1rem\"\r\n    },\r\n    \".doc-text-type-intro\": {\r\n        fontSize: \"1.25rem\",\r\n        fontWeight: \"300\"\r\n    },\r\n    \".doc-text-type-note\": {\r\n        background: \"rgba(220,160,64,.08)\",\r\n        borderTop: \"2px solid rgba(0,0,0,.2)\",\r\n        padding: \".5rem 1rem\",\r\n        margin: \"1.5rem 0\"\r\n    },\r\n    \".doc-text-type-note > :first-child\": {\r\n        marginTop: \".5rem\"\r\n    },\r\n    \".doc-text-type-note pre\": {\r\n        background: \"transparent\",\r\n        border: \"0\",\r\n        padding: \"0\"\r\n    },\r\n    \".doc-text-type-example\": {\r\n        background: \"rgba(0,64,128,.05)\",\r\n        padding: \".5rem 1rem\",\r\n        margin: \"1.5rem 0\"\r\n    },\r\n    \".doc-text-type-example pre\": {\r\n        background: \"transparent\",\r\n        border: \"0\"\r\n    },\r\n    \".doc-text-type-example > h3\": {\r\n        background: \"#666\",\r\n        color: \"#fff\",\r\n        textTransform: \"uppercase\",\r\n        fontSize: \".8em\",\r\n        lineHeight: \"1.75em\",\r\n        padding: \".25rem 1rem\",\r\n        margin: \"-.5rem -1rem 1rem -1rem\"\r\n    },\r\n    \".doc-text-type-example > h3:last-child\": {\r\n        marginBottom: \"-.5rem\"\r\n    },\r\n    \".doc-text-type-example > pre\": {\r\n        marginLeft: \"-.65rem\",\r\n        marginRight: \"-.65rem\"\r\n    },\r\n    \".doc-text-type-example > h3 + pre\": {\r\n        margin: \"-1rem -1rem 1rem\",\r\n        borderRadius: \"0\",\r\n        paddingLeft: \".75rem\"\r\n    },\r\n    \".doc-text-type-example > pre:first-child\": {\r\n        borderTop: \"2px solid rgba(0,64,128,.2)\",\r\n        margin: \"-.5rem -1rem 1rem\",\r\n        borderRadius: \"0\",\r\n        paddingLeft: \".75rem\"\r\n    },\r\n    \".doc-text-type-example > pre:first-child + .doc-text-example-output\": {\r\n        marginTop: \"-1rem !important\"\r\n    },\r\n    \".doc-text-example-output\": {\r\n        display: \"block !important\",\r\n        overflow: \"auto !important\",\r\n        width: \"auto !important\",\r\n        margin: \"0 -1rem -.5rem !important\",\r\n        background: \"#fff\"\r\n    },\r\n    \".doc-text-type-example > h3 + pre + .doc-text-example-output\": {\r\n        marginTop: \"-1rem !important\"\r\n    },\r\n    \".doc-text-example-byline, .doc-text-example-byline button\": {\r\n        fontSize: \".75rem\",\r\n        textTransform: \"uppercase !important\",\r\n        fontWeight: \"600\",\r\n        borderBottom: \"1px dotted #ccc\"\r\n    },\r\n    \".toc_tree\": {\r\n        color: \"#444\"\r\n    },\r\n    \".toc_tree div\": {\r\n        outline: \"0\"\r\n    }\r\n});\r\n\n// CONCATENATED MODULE: ./src/docs-viewer/main.ts\n// Simple viewer for Typescene API documentation\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nnew dist_dom_lib_App_namespaceObject.DOMApplication(\"Documentation\");\r\ndist_dom_lib_UI_namespaceObject.DOM.Styles.font.family = \"\\\"Source Sans Pro\\\", sans-serif\";\r\n// Do not use predefined heading styles but take them from CSS\r\ndist_dom_lib_UI_namespaceObject.DOM.Styles.rebootStyles.remove(\"h1,h2,h3,h4,h5,h6\");\r\ndist_dom_lib_UI_namespaceObject.DOM.Styles.rebootStyles.remove(/^h\\d$/);\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvQXN5bmMvUHJvbWlzZS5qcz81Zjg3Iiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvQXN5bmMvU2lnbmFsLmpzP2RjZGUiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9Bc3luYy9EZWZlci5qcz81NjJiIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvQXN5bmMvT2JzZXJ2YWJsZU9iamVjdC5qcz82M2U4Iiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvQXN5bmMvT2JzZXJ2YWJsZUFycmF5LmpzPzc3NmQiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9Bc3luYy9PYnNlcnZhYmxlLmpzPzE1MzUiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9Bc3luYy9JbmplY3QuanM/MGRiNSIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL0FzeW5jL2luZGV4LmpzPzE1NjEiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9Bc3luYy5qcz80OTU3Iiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9Bc3luYy5qcz80ZTBlIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvU3R5bGUuanM/MzYzNyIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29tcG9uZW50U2lnbmFsLmpzPzRiZmMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9VSS9CaW5kaW5nLmpzP2VjYTEiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL1RleHRMYWJlbEZhY3RvcnkuanM/MDM2YyIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29tcG9uZW50RmFjdG9yeS5qcz85YTUwIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db21wb25lbnQuanM/ODI0YyIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29tcG9uZW50UmVuZGVyZXIuanM/Mjg4ZiIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udGFpbmVycy9Db250YWluZXIuanM/OGI4NSIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0RyYWcuanM/YTU1ZSIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL1NjcmVlbi5qcz84ZWQyIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvUGFnZS5qcz8xZGJjIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvTWVudS5qcz9lYmVmIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9Db250cm9sRWxlbWVudC5qcz82MDM4Iiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9CdXR0b24uanM/ZmIyMiIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udGFpbmVycy9EaWFsb2dDb250YWluZXIuanM/YzYyNSIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udGFpbmVycy9EcmF3ZXJDb250YWluZXIuanM/Y2FkZCIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udGFpbmVycy9MYXlvdXRDb250YWluZXIuanM/NWIxNCIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQmxvY2tzL0Jsb2NrLmpzPzNlMGIiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0Jsb2Nrcy9DYXJkLmpzPzExNDkiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0Jsb2Nrcy9Db250YWluZXJCbG9jay5qcz80MGU3Iiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9CbG9ja3MvRGl2aWRlci5qcz8yYmMzIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9CbG9ja3MvTGlzdC5qcz8xMjkwIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9CbG9ja3MvVHJlZUxpc3QuanM/NTUxMiIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQmxvY2tzL1Jvdy5qcz9kMGY4Iiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9CbG9ja3MvVHJlZUxpc3RSb3cuanM/MzRjNiIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQmxvY2tzL05hdkxpc3QuanM/Y2U1NSIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQmxvY2tzL1RhYmxlUm93LmpzP2ViNzQiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0Jsb2Nrcy9UYWJsZS5qcz9iNjQ1Iiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9CbG9ja0NvbnRyb2wuanM/MTM0ZCIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvQnV0dG9uR3JvdXAuanM/YTNiMyIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvQ29udGFpbmVyQ29udHJvbC5qcz8yMjQzIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9Db250cm9sU3RhY2suanM/MmI4MCIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvSWNvbi5qcz9iNjU0Iiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9JbWFnZS5qcz9jNjIxIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9MYWJlbC5qcz8zMWExIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9Qcm9ncmVzc0Jhci5qcz8xYzhlIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9TcGFjZXIuanM/ZDg5MSIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvSW5wdXRDb250cm9scy9JbnB1dENvbnRyb2wuanM/NDc5ZiIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvSW5wdXRDb250cm9scy9DaGVja2JveC5qcz85ZjExIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9JbnB1dENvbnRyb2xzL1NlbGVjdEZpZWxkLmpzPzc0YzQiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0NvbnRyb2xzL0lucHV0Q29udHJvbHMvVGV4dEZpZWxkLmpzPzk5ZTAiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL2luZGV4LmpzP2Q2MWIiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9VSS9BbmltYXRpb24uanM/Zjc2NCIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL1VJL2luZGV4LmpzPzE5M2EiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9VSS5qcz8wZjllIiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9ET00vU3R5bGVzaGVldC5qcz9jZmFmIiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9ET00vc3R5bGVzL3JlYm9vdC5qcz8yOGUzIiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9ET00vc3R5bGVzL2NvbnRyb2xzLmpzP2E4ZmQiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL0RPTS9TdHlsZXMuanM/YjgwZSIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvRE9NL0RPTVBhZ2VPcHRpb25zLmpzPzg3ZmYiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1VwZGF0ZUNvbnRleHQuanM/YTg1NSIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0Jsb2Nrcy9CbG9jay5qcz9kZDgxIiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9ET00vRE9NQmxvY2suanM/MWFjOCIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvRE9NL0RPTUFuaW1hdGlvbi5qcz9iOWY2Iiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9ET00vbWFpbi5qcz9jYTExIiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9ET00vRm9jdXMuanM/YzU5YyIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvRE9NL2luZGV4LmpzP2Y1ZGEiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL0RyYWcuanM/ZDhkNyIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvUGFnZVJlbmRlcmVyLmpzPzE0OWEiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250YWluZXJzL0NvbnRhaW5lci5qcz84NDRlIiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udGFpbmVycy9EaWFsb2dDb250YWluZXIuanM/Mzc3ZiIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0NvbnRhaW5lcnMvRHJhd2VyQ29udGFpbmVyLmpzPzc5MDIiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250YWluZXJzL0xheW91dENvbnRhaW5lci5qcz9iOTBlIiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQmxvY2tzL0NhcmQuanM/OTVjYiIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0Jsb2Nrcy9Db250YWluZXJCbG9jay5qcz9iNzcxIiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQmxvY2tzL0RpdmlkZXIuanM/MjA0NyIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0Jsb2Nrcy9MaXN0LmpzPzgzOTIiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250cm9scy9Db250cm9sRWxlbWVudC5qcz84Y2Q0Iiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvTGFiZWwuanM/N2I0NSIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0Jsb2Nrcy9OYXZMaXN0LmpzPzg4ZDkiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9CbG9ja3MvUm93LmpzP2Q2NjAiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9CbG9ja3MvVGFibGUuanM/MDc1YiIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0Jsb2Nrcy9UYWJsZVJvdy5qcz80ZTU5Iiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvQmxvY2tDb250cm9sLmpzPzMxYmIiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250cm9scy9CdXR0b24uanM/Y2E2ZCIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0NvbnRyb2xzL0J1dHRvbkdyb3VwLmpzP2U3NDgiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250cm9scy9Db250YWluZXJDb250cm9sLmpzP2JjZjYiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250cm9scy9Db250cm9sU3RhY2suanM/ODA2MyIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0NvbnRyb2xzL0ljb24uanM/NDNjMSIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0NvbnRyb2xzL0ltYWdlLmpzP2FlOTIiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250cm9scy9Qcm9ncmVzc0Jhci5qcz8xODY2Iiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvU3BhY2VyLmpzPzJiZDUiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250cm9scy9JbnB1dENvbnRyb2xzL0NoZWNrYm94LmpzP2MwZDIiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250cm9scy9JbnB1dENvbnRyb2xzL1NlbGVjdEZpZWxkLmpzPzhmYWMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250cm9scy9JbnB1dENvbnRyb2xzL1RleHRGaWVsZC5qcz9jZjE3Iiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvaW5kZXguanM/MTYxMyIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvTWVudS5qcz83MmQ2Iiwid2VicGFjazovLy8uL2Rpc3QvZG9tL2xpYi9VSS9FdmVudHMuanM/MTJhYiIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkvaW5kZXguanM/Mzg2OCIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvVUkuanM/MjMyNiIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL0FwcC9WaWV3L1ZpZXdMYXlvdXQuanM/ODYzMyIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL0FwcC9WaWV3L0xheW91dC9CYXNlLmpzP2FkMjYiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9BcHAvVmlldy9MYXlvdXQvU2luZ2xlLmpzP2Y0OTQiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9BcHAvVmlldy9MYXlvdXQvQXBwLmpzPzQwM2EiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9BcHAvVmlldy9MYXlvdXQvaW5kZXguanM/ZGEzMiIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL0FwcC9TZXJ2aWNlL1NlcnZpY2UuanM/ZDBjZCIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL0FwcC9TZXJ2aWNlL2luZGV4LmpzPzE1OTMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9BcHAvQXBwbGljYXRpb24uanM/YjBiOSIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL0FwcC9WaWV3L1ZpZXdNYXBwaW5nLmpzPzUwMzEiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9BcHAvVmlldy9NZXNzYWdlQm94LmpzP2IzMmQiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9BcHAvVmlldy9pbmRleC5qcz9kZjlhIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvQXBwL0FjdGl2aXR5L0FjdGl2aXR5LmpzPzJiMWIiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9BcHAvQWN0aXZpdHkvQWN0aXZhdGlvbi5qcz9lYjk1Iiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvQXBwL0FjdGl2aXR5L0FjdGl2aXR5U3RhY2suanM/ZjUwMyIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL0FwcC9BY3Rpdml0eS9pbmRleC5qcz8yYzAwIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvQXBwL0N1bHR1cmUvQ3VsdHVyZVNlcnZpY2UuanM/ZDIzNSIsIndlYnBhY2s6Ly8vLi9kaXN0L2NvcmUvbGliL0FwcC9DdWx0dXJlL09ic2VydmVyLmpzPzBiN2YiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9BcHAvQ3VsdHVyZS9pbmRleC5qcz9kOGNmIiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvQXBwL2luZGV4LmpzP2YwZmIiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jb3JlL2xpYi9BcHAuanM/OTA4ZiIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvQXBwL0RPTUFwcGxpY2F0aW9uLmpzPzBkMWIiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL0FwcC9IdHRwLmpzPzBhNWEiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL0FwcC9MYXlvdXQuanM/OTQwZCIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvQXBwL2luZGV4LmpzPzZkMmEiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kb20vbGliL0FwcC5qcz9lZmY2Iiwid2VicGFjazovLy8uL2Rpc3QvY29yZS9saWIvaW5kZXguanM/NzVjMiIsIndlYnBhY2s6Ly8vLi9kaXN0L2RvbS9saWIvaW5kZXguanM/Y2MyMCIsIndlYnBhY2s6Ly8vc3JjL2RvY3Mtdmlld2VyL0RvY3VtZW50U2VydmljZS50cz80NWYwIiwid2VicGFjazovLy9zcmMvZG9jcy12aWV3ZXIvTWFpbkFjdGl2aXR5LnRzPzFlOTciLCJ3ZWJwYWNrOi8vL3NyYy9kb2NzLXZpZXdlci9NYWluVmlldy50cz82MzVmIiwid2VicGFjazovLy9zcmMvZG9jcy12aWV3ZXIvRG9jQWN0aXZpdHkudHM/MDEwZSIsIndlYnBhY2s6Ly8vc3JjL2RvY3Mtdmlld2VyL01vbmFjb0VkaXRvci50cz85YzJmIiwid2VicGFjazovLy9zcmMvZG9jcy12aWV3ZXIvQ29kZU91dHB1dC50cz8wNWRmIiwid2VicGFjazovLy9zcmMvZG9jcy12aWV3ZXIvRG9jQXJ0aWNsZS50cz9mNGI2Iiwid2VicGFjazovLy9zcmMvZG9jcy12aWV3ZXIvRG9jVmlldy50cz81OWY4Iiwid2VicGFjazovLy9zcmMvZG9jcy12aWV3ZXIvVE9DVmlldy50cz80NmQ5Iiwid2VicGFjazovLy9zcmMvZG9jcy12aWV3ZXIvc3R5bGUudHM/MTM4OCIsIndlYnBhY2s6Ly8vc3JjL2RvY3Mtdmlld2VyL21haW4udHM/YmNjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZlciwgcnVuWWllbGQgfSBmcm9tIFwiLi9EZWZlclwiO1xuaW1wb3J0IHsgVW5oYW5kbGVkRXhjZXB0aW9uLCBTaWduYWwgfSBmcm9tIFwiLi9TaWduYWxcIjtcbi8qKiBSZXByZXNlbnRzIGEgdmFsdWUgdG8gYmUgcmVzb2x2ZWQgYXQgYW55IHRpbWUgaW4gdGhlIGZ1dHVyZSAqL1xudmFyIFByb21pc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgUHJvbWlzZSBpbnN0YW5jZSBieSBydW5uaW5nIHRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbiwgd2hpY2ggaXMgZ2l2ZW4gY2FsbGJhY2tzIHRvIHJlc29sdmUgYW5kL29yIHJlamVjdCB0aGUgcHJvbWlzZTsgdGhlIHByb21pc2UgaXMgYWxzbyByZWplY3RlZCBpZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhyb3dzIGFuIGV4Y2VwdGlvbiAqL1xuICAgIGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICAgICAgLyogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX1Jlc29sdmUgPSBTaWduYWwuY3JlYXRlKCk7XG4gICAgICAgIC8qIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9SZWplY3QgPSBTaWduYWwuY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVXaXRoKGV4ZWN1dG9yKTtcbiAgICB9XG4gICAgLyoqIERlbGF5IHRoZSBleGVjdXRpb24gb2YgYSBjYWxsYmFjayBidXQgcmV0dXJuIGEgcHJvbWlzZSBmb3IgaXRzIHJlc3VsdCAqL1xuICAgIFByb21pc2UuZGVsYXkgPSBmdW5jdGlvbiAoZiwgbXMsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBQcm9taXNlKCk7XG4gICAgICAgIC8vIHNldCBhIHRpbWVyIGFuZCBydW4gYWxsIGRlZmVycmVkIGZ1bmN0aW9ucyByaWdodCBhd2F5IChlLmcuIC50aGVuKC4uLikpXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzdWx0Ll9yZXNvbHZlV2l0aChmdW5jdGlvbiAocikgeyByZXR1cm4gcihmLmFwcGx5KHVuZGVmaW5lZCwgYXJncykpOyB9KTtcbiAgICAgICAgICAgIHJ1bllpZWxkKCk7XG4gICAgICAgIH0sIG1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCBhZnRlciBhIGRlbGF5ICovXG4gICAgUHJvbWlzZS5zbGVlcCA9IGZ1bmN0aW9uIChtcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuZGVsYXkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0sIG1zKTtcbiAgICB9O1xuICAgIC8qKiBEZWZlciB0aGUgZXhlY3V0aW9uIG9mIGEgY2FsbGJhY2sgYnV0IHJldHVybiBhIHByb21pc2UgZm9yIGl0cyByZXN1bHQgKi9cbiAgICBQcm9taXNlLmRlZmVyID0gZnVuY3Rpb24gKGYsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBQcm9taXNlKCk7XG4gICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHsgcmVzdWx0Ll9yZXNvbHZlV2l0aChmdW5jdGlvbiAocikgeyByZXR1cm4gcihmLmFwcGx5KHVuZGVmaW5lZCwgYXJncykpOyB9KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogRXhlY3V0ZXMgZ2l2ZW4gY2FsbGJhY2ssIHByb3ZpZGluZyBpdCB3aXRoIGEgTm9kZS5qcy1zdHlsZSAoZXJyLCByZXN1bHQpID0+IHsuLi59IGhhbmRsZXIgdGhhdCBpbW1lZGlhdGVseSByZXNvbHZlcyBvciByZWplY3RzIHRoZSByZXN1bHRpbmcgcHJvbWlzZSB3aGVuIGNhbGxlZDsgKHVzZSBhcyBlLmcuIGBQcm9taXNlLmZuKGYgPT4gZnMucmVhZEZpbGUoJy9ldGMvcGFzc3dkJywgZikpLnRoZW4oLi4uKSlgICovXG4gICAgUHJvbWlzZS5mbiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJuIGEgcmVzb2x2ZWQgcHJvbWlzZSAqL1xuICAgIFByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKS5fcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSAqL1xuICAgIFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgpLl9yZWplY3QoZXJyb3IpO1xuICAgIH07XG4gICAgLyoqIFJldHVybiBhIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgZ2l2ZW4gcHJvbWlzZXMgYXJlIGZ1bGZpbGxlZCBhbmQgaXMgaW1tZWRpYXRlbHkgcmVqZWN0ZWQgd2hlbiBvbmUgb2YgdGhlIHByb21pc2VzIGlzIHJlamVjdGVkICovXG4gICAgUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBQcm9taXNlKCk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIGxlZnQgPSBwcm9taXNlcy5sZW5ndGg7XG4gICAgICAgIC8vIGZ1bGZpbGwgcHJvbWlzZSBpZiBub3QgcmVqZWN0ZWQgYmVmb3JlXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwoKSB7XG4gICAgICAgICAgICAhcmVzdWx0Ll9pc1JlamVjdGVkICYmIHJlc3VsdC5fcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdhaXQgZm9yIGVhY2ggZ2l2ZW4gcHJvbWlzZVxuICAgICAgICBwcm9taXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgLS1sZWZ0IHx8IGZ1bGZpbGwoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5fcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZnVsZmlsbCBhbHJlYWR5IGlmIG5vIHByb21pc2VzIGdpdmVuXG4gICAgICAgICFsZWZ0ICYmIGZ1bGZpbGwoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgZXhhY3RseSBsaWtlIHRoZSBmaXJzdCBvZiB0aGUgZ2l2ZW4gcHJvbWlzZXMgdGhhdCBpcyByZXNvbHZlZCBvciByZWplY3RlZCAqL1xuICAgIFByb21pc2UucmFjZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFByb21pc2UoKTtcbiAgICAgICAgcHJvbWlzZXMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gcmVzdWx0Ll9yZXNvbHZlKHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiByZXN1bHQuX3JlamVjdChlcnJvcik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBQcm9taXNlKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGZ1bGZpbGxlZCwgc2NoZWR1bGUgY2FsbCB0byBvbkZ1bGZpbGxlZCBvciBmdWxmaWxsIG5vd1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHsgcmVzdWx0Ll9yZXNvbHZlV2l0aChmdW5jdGlvbiAocikgeyByZXR1cm4gcihvbkZ1bGZpbGxlZChfdGhpcy5fdmFsdWUpKTsgfSk7IH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc3VsdC5fcmVzb2x2ZSh0aGlzLl92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZWplY3RlZCkge1xuICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSByZWplY3RlZCwgc2NoZWR1bGUgY2FsbCB0byBvblJlamVjdGVkIG9yIHJlamVjdCBub3dcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHsgcmVzdWx0Ll9yZXNvbHZlV2l0aChmdW5jdGlvbiAocikgeyByZXR1cm4gcihvblJlamVjdGVkKF90aGlzLl9lcnJvcikpOyB9KTsgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0Ll9yZWplY3QodGhpcy5fZXJyb3IpO1xuICAgICAgICAgICAgLy8gc2V0IGZsYWcgdG8gbWFrZSBzdXJlIFVuaGFuZGxlZEV4Y2VwdGlvbiBkb2VzIG5vdCBnZXQgY2FsbGVkIGFzeW5jXG4gICAgICAgICAgICB0aGlzLl9obmRSZWplY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZnVsZmlsbCByZXN1bHQgd2hlbiByZWFkeVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fUmVzb2x2ZS5fY29ubmVjdChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Ll9yZXNvbHZlV2l0aChmdW5jdGlvbiAocikgeyByZXR1cm4gcihvbkZ1bGZpbGxlZCh2KSk7IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcGFzcyBvbiByZXN1bHQgaWYgbm8gaGFuZGxlciBwYXNzZWQgaW5cbiAgICAgICAgICAgICAgICB0aGlzLl9SZXNvbHZlLl9jb25uZWN0KGZ1bmN0aW9uICh2KSB7IHJldHVybiByZXN1bHQuX3Jlc29sdmUodik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHJlamVjdGlvbnNcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fUmVqZWN0Ll9jb25uZWN0KGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuX3Jlc29sdmVXaXRoKGZ1bmN0aW9uIChyKSB7IHJldHVybiByKG9uUmVqZWN0ZWQodikpOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHBhc3Mgb24gcmVqZWN0aW9ucyBpZiBubyBoYW5kbGVyIHBhc3NlZCBpblxuICAgICAgICAgICAgICAgIHRoaXMuX1JlamVjdC5fY29ubmVjdChmdW5jdGlvbiAodikgeyByZXR1cm4gcmVzdWx0Ll9yZWplY3Qodik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFsd2F5cyByZXR1cm4gYSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdCBvZiBvbkZ1bGZpbGxlZCBPUiBvblJlamVjdGVkXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgUmV0dXJuIGN1cnJlbnQgc3RhdHVzOiBudWxsIGlmIHVuZnVsZmlsbGVkLCBvYmplY3Qgd2l0aCB2YWx1ZSBwcm9wZXJ0eSAoaWYgcmVzb2x2ZWQpLCBhbmQvb3IgZXJyb3IgcHJvcGVydHkgKGlmIHJlamVjdGVkKSAqL1xuICAgIFByb21pc2UucHJvdG90eXBlLl9nZXRTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKVxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRoaXMuX3ZhbHVlIH07XG4gICAgICAgIGlmICh0aGlzLl9pc1JlamVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmVqZWN0ZWQ6IHRydWUsIGVycm9yOiB0aGlzLl9lcnJvciB9O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgUmVzb2x2ZSB0aGUgcHJvbWlzZSB3aXRoIGEgdmFsdWUsIG9yIChmdXR1cmUpIHJlc3VsdCBvZiBhIHByb21pc2UgKi9cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVzb2x2aW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5faXNSZXNvbHZlZCAmJiAhdGhpcy5faXNSZWplY3RlZCAmJlxuICAgICAgICAgICAgKCF0aGlzLl9yZXNvbHZpbmcgfHwgcmVzb2x2aW5nID09PSB0aGlzLl9yZXNvbHZpbmcpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlY3Vyc2l2ZSBwcm9taXNlIGZvdW5kXCIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdGhlbkZuID0gdmFsdWUgJiYgdmFsdWUudGhlbjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoZW5GbiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgICgodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB8fCAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBwcm9taXNlIHRvIGJlIHJlc29sdmVkIGFuZCByZWN1cnNlXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmluZyA9IHRoaXMuX3Jlc29sdmluZyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGVuRm4uY2FsbCh2YWx1ZSwgZnVuY3Rpb24gKHYpIHsgX3RoaXMuX3Jlc29sdmUodiwgcmVzb2x2aW5nKTsgfSwgZnVuY3Rpb24gKGUpIHsgX3RoaXMuX3JlamVjdChlLCByZXNvbHZpbmcpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBzdGF0dXMgYW5kIHNjaGVkdWxlIGhhbmRsZXIgY2hhaW4gKGlmIGFueSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZXNvbHZpbmc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX1Jlc29sdmUuZW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBzaWduYWwgcmVmZXJlbmNlcyB0byBoZWxwIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fUmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX1JlamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIG9vcHMsIGNhdWdodCBhbiBleGNlcHRpb24sIG5vdyByZWplY3QgdGhpcyBwcm9taXNlXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KGUsIHJlc29sdmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsIFJ1biBhIGZ1bmN0aW9uIHRoYXQgbWF5IHJlc29sdmUgb3IgcmVqZWN0IHRoZSBwcm9taXNlLCBpZiBzdGlsbCBub3QgZnVsZmlsbGVkICovXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Jlc29sdmVXaXRoID0gZnVuY3Rpb24gKGV4ZWN1dG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBjYWxsIHJlc29sdmVyIGZ1bmN0aW9uIHdpdGggY2FsbGJhY2sgZm9yIHJlc29sdmluZyB0aGlzIHByb21pc2VcbiAgICAgICAgICAgIHRoaXMuX2lzUmVzb2x2ZWQgfHwgdGhpcy5faXNSZWplY3RlZCB8fFxuICAgICAgICAgICAgICAgIGV4ZWN1dG9yKGZ1bmN0aW9uICh2KSB7IF90aGlzLl9yZXNvbHZlKHYpOyB9LCBmdW5jdGlvbiAoZSkgeyBfdGhpcy5fcmVqZWN0KGUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gb29wcywgY2F1Z2h0IGFuIGV4Y2VwdGlvbiwgbm93IHJlamVjdCB0aGlzIHByb21pc2VcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgUmVqZWN0IHRoZSBwcm9taXNlIGJlY2F1c2UgYW4gZXJyb3Igb2NjdXJyZWQgKi9cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKGVycm9yLCByZXNvbHZpbmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gc2V0IHN0YXR1cyBhbmQgc2NoZWR1bGUgaGFuZGxlciBjaGFpbiAoaWYgYW55KVxuICAgICAgICBpZiAoIXRoaXMuX2lzUmVzb2x2ZWQgJiYgIXRoaXMuX2lzUmVqZWN0ZWQgJiZcbiAgICAgICAgICAgICghdGhpcy5fcmVzb2x2aW5nIHx8IHJlc29sdmluZyA9PT0gdGhpcy5fcmVzb2x2aW5nKSkge1xuICAgICAgICAgICAgdGhpcy5faXNSZWplY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgaWYgKHRoaXMuX1JlamVjdC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1pdCBzaWduYWwgd2hpY2ggaXMgaGFuZGxlZCBieSBvblJlamVjdGVkIGhhbmRsZXIocylcbiAgICAgICAgICAgICAgICB0aGlzLl9SZWplY3QuZW1pdChlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNpZ25hbCByZWZlcmVuY2VzIHRvIGhlbHAgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX1Jlc29sdmU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX1JlamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVtaXQgc2lnbmFsIGFzeW5jIGlmIHN0aWxsIG5vdCBoYW5kbGVkXG4gICAgICAgICAgICAgICAgLy8gKHdhaXQgZm9yIGNoYWluZWQgY2FsbHMgb24gYWxyZWFkeS1yZWplY3RlZCBwcm9taXNlKVxuICAgICAgICAgICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2huZFJlamVjdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgVW5oYW5kbGVkRXhjZXB0aW9uLmVtaXQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2U7XG59KCkpO1xuZXhwb3J0IHsgUHJvbWlzZSB9O1xuLyoqIFJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIGEgZGVsYXkgKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGVlcChtcywgdmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5kZWxheShmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSwgbXMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL0FzeW5jL1Byb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IGRlZmVyIH0gZnJvbSBcIi4vRGVmZXJcIjtcbmltcG9ydCB7IFByb21pc2UgfSBmcm9tIFwiLi9Qcm9taXNlXCI7XG4vLyByZW1vdmUgY3ljbGljYWwgZGVwZW5kZW5jeSBieSByZXF1aXJpbmcgdGhpcyBmcm9tIHJvb3Q6XG5pbXBvcnQgeyBPYnNlcnZhYmxlVmFsdWUgfSBmcm9tIFwiLi9cIjtcbi8qKiBGbGFnIHVzZWQgdG8gY29vcmRpbmF0ZSBiZXR3ZWVuIGhhbmRsZXIgYWRkZWQgYnkgY29ubmVjdE9uY2UsIGFuZCBlbWl0U3luYyBtZXRob2QgKHNldCB3aGVuIGRlbGV0ZWQgb3duIGhhbmRsZXIsIGkuZS4gZW1pdFN5bmMgbmVlZHMgdG8gY2FsbCBoYW5kbGVyIGF0IHNhbWUgaW5kZXggYWdhaW4pICovXG52YXIgX2hhbmRsZXJEZWxldGVkU2VsZiA9IGZhbHNlO1xuLyoqIFZhcmlhYmxlIHVzZWQgYnkgU2lnbmFsLmNyZWF0ZSB0byBrZWVwIHRyYWNrIG9mIG1vc3Qgc3BlY2lmaWMgc2lnbmFsIHRvIGJlIGVtaXR0ZWQgKi9cbnZhciBfY3VycmVudFNpZ25hbDtcbi8qKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgYSBoYW5kbGVyIGZ1bmN0aW9uIHdoaWNoIGxvb2tzIGZvciBhIGdpdmVuIG1ldGhvZCBvbiBnaXZlbiB0YXJnZXQgKi9cbmZ1bmN0aW9uIG1ha2VNZXRob2RIYW5kbGVyKG1ldGhvZCwgdGFyZ2V0KSB7XG4gICAgaWYgKCF0YXJnZXQpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUYXJnZXQgaXMgXCIgKyB0YXJnZXQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmID0gdGFyZ2V0W21ldGhvZF07XG4gICAgICAgIGlmICh0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRhcmdldCBkb2VzIG5vdCBjb250YWluIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuICAgICAgICBmLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuLyoqIEVuY2Fwc3VsYXRlcyBhIHNpZ25hbCB0aGF0IGNhbiBiZSB1c2VkIHRvIHRyaWdnZXIgb25lIG9yIG1vcmUgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHk7IGRvIF9ub3RfIGNvbnN0cnVjdCBgU2lnbmFsYCBjbGFzc2VzIGRpcmVjdGx5LCB1c2UgdGhlIHN0YXRpYyBgLmNyZWF0ZWAgbWV0aG9kIHRvIGNyZWF0ZSBkZXJpdmVkIGNsYXNzZXMgd2hpY2ggY2FuIGJlIGluc3RhbnRpYXRlZCBhbmQgZW1pdHRlZCAqL1xudmFyIFNpZ25hbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2lnbmFsKGRhdGEsIHNlbGYpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNpZ25hbCkpIHtcbiAgICAgICAgICAgIC8vIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBub3QgYSBjb25zdHJ1Y3RvcjogZW1pdCBkaXJlY3RseVxuICAgICAgICAgICAgc2VsZiAmJiBzZWxmLmVtaXQuY2FsbChzZWxmLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5fX2VtaXR0YWJsZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2lnbmFsLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIFJlc3VsdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoRGVmaW5lZFNpZ25hbCwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIERlZmluZWRTaWduYWwodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICghX2N1cnJlbnRTaWduYWwpXG4gICAgICAgICAgICAgICAgICAgIF9jdXJyZW50U2lnbmFsID0gUmVzdWx0O1xuICAgICAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdmFsdWUsIF9jdXJyZW50U2lnbmFsKSB8fCB0aGlzO1xuICAgICAgICAgICAgICAgIF9jdXJyZW50U2lnbmFsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBEZWZpbmVkU2lnbmFsO1xuICAgICAgICB9KHRoaXMpKTtcbiAgICAgICAgUmVzdWx0LiRzaWdOSG5kID0gMDtcbiAgICAgICAgUmVzdWx0Ll9fZW1pdHRhYmxlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBbaW1wbGVtZW50YXRpb25dIENyZWF0ZSBhIHJlYWQtb25seSBvYnNlcnZhYmxlIHZhbHVlIHRoYXQgY29udGFpbnMgdGhlIGxhc3QgZW1pdHRlZCB2YWx1ZSAoaW5pdGlhbGx5IHVuZGVmaW5lZCwgb25seSBjb250YWlucyBhIHZhbHVlIGFmdGVyIHRoZSBmaXJzdCB0aW1lIHRoaXMgc2lnbmFsIGlzIGVtaXR0ZWQpICovXG4gICAgU2lnbmFsLm9ic2VydmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlVmFsdWUuZnJvbVNpZ25hbCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKiBbaW1wbGVtZW50YXRpb25dIEFkZCBhIGhhbmRsZXIgKi9cbiAgICBTaWduYWwuY29ubmVjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGFyZ2V0KSB7XG4gICAgICAgIC8vIG1ha2UgaGFuZGxlciBmdW5jdGlvbiBpZiBnaXZlbiBvbmx5IGEgbWV0aG9kIG5hbWVcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbWFrZU1ldGhvZEhhbmRsZXIoY2FsbGJhY2ssIHRhcmdldCk7XG4gICAgICAgIC8vIGFkZCBoYW5kbGVyIHRvIHRoZSBsaXN0LCByZXR1cm4gYSBTaWduYWxDb25uZWN0aW9uIG9iamVjdFxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHsgZGlzY29ubmVjdGVkOiBmYWxzZSB9O1xuICAgICAgICBjb25uZWN0aW9uLmRpc2Nvbm5lY3QgPSBTaWduYWwuX2Nvbm5lY3QuY2FsbCh0aGlzLCBjYWxsYmFjaywgY29ubmVjdGlvbik7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH07XG4gICAgLyoqIFtpbXBsZW1lbnRhdGlvbl0gQWRkIGEgb25lLXRpbWUgaGFuZGxlciAqL1xuICAgIFNpZ25hbC5jb25uZWN0T25jZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGFyZ2V0KSB7XG4gICAgICAgIC8vIG1ha2UgaGFuZGxlciBmdW5jdGlvbiBpZiBnaXZlbiBvbmx5IGEgbWV0aG9kIG5hbWVcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbWFrZU1ldGhvZEhhbmRsZXIoY2FsbGJhY2ssIHRhcmdldCk7XG4gICAgICAgIC8vIGFkZCB3cmFwcGVyIHRvIHRoZSBsaXN0LCBjYWxsIGhhbmRsZXIgb25seSBvbmNlXG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZSwgdW4gPSBTaWduYWwuX2Nvbm5lY3QuY2FsbCh0aGlzLCBmdW5jdGlvbiAoZGF0YSwgc3JjKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2hhbmRsZXJEZWxldGVkU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdW4oKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhLCBzcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgSW1wbGVtZW50YXRpb24gb2YgY29ubmVjdDogcmV0dXJucyBkaXNjb25uZWN0IGZ1bmN0aW9uIFt1c2VkIHRvIHNwZWVkIHVwIGNvbm5lY3Rpb25zIGluIG90aGVyIEFzeW5jIGNsYXNzZXNdICovXG4gICAgU2lnbmFsLl9jb25uZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzaWduYWxDb25uZWN0aW9uKSB7XG4gICAgICAgIC8vIGNvcHkgYWxsIGluaGVyaXRlZCBzdGF0aWMgcHJvcGVydGllcyBvbnRvIHRoaXMgY2xhc3MgaW5zdGFuY2VcbiAgICAgICAgLy8gKG9yIGluaXRpYWxpemUgcmUtdXNlZCBvYmplY3QpXG4gICAgICAgIHZhciBzID0gdGhpcztcbiAgICAgICAgaWYgKHMuJHNpZ1NlbGYgIT09IHMpIHtcbiAgICAgICAgICAgIHMuJHNpZ1NlbGYgPSBzO1xuICAgICAgICAgICAgcy4kc2lnaDEgPSBzLiRzaWdoMSwgcy4kc2lnaDIgPSBzLiRzaWdoMiwgcy4kc2lnaDMgPSBzLiRzaWdoMywgcy4kc2lnaDQgPSBzLiRzaWdoNDtcbiAgICAgICAgICAgIHMuJHNpZ0huZCA9IHMuJHNpZ0huZCAmJiBzLiRzaWdIbmQuc2xpY2UoKTtcbiAgICAgICAgICAgIHMuJHNpZ05IbmQgPSBzLiRzaWdOSG5kIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGhhbmRsZXIgdG8gdGhlIGxpc3RcbiAgICAgICAgc3dpdGNoIChzLiRzaWdOSG5kKyspIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAvLyBjYWxsIFwidXBcIiBsaXN0ZW5lciB0byBtYWtlIHN1cmUgc2lnbmFscyBnZXQgZW1pdHRlZFxuICAgICAgICAgICAgICAgIHMuJHNpZ2gxID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgcy5vbkhhbmRsZXJDb25uZWN0ZWQgJiYgcy5vbkhhbmRsZXJDb25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzLiRzaWdoMiA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHMuJHNpZ2gzID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcy4kc2lnaDQgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IChzLiRzaWdIbmQgfHwgKHMuJHNpZ0huZCA9IFtdKSkucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBoYW5kbGVyIGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgIGlmIChzLiRzaWdoMSA9PT0gY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgX2EgPSBbcy4kc2lnaDIsIHMuJHNpZ2gzLCBzLiRzaWdoNCwgcy4kc2lnSG5kICYmIHMuJHNpZ0huZC5zaGlmdCgpXSwgcy4kc2lnaDEgPSBfYVswXSwgcy4kc2lnaDIgPSBfYVsxXSwgcy4kc2lnaDMgPSBfYVsyXSwgcy4kc2lnaDQgPSBfYVszXSwgX2EsXG4gICAgICAgICAgICAgICAgICAgIHMuJHNpZ05IbmQtLTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHMuJHNpZ2gyID09PSBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICBfYiA9IFtzLiRzaWdoMywgcy4kc2lnaDQsIHMuJHNpZ0huZCAmJiBzLiRzaWdIbmQuc2hpZnQoKV0sIHMuJHNpZ2gyID0gX2JbMF0sIHMuJHNpZ2gzID0gX2JbMV0sIHMuJHNpZ2g0ID0gX2JbMl0sIF9iLFxuICAgICAgICAgICAgICAgICAgICBzLiRzaWdOSG5kLS07XG4gICAgICAgICAgICBlbHNlIGlmIChzLiRzaWdoMyA9PT0gY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgX2MgPSBbcy4kc2lnaDQsIHMuJHNpZ0huZCAmJiBzLiRzaWdIbmQuc2hpZnQoKV0sIHMuJHNpZ2gzID0gX2NbMF0sIHMuJHNpZ2g0ID0gX2NbMV0sIF9jLFxuICAgICAgICAgICAgICAgICAgICBzLiRzaWdOSG5kLS07XG4gICAgICAgICAgICBlbHNlIGlmIChzLiRzaWdoNCA9PT0gY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgcy4kc2lnaDQgPSBzLiRzaWdIbmQgJiYgcy4kc2lnSG5kLnNoaWZ0KCksXG4gICAgICAgICAgICAgICAgICAgIHMuJHNpZ05IbmQtLTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHMuJHNpZ05IbmQgPiA0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHMuJHNpZ0huZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocy4kc2lnSG5kW2ldID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy4kc2lnSG5kLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuJHNpZ05IbmQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgbmV3IGxlbmd0aDogY2FsbCBcImRvd25cIiBsaXN0ZW5lciBpZiBub25lXG4gICAgICAgICAgICBpZiAoIXMuJHNpZ05IbmQgJiYgcy5vbkhhbmRsZXJzRGlzY29ubmVjdGVkKVxuICAgICAgICAgICAgICAgIHMub25IYW5kbGVyc0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgLy8gc2V0IGRpc2Nvbm5lY3RlZCBmbGFnXG4gICAgICAgICAgICBpZiAoc2lnbmFsQ29ubmVjdGlvbilcbiAgICAgICAgICAgICAgICBzaWduYWxDb25uZWN0aW9uLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKiBbaW1wbGVtZW50YXRpb25dIFJlbW92ZSBhbGwgaGFuZGxlcnMgKi9cbiAgICBTaWduYWwuZGlzY29ubmVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY2FsbCBcImRvd25cIiBjYWxsYmFjayB0byBhbGxvdyBzaWduYWxzIHRvIHN0b3AgZm9yIG5vd1xuICAgICAgICBpZiAodGhpcy4kc2lnTkhuZCkge1xuICAgICAgICAgICAgdGhpcy4kc2lnaDEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiRzaWdoMiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuJHNpZ2gzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4kc2lnaDQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiRzaWdIbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiRzaWdOSG5kID0gMDtcbiAgICAgICAgICAgIHRoaXMub25IYW5kbGVyc0Rpc2Nvbm5lY3RlZCAmJiB0aGlzLm9uSGFuZGxlcnNEaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBbaW1wbGVtZW50YXRpb25dIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHNpZ25hbCBoYXMgYW55IGhhbmRsZXJzICovXG4gICAgU2lnbmFsLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuJHNpZ05IbmQgPiAwKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgSW52b2tlIGFsbCBoYW5kbGVycyBzeW5jaHJvbm91c2x5LCB3aXRob3V0IGNyZWF0aW5nIGEgU2lnbmFsIGluc3RhbmNlIGF0IGFsbDsgZXhjZXB0aW9ucyBpbiBoYW5kbGVycyBhcmUgTk9UIGNhdWdodCBoZXJlICovXG4gICAgU2lnbmFsLmVtaXRTeW5jID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuJHNpZ05IbmQpIHtcbiAgICAgICAgICAgIF9oYW5kbGVyRGVsZXRlZFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiRzaWdoMSAmJiAodGhpcy4kc2lnaDEuY2FsbCh1bmRlZmluZWQsIGRhdGEpLFxuICAgICAgICAgICAgICAgIF9oYW5kbGVyRGVsZXRlZFNlbGYpKVxuICAgICAgICAgICAgICAgIF9oYW5kbGVyRGVsZXRlZFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiRzaWdoMiAmJiAodGhpcy4kc2lnaDIuY2FsbCh1bmRlZmluZWQsIGRhdGEpLFxuICAgICAgICAgICAgICAgIF9oYW5kbGVyRGVsZXRlZFNlbGYpKVxuICAgICAgICAgICAgICAgIF9oYW5kbGVyRGVsZXRlZFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiRzaWdoMyAmJiAodGhpcy4kc2lnaDMuY2FsbCh1bmRlZmluZWQsIGRhdGEpLFxuICAgICAgICAgICAgICAgIF9oYW5kbGVyRGVsZXRlZFNlbGYpKVxuICAgICAgICAgICAgICAgIF9oYW5kbGVyRGVsZXRlZFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiRzaWdoNCAmJiAodGhpcy4kc2lnaDQuY2FsbCh1bmRlZmluZWQsIGRhdGEpLFxuICAgICAgICAgICAgICAgIF9oYW5kbGVyRGVsZXRlZFNlbGYpKVxuICAgICAgICAgICAgICAgIF9oYW5kbGVyRGVsZXRlZFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuJHNpZ0huZDtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGhhbmRsZXJzW2ldICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoaGFuZGxlcnNbaV0uY2FsbCh1bmRlZmluZWQsIGRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oYW5kbGVyRGVsZXRlZFNlbGYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgX2hhbmRsZXJEZWxldGVkU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCBJbnZva2UgYWxsIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5LCBwb3NzaWJseSB3aXRob3V0IGNyZWF0aW5nIGEgU2lnbmFsIGluc3RhbmNlIGF0IGFsbDsgZXhjZXB0aW9ucyBpbiBoYW5kbGVycyBhcmUgTk9UIGNhdWdodCBoZXJlICovXG4gICAgU2lnbmFsLmVtaXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuX19lbWl0dGFibGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgICBpZiAodGhpcy4kc2lnTkhuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNpZ2gxKVxuICAgICAgICAgICAgICAgIGRlZmVyKHRoaXMuJHNpZ2gxLmJpbmQodGhpcywgZGF0YSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNpZ2gyKVxuICAgICAgICAgICAgICAgIGRlZmVyKHRoaXMuJHNpZ2gyLmJpbmQodGhpcywgZGF0YSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNpZ2gzKVxuICAgICAgICAgICAgICAgIGRlZmVyKHRoaXMuJHNpZ2gzLmJpbmQodGhpcywgZGF0YSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNpZ2g0KVxuICAgICAgICAgICAgICAgIGRlZmVyKHRoaXMuJHNpZ2g0LmJpbmQodGhpcywgZGF0YSkpO1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy4kc2lnSG5kO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tpXSAmJiBkZWZlcihoYW5kbGVyc1tpXS5iaW5kKHRoaXMsIGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEludm9rZSBhbGwgaGFuZGxlcnMgYW5kIGNhcHR1cmUgcHJvbWlzZXMgb2YgdGhlaXIgcmV0dXJuIHZhbHVlcyBpbiAucmVzdWx0cyAodW5sZXNzIGFyZ3VtZW50IGlzIHRydWUpOyB3b3JrcyBvbmx5IG9uY2U7IHJldHVybnMgdGhpcyAqL1xuICAgIFNpZ25hbC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChub1Jlc3VsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5fZW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHZhciBuSGFuZGxlcnMgPSB0aGlzLmNvbnN0cnVjdG9yLiRzaWdOSG5kO1xuICAgICAgICBpZiAoIW5IYW5kbGVycylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgaGFuZGxlcjEgPSB0aGlzLmNvbnN0cnVjdG9yLiRzaWdoMTtcbiAgICAgICAgdmFyIGhhbmRsZXIyID0gdGhpcy5jb25zdHJ1Y3Rvci4kc2lnaDI7XG4gICAgICAgIHZhciBoYW5kbGVyMyA9IHRoaXMuY29uc3RydWN0b3IuJHNpZ2gzO1xuICAgICAgICB2YXIgaGFuZGxlcjQgPSB0aGlzLmNvbnN0cnVjdG9yLiRzaWdoNDtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5jb25zdHJ1Y3Rvci4kc2lnSG5kO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGlmICghbm9SZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyBpbnRpYWxpemUgYW4gYXJyYXkgb2YgUHJvbWlzZXNcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gdGhpcy5fcmVzdWx0cyA9IFtoYW5kbGVyMSA/XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuZGVmZXIoaGFuZGxlcjEuYmluZCh0aGlzLCBkYXRhKSkgOlxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKV07XG4gICAgICAgICAgICBpZiAobkhhbmRsZXJzID4gMSlcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goaGFuZGxlcjIgP1xuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmRlZmVyKGhhbmRsZXIyLmJpbmQodGhpcywgZGF0YSkpIDpcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgaWYgKG5IYW5kbGVycyA+IDIpXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGhhbmRsZXIzID9cbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5kZWZlcihoYW5kbGVyMy5iaW5kKHRoaXMsIGRhdGEpKSA6XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGlmIChuSGFuZGxlcnMgPiAzKVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChoYW5kbGVyNCA/XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuZGVmZXIoaGFuZGxlcjQuYmluZCh0aGlzLCBkYXRhKSkgOlxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBpZiAobkhhbmRsZXJzID4gNClcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7IHJldHVybiByZXN1bHRzLnB1c2goZiA/XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuZGVmZXIoZi5iaW5kKF90aGlzLCBkYXRhKSkgOlxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBjYXB0dXJlIHJlc3VsdHMsIHNjaGVkdWxlIHBsYWluIGhhbmRsZXJzXG4gICAgICAgICAgICBkZWZlcihoYW5kbGVyMS5iaW5kKHRoaXMsIGRhdGEpKTtcbiAgICAgICAgICAgIGlmIChuSGFuZGxlcnMgPiAxKVxuICAgICAgICAgICAgICAgIGRlZmVyKGhhbmRsZXIyLmJpbmQodGhpcywgZGF0YSkpO1xuICAgICAgICAgICAgaWYgKG5IYW5kbGVycyA+IDIpXG4gICAgICAgICAgICAgICAgZGVmZXIoaGFuZGxlcjMuYmluZCh0aGlzLCBkYXRhKSk7XG4gICAgICAgICAgICBpZiAobkhhbmRsZXJzID4gMylcbiAgICAgICAgICAgICAgICBkZWZlcihoYW5kbGVyNC5iaW5kKHRoaXMsIGRhdGEpKTtcbiAgICAgICAgICAgIGlmIChuSGFuZGxlcnMgPiA0KVxuICAgICAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYgJiYgZGVmZXIoZi5iaW5kKF90aGlzLCBkYXRhKSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vbkVtaXQpXG4gICAgICAgICAgICB0aGlzLl9vbkVtaXQodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEludm9rZSBnaXZlbiBjYWxsYmFjayhzKSB3aXRoIHJldHVybiB2YWx1ZXMgb2YgYWxsIGhhbmRsZXJzLCBvciBhbnkgZXhjZXB0aW9uIHRoYXQgb2NjdXJyZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBhbGwgaGFuZGxlcnM7IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2socykgaXRzZWxmICovXG4gICAgU2lnbmFsLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fcHJvbWlzZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9lbWl0dGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocikgeyBfdGhpcy5fb25FbWl0ID0gcjsgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5hbGwoX3RoaXMucmVzdWx0cyk7IH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UgPSBQcm9taXNlLmFsbCh0aGlzLnJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgLyoqIENhdGNoIGVycm9ycyB0aGF0IG9jY3VyIGR1cmluZyBleGVjdXRpb24gb2YgYWxsIGhhbmRsZXJzOyByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrIGl0c2VsZiAqL1xuICAgIFNpZ25hbC5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2lnbmFsLnByb3RvdHlwZSwgXCJyZXN1bHRzXCIsIHtcbiAgICAgICAgLyoqIEFycmF5IG9mIFByb21pc2VzIHRoYXQgcmVzb2x2ZSB0byByZXR1cm4gdmFsdWVzIG9mIGFsbCBoYW5kbGVycyAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHRzIHx8IFtdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2lnbmFsLnByb3RvdHlwZSwgXCJkYXRhXCIsIHtcbiAgICAgICAgLyoqIFRoZSBwYXlsb2FkIGRhdGEgZm9yIHRoaXMgc2lnbmFsIGluc3RhbmNlICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBpbnRlcm5hbCBOdW1iZXIgb2YgaGFuZGxlcnMgKi9cbiAgICBTaWduYWwuJHNpZ05IbmQgPSAwO1xuICAgIHJldHVybiBTaWduYWw7XG59KCkpO1xuZXhwb3J0IHsgU2lnbmFsIH07XG4vKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCBmb3IgYWxsIGV4Y2VwdGlvbnMgdGhhdCB3ZXJlIHVuaGFuZGxlZCBkdXJpbmcgYXN5bmMgZXhlY3V0aW9uOyBhIGN1c3RvbSBoYW5kbGVyIG1heSBiZSBhZGRlZCBoZXJlLCB0aGUgZGVmYXVsdCBoYW5kbGVyIGp1c3QgbG9ncyBhIHdhcm5pbmcgbWVzc2FnZSB0byB0aGUgY29uc29sZTsgdG8gZGlzYWJsZSB0aGlzIGJlaGF2aW9yIGZvciBzcGVjaWZpYyBlcnJvcnMsIHNldCBlcnJvci5tZXNzYWdlIHRvIGEgYmxhbmsgc3RyaW5nICovXG5leHBvcnQgdmFyIFVuaGFuZGxlZEV4Y2VwdGlvbiA9IFNpZ25hbC5jcmVhdGUoKTtcbi8vIGhvb2sgdXAgZGVmYXVsdCBiZWhhdmlvcjpcblVuaGFuZGxlZEV4Y2VwdGlvbi5fY29ubmVjdChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICBlcnJvciAmJiBlcnJvci5tZXNzYWdlICYmIGNvbnNvbGUgJiYgKGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmxvZykoXCJVbmhhbmRsZWQgZXhjZXB0aW9uIGluIGFzeW5jaHJvbm91cyBjb2RlIC0gXCIsIGVycm9yKTtcbiAgICB9XG4gICAgY2F0Y2ggKGFsbCkgeyB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9Bc3luYy9TaWduYWwuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgeyBVbmhhbmRsZWRFeGNlcHRpb24gfSBmcm9tIFwiLi9TaWduYWxcIjtcbi8qKiBRdWV1ZSBvZiBmdW5jdGlvbnMgdG8gZXhlY3V0ZSB3aGVuIGlkbGUgKGRlZmVycmVkIGZ1bmN0aW9ucykgKi9cbnZhciBkZWZlcnJlZCA9IFtdO1xudmFyIGRlZmVycmVkQXJncyA9IFtdO1xuLyoqIFRydWUgaWYgY3VycmVudGx5IGhhbmRsaW5nIGRlZmVycmVkIGZ1bmN0aW9ucyAqL1xudmFyIHJ1bm5pbmdEZWZlcnJlZCA9IGZhbHNlO1xuLyoqIFRydWUgaWYgYWxyZWFkeSBzY2hlZHVsZWQgbmV4dCBoYW5kbGVyICovXG52YXIgc2NoZWR1bGVkO1xuLyoqIEN1cnJlbnQgc2V0VGltZW91dCBJRCwgaWYgPj0gMCAqL1xudmFyIGRlZmVyVGltZW91dCA9IC0xO1xuLyoqIFRydWUgaWYgcG9zdE1lc3NhZ2Ugd29ya3MsIHRvbyAqL1xudmFyIGNhblBvc3RNZXNzYWdlO1xuLyoqIFRydWUgaWYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdvcmtzICovXG52YXIgY2FuUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpICYmXG4gICAgKHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIik7XG4vKiogVHJ1ZSBpZiBuYXRpdmUgUHJvbWlzZSBleGlzdHMgKi9cbnZhciByZXNvbHZlZFByb21pc2UgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikgJiZcbiAgICAodHlwZW9mIHdpbmRvdy5Qcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSAmJlxuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoMCk7XG4vKiogUnVuIGEgYmF0Y2ggb2YgZGVmZXJyZWQgZnVuY3Rpb25zICovXG5mdW5jdGlvbiBfcnVuRGVmZXJyZWQodGltZSwgbWFudWFsWWllbGQpIHtcbiAgICB2YXIgdHJhY2tUaW1lID0gKHRpbWUgPiAwKTtcbiAgICBpZiAobWFudWFsWWllbGQgIT09IHRydWUpXG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmIChkZWZlclRpbWVvdXQgPj0gMCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZGVmZXJUaW1lb3V0KTtcbiAgICAgICAgZGVmZXJUaW1lb3V0ID0gLTE7XG4gICAgfVxuICAgIC8vIHJ1biBhIG51bWJlciBvZiBkZWZlcnJlZCBmdW5jdGlvbnNcbiAgICBydW5uaW5nRGVmZXJyZWQgPSB0cnVlO1xuICAgIHZhciBuID0gZGVmZXJyZWQubGVuZ3RoO1xuICAgIHZhciBtYXggPSBNYXRoLm1heCh0cmFja1RpbWUgPyAxMDAwIDogMTAwLCBuID4+IDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmZXJyZWQubGVuZ3RoICYmIGkgPCBtYXg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmZXJyZWRbaV0uYXBwbHkodW5kZWZpbmVkLCBkZWZlcnJlZEFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIFVuaGFuZGxlZEV4Y2VwdGlvbihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3AgaWYgZXhjZWVkaW5nIGFuaW1hdGlvbiBmcmFtZSB0aW1lIChpZiBhcHBsaWNhYmxlKSxcbiAgICAgICAgLy8ga2VlcCBnb2luZyBpZiBxdWV1ZSBpcyBzdGlsbCBncm93aW5nXG4gICAgICAgIGlmICh0cmFja1RpbWUgJiYgKGRlZmVycmVkLmxlbmd0aCA8IG4gKyBpKSAmJlxuICAgICAgICAgICAgcGVyZm9ybWFuY2Uubm93KCkgLSB0aW1lID4gNjApXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcnVubmluZ0RlZmVycmVkID0gZmFsc2U7XG4gICAgLy8gcmVzY2hlZHVsZSBpZiBuZWNlc3NhcnlcbiAgICBpZiAoaSA8IGRlZmVycmVkLmxlbmd0aCkge1xuICAgICAgICBkZWZlcnJlZC5zcGxpY2UoMCwgaSk7XG4gICAgICAgIGRlZmVycmVkQXJncy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIC8vIHJlc2NoZWR1bGUgc2xvd2x5IGlmIHF1ZXVlIGRpZG4ndCBncm93IHNpZ25pZmljYW50bHlcbiAgICAgICAgX3Jlc2NoZWR1bGUoZGVmZXJyZWQubGVuZ3RoID4gbiArIDIwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlZmVycmVkLmxlbmd0aCA9IDA7XG4gICAgICAgIGRlZmVycmVkQXJncy5sZW5ndGggPSAwO1xuICAgIH1cbn1cbi8qKiBTY2hlZHVsZSBhIGRlZmVycmVkIGZ1bmN0aW9uIHJ1biAoYnV0IG5vdCB0aHJvdWdoIFByb21pc2UgdHdpY2UgaW4gYSByb3cpICovXG5mdW5jdGlvbiBfcmVzY2hlZHVsZShpbW1lZGlhdGUpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCAmJiAhcnVubmluZ0RlZmVycmVkKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIGlmICghaW1tZWRpYXRlICYmIGNhblJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3J1bkRlZmVycmVkKTtcbiAgICAgICAgZWxzZSBpZiAoaW1tZWRpYXRlICYmIHJlc29sdmVkUHJvbWlzZSlcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKF9ydW5EZWZlcnJlZCk7XG4gICAgICAgIGVsc2UgaWYgKGNhblBvc3RNZXNzYWdlKVxuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKFwieWllbGRcIiwgXCIqXCIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KF9ydW5EZWZlcnJlZCwgMCwgMCk7XG4gICAgfVxufVxuLyoqIEV4ZWN1dGUgZ2l2ZW4gZnVuY3Rpb24gb25seSB3aGVuIGlkbGUsIHdpdGggZ2l2ZW4gYXJndW1lbnRzIChhcnJheSBvciBgYXJndW1lbnRzYCBvYmplY3QpIGlmIGFueSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmVyKGYsIGFyZ3MpIHtcbiAgICBkZWZlcnJlZC5wdXNoKGYpO1xuICAgIGRlZmVycmVkQXJncy5wdXNoKGFyZ3MpO1xuICAgIF9yZXNjaGVkdWxlKHRydWUpO1xufVxuLyoqIFJ1biBhIGJhdGNoIG9mIGRlZmVycmVkIGZ1bmN0aW9uczsgcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBzdGlsbCBtb3JlIGRlZmVycmVkIGZ1bmN0aW9ucyBpbiB0aGUgcXVldWUsIG9yIGZhbHNlIGlmIHRoZXJlIGFyZSBub25lIG9yIGlmIGFscmVhZHkgcnVubmluZzsgc2V0IGFyZ3VtZW50IHRvIHRydWUgdG8gcnVuIF9hbGxfIGRlZmVycmVkIGZ1bmN0aW9ucyB0aGF0IGFyZSBjdXJyZW50bHkgaW4gdGhlIHF1ZXVlIChidXQgbm90IHRob3NlIHRoYXQgZ2V0IGFkZGVkIGFmdGVyIHRoZSBjYWxsIHRvIGBydW5ZaWVsZGApICovXG5leHBvcnQgZnVuY3Rpb24gcnVuWWllbGQoeWllbGRBbGwpIHtcbiAgICBpZiAocnVubmluZ0RlZmVycmVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHlpZWxkQWxsKSB7XG4gICAgICAgIC8vIHJ1biB1cCB0byBjdXJyZW50IHBvc2l0aW9uIGluIHF1ZXVlXG4gICAgICAgIHZhciBzdG9wID0gZmFsc2U7XG4gICAgICAgIGRlZmVycmVkLnB1c2goZnVuY3Rpb24gKCkgeyBzdG9wID0gdHJ1ZTsgfSk7XG4gICAgICAgIGRlZmVycmVkQXJncy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHdoaWxlIChfcnVuRGVmZXJyZWQoMCwgdHJ1ZSkgJiYgIXN0b3ApXG4gICAgICAgICAgICA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBydW4gb25seSBvbmUgYmF0Y2ggb3IgdW50aWwgdGltZWQgb3V0XG4gICAgICAgIHZhciB0aW1lID0gY2FuUmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gcGVyZm9ybWFuY2Uubm93KCkgOiAwO1xuICAgICAgICBfcnVuRGVmZXJyZWQodGltZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiAoZGVmZXJyZWQubGVuZ3RoID4gMCk7XG59XG4vLyBjaGVjayBpZiBwb3N0TWVzc2FnZSB3b3JrcyBpbiB0aGlzIGJyb3dzZXIgYW5kIHNldCBmbGFnXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhblBvc3RNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgX3J1bkRlZmVycmVkKCk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cucG9zdE1lc3NhZ2UoXCJ5aWVsZFwiLCBcIipcIik7IH0sIDEpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL0FzeW5jL0RlZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSBcIi4vU2lnbmFsXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlVmFsdWUsIGFzc2VydFVub2JzZXJ2ZWQsIHVub2JzZXJ2ZWQgfSBmcm9tIFwiLi9PYnNlcnZhYmxlXCI7XG52YXIgT0JTRVJWQUJMRV9ISURERU5fUFJPUF9QUkVGSVggPSBcIipvYnNlcnZhYmxlOlwiO1xudmFyIEhBU19HRVRURVJfUFJPUCA9IFwiKm9ic2VydmFibGUtZ2V0dGVyXCI7XG4vKiogUmVwcmVzZW50cyBhbiBvYmplY3Qgd2l0aCAoc29tZSkgb2JzZXJ2YWJsZSBtZW1iZXJzOyBtYXkgYmUgZXh0ZW5kZWQgaW50byBhIGRlcml2ZWQgY2xhc3MsIG9yIHVzZSBgbWFrZU9iamVjdE9ic2VydmFibGVgIGZ1bmN0aW9uIHRvIG1peCBpbnRvIGFueSBvYmplY3QgW3JlcXVpcmVzIEVTNSsgdGFyZ2V0XSAqL1xudmFyIE9ic2VydmFibGVPYmplY3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBDcmVhdGUgYW4gb2JqZWN0IHdpdGggKHNvbWUpIG9ic2VydmFibGUgbWVtYmVycyAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVPYmplY3QoKSB7XG4gICAgICAgIGFzc2VydFVub2JzZXJ2ZWQoKTtcbiAgICAgICAgX2FkZFNpZ25hbEdldHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBwcm9wZXJ0eSB3aXRoIGdpdmVuIG5hbWUgaXMgb2JzZXJ2YWJsZSAqL1xuICAgIE9ic2VydmFibGVPYmplY3QucHJvdG90eXBlLmhhc09ic2VydmFibGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBpc09ic2VydmFibGVQcm9wZXJ0eSh0aGlzLCBuYW1lKTtcbiAgICB9O1xuICAgIC8qKiBBZGQgYW4gb2JzZXJ2YWJsZSBwcm9wZXJ0eSB3aXRoIGdpdmVuIG5hbWUgYW5kIHZhbHVlOyBhbnkgZXhpc3RpbmcgKG9ic2VydmFibGUpIHByb3BlcnRpZXMgd2l0aCB0aGlzIG5hbWUgYXJlIHJlbW92ZWQgZmlyc3QgKi9cbiAgICBPYnNlcnZhYmxlT2JqZWN0LnByb3RvdHlwZS5hZGRPYnNlcnZhYmxlUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbWFrZVByb3BlcnR5T2JzZXJ2YWJsZSh0aGlzLCBuYW1lKTtcbiAgICAgICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVPYmplY3Q7XG59KCkpO1xuZXhwb3J0IHsgT2JzZXJ2YWJsZU9iamVjdCB9O1xuLyoqIFJldHVybnMgYSBuZXcgYE9ic2VydmFibGVPYmplY3RgIHdpdGggcHJvcGVydGllcyBjb3BpZWQgZnJvbSBnaXZlbiBvYmplY3Q7IGBPYnNlcnZhYmxlVmFsdWVgIGluc3RhbmNlcyBhcmUgcmVmZXJlbmNlZCBkaXJlY3RseSAoaW5jbHVkaW5nIGdldHRlciBhbmQgc2V0dGVyKSwgQXJyYXkgcHJvcGVydGllcyBhcmUgdHVybmVkIGludG8gYE9ic2VydmFibGVBcnJheWAgaW5zdGFuY2VzLCBhbmQgcGxhaW4gT2JqZWN0IGluc3RhbmNlcyBpbnRvIGBPYnNlcnZhYmxlT2JqZWN0YCBpbnN0YW5jZXM7IGFsc28gc2VhbHMgdGhlIG5ldyBpbnN0YW5jZSBpZiB0aGUgb2JqZWN0IHBhcmFtZXRlciB3YXMgc2VhbGVkLCBhbmQgZnJlZXplcyBpdCBpZiB0aGUgb2JqZWN0IHBhcmFtZXRlciB3YXMgZnJvemVuKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT2JqZWN0T2JzZXJ2YWJsZShvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IE9ic2VydmFibGVPYmplY3QoKTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIC8vIGRlZmluZSBub24tY29uZmlndXJhYmxlIHByb3BlcnRpZXMgd2l0aCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgIHZhciBzcGVjSXNPYnNlcnZhYmxlID0gKG9iaiBpbnN0YW5jZW9mIE9ic2VydmFibGVPYmplY3QpO1xuICAgICAgICB2YXIgZGVzYztcbiAgICAgICAgZm9yICh2YXIgbWVtYmVyIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKChzcGVjSXNPYnNlcnZhYmxlID9cbiAgICAgICAgICAgICAgICBvYmouaGFzT2JzZXJ2YWJsZVByb3BlcnR5KG1lbWJlcikgOlxuICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIG1lbWJlcikpICYmXG4gICAgICAgICAgICAgICAgKGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgbWVtYmVyKSkpIHtcbiAgICAgICAgICAgICAgICBfZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5KHJlc3VsdCwgbWVtYmVyLCBkZXNjLnZhbHVlLCBkZXNjLmdldCwgZGVzYy5zZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1peGluIG1ldGhvZCBhbmQgc2lnbmFsXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIFwiaGFzT2JzZXJ2YWJsZVByb3BlcnR5XCIsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBPYnNlcnZhYmxlT2JqZWN0LnByb3RvdHlwZS5oYXNPYnNlcnZhYmxlUHJvcGVydHlcbiAgICAgICAgfSk7XG4gICAgICAgIF9hZGRTaWduYWxHZXR0ZXIocmVzdWx0KTtcbiAgICAgICAgLy8gY29weSBvYmplY3Qgc3RhdHVzXG4gICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4ob2JqKSkge1xuICAgICAgICAgICAgLy8gZ28gdGhyb3VnaCBhbGwgcHJvcGVydGllcyB0byBpbml0aWFsaXplIGhpZGRlbiBvYnNlcnZhYmxlIGZpcnN0XG4gICAgICAgICAgICBmb3IgKHZhciBtZW1iZXIgaW4gb2JqKVxuICAgICAgICAgICAgICAgIHJlc3VsdFttZW1iZXJdO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE9iamVjdC5pc1NlYWxlZChvYmopKSB7XG4gICAgICAgICAgICAvLyBnbyB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgaGlkZGVuIG9ic2VydmFibGUgZmlyc3RcbiAgICAgICAgICAgIGZvciAodmFyIG1lbWJlciBpbiBvYmopXG4gICAgICAgICAgICAgICAgcmVzdWx0W21lbWJlcl07XG4gICAgICAgICAgICBPYmplY3Quc2VhbChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogTWFrZSB0aGUgcHJvcGVydHkgd2l0aCBnaXZlbiBuYW1lIG9ic2VydmFibGU7IHVzZSBnaXZlbiBvYnNlcnZhYmxlIHZhbHVlIGluc3RhbmNlLCBpZiBhbnksIG90aGVyd2lzZSB1c2UgYSBuZXcgb2JzZXJ2YWJsZSB2YWx1ZSBpbnN0YW5jZSB0aGF0IGhvbGRzIHRoZSBjdXJyZW50IHByb3BlcnR5IHZhbHVlIGFuZC9vciB1c2VzIHRoZSBjdXJyZW50IHByb3BlcnR5IGdldHRlciBhbmQgc2V0dGVyIFtyZXF1aXJlcyBFUzUrIHRhcmdldF0gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUHJvcGVydHlPYnNlcnZhYmxlKG9iaiwgbWVtYmVyLCBpbnN0YW5jZSkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBTdHJpbmcobWVtYmVyKTtcbiAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBPYnNlcnZhYmxlVmFsdWUpIHtcbiAgICAgICAgLy8gdXNlIGdpdmVuIGluc3RhbmNlXG4gICAgICAgIF9kZWZpbmVPYnNlcnZhYmxlUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUsIGluc3RhbmNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHVzZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLCBvciBvdGhlcndpc2UganVzdCB0aGUgdmFsdWVcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgX2RlZmluZU9ic2VydmFibGVQcm9wZXJ0eShvYmosIHByb3BlcnR5TmFtZSwgZGVzYyA/IGRlc2MudmFsdWUgOiBvYmpbcHJvcGVydHlOYW1lXSwgZGVzYyAmJiBkZXNjLmdldCwgZGVzYyAmJiBkZXNjLnNldCk7XG4gICAgfVxufVxuLyoqIERlbGV0ZSB0aGUgcHJvcGVydHkgd2l0aCBnaXZlbiBuYW1lIGFuZCBjbGVhciBpdHMgb2JzZXJ2YWJsZSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZU9ic2VydmFibGVQcm9wZXJ0eShvYmosIG1lbWJlcikge1xuICAgIHZhciBoaWRkZW5NZW1iZXIgPSBfZ2V0SGlkZGVuTmFtZShtZW1iZXIpO1xuICAgIHZhciBvYnNlcnZhYmxlID0gb2JqW2hpZGRlbk1lbWJlcl07XG4gICAgaWYgKG9ic2VydmFibGUgJiYgb2JzZXJ2YWJsZS5zdWJzY3JpYmVkICYmIG9ic2VydmFibGUud3JpdGFibGUpXG4gICAgICAgIG9ic2VydmFibGUudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgZGVsZXRlIG9ialttZW1iZXJdO1xuICAgIGRlbGV0ZSBvYmpbaGlkZGVuTWVtYmVyXTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgcHJvcGVydHkgd2l0aCBnaXZlbiBuYW1lIGlzIGRlZmluZWQgYW5kIGlzIG9ic2VydmFibGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09ic2VydmFibGVQcm9wZXJ0eShvYmosIG1lbWJlcikge1xuICAgIHZhciBoaWRkZW5NZW1iZXIgPSBfZ2V0SGlkZGVuTmFtZShtZW1iZXIpO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBoaWRkZW5NZW1iZXIpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgcHBEZXNjcmlwdG9yID0gX2dldFByb3RvUHJvcERlc2Mob2JqLCBtZW1iZXIpO1xuICAgIGlmIChwcERlc2NyaXB0b3IgJiYgcHBEZXNjcmlwdG9yLmdldCAmJiBwcERlc2NyaXB0b3IuZ2V0W0hBU19HRVRURVJfUFJPUF0pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vID0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LVxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBhZGQgYSBnZXR0ZXIgZm9yIHRoZSBgT2JzZXJ2YWJsZU9iamVjdC5Qcm9wZXJ0eUNoYW5nZWAgc2lnbmFsIHRvIGFueSBvYmplY3QgKi9cbmZ1bmN0aW9uIF9hZGRTaWduYWxHZXR0ZXIob2JqKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBcIlByb3BlcnR5Q2hhbmdlXCIpKSB7XG4gICAgICAgIHZhciBTO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBcIlByb3BlcnR5Q2hhbmdlXCIsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghUykge1xuICAgICAgICAgICAgICAgICAgICBTID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBTLnRhcmdldCA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzUHJvcGVydHlDaGFuZ2VTaWduYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBwcm90b3R5cGUncyBwcm9wZXJ0eSBkZXNjcmlwdG9yICovXG5mdW5jdGlvbiBfZ2V0UHJvdG9Qcm9wRGVzYyhvYmosIG1lbWJlcikge1xuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIHJldHVybiBwcm90byA/XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIFN0cmluZyhtZW1iZXIpKSB8fFxuICAgICAgICAgICAgX2dldFByb3RvUHJvcERlc2MocHJvdG8sIG1lbWJlcikgOlxuICAgICAgICB1bmRlZmluZWQ7XG59XG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGFkZCBhIGdldHRlciBhbmQgc2V0dGVyIGZvciBhIHNpbmdsZSBwcm9wZXJ0eSAqL1xuZnVuY3Rpb24gX2RlZmluZU9ic2VydmFibGVQcm9wZXJ0eShvYmosIG1lbWJlciwgaW5pdGlhbCwgZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgICB2YXIgaGlkZGVuTWVtYmVyID0gX2dldEhpZGRlbk5hbWUobWVtYmVyKTtcbiAgICAvLyBjbGVhciBleGlzdGluZyBvYnNlcnZhYmxlIHZhbHVlLCBpZiBhbnksIG9yIGRlZmluZSBoaWRkZW4gcHJvcGVydHlcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaGlkZGVuTWVtYmVyKSlcbiAgICAgICAgZGVsZXRlT2JzZXJ2YWJsZVByb3BlcnR5KG9iaiwgbWVtYmVyKTtcbiAgICBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgaGlkZGVuTWVtYmVyLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBkZWZpbmUgb2JzZXJ2YWJsZSBwcm9wZXJ0eSBpdHNlbGZcbiAgICB2YXIgZGVzY3JpcHRvciA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH07XG4gICAgX21ha2VPYnNlcnZhYmxlUHJvcGVydHlEZWYoZGVzY3JpcHRvciwgbWVtYmVyLCBnZXR0ZXIsIHNldHRlcik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWVtYmVyLCBkZXNjcmlwdG9yKTtcbiAgICAvLyBzdG9yZSBvYnNlcnZhYmxlIHZhbHVlIGluc3RhbmNlLCBpZiByZWZlcmVuY2VkIGRpcmVjdGx5XG4gICAgaWYgKGluaXRpYWwgaW5zdGFuY2VvZiBPYnNlcnZhYmxlVmFsdWUpXG4gICAgICAgIG9ialtoaWRkZW5NZW1iZXJdID0gaW5pdGlhbDtcbiAgICBlbHNlIGlmIChpbml0aWFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgIG9ialttZW1iZXJdID0gaW5pdGlhbDtcbn1cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgcHJvcGVydHkgZGVmaW5pdGlvbiBmb3IgYW4gb2JzZXJ2YWJsZSBwcm9wZXJ0eSAqL1xuZnVuY3Rpb24gX21ha2VPYnNlcnZhYmxlUHJvcGVydHlEZWYoZGVzY3JpcHRvciwgbWVtYmVyLCBnZXR0ZXIsIHNldHRlciwgZ2V0RmlsdGVyLCBzZXRGaWx0ZXIsIHNoYWxsb3cpIHtcbiAgICB2YXIgaGlkZGVuTWVtYmVyID0gX2dldEhpZGRlbk5hbWUobWVtYmVyKTtcbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIE9ic2VydmFibGVWYWx1ZSBmb3IgYSBtZW1iZXJcbiAgICBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlVmFsdWUob2JqKSB7XG4gICAgICAgIGlmIChvYmpbaGlkZGVuTWVtYmVyXSlcbiAgICAgICAgICAgIHJldHVybiBvYmpbaGlkZGVuTWVtYmVyXTtcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvYnNlcnZhYmxlIHZhbHVlXG4gICAgICAgIHJldHVybiBvYmpbaGlkZGVuTWVtYmVyXSA9IHVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG8gPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoc2hhbGxvdylcbiAgICAgICAgICAgICAgICBvLnNoYWxsb3cgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGdldHRlcilcbiAgICAgICAgICAgICAgICBvLmdldHRlcihnZXR0ZXIuYmluZChvYmopKTtcbiAgICAgICAgICAgIGlmIChzZXR0ZXIpXG4gICAgICAgICAgICAgICAgby5zZXR0ZXIoc2V0dGVyLmJpbmQob2JqKSk7XG4gICAgICAgICAgICAvLyBlbWl0IFByb3BlcnR5Q2hhbmdlIGZvciBPYnNlcnZhYmxlIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBvLmludm9rZU9uQ2hhbmdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLl9oYXNQcm9wZXJ0eUNoYW5nZVNpZ25hbClcbiAgICAgICAgICAgICAgICAgICAgb2JqLlByb3BlcnR5Q2hhbmdlKG1lbWJlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gc2F2ZSBnZXR0ZXIgd2l0aCBmbGFnXG4gICAgZGVzY3JpcHRvci5nZXQgPSBnZXRGaWx0ZXIgP1xuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsdGVyKGdldE9ic2VydmFibGVWYWx1ZSh0aGlzKS52YWx1ZSk7XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0T2JzZXJ2YWJsZVZhbHVlKHRoaXMpLnZhbHVlO1xuICAgICAgICB9O1xuICAgIGRlc2NyaXB0b3IuZ2V0W0hBU19HRVRURVJfUFJPUF0gPSB0cnVlO1xuICAgIC8vIHNhdmUgc2V0dGVyXG4gICAgZGVzY3JpcHRvci5zZXQgPSBzZXRGaWx0ZXIgP1xuICAgICAgICBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIGdldE9ic2VydmFibGVWYWx1ZSh0aGlzKS52YWx1ZSA9IHNldEZpbHRlcih2KTtcbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0T2JzZXJ2YWJsZVZhbHVlKHRoaXMpLnZhbHVlID0gdjtcbiAgICAgICAgfTtcbn1cbmZ1bmN0aW9uIF9nZXRIaWRkZW5OYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gT0JTRVJWQUJMRV9ISURERU5fUFJPUF9QUkVGSVggKyBuYW1lO1xufVxuLy8gPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tXG4vKiogX01ldGhvZC9hY2Nlc3NvciBkZWNvcmF0b3JfLCB3cmFwcyBhIG1ldGhvZCBvciBnZXR0ZXIgKGJ1dCBub3Qgc2V0dGVyKSBpbiBhbiBgdW5vYnNlcnZlZGAgY2FsbCwgc28gdGhhdCBhbnkgb2JzZXJ2YWJsZSB2YWx1ZXMgcmVhZCBieSB0aGlzIG1ldGhvZCAob3IgZnVuY3Rpb25zIGludm9rZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGlzIG1ldGhvZCkgYXJlIG5vdCBtYXJrZWQgYXMgZGVwZW5kZW5jaWVzIG9mIGFueSBjdXJyZW50bHkgZXZhbHVhdGluZyBvYnNlcnZhYmxlIHZhbHVlcyBbcmVxdWlyZXMgRVM1KyB0YXJnZXRdIFtkZWNvcmF0b3JdICovXG5leHBvcnQgZnVuY3Rpb24gdW5vYnNlcnZhYmxlKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICAgICAgICAvLyB3cmFwIGdldHRlciB0byBpbnZva2UgaXQgYXMgdW5vYnNlcnZlZCAobm8gYXJndW1lbnRzKVxuICAgICAgICAgICAgdmFyIGZfMSA9IGRlc2NyaXB0b3IuZ2V0O1xuICAgICAgICAgICAgZGVzY3JpcHRvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVub2JzZXJ2ZWQuY2FsbCh0aGlzLCBmXzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIHdyYXAgZnVuY3Rpb24gdG8gbW9ua2V5IHBhdGNoIGl0IGFzIHVub2JzZXJ2ZWRcbiAgICAgICAgICAgIHZhciBmXzIgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bm9ic2VydmVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZfMi5hcHBseShfdGhpcywgYSk7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbn1cbi8qKiBfUmVhZC1vbmx5LWFjY2Vzc29yIGRlY29yYXRvcl8sIHdyYXBzIGEgZ2V0dGVyICh3aXRob3V0IHNldHRlcikgaW4gYW4gYHVub2JzZXJ2ZWRgIGNhbGwsIHNvIHRoYXQgYW55IG9ic2VydmFibGUgdmFsdWVzIHJlYWQgYnkgdGhlIGFjY2Vzc29yIChvciBmdW5jdGlvbnMgaW52b2tlZCBzeW5jaHJvbm91c2x5IGZyb20gd2l0aGluIHRoZSBhY2Nlc3NvcikgYXJlIG5vdCBtYXJrZWQgYXMgZGVwZW5kZW5jaWVzIG9mIGFueSBjdXJyZW50bHkgZXZhbHVhdGluZyBvYnNlcnZhYmxlIHZhbHVlczsgZGVmaW5lcyBhIHJlYWQtb25seSBwcm9wZXJ0eSB1c2luZyB0aGUgcmVzdWx0IG9mIHRoZSBhY2Nlc3NvciBjYWxsLCBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCB3YXMgaW52b2tlZCBmb3IgZWFjaCBpbnN0YW5jZSBbcmVxdWlyZXMgRVM1KyB0YXJnZXRdIFtkZWNvcmF0b3JdICovXG5leHBvcnQgZnVuY3Rpb24gdW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5nZXQpIHtcbiAgICAgICAgLy8gcHJvcGVydHkgY2Fubm90IGNvbnRhaW4gYSBzZXR0ZXIgKG11c3QgYmUgcmVhZC1vbmx5KVxuICAgICAgICBpZiAoZGVzY3JpcHRvci5zZXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgICAvLyB3cmFwIGdldHRlciB0byBpbnZva2UgaXQgYXMgdW5vYnNlcnZlZCAobm8gYXJndW1lbnRzKVxuICAgICAgICB2YXIgZiA9IGRlc2NyaXB0b3IuZ2V0O1xuICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHVub2JzZXJ2ZWQuY2FsbCh0aGlzLCBmKTtcbiAgICAgICAgICAgIC8vIHJlZGVmaW5lIHRoZSBwcm9wZXJ0eSBvbiB0aGlzIGluc3RhbmNlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2YWJsZSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvciwgZ2V0RmlsdGVyLCBzZXRGaWx0ZXIsIHNoYWxsb3cpIHtcbiAgICBpZiAoIWRlc2NyaXB0b3IpXG4gICAgICAgIGRlc2NyaXB0b3IgPSB7IGVudW1lcmFibGU6IHRydWUgfTtcbiAgICBfbWFrZU9ic2VydmFibGVQcm9wZXJ0eURlZihkZXNjcmlwdG9yLCBrZXksIGRlc2NyaXB0b3IuZ2V0LCBkZXNjcmlwdG9yLnNldCwgZ2V0RmlsdGVyLCBzZXRGaWx0ZXIsIHNoYWxsb3cpO1xuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufVxuLyoqIF9Qcm9wZXJ0eS9hY2Nlc3NvciBkZWNvcmF0b3JfLCBtYWtlcyBhIHByb3BlcnR5IG9ic2VydmFibGUgb24gZXZlcnkgaW5zdGFuY2UgYW5kIGNvbnZlcnRzIHZhbHVlcyB0byBzdHJpbmdzIHdoZW4gcmVhZCAoZW1wdHkgc3RyaW5nIGZvciBudWxsL3VuZGVmaW5lZC9OYU4pIFtyZXF1aXJlcyBFUzUrIHRhcmdldF0gW2RlY29yYXRvcl0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlX3N0cmluZyh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA9PT0gZmFsc2UpID8gU3RyaW5nKHZhbHVlKSA6IFwiXCI7XG4gICAgfSk7XG59XG4vKiogX1Byb3BlcnR5L2FjY2Vzc29yIGRlY29yYXRvcl8sIG1ha2VzIGEgcHJvcGVydHkgb2JzZXJ2YWJsZSBvbiBldmVyeSBpbnN0YW5jZSBhbmQgY29udmVydHMgdmFsdWVzIHRvIG51bWJlcnMgdXNpbmcgTnVtYmVyKC4uLikgd2hlbiByZWFkIFtyZXF1aXJlcyBFUzUrIHRhcmdldF0gW2RlY29yYXRvcl0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlX251bWJlcih0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE51bWJlcih2YWx1ZSk7IH0pO1xufVxuLyoqIF9Qcm9wZXJ0eS9hY2Nlc3NvciBkZWNvcmF0b3JfLCBtYWtlcyBhIHByb3BlcnR5IG9ic2VydmFibGUgb24gZXZlcnkgaW5zdGFuY2UsIGFzIGEgc2hhbGxvdyBvYnNlcnZhYmxlIHZhbHVlIChpLmUuIGRvZXMgbm90IHJlYWQgdmFsdWVzIGZyb20gb2JzZXJ2YWJsZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhpcyBwcm9wZXJ0eTsgYW5kIGRvZXMgbm90IGNvbnZlcnQgYXJyYXlzIHRvIG9ic2VydmFibGUgYXJyYXlzIG5vciBvYmplY3RzIHRvIG9ic2VydmFibGUgb2JqZWN0cykgW3JlcXVpcmVzIEVTNSsgdGFyZ2V0XSBbZGVjb3JhdG9yXSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmFibGVfc2hhbGxvdyh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG59XG4vKiogX1Byb3BlcnR5L2FjY2Vzc29yIGRlY29yYXRvcl8sIG1ha2VzIGEgcHJvcGVydHkgb2JzZXJ2YWJsZSBvbiBldmVyeSBpbnN0YW5jZSBhbmQgZW5mb3JjZXMgdGhhdCB2YWx1ZXMgYXJlIG5vdCB1bmRlZmluZWQgb3IgbnVsbCB3aGVuIHJlYWQgKHRocm93cyBUeXBlRXJyb3IpIGFuZCB0aGF0IHVuZGVmaW5lZC9udWxsIHZhbHVlcyBjYW5ub3QgYmUgc2V0IChhbHNvIHRocm93cyBUeXBlRXJyb3IpIFtyZXF1aXJlcyBFUzUrIHRhcmdldF0gW2RlY29yYXRvcl0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlX25vdF9udWxsKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGUodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioa2V5ICsgXCIgaXMgXCIgKyB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGtleSArIFwiIGNhbm5vdCBiZSBcIiArIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCBBbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlX25vbk51bGwoKSB7XG4gICAgcmV0dXJuIG9ic2VydmFibGVfbm90X251bGwuY2FsbCh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG59XG4vKiogX1Byb3BlcnR5L2FjY2Vzc29yIGRlY29yYXRvcl8sIG1ha2VzIGEgcHJvcGVydHkgb2JzZXJ2YWJsZSBvbiBldmVyeSBpbnN0YW5jZSBhbmQgZW5mb3JjZXMgdGhhdCB2YWx1ZXMgYXJlIG5vdCB1bmRlZmluZWQgb3IgbnVsbCB3aGVuIHJlYWQgKHRocm93cyBUeXBlRXJyb3IpIGFuZCB0aGF0IG9ubHkgaW5zdGFuY2VzIG9mIE9iamVjdCBjYW4gYmUgc2V0LCB3aGljaCBhcmUgc2VhbGVkIGF1dG9tYXRpY2FsbHkgW3JlcXVpcmVzIEVTNSsgdGFyZ2V0XSBbZGVjb3JhdG9yXSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmFibGVfc2VhbCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGtleSArIFwiIGlzIFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihrZXkgKyBcIiBtdXN0IGJlIGFuIE9iamVjdCwgbm90IFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmlzU2VhbGVkKHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0LnNlYWwodmFsdWUpO1xuICAgIH0pO1xufVxuLyoqIF9Qcm9wZXJ0eS9hY2Nlc3NvciBkZWNvcmF0b3JfLCBtYWtlcyBhIHByb3BlcnR5IG9ic2VydmFibGUgb24gZXZlcnkgaW5zdGFuY2UgYW5kIGVuZm9yY2VzIHRoYXQgdmFsdWVzIGFyZSBub3QgdW5kZWZpbmVkIG9yIG51bGwgd2hlbiByZWFkICh0aHJvd3MgVHlwZUVycm9yKSBhbmQgdGhhdCBvbmx5IGluc3RhbmNlcyBvZiBPYmplY3QgY2FuIGJlIHNldCwgd2hpY2ggYXJlIGZyb3plbiBhdXRvbWF0aWNhbGx5IFtyZXF1aXJlcyBFUzUrIHRhcmdldF0gW2RlY29yYXRvcl0gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlX2ZyZWV6ZSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIHJldHVybiBvYnNlcnZhYmxlKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGtleSArIFwiIGlzIFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihrZXkgKyBcIiBtdXN0IGJlIGFuIE9iamVjdCwgbm90IFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gICAgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXN5bmMvT2JzZXJ2YWJsZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCB7IGRlZmVyIH0gZnJvbSBcIi4vRGVmZXJcIjtcbmltcG9ydCB7IE9ic2VydmFibGVWYWx1ZSwgYXNzZXJ0VW5vYnNlcnZlZCwgdW5vYnNlcnZlZCB9IGZyb20gXCIuL09ic2VydmFibGVcIjtcbmltcG9ydCB7IG1ha2VQcm9wZXJ0eU9ic2VydmFibGUsIGRlbGV0ZU9ic2VydmFibGVQcm9wZXJ0eSB9IGZyb20gXCIuL09ic2VydmFibGVPYmplY3RcIjtcbjtcbi8qKiBFbmNhcHN1bGF0ZXMgYEFycmF5YCB3aXRoIG9ic2VydmFibGUgcHJvcGVydGllczsgdGhlIHJlc3VsdCB3b3JrcyBleGFjdGx5IGxpa2UgYSByZWd1bGFyIGFycmF5LCBidXQgc2V0dGluZyBlbGVtZW50cyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIGFycmF5ICg+PSBsZW5ndGgpIGRvZXMgTk9UIHdvcms6IGxlbmd0aCBtdXN0IGJlIHNldCBmaXJzdCAqL1xudmFyIE9ic2VydmFibGVBcnJheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIENyZWF0ZSBhIG5ldyBlbXB0eSBgT2JzZXJ2YWJsZUFycmF5YCBpbnN0YW5jZSAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVBcnJheSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYXNzZXJ0VW5vYnNlcnZlZCgpO1xuICAgICAgICB2YXIgX2xlbmd0aCA9IE9ic2VydmFibGVWYWx1ZS5mcm9tVmFsdWUoMCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9sZW5ndGgudmFsdWU7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgbmV3IG51bWVyaWMgcHJvcGVydGllcyBvYnNlcnZhYmxlXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRMZW5ndGggPSBfbGVuZ3RoLmdldExhc3RWYWx1ZSgpIHx8IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRMZW5ndGggPCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BlcnR5T2JzZXJ2YWJsZShfdGhpcywgY3VycmVudExlbmd0aCsrKTtcbiAgICAgICAgICAgICAgICAvLyBjbGVhciByZW1vdmVkIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gdmFsdWU7IGwgPCBjdXJyZW50TGVuZ3RoOyBsKyspXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZU9ic2VydmFibGVQcm9wZXJ0eShfdGhpcywgbCk7XG4gICAgICAgICAgICAgICAgX2xlbmd0aC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBhbiBgT2JzZXJ2YWJsZUFycmF5YCBvdXQgb2YgYSByZWd1bGFyIEFycmF5ICovXG4gICAgT2JzZXJ2YWJsZUFycmF5LmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9ic2VydmFibGVBcnJheSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICByZXN1bHRbaV0gPSBhcnJheVtpXTtcbiAgICAgICAgcmVzdWx0Lmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBDcmVhdGUgYW4gYE9ic2VydmFibGVBcnJheWAgdGhhdCB0YWtlcyBhcnJheSBlbGVtZW50cyBmcm9tIHRoZSBhcnJheSBpbiBnaXZlbiBgT2JzZXJ2YWJsZVZhbHVlYCwgb3IgdGhlIHZhbHVlIGl0c2VsZiBhcyBhIHNpbmdsZSBlbGVtZW50IGlmIGl0IGlzIG5vdCBhbiBhcnJheSwgb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkOyBjaGFuZ2VzIGluIGFycmF5IGVsZW1lbnRzIGFuZC9vciBvYnNlcnZhYmxlIHZhbHVlcyBhcmUgcmVmbGVjdGVkIGFzeW5jaHJvbm91c2x5OyB1c2UgdGhlIGBsYXp5YCBhcmd1bWVudCB0byBkZWZlciBpbml0aWFsaXphdGlvbiBvZiBhcnJheSBlbGVtZW50cyB1bnRpbCB0aGUgYC5sZW5ndGhgIHByb3BlcnR5IGlzIGFjY2Vzc2VkICovXG4gICAgT2JzZXJ2YWJsZUFycmF5LmZyb21PYnNlcnZhYmxlVmFsdWUgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZVZhbHVlLCBsYXp5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JzZXJ2YWJsZUFycmF5KCk7XG4gICAgICAgIC8vIHByb3h5IGxlbmd0aCBhbmQgYWxsIG51bWVyaWMgcHJvcGVydGllcyBpbiByZXN1bHRcbiAgICAgICAgdmFyIF9sZW5ndGggPSAwO1xuICAgICAgICB2YXIgbWFrZU1hcCA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiBuZXcgT2JzZXJ2YWJsZVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9ic2VydmFibGVWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IDAgJiYgdmFsdWUgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvYnNlcnZhYmxlVmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0xlbmd0aCA9ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbHVlLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgIGlmIChuZXdMZW5ndGggPiBfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBuZXcgbnVtZXJpYyBwcm9wZXJ0aWVzIG9ic2VydmFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSBfbGVuZ3RoOyBsIDwgbmV3TGVuZ3RoOyBsKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BlcnR5T2JzZXJ2YWJsZShyZXN1bHQsIGwsIG1ha2VNYXAobCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgcmVtb3ZlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gbmV3TGVuZ3RoOyBsIDwgX2xlbmd0aDsgbCsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZU9ic2VydmFibGVQcm9wZXJ0eShyZXN1bHQsIGwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9sZW5ndGggPSBuZXdMZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1vZGlmeSBsZW5ndGggb2YgbWFwcGVkIGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhbGwgdmFsdWVzXG4gICAgICAgIGlmICghbGF6eSlcbiAgICAgICAgICAgIHVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzdWx0Lmxlbmd0aDsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogQ3JlYXRlIGEgcmVhZC1vbmx5IGBPYnNlcnZhYmxlQXJyYXlgIHdpdGggZWFjaCB2YWx1ZSBvZiB0aGUgb3JpZ2luYWwgYXJyYXkgbWFwcGVkIHRvIHRoZSByZXN1bHQgb2YgdGhlIGdpdmVuIGdldHRlciBmdW5jdGlvbjsgb2JzZXJ2YWJsZSB2YWx1ZXMgdXNlZCBpbiB0aGUgbWFwIGZ1bmN0aW9uIGFyZSBub3Qgb2JzZXJ2ZWQgKGxpa2UgYE9ic2VydmFibGVWYWx1ZSNtYXBgKTsgdGhlIGdldHRlciBpcyBjYWxsZWQgZm9yIGNvbWJpbmF0aW9ucyBvZiB2YWx1ZSBhbmQgaW5kZXggKGkuZS4gZGVsZXRpbmcgYSB2YWx1ZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzb3VyY2UgYXJyYXkgd2lsbCB0cmlnZ2VyIGNoYW5nZXMgZm9yIGFsbCBlbGVtZW50cyBhZnRlciBpdDsgaWYgdGhlIGluZGV4IGlzIG5vdCBpbXBvcnRhbnQgdGhlbiB1c2UgYC5tYXBBc3luY1ZhbHVlc2AgaW5zdGVhZCk7IHRoZSByZXN1bHRpbmcgYXJyYXkgbGVuZ3RoIGNoYW5nZXMgYWxvbmcgd2l0aCB0aGUgb3JpZ2luYWwgYXJyYXkgbGVuZ3RoOyB1c2UgdGhlIGBsYXp5YCBhcmd1bWVudCB0byBkZWZlciBpbml0aWFsaXphdGlvbiBvZiBhcnJheSBlbGVtZW50cyB1bnRpbCB0aGUgYC5sZW5ndGhgIHByb3BlcnR5IGlzIGFjY2Vzc2VkICovXG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5tYXBBc3luYyA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZywgbGF6eSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9ic2VydmFibGVBcnJheSgpO1xuICAgICAgICAvLyBrZWVwIGxlbmd0aCBpbiBhbiBvYnNlcnZhYmxlIGp1c3QgbGlrZSB0aGUgcHJvcGVydGllcyB0byBhdm9pZFxuICAgICAgICAvLyB1bmV4cGVjdGVkIGRpZmZlcmVuY2VzIGluIGNoYW5nZSBwcm9wYWdhdGlvbiB0aW1pbmdzXG4gICAgICAgIHZhciBvYnNlcnZhYmxlTGVuZ3RoID0gbmV3IE9ic2VydmFibGVWYWx1ZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5sZW5ndGg7IH0pO1xuICAgICAgICAvLyBwcm94eSBhbGwgbnVtZXJpYyBwcm9wZXJ0aWVzIGluIHJlc3VsdFxuICAgICAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgICAgIHZhciBtYWtlTWFwID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBsYXN0VmFsdWUgPSB7fTtcbiAgICAgICAgICAgIHZhciBtYXBwZWQgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGxhc3RWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcHBlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICBtYXBwZWQudmFsdWUgPSB1bm9ic2VydmVkKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGkgPj0gMCAmJiBpIDwgX3RoaXMubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcgfHwgcmVzdWx0LCB2YWx1ZSwgaSwgX3RoaXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9LCBsYXN0VmFsdWUgPSB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdMZW5ndGggPSBvYnNlcnZhYmxlTGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXdMZW5ndGggPiBfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBuZXcgbnVtZXJpYyBwcm9wZXJ0aWVzIG9ic2VydmFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSBfbGVuZ3RoOyBsIDwgbmV3TGVuZ3RoOyBsKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BlcnR5T2JzZXJ2YWJsZShyZXN1bHQsIGwsIG1ha2VNYXAobCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3TGVuZ3RoIDwgX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB1bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIHJlbW92ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IG5ld0xlbmd0aDsgbCA8IF9sZW5ndGg7IGwrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVPYnNlcnZhYmxlUHJvcGVydHkocmVzdWx0LCBsKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfbGVuZ3RoID0gbmV3TGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb2RpZnkgbGVuZ3RoIG9mIG1hcHBlZCBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGluaXRpYWxpemUgYWxsIHZhbHVlc1xuICAgICAgICBpZiAoIWxhenkpXG4gICAgICAgICAgICB1bm9ic2VydmVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdC5sZW5ndGg7IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqIENyZWF0ZSBhIHJlYWQtb25seSBPYnNlcnZhYmxlQXJyYXkgd2l0aCBlYWNoIHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBhcnJheSBtYXBwZWQgdG8gdGhlIHJlc3VsdCBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb247IG9ic2VydmFibGUgdmFsdWVzIHVzZWQgaW4gdGhlIG1hcCBmdW5jdGlvbiBhcmUgbm90IG9ic2VydmVkIChsaWtlIE9ic2VydmFibGVWYWx1ZSBtYXAgbWV0aG9kKTsgdGhlIHJlc3VsdGluZyBhcnJheSBsZW5ndGggY2hhbmdlcyBhbG9uZyB3aXRoIHRoZSBvcmlnaW5hbCBhcnJheSBsZW5ndGg7IHRoaXMgbWV0aG9kIGlzIHNsaWdodGx5IG1vcmUgZXhwZW5zaXZlIHRoYW4gbWFwQXN5bmMgZm9yIGxhcmdlciBhcnJheXMsIGVzcGVjaWFsbHkgaW4gbm9uLUVTNiBlbnZpcm9ubWVudHMsIGJ1dCBpcyBvdmVyYWxsIG1vcmUgZWZmaWNpZW50IGJlY2F1c2UgaXQgYXZvaWRzIHVubmVjZXNzYXJ5IGNhbGxiYWNrcyB3aGVuIHN1YnNjcmliZWQgdG87IHVzZSB0aGUgYGxhenlgIGFyZ3VtZW50IHRvIGRlZmVyIGluaXRpYWxpemF0aW9uIG9mIGFycmF5IGVsZW1lbnRzIHVudGlsIHRoZSBgLmxlbmd0aGAgcHJvcGVydHkgaXMgYWNjZXNzZWQgKi9cbiAgICBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLm1hcEFzeW5jVmFsdWVzID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnLCBsYXp5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgcHJldmlvdXNseSBzZWVuIHZhbHVlcyBpbiBhIE1hcCAod2l0aCBcInNlbWktcG9seWZpbGxcIilcbiAgICAgICAgdmFyIF9nZXQsIF9hZGQ7XG4gICAgICAgIHZhciBfZGVsO1xuICAgICAgICB2YXIgX2ZvckVhY2g7XG4gICAgICAgIGlmICh0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIHVzZSBuYXRpdmUgTWFwIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgX2dldCA9IG1hcC5nZXQuYmluZChtYXApLCBfYWRkID0gbWFwLnNldC5iaW5kKG1hcCk7XG4gICAgICAgICAgICBfZm9yRWFjaCA9IG1hcC5mb3JFYWNoLmJpbmQobWFwKTtcbiAgICAgICAgICAgIF9kZWwgPSBtYXAuZGVsZXRlLmJpbmQobWFwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZSBtaW5pbWFsIGFwcHJveGltYXRpb24gb2YgTWFwIG1ldGhvZHNcbiAgICAgICAgICAgIHZhciBvd25NYXAgPSBbXTtcbiAgICAgICAgICAgIF9hZGQgPSBmdW5jdGlvbiAodiwgbykgeyBvd25NYXAucHVzaCh7IHY6IHYsIG86IG8gfSk7IH07XG4gICAgICAgICAgICBfZ2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgIG93bk1hcC5zb21lKGZ1bmN0aW9uICh4KSB7IHJldHVybiAoeC52ID09PSB2ID8gKHJlc3VsdCA9IHgubywgdHJ1ZSkgOiBmYWxzZSk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX2RlbCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgb3duTWFwLnNvbWUoZnVuY3Rpb24gKHgsIGkpIHsgcmV0dXJuICh4LnYgPT09IHYgPyAhIW93bk1hcC5zcGxpY2UoaSwgMSkgOiBmYWxzZSk7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9mb3JFYWNoID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICBvd25NYXAuc2xpY2UoMCkuZm9yRWFjaChmdW5jdGlvbiAoeCkgeyByZXR1cm4gZih4Lm8sIHgudik7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGFsbCBjdXJyZW50IGlucHV0cyB0byBiZSBhYmxlIHRvIHBydW5lIHRoZSBtYXBcbiAgICAgICAgLy8gKHJlYWxseSBvbmx5IHdvcmtzIHdoZW4gZW50aXJlIGFycmF5IGlzIHN1YnNjcmliZWQgdG8pXG4gICAgICAgIHZhciBjdXJyZW50SW5wdXRzID0gW107XG4gICAgICAgIHZhciB0aW1lciA9IC0xO1xuICAgICAgICB2YXIgZGVmZXJQcnVuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lciA+PSAwKVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB2YXIgbXlUaW1lciA9IHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG15VGltZXIgPT09IHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5wdXRzLmxlbmd0aCA+IGxlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbnB1dHMubGVuZ3RoID0gbGVuO1xuICAgICAgICAgICAgICAgICAgICBfZm9yRWFjaChmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudElucHV0cy5pbmRleE9mKHYpIDwgMCAmJiBfZGVsKHYpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcHJ1bmUgdGhlIG1hcCB3aGVuIHRoZSBhcnJheSBnZXRzIHNob3J0ZXJcbiAgICAgICAgdmFyIHBydW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIHN1YnNjcmliZVRvUHJ1bmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcnVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5ldyBPYnNlcnZhYmxlVmFsdWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubGVuZ3RoOyB9KS5zdWJzY3JpYmUoZnVuY3Rpb24gKGxlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudElucHV0cy5sZW5ndGggPiBsZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlclBydW5lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbWFwIGlucHV0IGFycmF5IHRvIGFub3RoZXIgb2JzZXJ2YWJsZSBhcnJheVxuICAgICAgICB2YXIgb3duTmFOID0ge30sIG93blVuZGVmaW5lZCA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBBc3luYyhmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgdmFyIGRlZnYgPSB2ID09PSB1bmRlZmluZWQgPyBvd25VbmRlZmluZWQgOlxuICAgICAgICAgICAgICAgICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiAmJiBpc05hTih2KSkgPyBvd25OYU4gOiB2O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbnB1dHNbaV0gIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50SW5wdXRzW2ldICE9PSBkZWZ2KVxuICAgICAgICAgICAgICAgIGRlZmVyUHJ1bmUoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcnVuaW5nKVxuICAgICAgICAgICAgICAgIHN1YnNjcmliZVRvUHJ1bmUoKTtcbiAgICAgICAgICAgIGN1cnJlbnRJbnB1dHNbaV0gPSBkZWZ2O1xuICAgICAgICAgICAgLy8gcmV0dXJuIGxhc3QgcmVzdWx0IGZvciBzYW1lIGlucHV0IHZhbHVlIGlmIGZvdW5kXG4gICAgICAgICAgICB2YXIgZm91bmQgPSBfZ2V0KGRlZnYpO1xuICAgICAgICAgICAgaWYgKGZvdW5kICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgLy8gZ2V0IHJlc3VsdCBmb3IgY3VycmVudCBpbnB1dCB2YWx1ZSBhbmQga2VlcCBpdCBmb3IgbGF0ZXJcbiAgICAgICAgICAgIHZhciBvID0gY2FsbGJhY2suY2FsbCh0aGlzQXJnIHx8IF90aGlzLCB2KTtcbiAgICAgICAgICAgIF9hZGQoZGVmdiwgbyk7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSwgdW5kZWZpbmVkLCBsYXp5KTtcbiAgICB9O1xuICAgIC8qKiBDcmVhdGUgYSByZWFkLW9ubHkgb2JzZXJ2YWJsZSBhcnJheSB0aGF0IGNvbnRhaW5zIGFsbCB2YWx1ZXMgZnJvbSB0aGUgb3JpZ2luYWwgYXJyYXkgYW5kIGFsbCBuZXN0ZWQgKG9ic2VydmFibGUpIGFycmF5cywgb3B0aW9uYWxseSByZW1vdmluZyBnYXBzIChpLmUuIHVuZGVmaW5lZCBvciBudWxsIGVsZW1lbnRzKTsgdGhlIHJlc3VsdGluZyBhcnJheSBhbmQgaXRzIGxlbmd0aCBfYWx3YXlzXyBjaGFuZ2UgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIGFycmF5LCBldmVuIGlmIG5vdCBzdWJzY3JpYmVkIHRvIGEgdmFsdWUgb3IgdGhlIGxlbmd0aCBwcm9wZXJ0eTsgdXNlIHRoZSBgbGF6eWAgYXJndW1lbnQgdG8gZGVmZXIgaW5pdGlhbGl6YXRpb24gb2YgYXJyYXkgZWxlbWVudHMgdW50aWwgdGhlIGAubGVuZ3RoYCBwcm9wZXJ0eSBpcyBhY2Nlc3NlZCAqL1xuICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuZmxhdHRlbkFzeW5jID0gZnVuY3Rpb24gKHJlbW92ZUdhcHMsIGxhenkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gY3JlYXRlIGFuIG9ic2VydmFibGUgdGhhdCBhbGwgb3RoZXIgcHJvcGVydGllcyBkZXBlbmQgb247IHRoaXMgaXNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGZsYXR0ZW5pbmcgYWN0dWFsbHkgaGFwcGVucywgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgdmFyIG5vbk9ic2VydmFibGVGbGF0ID0gW107XG4gICAgICAgIHZhciBjb3VudCA9IDAsIGxhc3RDb3VudDtcbiAgICAgICAgdmFyIG8gPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciBmID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGFfMSA9IGE7IF9pIDwgYV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGFfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2Ugb24gYXJyYXlzLCB0byBhZGQgZWxlbWVudHMgaW4gdGhpcyBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgZih2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghcmVtb3ZlR2FwcyB8fCB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGVsZW1lbnQgdG8gcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICBub25PYnNlcnZhYmxlRmxhdFtpKytdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmKF90aGlzKTtcbiAgICAgICAgICAgIG5vbk9ic2VydmFibGVGbGF0Lmxlbmd0aCA9IGk7XG4gICAgICAgICAgICAvLyBhbHdheXMgcmV0dXJuIHNvbWV0aGluZyBuZXcgdG8gZm9yY2UgdXBkYXRlc1xuICAgICAgICAgICAgcmV0dXJuIChsYXN0Q291bnQgPSArK2NvdW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHVzZSB0aGUgb2JzZXJ2YWJsZSB2YWx1ZSB0byB1cGRhdGUgZmxhdHRlbmVkIGFycmF5XG4gICAgICAgIC8vICh0ZW1wb3JhcmlseSBzdWJzY3JpYmUgdG8gYXZvaWQgZmxhdHRlbmluZyBhZ2FpbiB3aXRoaW5cbiAgICAgICAgLy8gY3VycmVudCBkZWZlciB0aW1lZnJhbWUpXG4gICAgICAgIGZ1bmN0aW9uIGZsYXR0ZW5BdXRvU3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgaWYgKCFvLnN1YnNjcmliZWQgJiYgIU9ic2VydmFibGVWYWx1ZS5pc09ic2VydmluZygpKSB7XG4gICAgICAgICAgICAgICAgdW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gby5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHY7IH0pLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7IHRlbXAuY2xlYXIoKTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3h5IGFsbCBmbGF0dGVuZWQgcHJvcGVydGllcyBpbiByZXN1bHRcbiAgICAgICAgdmFyIG1ha2VJdGVtID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBpbyA9IG5ldyBPYnNlcnZhYmxlVmFsdWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGZsYXR0ZW4gdGhlIGFycmF5IGZpcnN0LCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBmbGF0dGVuQXV0b1N1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub25PYnNlcnZhYmxlRmxhdFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlvO1xuICAgICAgICB9O1xuICAgICAgICAvLyBub3csIG1hcCBhbGwgcHJvcGVydGllcyBmcm9tIHRoaXMgb2JzZXJ2YWJsZVxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9ic2VydmFibGVBcnJheSgpO1xuICAgICAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGZsYXR0ZW4gdGhlIGFycmF5IGZpcnN0LCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBmbGF0dGVuQXV0b1N1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdMZW5ndGggPSBub25PYnNlcnZhYmxlRmxhdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCA+IF9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIG5ldyBudW1lcmljIHByb3BlcnRpZXMgb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IF9sZW5ndGg7IGwgPCBuZXdMZW5ndGg7IGwrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcGVydHlPYnNlcnZhYmxlKHJlc3VsdCwgbCwgbWFrZUl0ZW0obCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3TGVuZ3RoIDwgX2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB1bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIHJlbW92ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IG5ld0xlbmd0aDsgbCA8IF9sZW5ndGg7IGwrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVPYnNlcnZhYmxlUHJvcGVydHkocmVzdWx0LCBsKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfbGVuZ3RoID0gbmV3TGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb2RpZnkgbGVuZ3RoIG9mIGZsYXR0ZW5lZCBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGluaXRpYWxpemUgYWxsIHZhbHVlc1xuICAgICAgICBpZiAoIWxhenkpXG4gICAgICAgICAgICB1bm9ic2VydmVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdC5sZW5ndGg7IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqIFJlcHJlc2VudCBvYnNlcnZhYmxlIGFycmF5cyBhcyByZWd1bGFyIEpTT04gYXJyYXlzICovXG4gICAgT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKDApO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVBcnJheTtcbn0oKSk7XG5leHBvcnQgeyBPYnNlcnZhYmxlQXJyYXkgfTtcbnZhciBfbWFwQXN5bmMgPSBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLm1hcEFzeW5jO1xudmFyIF9tYXBBc3luY1ZhbHVlcyA9IE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUubWFwQXN5bmNWYWx1ZXM7XG52YXIgX2ZsYXR0ZW5Bc3luYyA9IE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUuZmxhdHRlbkFzeW5jO1xudmFyIF90b0pTT04gPSBPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnRvSlNPTjtcbk9ic2VydmFibGVBcnJheS5wcm90b3R5cGUgPSBuZXcgQXJyYXk7XG5PYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2JzZXJ2YWJsZUFycmF5O1xuT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5tYXBBc3luYyA9IF9tYXBBc3luYztcbk9ic2VydmFibGVBcnJheS5wcm90b3R5cGUubWFwQXN5bmNWYWx1ZXMgPSBfbWFwQXN5bmNWYWx1ZXM7XG5PYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLmZsYXR0ZW5Bc3luYyA9IF9mbGF0dGVuQXN5bmM7XG5PYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLnRvSlNPTiA9IF90b0pTT047XG4vLyB0aGVzZSBmdW5jdGlvbnMgc2hvdWxkIG5vdCBkZXBlbmQgb24gLmxlbmd0aCBidXQgd291bGQgaWYgbm90IHdyYXBwZWRcbnZhciBfYXJyYXlQdXNoID0gT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5wdXNoO1xuT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX2FycmF5UHVzaC5hcHBseShfdGhpcywgaXRlbXMpOyB9KTtcbn07XG52YXIgX2FycmF5VW5zaGlmdCA9IE9ic2VydmFibGVBcnJheS5wcm90b3R5cGUudW5zaGlmdDtcbk9ic2VydmFibGVBcnJheS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB1bm9ic2VydmVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9hcnJheVVuc2hpZnQuYXBwbHkoX3RoaXMsIGl0ZW1zKTsgfSk7XG59O1xuLy8gb3ZlcnJpZGUgY29uY2F0LCB3aGljaCBvdGhlcndpc2Ugd291bGQgc2VlIE9ic2VydmFibGVBcnJheXMgYXMgdmFsdWVzOlxuT2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkodGhpcy5zbGljZSgwKSwgaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAoaXRlbSBpbnN0YW5jZW9mIE9ic2VydmFibGVBcnJheSkgPyBpdGVtLnNsaWNlKDApIDogaXRlbTsgfSkpO1xufTtcbi8qKiBSZXR1cm5zIGFuIE9ic2VydmFibGVBcnJheSBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgcmVzdWx0IG9mIGdpdmVuIGZ1bmN0aW9uOiBpZiB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgYW4gYXJyYXksIHRoZW4gYWxsIGVsZW1lbnRzIGFyZSBjb3BpZWQgdG8gdGhlIHJlc3VsdDsgaWYgdGhlIHJldHVybmVkIHZhbHVlIGlzIGFuIG9ic2VydmFibGUgYXJyYXksIGFsbCBlbGVtZW50cyBhcmUgcHJveGllZDsgaWYgdGhlIHJldHVybmVkIHZhbHVlIGlzIG5vdCBhbiBhcnJheSwgdGhlIHJlc3VsdCBjb250YWlucyB0aGlzIHZhbHVlIGFzIGEgc2luZ2xlIGVsZW1lbnQ7IGlmIHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCB3aWxsIGJlIGFuIGVtcHR5IGFycmF5OyBjaGFuZ2VzIGluIHZhbHVlcy9lbGVtZW50cyBhcmUgcmVmbGVjdGVkIGFzeW5jaHJvbm91c2x5ICovXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZUFycmF5KGYpIHtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZUFycmF5LmZyb21PYnNlcnZhYmxlVmFsdWUobmV3IE9ic2VydmFibGVWYWx1ZShmKSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXN5bmMvT2JzZXJ2YWJsZUFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IHsgZGVmZXIgfSBmcm9tIFwiLi9EZWZlclwiO1xuaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gXCIuL1Byb21pc2VcIjtcbmltcG9ydCB7IFNpZ25hbCB9IGZyb20gXCIuL1NpZ25hbFwiO1xuaW1wb3J0IHsgbWFrZU9iamVjdE9ic2VydmFibGUgfSBmcm9tIFwiLi9PYnNlcnZhYmxlT2JqZWN0XCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlQXJyYXkgfSBmcm9tIFwiLi9PYnNlcnZhYmxlQXJyYXlcIjtcbi8qKiBXYXRjaGVkIG9ic2VydmFibGUgY3VycmVudGx5IGV2YWx1YXRpbmcsIGlmIGFueTsgdXNlZCB0byBjb25uZWN0IGRlcGVuZGVuY2llcyB0aHJvdWdoIHNpZ25hbHMgKi9cbnZhciBjdXJyZW50V2F0Y2hlZEV2YWxpbmc7XG4vKiogVW53YXRjaGVkIG9ic2VydmFibGUgY3VycmVudGx5IGV2YWx1YXRpbmcsIGlmIGFueTsgdXNlZCB0byBjb2xsZWN0IGRlcGVuZGVuY2llcyBmb3IgZGlydHkgY2hlY2tpbmcgKi9cbnZhciBjdXJyZW50VW53YXRjaGVkRXZhbGluZztcbi8qKiBAaW50ZXJuYWwgVGhyb3dzIGFuIGVycm9yIGlmIGN1cnJlbnRseSBydW5uaW5nIGFuIG9ic2VydmFibGUgZ2V0dGVyICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VW5vYnNlcnZlZCgpIHtcbiAgICBpZiAoY3VycmVudFdhdGNoZWRFdmFsaW5nIHx8IGN1cnJlbnRVbndhdGNoZWRFdmFsaW5nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYnNlcnZhYmxlIGdldHRlciBtdXN0IGJlIGEgcHVyZSBmdW5jdGlvbiwgXCIgK1xuICAgICAgICAgICAgXCJjYW5ub3QgY3JlYXRlIG9yIHNldCBvdGhlciBvYnNlcnZhYmxlc1wiKTtcbn1cbi8qKiBSZXByZXNlbnRzIGFuIG9ic2VydmFibGUgdmFsdWUgKHdpdGggdGhlIHZhbHVlIGl0c2VsZiBpbiBgLnZhbHVlYCkgKi9cbnZhciBPYnNlcnZhYmxlVmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgKHNpbmdsZSkgb2JzZXJ2ZWQgdmFsdWUgdXNpbmcgb3B0aW9uYWwgZ2V0dGVyIGFuZCBzZXR0ZXIgZnVuY3Rpb25zOyBub3RlIHRoYXQgZ2V0dGVycyAqc2hvdWxkKiBiZSBwdXJlIGZ1bmN0aW9ucyB3aXRob3V0IHNpZGUgZWZmZWN0cywgY3JlYXRpbmcgb3Igc2V0dGluZyBvdGhlciBvYnNlcnZhYmxlcyBmcm9tIHRoZSBnZXR0ZXIgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3I7IGdldHRlciBpcyBub3QgY2FsbGVkIGltbWVkaWF0ZWx5IGJ1dCBvbmx5IHdoZW4gYmVpbmcgc3Vic2NyaWJlZCB0byBvciB3aGVuIG9idGFpbmluZyB0aGUgdmFsdWUgaXRzZWxmIChmcm9tIGAudmFsdWVgKSAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVWYWx1ZShnZXR0ZXIsIHNldHRlcikge1xuICAgICAgICAvKiogQGludGVybmFsIFVuaXF1ZSBJRCB1c2VkIHRvIHF1aWNrbHkgaW5kZXggZGVwZW5kYW50cyBvZiBvYnNlcnZhYmxlcyAqL1xuICAgICAgICB0aGlzLl91aWQgPSBTdHJpbmcoKytPYnNlcnZhYmxlVmFsdWUuVUlEKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBDb3VudGVyIHRoYXQgaXMgaW5jcmVtZW50ZWQgZXZlcnkgdGltZSB0aGUgdmFsdWUgYmVjb21lcyB1bnN0YWJsZSAoaS5lLiB2YWx1ZSBzZXQgZGlyZWN0bHksIGRlcGVuZGVuY3kgY2hhbmdlZCwgZXRjLikgKi9cbiAgICAgICAgdGhpcy5fZGlydHlJZHggPSAwO1xuICAgICAgICBhc3NlcnRVbm9ic2VydmVkKCk7XG4gICAgICAgIC8vIGhvbGQgb2ZmIG9uIGV2YWx1YXRpbmcgdW50aWwgdmFsdWUgZ2V0dGVyIGlzIGNhbGxlZFxuICAgICAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUlkeCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlcjtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBjdXJyZW50bHkgcnVubmluZyBpbiBhIHN1YnNjcmliZWQtdG8gb2JzZXJ2YWJsZSBjb250ZXh0IChpLmUuIGV2YWx1YXRpbmcgYW4gb2JzZXJ2YWJsZSB2YWx1ZSwgcmVjb3JkaW5nIGRlcGVuZGVuY2llcyBvbiBvdGhlciBvYnNlcnZhYmxlIHZhbHVlcyBiZWluZyBhY2Nlc3NlZCBmcm9tIHRoaXMgY29udGV4dCkgKi9cbiAgICBPYnNlcnZhYmxlVmFsdWUuaXNPYnNlcnZpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIWN1cnJlbnRXYXRjaGVkRXZhbGluZztcbiAgICB9O1xuICAgIC8qKiBFbmNhcHN1bGF0ZSBnaXZlbiB2YWx1ZSBhcyBhbiBPYnNlcnZhYmxlVmFsdWUgKi9cbiAgICBPYnNlcnZhYmxlVmFsdWUuZnJvbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKCk7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqIEVuY2Fwc3VsYXRlIGdpdmVuIHByb21pc2VkIHZhbHVlIGFzIGFuIE9ic2VydmFibGVWYWx1ZTsgdGhlIG9ic2VydmVkIHZhbHVlIHdpbGwgc3RhcnQgb3V0IGFzIGB1bmRlZmluZWRgIGJ1dCB0aGVuIGNoYW5nZXMgdG8gdGhlIGBQcm9taXNlYCByZXN1bHQgd2hlbiByZXNvbHZlZDsgb3IgaWYgcHJvbWlzZSB3YXMgcmVqZWN0ZWQsIGhhbmdzIG9uIHRvIHRoZSBlcnJvciBhbmQgdGhyb3dzIGl0IHdoZW4gcmV0cmlldmluZyB0aGUgb2JzZXJ2YWJsZSB2YWx1ZSAqL1xuICAgIE9ic2VydmFibGVWYWx1ZS5mcm9tUHJvbWlzZSA9IGZ1bmN0aW9uICh2YWx1ZVByb21pc2UpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBPYnNlcnZhYmxlVmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIHNob3J0Y3V0IHByb21pc2Ugc3RhdHVzIHRvIGF2b2lkIGFzeW5jXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gdmFsdWVQcm9taXNlLl9nZXRTdGF0dXMoKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCB2YWx1ZSB0byBcImVycm9yXCIgdG8gdHJpZ2dlciBjaGFuZ2Ugc2lnbmFsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9lcnJvciA9IHN0YXR1cy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll9ybyA9IHJlc3VsdC5fbmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHZhbHVlIHRvIHJlc29sdmVkIHByb21pc2UgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gc3RhdHVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuX3JvID0gcmVzdWx0Ll9uYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgbm90IGZ1bGZpbGxlZCB5ZXQsIHVzZSAudGhlbiBhbnl3YXk6XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBzZXQgdmFsdWUgdG8gcmVzb2x2ZWQgcHJvbWlzZSB2YWx1ZVxuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXN1bHQuX3JvID0gcmVzdWx0Ll9uYyA9IHRydWU7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gc2V0IHZhbHVlIHRvIFwiZXJyb3JcIiB0byB0cmlnZ2VyIGNoYW5nZSBzaWduYWxcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgIHJlc3VsdC5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIHJlc3VsdC5fcm8gPSByZXN1bHQuX25jID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogQ29ubmVjdCB0byBnaXZlbiBgU2lnbmFsYCwgYW5kIGNyZWF0ZSBhIHJlYWQtb25seSBvYnNlcnZhYmxlIHZhbHVlIHRoYXQgYWx3YXlzIGNvbnRhaW5zIHRoZSBsYXN0IGVtaXR0ZWQgc2lnbmFsIHZhbHVlIChpbml0aWFsbHkgdW5kZWZpbmVkOyB0aGUgdmFsdWUgaXMgb25seSBzZXQgYWZ0ZXIgdGhlIG5leHQgdGltZSB0aGUgc2lnbmFsIGlzIGVtaXR0ZWQpICovXG4gICAgT2JzZXJ2YWJsZVZhbHVlLmZyb21TaWduYWwgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKCk7XG4gICAgICAgIHJlc3VsdC5fcm8gPSB0cnVlO1xuICAgICAgICBzaWduYWwuX2Nvbm5lY3QoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJlc3VsdC5fcm8gPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHY7XG4gICAgICAgICAgICByZXN1bHQuX3JvID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogU2V0IGEgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgb2JzZXJ2YWJsZSB2YWx1ZSwgd2hpY2ggc2hvdWxkIHJldHVybiBhIGN1cnJlbnQgdmFsdWUsIG9yIGFub3RoZXIgT2JzZXJ2YWJsZVZhbHVlIGluc3RhbmNlLCBvciBzZXQgYC52YWx1ZWAgZGlyZWN0bHk7IG5vdGUgdGhhdCBnZXR0ZXJzICpzaG91bGQqIGJlIHB1cmUgZnVuY3Rpb25zIHdpdGhvdXQgc2lkZSBlZmZlY3RzLCBjcmVhdGluZyBvciBzZXR0aW5nIG90aGVyIG9ic2VydmFibGVzIGZyb20gdGhlIGdldHRlciB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvcjsgdGhlIGdldHRlciBpcyBvbmx5IGludm9rZWQgKGFzeW5jaHJvbm91c2x5KSBpZiBhIHZhbHVlIGhhZCBiZWVuIHNldCBwcmV2aW91c2x5IGFuZCBuZWVkcyB0byBiZSB1cGRhdGVkOyByZWFkaW5nIGAudmFsdWVgIGZyb20gdGhlIGdldHRlciByZXN1bHRzIGluIHRoZSB2YWx1ZSBwcmV2aW91c2x5IHNldCwgbm8gcmVjdXJzaW9uIG9jY3VyczsgcmV0dXJucyB0aGlzICovXG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5nZXR0ZXIgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAodGhpcy5fcm8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbW9kaWZ5IHRoaXMgb2JzZXJ2YWJsZSB2YWx1ZVwiKTtcbiAgICAgICAgYXNzZXJ0VW5vYnNlcnZlZCgpO1xuICAgICAgICB0aGlzLl9nZXR0ZXIgPSBmO1xuICAgICAgICAvLyByZW1vdmUgY3VycmVudCBzdGF0aWMgdmFsdWUgYW5kIHJlLWV2YWwgaWYgbmVlZGVkXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgXCJfdmFsXCIpKSB7XG4gICAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fdmFsO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNFdmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIChvbGQgZ2V0dGVyJ3MpIGRlcGVuZGVuY2llcyBpZiBjbGVhcmluZyBnZXR0ZXJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZURlcGVuZGVuY2llcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIFNldCBhIHNldHRlciBmdW5jdGlvbiBmb3IgdGhlIG9ic2VydmFibGUgdmFsdWU7IHNldHRpbmcgYC52YWx1ZWAgZGlyZWN0bHkgZnJvbSB0aGUgc2V0dGVyIHJlc3VsdHMgaW4gY2hhbmdpbmcgdGhlIHVuZGVybHlpbmcgb2JzZXJ2YWJsZSB2YWx1ZSAod2hpY2ggY2FuIGFsc28gYmUgcmVhZCBieSB0aGUgZ2V0dGVyLCBvciB0aGUgc2V0dGVyIGl0c2VsZiksIG5vIHJlY3Vyc2lvbiBvY2N1cnM7IHJldHVybnMgdGhpcyAqL1xuICAgIE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JvKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1vZGlmeSB0aGlzIG9ic2VydmFibGUgdmFsdWVcIik7XG4gICAgICAgIGFzc2VydFVub2JzZXJ2ZWQoKTtcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gZjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIC8qKiBPYnNlcnZhYmxlIHZhbHVlLCAocmUtKSBldmFsdWF0ZWQgb25seSBpZiBuZWNlc3Nhcnk7IHdoZW4gc2V0IHRvIGFuIGBPYnNlcnZhYmxlVmFsdWVgIGluc3RhbmNlLCB0aGlzIHByb3BlcnR5IHJldHVybnMgdGhhdCBpbnN0YW5jZSdzIHZhbHVlLCB1bnRpbCB0aGlzIHByb3BlcnR5IGlzIHNldCB0byBhbm90aGVyIHZhbHVlIChleGNlcHQgaWYgdGhlIGBPYnNlcnZhYmxlVmFsdWVgIGhhcyBhIHNldHRlciwgd2hpY2ggaXMgY2FsbGVkIGZpcnN0KTsgcGxhaW4gQXJyYXkgdmFsdWVzIGFyZSB0dXJuZWQgaW50byBgT2JzZXJ2YWJsZUFycmF5YCBpbnN0YW5jZXMsIGFuZCBwbGFpbiBPYmplY3QgaW5zdGFuY2VzIGludG8gYE9ic2VydmFibGVPYmplY3RgIGluc3RhbmNlcyAtLS0gdW5sZXNzIGAuc2hhbGxvd2AgaXMgc2V0IHRvIHRydWUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgLy8gcmV0dXJuIGN1cnJlbnQgdmFsdWUgaWYgcnVubmluZyBnZXR0ZXIsIHNldHRlciwgb3IgdmFsdWUgd2lsbCBub3RcbiAgICAgICAgICAgIC8vIGNoYW5nZSBhbmQgaXMgbm90IHByb3hpZWQgZnJvbSBhbm90aGVyIG9ic2VydmFibGUgdmFsdWU6XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0dGluZyAmJiAhdGhpcy5fc2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0dGluZyB8fCB0aGlzLl9zZXR0aW5nIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fbmMgJiYgISh0aGlzLl92YWwgaW5zdGFuY2VvZiBPYnNlcnZhYmxlVmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWw7XG4gICAgICAgICAgICAvLyByZWdpc3RlciBhcyBkZXBlbmRlbmN5IHRvIHByZXZpb3VzbHkgZXZhbHVhdGluZyBvYnNlcnZhYmxlXG4gICAgICAgICAgICBpZiAoY3VycmVudFdhdGNoZWRFdmFsaW5nKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRXYXRjaGVkRXZhbGluZy5fYWRkQ29ubmVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRVbndhdGNoZWRFdmFsaW5nKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRVbndhdGNoZWRFdmFsaW5nLl9hZGRDaGVjayh0aGlzKTtcbiAgICAgICAgICAgIC8vIHJlLWV2YWx1YXRlIGlmIG5lY2Vzc2FyeTpcbiAgICAgICAgICAgIHZhciBoYWRWYWx1ZSA9ICEhdGhpcy5fdmFsSWR4O1xuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5fdmFsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX25lZWRzRXZhbCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2xkQ29ubmVjdGlvbnMgPSB0aGlzLl9kZXBDb25uZWN0aW9ucztcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhpcyBpbnN0YW5jZSBhcyBjdXJyZW50bHkgZXZhbHVhdGluZyB0byBmaW5kIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgIHZhciBwcmV2V2F0Y2hlZCA9IGN1cnJlbnRXYXRjaGVkRXZhbGluZywgcHJldlVud2F0Y2hlZCA9IGN1cnJlbnRVbndhdGNoZWRFdmFsaW5nO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93YXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXYXRjaGVkRXZhbGluZyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlcENvbm5lY3Rpb25zID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VW53YXRjaGVkRXZhbGluZyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlcENoZWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9nZXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBnZXR0ZXIgcmVzdWx0IG9yIGxldCBnZXR0ZXIgc2V0IHZhbHVlIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9nZXR0ZXIuY2FsbCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9kaXJlY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0dGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHNvbGxpY2l0aW5nIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2F0Y2hlZEV2YWxpbmcgPSBwcmV2V2F0Y2hlZDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFVud2F0Y2hlZEV2YWxpbmcgPSBwcmV2VW53YXRjaGVkO1xuICAgICAgICAgICAgICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZENvbm5lY3Rpb25zID0gdGhpcy5fb2xkQ29ubmVjdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vbGRDb25uZWN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlcENvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1aWQgaW4gb2xkQ29ubmVjdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kZXBDb25uZWN0aW9uc1t1aWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRDb25uZWN0aW9uc1t1aWRdLmRpcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG1hcmsgdmFsdWUgYXMgdXAgdG8gZGF0ZVxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbElkeCA9IHRoaXMuX2RpcnR5SWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIG5ldyB2YWx1ZVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsO1xuICAgICAgICAgICAgLy8gcHJveHkgb3RoZXIgT2JzZXJ2YWJsZVZhbHVlcycgdmFsdWVzXG4gICAgICAgICAgICB2YXIgb2xkQ29ubmVjdGlvbiA9IHRoaXMuX3Byb3h5Q29ubmVjdGlvbjtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaGFsbG93ICYmIHZhbHVlIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dhdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2NyaWJlcnMgc2hvdWxkIGFsc28gYmUgbm90aWZpZWQgZm9yIHByb3h5IHZhbHVlIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gKHVudGlsIG5leHQgdmFsdWUgaXMgZXZhbHVhdGVkLCBvciB0aGlzIG9ic2VydmFibGUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5zdWJzY3JpYmVkIGZyb20pXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm94aWVkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWcgPSBwcm94aWVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm94eUNvbm5lY3Rpb24gPSBzaWcuY29ubmVjdChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl92YWwgPT09IHByb3hpZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdFN5bmModik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZENvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBvbGRDb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJveHlDb25uZWN0aW9uID09PSBvbGRDb25uZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJveHlDb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW1pdCBzaWduYWwocykgaWYgY2hhbmdlZFxuICAgICAgICAgICAgaWYgKGhhZFZhbHVlICYmIHRoaXMuX3ZhbCAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXhDYWxsYmFja3MgJiYgdGhpcy5fYXV4Q2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYoKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0U3luYyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2dldHRpbmcgJiYgIXRoaXMuX3NldHRpbmcpXG4gICAgICAgICAgICAgICAgYXNzZXJ0VW5vYnNlcnZlZCgpO1xuICAgICAgICAgICAgLy8gY29udmVydCBwbGFpbiBhcnJheXMgYW5kIG9iamVjdHMgKHVubGVzcyBhYm91dCB0byBydW4gc2V0dGVyKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYWxsb3cgJiYgKCF0aGlzLl9zZXR0ZXIgfHwgdGhpcy5fc2V0dGluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIE9ic2VydmFibGVBcnJheSBpbnN0YW5jZXMgb3V0IG9mIHBsYWluIEFycmF5c1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB1bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gT2JzZXJ2YWJsZUFycmF5LmZyb21BcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtYWtlIE9ic2VydmFibGVPYmplY3QgaW5zdGFuY2VzIG91dCBvZiBwbGFpbiBPYmplY3RzXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1ha2VPYmplY3RPYnNlcnZhYmxlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgd2hhdCB0byBkbyB3aXRoIHRoZSBuZXcgdmFsdWU6XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0dGluZykge1xuICAgICAgICAgICAgICAgIC8vIHNldCB2YWx1ZSBkaXJlY3RseSwgbm8gc2lnbmFscyBidXQgbWFyayBhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbElkeCA9ICsrdGhpcy5fZGlydHlJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXR0ZXIgJiYgIXRoaXMuX3NldHRlciB8fCB0aGlzLl9ybykge1xuICAgICAgICAgICAgICAgIC8vIGNhbm5vdCBzZXQgdmFsdWUgZGlyZWN0bHkgb3V0c2lkZSBvZiBnZXR0ZXIgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAvLyAob3IgdmFsdWUgaXMgcmVzb2x2ZWQgUHJvbWlzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKCF0aGlzLl9zZXR0ZXIgfHwgdGhpcy5fc2V0dGluZykgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5fdmFsIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbC5fc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJveHkgdGhyb3VnaCBvYnNlcnZhYmxlIHZhbHVlIHNldHRlclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc2V0dGVyICYmICF0aGlzLl9zZXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gaW52b2tlIHNldHRlclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldHRlci5jYWxsKHVuZGVmaW5lZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB0aGlzLl92YWwpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIHZhbHVlIGFzIGNoYW5nZWQgKGJ1dCBub3QgZGlydHkpXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsSWR4ID0gKyt0aGlzLl9kaXJ0eUlkeDtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdmFsdWUgYW5kIGVtaXQgc2lnbmFsKHMpXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXhDYWxsYmFja3MgJiYgdGhpcy5fYXV4Q2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYoKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0U3luYyh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogUmV0dXJucyAudmFsdWUgKG9ic2VydmFibGUgaWYgdXNlZCB3aXRoaW4gYW4gb2JzZXJ2YWJsZSBnZXR0ZXIpICovXG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52YWx1ZTsgfTtcbiAgICAvKiogUmV0dXJucyAudmFsdWUgYXMgYSBzdHJpbmcgKG9ic2VydmFibGUgaWYgdXNlZCB3aXRoaW4gYW4gb2JzZXJ2YWJsZSBnZXR0ZXIpICovXG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlKTsgfTtcbiAgICAvKiogUmV0dXJucyBsYXN0IHZhbHVlIHNldCwgZG9lcyBub3QgcmUtZXZhbHVhdGUgYW5kL29yIGFkZCBkZXBlbmRlbmN5ICovXG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5nZXRMYXN0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJldHVybiB2YWx1ZSBvciBwcm94eSBvdGhlciBPYnNlcnZhYmxlVmFsdWUncyB2YWx1ZVxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl92YWw7XG4gICAgICAgIHdoaWxlICh2YWx1ZSBpbnN0YW5jZW9mIE9ic2VydmFibGVWYWx1ZSlcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZ2V0TGFzdFZhbHVlKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKiBUcmFuc2Zvcm0gdGhpcyBvYnNlcnZhYmxlIHZhbHVlIHVzaW5nIGdpdmVuIGZ1bmN0aW9uLCBpbnRvIGEgbmV3IE9ic2VydmFibGVWYWx1ZSBpbnN0YW5jZTsgbm90ZSB0aGF0IHRoZSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiBpcyBub3QgbmVjZXNzYXJpbHkgaW52b2tlZCBhZnRlciBlYWNoIHZhbHVlIGNoYW5nZSwgaWYgdGhlIG5ldyBvYnNlcnZhYmxlIGlzIG5vdCBzdWJzY3JpYmVkIHRvIGFuZC9vciBtdWx0aXBsZSBjaGFuZ2VzIG9jY3VyIChhc3luY2hyb25vdXNseSkgYmVmb3JlIHRoZSB0cmFuc2Zvcm1hdGlvbiBpcyBldmFsdWF0ZWQ7IG9ic2VydmFibGVzIHVzZWQgYnkgdGhlIGdpdmVuIGZ1bmN0aW9uIGl0c2VsZiBhcmUgbm90IGF1dG9tYXRpY2FsbHkgc3Vic2NyaWJlZCB0byAod3JhcCBnaXZlbiBmdW5jdGlvbiBpbiBvYnNlcnZlKC4uLikgdG8gb2JzZXJ2ZSBkZXBlbmRlbmNpZXMgYXMgd2VsbCkgKi9cbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGFzdFZhbHVlID0ge307XG4gICAgICAgIHZhciBtYXBwZWQgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBsYXN0VmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcHBlZC52YWx1ZTtcbiAgICAgICAgICAgIG1hcHBlZC52YWx1ZSA9IHVub2JzZXJ2ZWQoY2FsbGJhY2ssIGxhc3RWYWx1ZSA9IHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jb25uZWN0KGNhbGxiYWNrKTtcbiAgICAgICAgLy8gbGlzdGVuIGZvciBzaWduYWwgZW1pc3Npb25zIHdoaWxlIGluaXRpYWxpemluZyB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl92YWwsIGVtaXR0ZWQgPSBmYWxzZSwgZjtcbiAgICAgICAgaWYgKHRoaXMuX2dldHRlciB8fCB0aGlzLl92YWwgaW5zdGFuY2VvZiBPYnNlcnZhYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXV4Q2FsbGJhY2tzKVxuICAgICAgICAgICAgICAgIHRoaXMuX2F1eENhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fYXV4Q2FsbGJhY2tzLnB1c2goZiA9IGZ1bmN0aW9uICgpIHsgZW1pdHRlZCA9IHRydWU7IH0pO1xuICAgICAgICAgICAgdW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7IGN1cnJlbnQgPSBfdGhpcy52YWx1ZTsgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXV4Q2FsbGJhY2tzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYXV4Q2FsbGJhY2tzO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuX2F1eENhbGxiYWNrcyA9IHRoaXMuX2F1eENhbGxiYWNrcy5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IGY7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vdCBhbHJlYWR5IGVtaXR0ZWQgc2lnbmFsLCBpbnZva2UgY2FsbGJhY2sgZm9yIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgaWYgKCFlbWl0dGVkKVxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgZGVmZXIoY2FsbGJhY2ssIFtjdXJyZW50XSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIFN0YXJ0IGxpc3RlbmluZyBmb3IgY2hhbmdlcyB0byB0aGlzIG9ic2VydmFibGUgdmFsdWUgYW5kIGFsbCBvZiBpdHMgZGVwZW5kZW5jaWVzIGFzeW5jaHJvbm91c2x5LCBhbmQgcmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIG5leHQgKGRpZmZlcmVudCkgdmFsdWUgb2YgdGhlIG9ic2VydmFibGU7IGRvZXMgX25vdF8gZm9yY2UgZXZhbHVhdGlvbiBvZiB0aGUgY3VycmVudCB2YWx1ZSAoaS5lLiBnZXR0ZXJzIGFyZSBub3QgY2FsbGVkKTsgc3RvcHMgc3Vic2NyaWJpbmcgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgKi9cbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGZvcmNlIHNpZ25hbCBldmVuIGlmIG5vIHZhbHVlIGhhZCBiZWVuIHNldCB5ZXRcbiAgICAgICAgaWYgKCF0aGlzLl92YWxJZHgpXG4gICAgICAgICAgICB0aGlzLl92YWxJZHggPSAtMTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBfdGhpcy5jb25uZWN0T25jZShmdW5jdGlvbiAodikgeyByZXNvbHZlKHYpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZSwgXCJzdWJzY3JpYmVkXCIsIHtcbiAgICAgICAgLyoqIFRydWUgaWYgdGhpcyBvYnNlcnZhYmxlIHZhbHVlIGlzIGN1cnJlbnRseSBzdWJzY3JpYmVkIHRvLCBlaXRoZXIgZGlyZWN0bHkgb3IgZnJvbSBkZXBlbmRlbnQgb2JzZXJ2YWJsZXMgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRoaXMuX3dhdGNoZWQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLCBcIndyaXRhYmxlXCIsIHtcbiAgICAgICAgLyoqIFRydWUgaWYgdGhpcyBvYnNlcnZhYmxlIHZhbHVlIGlzIHdyaXRhYmxlIChub3Qgb25seSBhIGdldHRlciBkZWZpbmVkKSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEodGhpcy5fcm8gfHwgdGhpcy5fZ2V0dGVyICYmICF0aGlzLl9zZXR0ZXIpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQGludGVybmFsIEFkZCBhIGNhbGxiYWNrIHRvIGludm9rZSAoc3luY2hyb25vdXNseSkgd2hlbiB0aGlzIHZhbHVlIGNoYW5nZXMsIGJ1dCBkbyBub3Qgd2F0Y2ggZm9yIGNoYW5nZXMgZGlyZWN0bHkgKGkuZS4gZG9lcyBub3QgY29ubmVjdCB0byBzaWduYWwgYW5kIHN0YXJ0IHdhdGNoaW5nKSwgY2FsbGJhY2sgbXVzdCBOT1QgdGhyb3cgYW4gZXhjZXB0aW9uOyB1c2VkIGZvciBlbWl0dGluZyBPYnNlcnZhYmxlLlByb3BlcnR5Q2hhbmdlICovXG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5pbnZva2VPbkNoYW5nZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuX2F1eENhbGxiYWNrcylcbiAgICAgICAgICAgIHRoaXMuX2F1eENhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLl9hdXhDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKiogQ2xlYXIgdmFsdWUgYW5kIHJlbW92ZSBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9ucywgdW5zdWJzY3JpYmUgZnJvbSBkZXBlbmRlbmNpZXMgKi9cbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldHRlcih1bmRlZmluZWQpLnNldHRlcih1bmRlZmluZWQpO1xuICAgICAgICBkZWxldGUgdGhpcy5fdmFsO1xuICAgICAgICBkZWxldGUgdGhpcy5fc2V0O1xuICAgIH07XG4gICAgLyoqIE1hbnVhbGx5IGludm9rZSB0aGUgZ2V0dGVyIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHksIGlmIGFueTsgY2FuIGJlIHVzZWQgb25seSBpZiBub3QgY3VycmVudGx5IGV2YWx1YXRpbmcgYW5vdGhlciBvYnNlcnZhYmxlIHZhbHVlIChvdGhlcndpc2UsIHdyYXAgaW4gYSBjYWxsIHRvIGB1bm9ic2VydmVkYCk7IGNhbGxpbmcgdGhpcyBtZXRob2QgaXMgbm9ybWFsbHkgbm90IG5lY2Vzc2FyeSwgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgZXh0ZXJuYWwgZmFjdG9ycyBvdXRzaWRlIG9mIG9ic2VydmFibGVzIGNoYW5nZSBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlIHJlc3VsdCBvZiB0aGUgZ2V0dGVyIGZ1bmN0aW9uIGNoYW5nZXM7IGlmIHNvLCB0aGVuIHN1YnNlcXVlbnQgcmV0cmlldmFsIG9mIGAudmFsdWVgIHJlc3VsdHMgaW4gdGhlIG5ldyB2YWx1ZSwgYW5kIGRlcGVuZGVudCBvYnNlcnZhYmxlIHZhbHVlcyBhcmUgc2NoZWR1bGVkIHRvIHVwZGF0ZSBhdXRvbWF0aWNhbGx5IChhc3luY2hyb25vdXNseSkgKi9cbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXNzZXJ0VW5vYnNlcnZlZCgpO1xuICAgICAgICBpZiAodGhpcy5fZ2V0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUlkeCsrO1xuICAgICAgICAgICAgdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCBSZXR1cm5zIHRydWUgaWYgdmFsdWUgbmVlZHMgdG8gYmUgcmVldmFsdWF0ZWQgKi9cbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLl9uZWVkc0V2YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZ2V0dGVyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoKHRoaXMuX3ZhbElkeCB8fCAwKSAhPT0gdGhpcy5fZGlydHlJZHgpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gaWYgdmFsdWUgaXMgd2F0Y2hlZCwgdGhlbiBkZXBlbmRlbmNpZXMgYXJlIHdhdGNoZWQgdG9vXG4gICAgICAgIC8vIGFuZCBhcmUgdXAgdG8gZGF0ZSBpZiB2YWx1ZSBpcyB1cCB0byBkYXRlIChhYm92ZSBjaGVjaylcbiAgICAgICAgaWYgKHRoaXMuX3dhdGNoZWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIGNoZWNrIGlmIGRlcGVuZGVuY2llcyAobWF5KSBoYXZlIGNoYW5nZWQgc2luY2UgbGFzdCBldmFsdWF0aW9uXG4gICAgICAgIHJldHVybiAhdGhpcy5fZGVwQ2hlY2tzIHx8IHRoaXMuX2RlcENoZWNrcy5zb21lKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmKHt9KTsgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsIE1hcmsgYXMgZGlydHkgKGlmIG5vdCBhbHJlYWR5IGRpcnR5KSBhbmQgc2NoZWR1bGUgcmUtZXZhbHVhdGlvbiBvZiB2YWx1ZSBpZiBzdGlsbCB3YXRjaGVkICovXG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5fYXN5bmNFdmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoKHRoaXMuX3ZhbElkeCB8fCAwKSA9PT0gdGhpcy5fZGlydHlJZHggJiYgIXRoaXMuX2dldHRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5SWR4Kys7XG4gICAgICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl93YXRjaGVkICYmIF90aGlzLl92YWxJZHggIT09IF90aGlzLl9kaXJ0eUlkeClcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCBSZWdpc3RlciBhIHdhdGNoZWQgZGVwZW5kZW5jeSBvZiB0aGlzIHZhbHVlICovXG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5fYWRkQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5fZGVwQ29ubmVjdGlvbnMpXG4gICAgICAgICAgICB0aGlzLl9kZXBDb25uZWN0aW9ucyA9IHt9O1xuICAgICAgICAvLyBjaGVjayBpZiBjb25uZWN0aW9uIGFscmVhZHkgZXhpc3RlZFxuICAgICAgICB2YXIgb2xkO1xuICAgICAgICBpZiAodGhpcy5fb2xkQ29ubmVjdGlvbnMgJiYgKG9sZCA9IHRoaXMuX29sZENvbm5lY3Rpb25zW290aGVyLl91aWRdKSkge1xuICAgICAgICAgICAgLy8gdXNlIGV4aXN0aW5nIG9iamVjdFxuICAgICAgICAgICAgdGhpcy5fZGVwQ29ubmVjdGlvbnNbb3RoZXIuX3VpZF0gPSBvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhZGQgaGFuZGxlciB0byBtYXJrIHRoaXMgdmFsdWUgYXMgZGlydHkgd2hlbmV2ZXIgb3RoZXIgdmFsdWVcbiAgICAgICAgICAgIC8vIGNoYW5nZXMgKG5vdCBhc3luYyBzaW5jZSBzaWduYWwgaXMgYWx3YXlzIGVtaXR0ZWQgc3luY2hyb25vdXNseSxcbiAgICAgICAgICAgIC8vIHNlZSBhYm92ZSk7IF9jb25uZWN0IHJldHVybnMgZGlzY29ubmVjdCBtZXRob2RcbiAgICAgICAgICAgIHZhciBkaXMgPSBvdGhlci5fY29ubmVjdCh0aGlzLl9hc3luY0V2YWwuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAvLyBzdG9yZSBuZXcgZGVwZW5kZW5jeSBvYmplY3RcbiAgICAgICAgICAgIHRoaXMuX2RlcENvbm5lY3Rpb25zW290aGVyLl91aWRdID0geyBkZXA6IG90aGVyLCBkaXM6IGRpcyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsIFJlZ2lzdGVyIGFuIHVud2F0Y2hlZCBkZXBlbmRlbmN5IG9mIHRoaXMgdmFsdWUgKGNoZWNrZWQgZm9yIGNoYW5nZXMgZXZlcnkgdGltZSB3aGVuIGdldHRpbmcgdGhlIHVud2F0Y2hlZCBvYnNlcnZhYmxlIHZhbHVlKSAqL1xuICAgIE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUuX2FkZENoZWNrID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvdGhlciA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gbWFpbnRhaW4gYSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgb3RoZXIgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAgICAgLy8gKGRpZmZlcmVudCBfZGlydHlJZHggb3IgcmVjdXJzZSBkb3duIGRlcGVuZGVuY3kgdHJlZSlcbiAgICAgICAgdmFyIGxhc3REaXJ0eUlkeCA9IG90aGVyLl9kaXJ0eUlkeDtcbiAgICAgICAgKHRoaXMuX2RlcENoZWNrcyB8fCAodGhpcy5fZGVwQ2hlY2tzID0gW10pKS5wdXNoKGZ1bmN0aW9uIChzZWVuKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltfdGhpcy5fdWlkXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNlZW5bX3RoaXMuX3VpZF0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIChvdGhlci5fZGlydHlJZHggIT09IGxhc3REaXJ0eUlkeCB8fFxuICAgICAgICAgICAgICAgICFvdGhlci5fZGVwQ2hlY2tzIHx8IG90aGVyLl9kZXBDaGVja3Muc29tZShmdW5jdGlvbiAoZikgeyByZXR1cm4gZihzZWVuKTsgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgRGlzY29ubmVjdCBleGlzdGluZyBkZXBlbmRlbmNpZXMgKi9cbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLl9yZW1vdmVEZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9kZXBDaGVja3M7XG4gICAgICAgIHZhciBjb25uZWN0aW9ucyA9IHRoaXMuX2RlcENvbm5lY3Rpb25zO1xuICAgICAgICBkZWxldGUgdGhpcy5fZGVwQ29ubmVjdGlvbnM7XG4gICAgICAgIGZvciAodmFyIHVpZCBpbiBjb25uZWN0aW9ucylcbiAgICAgICAgICAgIGNvbm5lY3Rpb25zW3VpZF0uZGlzKCk7XG4gICAgICAgIC8vIGFsc28gZGlzY29ubmVjdCBmcm9tIHByb3hpZWQgb2JzZXJ2YWJsZSwgaWYgYW55XG4gICAgICAgIGlmICh0aGlzLl9wcm94eUNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3h5Q29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJveHlDb25uZWN0aW9uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsIGhhbmRsZXIgZm9yIGZpcnN0IHNpZ25hbCBjb25uZWN0aW9uICovXG4gICAgT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5vbkhhbmRsZXJDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3dhdGNoZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuX2RlcENoZWNrcyB8fCB0aGlzLl9kZXBDaGVja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBub3Qgc3VyZSBhYm91dCBkZXBlbmRlbmNpZXMsIGZvcmNlIHJlLWV2YWxcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZURlcGVuZGVuY2llcygpO1xuICAgICAgICAgICAgdGhpcy5fZGlydHlJZHgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGRlcGVuZGVuY2llcyBsYXN0IHRpbWUsIG5vIG5lZWQgdG8gY2hlY2tcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZURlcGVuZGVuY2llcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsIGhhbmRsZXIgZm9yIGxhc3Qgc2lnbmFsIGRpc2Nvbm5lY3Rpb24gKi9cbiAgICBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlLm9uSGFuZGxlcnNEaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3dhdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRGVwZW5kZW5jaWVzKCk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgT2JzZXJ2YWJsZVZhbHVlLlVJRCA9IDA7XG4gICAgcmV0dXJuIE9ic2VydmFibGVWYWx1ZTtcbn0oKSk7XG5leHBvcnQgeyBPYnNlcnZhYmxlVmFsdWUgfTtcbi8vIE5PVEU6IG1peGluZyBpbiByZXF1aXJlZCBzaWduYWwgbWV0aG9kcyBoZXJlIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UsXG4vLyByZXB1cnBvc2luZyBPYnNlcnZhYmxlVmFsdWUgaW5zdGFuY2VzIGFzIHRoZWlyIG93biBjaGFuZ2Ugc2lnbmFsc1xuT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5fY29ubmVjdCA9IFNpZ25hbC5fY29ubmVjdDtcbk9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUuY29ubmVjdCA9IFNpZ25hbC5jb25uZWN0O1xuT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZS5jb25uZWN0T25jZSA9IFNpZ25hbC5jb25uZWN0T25jZTtcbk9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGUuZW1pdFN5bmMgPSBTaWduYWwuZW1pdFN5bmM7XG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZSh2KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyBPYnNlcnZhYmxlVmFsdWUodikgOlxuICAgICAgICAodiAmJiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygdi50aGVuID09PSBcImZ1bmN0aW9uXCIpID9cbiAgICAgICAgICAgIE9ic2VydmFibGVWYWx1ZS5mcm9tUHJvbWlzZSh2KSA6XG4gICAgICAgICAgICAodiBpbnN0YW5jZW9mIEFycmF5KSA/XG4gICAgICAgICAgICAgICAgT2JzZXJ2YWJsZUFycmF5LmZyb21BcnJheSh2KSA6XG4gICAgICAgICAgICAgICAgKHYgaW5zdGFuY2VvZiBPYmplY3QpID9cbiAgICAgICAgICAgICAgICAgICAgbWFrZU9iamVjdE9ic2VydmFibGUodikgOlxuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IH0pKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5vYnNlcnZlZChmKSB7XG4gICAgdmFyIHByZXZXYXRjaGVkID0gY3VycmVudFdhdGNoZWRFdmFsaW5nO1xuICAgIHZhciBwcmV2VW53YXRjaGVkID0gY3VycmVudFVud2F0Y2hlZEV2YWxpbmc7XG4gICAgdHJ5IHtcbiAgICAgICAgY3VycmVudFdhdGNoZWRFdmFsaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICBjdXJyZW50VW53YXRjaGVkRXZhbGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50V2F0Y2hlZEV2YWxpbmcgPSBwcmV2V2F0Y2hlZDtcbiAgICAgICAgY3VycmVudFVud2F0Y2hlZEV2YWxpbmcgPSBwcmV2VW53YXRjaGVkO1xuICAgIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9Bc3luYy9PYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZVZhbHVlLCB1bm9ic2VydmVkIH0gZnJvbSBcIi4vT2JzZXJ2YWJsZVwiO1xuaW1wb3J0IHsgbWFrZVByb3BlcnR5T2JzZXJ2YWJsZSB9IGZyb20gXCIuL09ic2VydmFibGVPYmplY3RcIjtcbi8qKiBfUHJvcGVydHkgZGVjb3JhdG9yXywgbWFrZXMgYSBwcm9wZXJ0eSBvYnNlcnZhYmxlIG9uIGV2ZXJ5IGluc3RhbmNlLCB3aXRoIGEgcmVhZC1vbmx5IHZhbHVlIHNoYXJlZCBhY3Jvc3MgYWxsIGluc3RhbmNlcyB0YWtlbiBmcm9tIGFuIChlYXJsaWVyIE9SIGxhdGVyKSBjYWxsIHRvIGBpbmplY3RgLCAqdW50aWwqIHRoZSBwcm9wZXJ0eSBpcyBkaXJlY3RseSBhc3NpZ25lZCB0byBbcmVxdWlyZXMgRVM1KyB0YXJnZXRdIFtkZWNvcmF0b3JdICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0YWJsZSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGlmICghZGVzY3JpcHRvcilcbiAgICAgICAgZGVzY3JpcHRvciA9IHsgZW51bWVyYWJsZTogdHJ1ZSB9O1xuICAgIC8vIGNhcHR1cmUgZXhpc3RpbmcgdmFsdWUgKGUuZy4gbWV0aG9kIG9uIHByb3RvdHlwZSlcbiAgICB2YXIgdmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIGRlbGV0ZSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIGRlbGV0ZSBkZXNjcmlwdG9yLndyaXRhYmxlO1xuICAgIC8vIHVzZSBhIHNpbmdsZSBvYnNlcnZhYmxlIHBlciBjbGFzcyB0byBjYXB0dXJlIHRoZSBsYXN0IGluamVjdGVkIHZhbHVlXG4gICAgdmFyIGluamVjdG9yID0gT2JzZXJ2YWJsZVZhbHVlLmZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgZGVzY3JpcHRvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWFrZVByb3BlcnR5T2JzZXJ2YWJsZShfdGhpcywga2V5LCBPYnNlcnZhYmxlVmFsdWUuZnJvbVZhbHVlKGluamVjdG9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgIH07XG4gICAgLy8gc2V0dGVyIGp1c3QgaW5pdGlhbGl6ZXMgYW4gb2JzZXJ2YWJsZSB3aXRoIGdpdmVuIHZhbHVlXG4gICAgLy8gKHdpbGwgaWdub3JlIGluamVjdGlvbiBhbHRvZ2V0aGVyKVxuICAgIGRlc2NyaXB0b3Iuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIG1ha2VQcm9wZXJ0eU9ic2VydmFibGUodGhpcywga2V5KTtcbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgfTtcbiAgICAvLyBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgb2JzZXJ2YWJsZSBpbmplY3RvciB2YWx1ZVxuICAgIGRlc2NyaXB0b3IuZ2V0W1wiKmluamVjdG9yXCJdID0gaW5qZWN0b3I7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59XG4vKiogU2V0IGdpdmVuIGluamVjdGFibGUgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzIChkZWNvcmF0ZWQgd2l0aCBgaW5qZWN0YWJsZWApIG9uICphbGwqIGluc3RhbmNlcyBvZiBnaXZlbiBjbGFzcyBhbmQgZGVyaXZlZCBjbGFzc2VzIHRvIHRoZSBnaXZlbiB2YWx1ZXMsIGV4Y2VwdCBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoZSBwcm9wZXJ0eSBoYXMgYmVlbiBvdmVyd3JpdHRlbiBkaXJlY3RseTsgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBldmVuIHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyB0byByZWRlZmluZSB0aGVpciBpbmplY3RlZCB2YWx1ZTsgcmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgcHJldmlvdXMgaW5qZWN0ZWQgdmFsdWVzIChmb3IgZS5nLiBvdmVycmlkaW5nIGFuIGluamVjdGVkIGZ1bmN0aW9uIHRoYXQgY2FsbHMgaW50byB0aGUgcHJldmlvdXNseSBpbmplY3RlZCBmdW5jdGlvbjsgd2hlbiBpbmplY3RpbmcgaW50byBhIGRlcml2ZWQgY2xhc3MsIHRoZXNlIHByb3BlcnRpZXMgdXNlIGFjY2Vzc29ycyB0byByZXR1cm4gbGF0ZXN0IG92ZXJyaWRkZW4gaW5qZWN0ZWQgdmFsdWVzIG9uIGJhc2UgY2xhc3MoZXMpIGR5bmFtaWNhbGx5KSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluamVjdCh0YXJnZXRDbGFzcywgc3BlYykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3BlYywgbmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAvLyBnZXQgdGhlIGluamVjdG9yIG9ic2VydmFibGUgZm9yIHRoZSBwcm9wZXJ0eSBvbiBnaXZlbiBwcm90b3R5cGUsXG4gICAgICAgIC8vIGFkZCBhIHZhbHVlIG9yIGdldHRlciBvbiB0aGUgcmVzdWx0IG9iamVjdCB0aGF0IHJlZmxlY3RzIHRoZSBvbGQgT1JcbiAgICAgICAgLy8gb3ZlcnJpZGRlbiAob2JzZXJ2YWJsZSkgdmFsdWVcbiAgICAgICAgdmFyIGdldEluamVjdG9yID0gZnVuY3Rpb24gKHByb3RvLCBkKSB7XG4gICAgICAgICAgICBpZiAoIXByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFkZXNjIHx8ICFkZXNjLmdldCB8fCAhZGVzYy5nZXRbXCIqaW5qZWN0b3JcIl0pIHtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNlIGlmIG5vdCBkZWZpbmVkIGF0IHRoaXMgbGV2ZWxcbiAgICAgICAgICAgICAgICB2YXIgZ2V0dGVyXzEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRJbmplY3RvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pKTsgfTtcbiAgICAgICAgICAgICAgICB2YXIgaW5qZWN0b3JfMSA9IGdldHRlcl8xKCk7XG4gICAgICAgICAgICAgICAgaWYgKGQgJiYgaW5qZWN0b3JfMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCB0aGUgaW5qZWN0b3IgZnVydGhlciBkb3duIHRoZSBwcm90b3R5cGUgY2hhaW5cbiAgICAgICAgICAgICAgICAgICAgZC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXR0ZXJfMSgpLmdldExhc3RWYWx1ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5qZWN0b3JfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvdW5kIHRoZSBpbmplY3RvciBvYnNlcnZhYmxlXG4gICAgICAgICAgICAgICAgdmFyIGluamVjdG9yXzIgPSBkZXNjLmdldFtcIippbmplY3RvclwiXTtcbiAgICAgICAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgbGFzdCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBkLnZhbHVlID0gaW5qZWN0b3JfMi5nZXRMYXN0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluamVjdG9yXzI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGQgPSB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogZmFsc2UgfTtcbiAgICAgICAgaW5qZWN0b3IgPSBnZXRJbmplY3Rvcih0YXJnZXRDbGFzcy5wcm90b3R5cGUsIGQpO1xuICAgICAgICBpZiAoIWluamVjdG9yKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBhbiBpbmplY3RlZCBwcm9wZXJ0eTogXCIgKyBuYW1lKTtcbiAgICAgICAgLy8gc3RvcmUgZ2V0dGVyIG9yIHZhbHVlIG9uIHJlc3VsdCBvYmplY3RcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgbmFtZSwgZCk7XG4gICAgICAgIC8vIGlmIGluamVjdGluZyBvbiBkZXJpdmVkIGNsYXNzLCB1c2Ugb3ZlcnJpZGluZyBpbmplY3RvciBpbnN0ZWFkXG4gICAgICAgIGlmIChkLmdldCkge1xuICAgICAgICAgICAgb3ZlcnJpZGUgPSBpbmplY3RhYmxlKHRhcmdldENsYXNzLnByb3RvdHlwZSwgbmFtZSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0Q2xhc3MucHJvdG90eXBlLCBuYW1lLCBvdmVycmlkZSk7XG4gICAgICAgICAgICBpbmplY3RvciA9IG92ZXJyaWRlLmdldFtcIippbmplY3RvclwiXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdGhlIG5ldyB2YWx1ZSBpbiB0aGUgKG5ldykgaW5qZWN0b3Igb2JzZXJ2YWJsZVxuICAgICAgICBpbmplY3Rvci52YWx1ZSA9IHNwZWNbbmFtZV07XG4gICAgfTtcbiAgICB2YXIgZCwgaW5qZWN0b3IsIG92ZXJyaWRlO1xuICAgIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgICAgICBfbG9vcF8xKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXN5bmMvSW5qZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZXhwb3J0ICogZnJvbSBcIi4vRGVmZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1NpZ25hbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vUHJvbWlzZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vT2JzZXJ2YWJsZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vT2JzZXJ2YWJsZUFycmF5XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9PYnNlcnZhYmxlT2JqZWN0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9JbmplY3RcIjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9Bc3luYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImV4cG9ydCAqIGZyb20gXCIuL0FzeW5jL2luZGV4XCI7XG5pbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiLi9Bc3luYy9pbmRleFwiO1xuZXhwb3J0IGRlZmF1bHQgQXN5bmM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJleHBvcnQgKiBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9Bc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCBBc3luYyBmcm9tIFwiLi4vQXN5bmNcIjtcbi8qKiBOZXh0IFVJRCB0byBiZSB1c2VkICovXG52YXIgX25leHRVSUQgPSAwO1xuLyoqIEVuY2Fwc3VsYXRlcyBDU1Mgc3R5bGUgcHJvcGVydGllcywgY2xhc3NlcywgYW5kIGhpZGRlbi9zZWxlY3RlZCBhdHRyaWJ1dGVzOyB0aGVzZSBzdHlsZXMgYXJlIG9ic2VydmVkIHdoZW4gYXBwbGllZCB0byBjb21wb25lbnRzIG9uIHNjcmVlbiwgYnkgdGhlbXNlbHZlcyBvciBvdmVycmlkZGVuIHVzaW5nIGFub3RoZXIgU3R5bGUgaW5zdGFuY2UgKHNlZSBgLm92ZXJyaWRlKC4uLilgKTsgcHJvcGVydGllcyBhcmUgYWx3YXlzIGFwcGxpZWQgaW4gYWxwaGFiZXRpY2FsIG9yZGVyLCBpLmUgYGJhY2tncm91bmRDb2xvcmAgYWZ0ZXIgYGJhY2tncm91bmRgLCBgcGFkZGluZ1RvcGAgYWZ0ZXIgYHBhZGRpbmdgLCBldGMuICovXG52YXIgU3R5bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugd2l0aCBnaXZlbiBzdHlsZXM7IGNsYXNzIG5hbWUgYXJndW1lbnQgbWF5IGNvbnRhaW4gbXVsdGlwbGUgY2xhc3MgbmFtZXMgc2VwYXJhdGVkIHdpdGggc3BhY2VzICovXG4gICAgZnVuY3Rpb24gU3R5bGUoc3R5bGVzLCBjbGFzc05hbWUsIGhpZGRlbikge1xuICAgICAgICAvKiogR2xvYmFsbHkgdW5pcXVlIElEIGZvciB0aGlzIFN0eWxlIGluc3RhbmNlICovXG4gICAgICAgIHRoaXMudWlkID0gXCJTXCIgKyBfbmV4dFVJRCsrO1xuICAgICAgICB0aGlzLl9rZXlzID0gbmV3IEFzeW5jLk9ic2VydmFibGVBcnJheSgpO1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSBuZXcgQXN5bmMuT2JzZXJ2YWJsZVZhbHVlKCk7XG4gICAgICAgIHRoaXMuX292ZXJyaWRlcyA9IG5ldyBBc3luYy5PYnNlcnZhYmxlVmFsdWUoKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy5hZGRDbGFzcy5hcHBseSh0aGlzLCBjbGFzc05hbWUuc3BsaXQoL1xccysvKSk7XG4gICAgICAgIGlmIChoaWRkZW4gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGhpZGRlbiA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gICAgICAgIGlmIChzdHlsZXMpXG4gICAgICAgICAgICB0aGlzLnNldChzdHlsZXMpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGEgU3R5bGUgaW5zdGFuY2UgdGhhdCBvbmx5IGNvbnRhaW5zIGdpdmVuIGNsYXNzIG5hbWUocyk7IGFsaWFzIGZvciBuZXcgU3R5bGUodW5kZWZpbmVkLCBjbGFzc05hbWUpICovXG4gICAgU3R5bGUud2l0aENsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0eWxlKHVuZGVmaW5lZCwgY2xhc3NOYW1lKTtcbiAgICB9O1xuICAgIC8qKiBBZGQgdGhlIGdpdmVuIGNsYXNzIG5hbWUocyk7IHJldHVybnMgdGhpcyAqL1xuICAgIFN0eWxlLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGNsYXNzTmFtZXNfMSA9IGNsYXNzTmFtZXM7IF9hIDwgY2xhc3NOYW1lc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHMgPSBjbGFzc05hbWVzXzFbX2FdO1xuICAgICAgICAgICAgcyA9IHMudHJpbSgpO1xuICAgICAgICAgICAgaWYgKHMpXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkoXCIuXCIgKyBzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZW1vdmUgdGhlIGdpdmVuIGNsYXNzIG5hbWUocyksIGZyb20gdGhpcyBpbnN0YW5jZSBhcyB3ZWxsIGFzIGFueSBpbnN0YW5jZXMgdGhhdCB0aGlzIGluc3RhbmNlIG92ZXJyaWRlczsgcmV0dXJucyB0aGlzICovXG4gICAgU3R5bGUucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2xhc3NOYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgY2xhc3NOYW1lc18yID0gY2xhc3NOYW1lczsgX2EgPCBjbGFzc05hbWVzXzIubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGNsYXNzTmFtZXNfMltfYV07XG4gICAgICAgICAgICBzID0gcy50cmltKCk7XG4gICAgICAgICAgICBpZiAocylcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShcIi5cIiArIHMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZW1vdmUgKGFsbCkgZXhpc3RpbmcgQ1NTIGNsYXNzIG5hbWUocykgYW5kIHVzZSBnaXZlbiBjbGFzcyhlcykgKG9ubHkgb24gdGhpcyBTdHlsZSBpbnN0YW5jZSwgbm90IG9uIG92ZXJyaWRpbmcgb3Igb3ZlcnJpZGRlbiBzdHlsZXMpOyByZXR1cm5zIHRoaXMgKi9cbiAgICBTdHlsZS5wcm90b3R5cGUuc2V0Q2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fa2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZVswXSA9PT0gXCIuXCIpXG4gICAgICAgICAgICAgICAgX3RoaXMuX3Byb3BzW25hbWVdID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZENsYXNzLmFwcGx5KHRoaXMsIGNsYXNzTmFtZXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IENTUyBjbGFzcyBuYW1lKHMpIHN0b3JlZCBpbiB0aGlzIGluc3RhbmNlIChvYnNlcnZhYmxlKSAqL1xuICAgIFN0eWxlLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleVswXSA9PT0gXCIuXCIgPyBcIiBcIiArIGtleS5zbGljZSgxKSA6IFwiXCI7IH0pXG4gICAgICAgICAgICAuam9pbihcIlwiKS5zbGljZSgxKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHZhbHVlIGZvciBnaXZlbiBwcm9wZXJ0eTsgdGhlIHByb3BlcnR5IG11c3QgYmUgc2V0IGV4cGxpY2l0bHkgb24gdGhpcyBTdHlsZSBpbnN0YW5jZSBvciBvdmVycmlkaW5nIFN0eWxlIGluc3RhbmNlcyAqL1xuICAgIFN0eWxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9wcm9wcyAmJiB0aGlzLl9wcm9wc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICB2YXIgb3ZlcnJpZGVzID0gdGhpcy5fb3ZlcnJpZGVzLnZhbHVlO1xuICAgICAgICBvdmVycmlkZXMgJiYgb3ZlcnJpZGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgciA9IHN0eWxlICYmIHN0eWxlLmdldChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgaWYgKHIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBBZGQgYSBkcm9wIHNoYWRvdyBlZmZlY3QsIHdpdGggZ2l2ZW4gZGVwdGggZmFjdG9yICgwLTEpOyByZXR1cm5zIHRoaXMgKi9cbiAgICBTdHlsZS5wcm90b3R5cGUuYWRkU2hhZG93RWZmZWN0ID0gZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3BlcnR5KFwiOnNoYWRvd1wiLCBkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3R5bGUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoaGlkZGVuKSB7XG4gICAgICAgIGlmIChoaWRkZW4gPT09IHZvaWQgMCkgeyBoaWRkZW4gPSB0cnVlOyB9XG4gICAgICAgIHRoaXMuX3NldFByb3BlcnR5KFwiOmhpZGRlblwiLCBoaWRkZW4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZW1vdmUgdGhlIFwiaGlkZGVuXCIgYXR0cmlidXRlOyByZXR1cm5zIHRoaXMgKi9cbiAgICBTdHlsZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkoXCI6aGlkZGVuXCIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBoaWRkZW4gc3RhdGUgZm9yIHRoaXMgU3R5bGUgaW5zdGFuY2UsIHRydWUgaWYgZXhwbGljaXRseSBoaWRkZW4sIGZhbHNlIGlmIGV4cGxpY2l0eSBzaG93biwgdW5kZWZpbmVkIG90aGVyd2lzZSAob2JzZXJ2YWJsZSkgKi9cbiAgICBTdHlsZS5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJvcHMgfHwgIXRoaXMuX3Byb3BzW1wiOmhpZGRlblwiXSlcbiAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KFwiOmhpZGRlblwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzW1wiOmhpZGRlblwiXTtcbiAgICB9O1xuICAgIFN0eWxlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkID09PSB2b2lkIDApIHsgc2VsZWN0ZWQgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMuX3NldFByb3BlcnR5KFwiOnNlbGVjdGVkXCIsIHNlbGVjdGVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmVtb3ZlIHRoZSBcInNlbGVjdGVkXCIgYXR0cmlidXRlOyByZXR1cm5zIHRoaXMgKi9cbiAgICBTdHlsZS5wcm90b3R5cGUuZGVzZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldFByb3BlcnR5KFwiOnNlbGVjdGVkXCIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBzZWxlY3Rpb24gc3RhdGUgZm9yIHRoaXMgU3R5bGUgaW5zdGFuY2UsIHRydWUgaWYgZXhwbGljaXRseSBzZWxlY3RlZCwgZmFsc2UgaWYgZXhwbGljaXR5IGRlc2VsZWN0ZWQsIHVuZGVmaW5lZCBvdGhlcndpc2UgKG9ic2VydmFibGUpICovXG4gICAgU3R5bGUucHJvdG90eXBlLmlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJvcHMgfHwgIXRoaXMuX3Byb3BzW1wiOnNlbGVjdGVkXCJdKVxuICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkoXCI6c2VsZWN0ZWRcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wc1tcIjpzZWxlY3RlZFwiXTtcbiAgICB9O1xuICAgIFN0eWxlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gc2V0IHNpbmdsZSBwcm9wZXJ0eVxuICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkob2JqLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgQXN5bmMuT2JzZXJ2YWJsZU9iamVjdCkge1xuICAgICAgICAgICAgLy8gcHJveHkgYWxsIGV4aXN0aW5nIG9ic2VydmFibGUgcHJvcGVydGllc1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc09ic2VydmFibGVQcm9wZXJ0eShwcm9wKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocHJvcCwgQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpbcHJvcF07IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvcHkgYWxsIHByb3BlcnRpZXMgZGlyZWN0bHlcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwcm9wLCBvYmpbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBvYnNlcnZhYmxlIGxpc3Qgb2Ygc29ydGVkIHByb3BlcnRpZXNcbiAgICAgICAgdmFyIHNvcnRlZCA9IHRoaXMuX2tleXM7XG4gICAgICAgIGlmIChzb3J0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdW5zb3J0ZWQgPSBPYmplY3Qua2V5cyh0aGlzLl9wcm9wcyk7XG4gICAgICAgICAgICBzb3J0ZWQubGVuZ3RoID0gdW5zb3J0ZWQubGVuZ3RoO1xuICAgICAgICAgICAgdW5zb3J0ZWQuc29ydCgpLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaSkgeyBzb3J0ZWRbaV0gPSBrZXk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCBDYWxsIGdpdmVuIGNhbGxiYWNrIGZvciBlYWNoIHByb3BlcnR5IHRoYXQgaGFzIGJlZW4gc2V0IG9uIHRoaXMgU3R5bGUgaW5zdGFuY2UsIGluIGFscGhhYmV0aWNhbCAoQVNDSUkpIG9yZGVyLCBfcGx1c18gcHJvcGVydGllcyBcIjpoaWRkZW5cIiwgXCI6c2VsZWN0ZWRcIiBhbmQgXCIuY2xhc3NuYW1lXCIgcHJvcGVydGllcyBpZiBkZWZpbmVkIG9uIHRoaXMgaW5zdGFuY2UgKi9cbiAgICBTdHlsZS5wcm90b3R5cGUuZm9yRWFjaFByb3BlcnR5ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fa2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IGYobmFtZSwgX3RoaXMuX3Byb3BzW25hbWVdKTsgfSk7XG4gICAgfTtcbiAgICAvKiogT3ZlcnJpZGUgc3R5bGVzIGFuZCBjbGFzc2VzIHdpdGggdGhvc2UgZnJvbSBnaXZlbiBTdHlsZSBpbnN0YW5jZTsgcmV0dXJucyB0aGlzICovXG4gICAgU3R5bGUucHJvdG90eXBlLm92ZXJyaWRlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIHZhciBvdmVycmlkZXMgPSB0aGlzLl9vdmVycmlkZXMudmFsdWUgfHxcbiAgICAgICAgICAgICh0aGlzLl9vdmVycmlkZXMudmFsdWUgPSBuZXcgQXN5bmMuT2JzZXJ2YWJsZUFycmF5KCkpO1xuICAgICAgICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBBc3luYy5PYnNlcnZhYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhbiBvYnNlcnZhYmxlIHZhbHVlIHRvIHRoZSBvdmVycmlkZXMgbGlzdFxuICAgICAgICAgICAgb3ZlcnJpZGVzLnB1c2goQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzdHlsZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocyAmJiAhKHMgaW5zdGFuY2VvZiBTdHlsZSkpXG4gICAgICAgICAgICAgICAgICAgIHMgPSBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBTdHlsZShzKTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhIFN0eWxlIGluc3RhbmNlIHRvIHRoZSBvdmVycmlkZXMgbGlzdFxuICAgICAgICAgICAgaWYgKCEoc3R5bGUgaW5zdGFuY2VvZiBTdHlsZSkpXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBuZXcgU3R5bGUoc3R5bGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBvdmVycmlkZXMucHVzaChzdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIGxpc3QgdGhhdCBjb25zaXN0cyBvZiB0aGlzIFN0eWxlIGluc3RhbmNlIGl0c2VsZiwgcGx1cyBhbnkgcmVjdXJzaXZlbHkgb3ZlcnJpZGluZyBTdHlsZSBpbnN0YW5jZXMgaW4gZWZmZWN0OyBleGNlcHQgZm9yIGluc3RhbmNlcyB3aXRob3V0IGFueSBub24tZW1wdHkgcHJvcGVydGllcyBvciBjbGFzc2VzIChvYnNlcnZhYmxlKSAqL1xuICAgIFN0eWxlLnByb3RvdHlwZS5nZXRPdmVycmlkZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzO1xuICAgICAgICAoZnVuY3Rpb24gYWRkT3ZlcnJpZGVzKHMpIHtcbiAgICAgICAgICAgIGlmICghcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocy5fc3RhdHVzLnZhbHVlID49IChzID09PSBiYXNlID8gMiA6IDEpKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHMpO1xuICAgICAgICAgICAgdmFyIG92ZXJyaWRlcyA9IHMuX292ZXJyaWRlcy52YWx1ZTtcbiAgICAgICAgICAgIG92ZXJyaWRlcyAmJiBvdmVycmlkZXMuZm9yRWFjaChhZGRPdmVycmlkZXMpO1xuICAgICAgICB9KSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBIZWxwZXIgbWV0aG9kIHRvIHNldCBhbiBvYnNlcnZhYmxlIHByb3BlcnR5IG9uIGAuX3Byb3BzYCB0byBnaXZlbiB2YWx1ZSBhbmQgc2V0IGAuX3N0YXR1c2AgYWNjb3JkaW5nbHk7IGNyZWF0ZXMgdGhlIGAuX3Byb3BzYCBvYmplY3QsIG1ha2VzIHRoZSBwcm9wZXJ0eSBvYnNlcnZhYmxlLCBhbmQgYWRkcyB0aGUgcHJvcGVydHkgbmFtZSB0byB0aGUgYC5fa2V5c2AgYXJyYXkgaWYgbmVlZGVkIChidXQgZG9lcyBOT1Qgc29ydCBpdCkgKi9cbiAgICBTdHlsZS5wcm90b3R5cGUuX3NldFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5fcHJvcHMpXG4gICAgICAgICAgICB0aGlzLl9wcm9wcyA9IG5ldyBBc3luYy5PYnNlcnZhYmxlT2JqZWN0KCk7XG4gICAgICAgIC8vIG1ha2UgcHJvcGVydHkgb2JzZXJ2YWJsZSBhbmQgYWRkIHRvIGxpc3Qgb2Yga2V5c1xuICAgICAgICBpZiAoIXRoaXMuX3Byb3BzLmhhc09ic2VydmFibGVQcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgQXN5bmMubWFrZVByb3BlcnR5T2JzZXJ2YWJsZSh0aGlzLl9wcm9wcywgbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9rZXlzLnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHZhbHVlXG4gICAgICAgIHRoaXMuX3Byb3BzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIC8vIGluY3JlYXNlIGN1cnJlbnQgc3RhdHVzXG4gICAgICAgIHZhciBzdGF0dXMgPSAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gXCJcIikgPyAyIDogMTtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0dXMudmFsdWUgfHwgdGhpcy5fc3RhdHVzLnZhbHVlIDwgc3RhdHVzKVxuICAgICAgICAgICAgdGhpcy5fc3RhdHVzLnZhbHVlID0gc3RhdHVzO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlO1xufSgpKTtcbmV4cG9ydCB7IFN0eWxlIH07XG4oZnVuY3Rpb24gKFN0eWxlKSB7XG4gICAgO1xufSkoU3R5bGUgfHwgKFN0eWxlID0ge30pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9TdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi9Bc3luY1wiO1xuLyoqIFNpZ25hbCB0aGF0IGlzIGVtaXR0ZWQgYnkgYSBjb21wb25lbnQgaW5zdGFuY2UgYXMgdGhlIHJlc3VsdCBvZiBhIHVzZXIgYWN0aW9uICovXG52YXIgQ29tcG9uZW50U2lnbmFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcG9uZW50U2lnbmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudFNpZ25hbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcG9uZW50U2lnbmFsO1xufShBc3luYy5TaWduYWwpKTtcbmV4cG9ydCB7IENvbXBvbmVudFNpZ25hbCB9O1xuLyoqIFtpbXBsZW1lbnRhdGlvbl0gXCJDb25zdHJ1Y3RvclwiIHdyYXBwZXIgZm9yIGEgVUkgc2lnbmFsIGhhbmRsZXIgKi9cbnZhciBDb21wb25lbnRTaWduYWxIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wb25lbnRTaWduYWxIYW5kbGVyKGYpIHtcbiAgICAgICAgaWYgKCF0aGlzIHx8ICF0aGlzLmNvbnN0cnVjdG9yIHx8XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yICE9PSBDb21wb25lbnRTaWduYWxIYW5kbGVyICYmXG4gICAgICAgICAgICAgICAgISh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIENvbXBvbmVudFNpZ25hbEhhbmRsZXIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZjtcbiAgICAgICAgcmVzdWx0LmNvbm5lY3RUbyA9IGZ1bmN0aW9uIChzaWduYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWduYWwuY29ubmVjdCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0LmlzRXZlbnRIYW5kbGVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBvbmVudFNpZ25hbEhhbmRsZXI7XG59KCkpO1xuZXhwb3J0IHsgQ29tcG9uZW50U2lnbmFsSGFuZGxlciB9O1xuLyoqIEBpbnRlcm5hbCBSZXR1cm5zIGEgbmV3IGNvbXBvbmVudCBzaWduYWwgY2xhc3Mgc3BlY2lmaWMgdG8gYSBjb21wb25lbnQsIHdpdGggZ2l2ZW4gc2lnbmFsIGJhc2UgY2xhc3MgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVDb21wb25lbnRTaWduYWwoYmFzZSwgY29tcG9uZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHByb3BlcnRpZXMgPT09IHZvaWQgMCkgeyBwcm9wZXJ0aWVzID0ge307IH1cbiAgICB2YXIgc2lnID0gYmFzZS5jcmVhdGUoKTtcbiAgICBmb3IgKHZhciBwIGluIHByb3BlcnRpZXMpXG4gICAgICAgIHNpZ1twXSA9IHByb3BlcnRpZXNbcF07XG4gICAgc2lnLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqIENvbnN0cnVjdG9yIGZvciBhIGNvbXBvbmVudCBzaWduYWwgaGFuZGxlciAobm8gZXZlbnQgZGF0YSkgKi9cbnZhciBBY3Rpb25IYW5kbGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWN0aW9uSGFuZGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3Rpb25IYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBBY3Rpb25IYW5kbGVyO1xufShDb21wb25lbnRTaWduYWxIYW5kbGVyKSk7XG5leHBvcnQgeyBBY3Rpb25IYW5kbGVyIH07XG4vKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCB3aGVuIGEga2V5Ym9hcmQgZXZlbnQgb2NjdXJzICovXG52YXIgS2V5RXZlbnRTaWduYWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhLZXlFdmVudFNpZ25hbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBLZXlFdmVudFNpZ25hbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gS2V5RXZlbnRTaWduYWw7XG59KENvbXBvbmVudFNpZ25hbCkpO1xuZXhwb3J0IHsgS2V5RXZlbnRTaWduYWwgfTtcbi8qKiBDb25zdHJ1Y3RvciBmb3IgYSBrZXlib2FyZCBldmVudCBoYW5kbGVyICovXG52YXIgS2V5SGFuZGxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEtleUhhbmRsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gS2V5SGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gS2V5SGFuZGxlcjtcbn0oQ29tcG9uZW50U2lnbmFsSGFuZGxlcikpO1xuZXhwb3J0IHsgS2V5SGFuZGxlciB9O1xuLyoqIFNpZ25hbCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBhIG1vdXNlL3BvaW50ZXIgZXZlbnQgb2NjdXJzICovXG52YXIgUG9pbnRlckV2ZW50U2lnbmFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9pbnRlckV2ZW50U2lnbmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvaW50ZXJFdmVudFNpZ25hbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUG9pbnRlckV2ZW50U2lnbmFsO1xufShDb21wb25lbnRTaWduYWwpKTtcbmV4cG9ydCB7IFBvaW50ZXJFdmVudFNpZ25hbCB9O1xuLyoqIENvbnN0cnVjdG9yIGZvciBhIG1vdXNlL3BvaW50ZXIgZXZlbnQgaGFuZGxlciAqL1xudmFyIFBvaW50ZXJIYW5kbGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9pbnRlckhhbmRsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9pbnRlckhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBvaW50ZXJIYW5kbGVyO1xufShDb21wb25lbnRTaWduYWxIYW5kbGVyKSk7XG5leHBvcnQgeyBQb2ludGVySGFuZGxlciB9O1xuLyoqIFNpZ25hbCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBhIGN1c3RvbSBkcmFnIGV2ZW50IG9jY3VycyAqL1xudmFyIERyYWdFdmVudFNpZ25hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYWdFdmVudFNpZ25hbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEcmFnRXZlbnRTaWduYWwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERyYWdFdmVudFNpZ25hbDtcbn0oQ29tcG9uZW50U2lnbmFsKSk7XG5leHBvcnQgeyBEcmFnRXZlbnRTaWduYWwgfTtcbi8qKiBDb25zdHJ1Y3RvciBmb3IgYSBkcmFnIGV2ZW50IGhhbmRsZXIgKi9cbnZhciBEcmFnSGFuZGxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYWdIYW5kbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERyYWdIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBEcmFnSGFuZGxlcjtcbn0oQ29tcG9uZW50U2lnbmFsSGFuZGxlcikpO1xuZXhwb3J0IHsgRHJhZ0hhbmRsZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0NvbXBvbmVudFNpZ25hbC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi9Bc3luY1wiO1xuLyoqIFJlcHJlc2VudHMgYSBwcm9wZXJ0eSBiaW5kaW5nLCB1c2VkIHdpdGggY29tcG9uZW50IGZhY3RvcmllcyB0byBwcm94eSB2YWx1ZXMgdGFrZW4gZnJvbSB0aGUgYmFzZSBjb21wb25lbnQgaW5zdGFuY2Ugb250byBwcm9wZXJ0aWVzIG9mIGl0cyBzdWIgY29tcG9uZW50cyAqL1xudmFyIEJpbmRpbmcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgYmluZGluZyBiYXNlZCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZS9wYXRoIChyZWZlcnJpbmcgdG8gdGhlIGJhc2UgY29tcG9uZW50LCBvbiB3aGljaCAud2l0aCBvciAuaW5pdGlhbGl6ZVdpdGggd2FzIGNhbGxlZDsgcmVzdWx0aW5nIHZhbHVlcyBjYW4gYWxzbyBiZSBpbnN0YW5jZXMgb2YgT2JzZXJ2YWJsZVZhbHVlIG9yIFByb21pc2UpLCBhbmQgb3B0aW9uYWxseSBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uLCBpbnZva2VkIGVhY2ggdGltZSB0aGUgb2JzZXJ2ZWQgdmFsdWUgY2hhbmdlcyAob3V0c2lkZSBvZiBhbnkgb2JzZXJ2YWJsZSBjb250ZXh0LCBsaWtlIGBtYXBgIG9uIGBPYnNlcnZhYmxlVmFsdWVgLCBpLmUuIG5vIGZ1cnRoZXIgZGVwZW5kZW5jaWVzIGFyZSByZWNvcmRlZCk7IGlmIG5vIHBhdGggaXMgc3BlY2lmaWVkLCB0aGUgbmFtZSBvZiB0aGUgaW5pdGlhbGl6ZXIgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGlzIGJpbmRpbmcgaXMgdXNlZCwgaWYgYW55ICovXG4gICAgZnVuY3Rpb24gQmluZGluZyhzb3VyY2VQYXRoLCBnZXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQYXRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBzb3VyY2VQYXRoID0gU3RyaW5nKHNvdXJjZVBhdGggfHwgXCJcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5fbmVnID0gc291cmNlUGF0aFswXSA9PT0gXCIhXCIpXG4gICAgICAgICAgICAgICAgc291cmNlUGF0aCA9IHNvdXJjZVBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgICB0aGlzLl9wID0gc291cmNlUGF0aC5zcGxpdChcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmdldCA9IGdldFRyYW5zZm9ybTtcbiAgICB9XG4gICAgLyoqIENvbnN0cnVjdCBhbiBPYnNlcnZhYmxlVmFsdWUgdGhhdCBpcyBib3VuZCB0byB0aGUgdmFsdWUgb24gZ2l2ZW4gY29tcG9uZW50ICh1c2VkIGJ5IGZhY3RvcnkgaW5pdGlhbGl6ZXIgdG8gYXBwbHkgYmluZGluZykgKi9cbiAgICBCaW5kaW5nLnByb3RvdHlwZS5vYnNlcnZlT24gPSBmdW5jdGlvbiAoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMuX3AsIG5lZyA9IHRoaXMuX25lZywgZmdldCA9IHRoaXMuX2ZnZXQ7XG4gICAgICAgIGlmICghcGFydHMpXG4gICAgICAgICAgICBwYXJ0cyA9IFtuYW1lIHx8IFwiXCJdO1xuICAgICAgICB2YXIgZ2V0dGVyID0gbmVnID9cbiAgICAgICAgICAgIChmdW5jdGlvbiAoZikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gIWYoKTsgfTsgfSkobWFrZVBhdGhGaW5kZXIocGFydHMsIGNvbXBvbmVudCkpIDpcbiAgICAgICAgICAgIG1ha2VQYXRoRmluZGVyKHBhcnRzLCBjb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gZmdldCA/XG4gICAgICAgICAgICBBc3luYy5vYnNlcnZlKGdldHRlcikubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB1bnByb21pc2UoZmdldCh2LCBjb21wb25lbnQpKTsgfSkgOlxuICAgICAgICAgICAgQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiB1bnByb21pc2UoZ2V0dGVyKCkpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nO1xufSgpKTtcbmV4cG9ydCB7IEJpbmRpbmcgfTtcbi8qKiBSZXByZXNlbnRzIGEgdHdvLXdheSBiaW5kaW5nIChgQmluZGluZ2AgdGhhdCBhbHNvIGluY2x1ZGVzIGEgc2V0dGVyIG9uIHRoZSBwcm94eSBwcm9wZXJ0eSkgKi9cbnZhciBUd29XYXlCaW5kaW5nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHdvV2F5QmluZGluZywgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgbmV3IHR3by13YXkgYmluZGluZyBiYXNlZCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZS9wYXRoIChzZWUgYG5ldyBCaW5kaW5nYCksIGFuZCBvcHRpb25hbGx5IGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24sIGludm9rZWQgZWFjaCB0aW1lIGEgbmV3IHZhbHVlIGlzIGJlaW5nIHNldCAob3V0c2lkZSBvZiBhbnkgb2JzZXJ2YWJsZSBjb250ZXh0KTsgaWYgbm8gcGF0aCBpcyBzcGVjaWZpZWQsIHRoZSBuYW1lIG9mIHRoZSBpbml0aWFsaXplciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoaXMgYmluZGluZyBpcyB1c2VkLCBpZiBhbnkgKi9cbiAgICBmdW5jdGlvbiBUd29XYXlCaW5kaW5nKHNvdXJjZVBhdGgsIGdldFRyYW5zZm9ybSwgc2V0VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNvdXJjZVBhdGgsIGdldFRyYW5zZm9ybSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2ZzZXQgPSBzZXRUcmFuc2Zvcm07XG4gICAgICAgIGlmIChzb3VyY2VQYXRoICYmIHNvdXJjZVBhdGguc2xpY2UoLTIpID09PSBcIigpXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJpbmRpbmc6IGNhbm5vdCBhc3NpZ24gdG8gYSBtZXRob2RcIik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIE1ha2UgYW4gT2JzZXJ2YWJsZVZhbHVlIHRoYXQgaXMgYm91bmQgdG8gdGhlIHZhbHVlIG9uIGdpdmVuIGNvbXBvbmVudCAodXNlZCBieSBmYWN0b3J5IGluaXRpYWxpemVyIHRvIGFwcGx5IGJpbmRpbmcpICovXG4gICAgVHdvV2F5QmluZGluZy5wcm90b3R5cGUub2JzZXJ2ZU9uID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgbmFtZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS5vYnNlcnZlT24uY2FsbCh0aGlzLCBjb21wb25lbnQsIG5hbWUpO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLl9wLCBuZWcgPSB0aGlzLl9uZWcsIGZzZXQgPSB0aGlzLl9mc2V0O1xuICAgICAgICBpZiAoIXBhcnRzKVxuICAgICAgICAgICAgcGFydHMgPSBbbmFtZSB8fCBcIlwiXTtcbiAgICAgICAgdmFyIGJhc2VGaW5kZXIgPSBtYWtlUGF0aEZpbmRlcihwYXJ0cy5zbGljZSgwLCAtMSksIGNvbXBvbmVudCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmVzdWx0LnNldHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBiYXNlRmluZGVyKCk7XG4gICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZzZXQpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZnNldChuZWcgPyAhdmFsdWUgOiB2YWx1ZSwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZWcpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gIXZhbHVlO1xuICAgICAgICAgICAgICAgIG9ialt0YXJnZXRdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFR3b1dheUJpbmRpbmc7XG59KEJpbmRpbmcpKTtcbmV4cG9ydCB7IFR3b1dheUJpbmRpbmcgfTtcbi8qKiBSZXByZXNlbnRzIGFuIGFycmF5IHByb3BlcnR5IGJpbmRpbmcsIHVzZWQgd2l0aCBjb21wb25lbnQgZmFjdG9yaWVzIHRvIHByb3h5IGFycmF5cyB0YWtlbiBmcm9tIHRoZSBiYXNlIGNvbXBvbmVudCBpbnN0YW5jZSBvbnRvIGFycmF5IHByb3BlcnRpZXMgb2YgaXRzIHN1YiBjb21wb25lbnRzOyBhbGwgYXJyYXlzIGFyZSBfbGF6aWx5IGJvdW5kXywgaS5lLiBlbGVtZW50cyByZW1haW4gdW5kZWZpbmVkIHVudGlsIHRoZWlyIGBsZW5ndGhgIHByb3BlcnR5IGhhcyBiZWVuIGV2YWx1YXRlZCAqL1xudmFyIEFycmF5QmluZGluZyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5QmluZGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheUJpbmRpbmcoc291cmNlUGF0aCwgZ2V0VHJhbnNmb3JtLCBpdGVtVHJhbnNmb3JtLCB1bmlxdWVWYWx1ZXMsIGZsYXR0ZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc291cmNlUGF0aCwgZ2V0VHJhbnNmb3JtKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZWx0c2V0ID0gaXRlbVRyYW5zZm9ybTtcbiAgICAgICAgX3RoaXMuX2ZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgICAgICBfdGhpcy5fbWFwVmFsdWVzID0gdW5pcXVlVmFsdWVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBNYWtlIGFuIE9ic2VydmFibGVWYWx1ZSB0aGF0IGlzIGJvdW5kIHRvIHRoZSB2YWx1ZSBvbiBnaXZlbiBjb21wb25lbnQgKHVzZWQgYnkgZmFjdG9yeSBpbml0aWFsaXplciB0byBhcHBseSBiaW5kaW5nKTsgd3JhcHMgYW4gb2JzZXJ2YWJsZSBhcnJheSBpbiBhbiBvYnNlcnZhYmxlIHZhbHVlOyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLCB1c2UgYC5vYnNlcnZlQXJyYXlPbiguLi4pYCBkaXJlY3RseSAodXNlZCBieSBjb21wb25lbnQgZmFjdG9yeSBpbml0aWFsaXplcikgKi9cbiAgICBBcnJheUJpbmRpbmcucHJvdG90eXBlLm9ic2VydmVPbiA9IGZ1bmN0aW9uIChjb21wb25lbnQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIEFzeW5jLk9ic2VydmFibGVWYWx1ZS5mcm9tVmFsdWUodGhpcy5vYnNlcnZlQXJyYXlPbihjb21wb25lbnQsIG5hbWUpKTtcbiAgICB9O1xuICAgIC8qKiBNYWtlIGFuIE9ic2VydmFibGVBcnJheSB0aGF0IGlzIGJvdW5kIHRvIHRoZSB2YWx1ZSBvbiBnaXZlbiBjb21wb25lbnQgKHVzZWQgYnkgZmFjdG9yeSBpbml0aWFsaXplciB0byBhcHBseSBiaW5kaW5nKTsgc2luY2UgYWNjZXNzaW5nIHRoZSBib3VuZCB2YWx1ZSBhdCB0aW1lIG9mIGJpbmRpbmcgbWF5IGJlIHByZW1hdHVyZSwgYWxsIGFycmF5IGVsZW1lbnRzIHJlbWFpbiB1bmRlZmluZWQgX3VudGlsXyB0aGUgYGxlbmd0aGAgcHJvcGVydHkgaXMgYWNjZXNzZWQgKGUuZy4gZnJvbSBhbiBvYnNlcnZhYmxlIGNvbnRleHQgc3VjaCBhcyBhIGNvbXBvbmVudCByZW5kZXJlcikgKi9cbiAgICBBcnJheUJpbmRpbmcucHJvdG90eXBlLm9ic2VydmVBcnJheU9uID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgbmFtZSkge1xuICAgICAgICAvLyBjcmVhdGUgYSBsYXppbHktaW5pdGlhbGl6ZWQgb2JzZXJ2YWJsZSBhcnJheVxuICAgICAgICB2YXIgcmVzdWx0ID0gQXN5bmMuT2JzZXJ2YWJsZUFycmF5LmZyb21PYnNlcnZhYmxlVmFsdWUoX3N1cGVyLnByb3RvdHlwZS5vYnNlcnZlT24uY2FsbCh0aGlzLCBjb21wb25lbnQsIG5hbWUpLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuX2VsdHNldCkge1xuICAgICAgICAgICAgLy8gYWRkaXRpb25hbCB0cmFuc2Zvcm1hdGlvbiBvZiB2YWx1ZXM6IHVzZSBtYXBBc3luY1tWYWx1ZXNdXG4gICAgICAgICAgICB2YXIgc2V0dGVyXzEgPSB0aGlzLl9lbHRzZXQ7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXBWYWx1ZXMgP1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tYXBBc3luY1ZhbHVlcyhmdW5jdGlvbiAodikgeyByZXR1cm4gc2V0dGVyXzEodiwgY29tcG9uZW50KTsgfSwgdW5kZWZpbmVkLCB0cnVlKSA6XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1hcEFzeW5jKGZ1bmN0aW9uICh2KSB7IHJldHVybiBzZXR0ZXJfMSh2LCBjb21wb25lbnQpOyB9LCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mbGF0dGVuKSB7XG4gICAgICAgICAgICAvLyBhZGRpdGlvbmFsIGZsYXR0ZW5pbmcgcmVxdWlyZWQgKHRyYW5zZm9ybWF0aW9uIG1heSByZXR1cm4gYXJyYXkpXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZmxhdHRlbkFzeW5jKHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlCaW5kaW5nO1xufShCaW5kaW5nKSk7XG5leHBvcnQgeyBBcnJheUJpbmRpbmcgfTtcbmV4cG9ydCBmdW5jdGlvbiBiaW5kKHNvdXJjZVBhdGgsIGdldFRyYW5zZm9ybSkge1xuICAgIHJldHVybiBuZXcgQmluZGluZyhzb3VyY2VQYXRoLCBnZXRUcmFuc2Zvcm0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQyKHNvdXJjZVBhdGgsIGdldFRyYW5zZm9ybSwgc2V0VHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBUd29XYXlCaW5kaW5nKHNvdXJjZVBhdGgsIGdldFRyYW5zZm9ybSwgc2V0VHJhbnNmb3JtKTtcbn1cbi8qKiBDcmVhdGUgYSBuZXcgYEFycmF5QmluZGluZ2AgZm9yIGdpdmVuIHByb3BlcnR5IG5hbWUvcGF0aCBvbiB0aGUgYmFzZSBjb21wb25lbnQsIHdoaWNoIHNob3VsZCBjb250YWluIGFuIGFycmF5OyB0aGUgYmluZGluZyByZXNvbHZlcyB0byBhbiBvYnNlcnZhYmxlIGFycmF5IG9mIGluc3RhbmNlcyBvZiBnaXZlbiBgQ29tcG9uZW50YCBjbGFzcyAod2l0aCBhIGNvbnN0cnVjdG9yIHRoYXQgdGFrZXMgb25lIG9yIHR3byBhcmd1bWVudHM6IHRoZSBvcmlnaW5hbCBhcnJheSBlbGVtZW50IHZhbHVlLCBhbmQgb3B0aW9uYWxseSB0aGUgYmFzZSBjb21wb25lbnQgcmVmZXJlbmNlKTsgZm9yIHVzZSBpbiBhIGNvbXBvbmVudCBpbml0aWFsaXplcjsgdXNlcyBgbWFwQXN5bmNgIG9uIHRoZSBvYnNlcnZhYmxlIGFycmF5IGJ5IGRlZmF1bHQ6IGRlbGV0aW5nIGEgdmFsdWUgaW4gdGhlIG1pZGRsZSBvZiB0aGUgYXJyYXkgd2lsbCB0cmlnZ2VyIHJlaW5zdGFudGlhdGlvbiBvZiBhbGwgY29tcG9uZW50cyBhZnRlciBpdDsgdG8gdXNlIGBtYXBBc3luY1ZhbHVlc2AgZm9yIGJldHRlciByZXN1bHRzIHdpdGggYXJyYXlzIG9mIG9iamVjdHMsIHNldCB0aGUgYHVuaXF1ZVZhbHVlc2AgYXJndW1lbnQgdG8gdHJ1ZTsgdG8gY3JlYXRlIGNvbXBvbmVudHMgYXN5bmNocm9ub3VzbHkgaW4gYmF0Y2hlcywgc2V0IHRoZSBgYmF0Y2hTaXplYCBhcmd1bWVudCB0byBhIG51bWJlcjsgYWxsIGFycmF5cyBhcmUgX2xhemlseSBib3VuZF8sIGkuZS4gZWxlbWVudHMgcmVtYWluIHVuZGVmaW5lZCB1bnRpbCB0aGVpciBgbGVuZ3RoYCBwcm9wZXJ0eSBoYXMgYmVlbiBldmFsdWF0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kQ29tcG9uZW50cyhzb3VyY2VQYXRoLCBjb21wb25lbnRDbGFzcywgdW5pcXVlVmFsdWVzLCBiYXRjaFNpemUpIHtcbiAgICBpZiAoYmF0Y2hTaXplID09PSB2b2lkIDApIHsgYmF0Y2hTaXplID0gMDsgfVxuICAgIHZhciBmID0gZnVuY3Rpb24gKHZhbHVlLCBiYXNlQ29tcG9uZW50KSB7IHJldHVybiBuZXcgY29tcG9uZW50Q2xhc3ModmFsdWUsIGJhc2VDb21wb25lbnQpOyB9O1xuICAgIHJldHVybiBuZXcgQXJyYXlCaW5kaW5nKHNvdXJjZVBhdGgsIHVuZGVmaW5lZCwgX2dldEJhdGNoVHJhbnNmb3JtZXIoZiwgYmF0Y2hTaXplKSwgdW5pcXVlVmFsdWVzKTtcbn1cbi8qKiBAaW50ZXJuYWwgSGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgZ2V0dGVyL3RyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIHJldHVybnMgYSByZXN1bHQgcmlnaHQgYXdheSBvciByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5IGJhc2VkIG9uIGdpdmVuIGJhdGNoIHNpemUgKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0QmF0Y2hUcmFuc2Zvcm1lcihmLCBiYXRjaFNpemUpIHtcbiAgICAvLyBjcmVhdGUgY29tcG9uZW50cyBzdHJhaWdodCBhd2F5IGlmIG5vIGJhdGNoIHNpemUgc3BlY2lmaWVkXG4gICAgaWYgKCFiYXRjaFNpemUpXG4gICAgICAgIHJldHVybiBmO1xuICAgIC8vIHVzZSBhIHByb21pc2UgdG8gY3JlYXRlIGNvbXBvbmVudHMgaW4gYmF0Y2hlc1xuICAgIHZhciBwO1xuICAgIHZhciBuID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9O1xuICAgICAgICBpZiAobisrID09PSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIC8vIGFub3RoZXIgYmF0Y2ggcHJvY2Vzc2VkLCBkZWxheSBmdXJ0aGVyXG4gICAgICAgICAgICBwID0gcCA/IHAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBBc3luYy5zbGVlcCgwKTsgfSkgOiBBc3luYy5zbGVlcCgwKTtcbiAgICAgICAgICAgIG4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwID8gcC50aGVuKHJlc29sdmUpIDogcmVzb2x2ZSgpO1xuICAgIH07XG59XG4vLyA9LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIHVucGFjayBwcm9taXNlcyB0cmFuc3BhcmVudGx5ICovXG5mdW5jdGlvbiB1bnByb21pc2Uodikge1xuICAgIHJldHVybiAodiAmJiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygdi50aGVuID09PSBcImZ1bmN0aW9uXCIpID9cbiAgICAgICAgQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7IHJldHVybiBBc3luYy5PYnNlcnZhYmxlVmFsdWUuZnJvbVByb21pc2Uodik7IH0pIDogdjtcbn1cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gbWFrZSBhIGdldHRlciBmb3IgdGhlIGdpdmVuIHBhdGggc2VnbWVudCBcIi4uLigpXCIgb24gdGhlIHJlc3VsdCBvZiBhIGNoYWluZWQgZ2V0dGVyIGZ1bmN0aW9uICovXG5mdW5jdGlvbiBtYWtlRnVuY0dldHRlcihnZXR0ZXIsIHMpIHtcbiAgICBzID0gcy5zbGljZSgwLCAtMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBnZXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIChiYXNlICYmICh0eXBlb2YgYmFzZVtzXSA9PT0gXCJmdW5jdGlvblwiKSkgP1xuICAgICAgICAgICAgYmFzZVtzXSgpIDogdW5kZWZpbmVkO1xuICAgIH07XG59XG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIG1ha2UgYSBnZXR0ZXIgZm9yIGEgY29tcG9uZW50IGJ5IElEIFwiJCguLi4pXCIgb24gdGhlIHJlc3VsdCBvZiBhIGNoYWluZWQgZ2V0dGVyIGZ1bmN0aW9uICovXG5mdW5jdGlvbiBtYWtlSURHZXR0ZXIoZ2V0dGVyLCBzKSB7XG4gICAgcyA9IHMuc2xpY2UoMiwgLTEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gZ2V0dGVyKCk7XG4gICAgICAgIHJldHVybiBjICYmIGMuZ2V0Q29tcG9uZW50QnlJZChzKTtcbiAgICB9O1xufVxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgd2l0aCBnaXZlbiBwYXRoIHNlZ21lbnRzIG9uIHRoZSBnaXZlbiBiYXNlIGNvbXBvbmVudCAqL1xuZnVuY3Rpb24gbWFrZVBhdGhGaW5kZXIocGFydHMsIGNvbXBvbmVudCkge1xuICAgIHZhciBmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50OyB9O1xuICAgIHJldHVybiBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKGYsIHMpIHtcbiAgICAgICAgLy8gaWRlbnRpdHk6XG4gICAgICAgIGlmIChzID09PSBcIiRcIiB8fCBzID09PSBcIiQoKVwiKVxuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIC8vIGdldCBjb21wb25lbnQgYnkgSURcbiAgICAgICAgaWYgKHNbMF0gPT09IFwiJFwiICYmIHNbMV0gPT09IFwiKFwiICYmIHMuc2xpY2UoLTEpID09PSBcIilcIilcbiAgICAgICAgICAgIHJldHVybiBtYWtlSURHZXR0ZXIoZiwgcyk7XG4gICAgICAgIC8vIGdldHRlciBjYWxsOlxuICAgICAgICBpZiAocy5zbGljZSgtMikgPT09IFwiKClcIilcbiAgICAgICAgICAgIHJldHVybiBtYWtlRnVuY0dldHRlcihmLCBzKTtcbiAgICAgICAgLy8gcHJvcGVydHkgZ2V0dGVyOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gKGYoKSB8fCB7fSlbc107IH07XG4gICAgfSwgZik7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQmluZGluZy5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IEJpbmRpbmcgfSBmcm9tIFwiLi4vQmluZGluZ1wiO1xuaW1wb3J0IHsgU3R5bGUgfSBmcm9tIFwiLi4vU3R5bGVcIjtcbmltcG9ydCB7IExhYmVsLCBQYXJhZ3JhcGgsIFdpZGVMYWJlbCwgSGVhZGluZzEsIEhlYWRpbmcyLCBIZWFkaW5nMywgSGVhZGluZzQsIEhlYWRpbmc1LCBIZWFkaW5nNiB9IGZyb20gXCIuLi9cIjtcbi8qKiBTaGFyZWQgZmFjdG9yeSBpbXBsZW1lbnRhdGlvbiBmb3IgYSBwaWVjZSBvZiB0ZXh0IGFzIGEgc3RyaW5nIGFuZC9vciBhcyAoYW4gb2JzZXJ2YWJsZSB2YWx1ZSByZXByZXNlbnRpbmcpIGEgTGFiZWwgaW5zdGFuY2UgKG9yIHN1YiBjbGFzcyk7IGNhbiBiZSB1c2VkIGluIENvbXBvbmVudCBmYWN0b3J5IHNwZWNzIHVzaW5nIFVJLnRsKC4uLikgb3Igd2l0aCBiYWNrdGlja3MgKi9cbnZhciBUZXh0TGFiZWxGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQ3JlYXRlIHRoZSB0ZXh0IGxhYmVsIGZhY3RvcnkgdXNpbmcgdGhlIGdpdmVuIHN0cmluZywgc3RyaW5nYWJsZSAob2JqZWN0IHdpdGggYSBgdG9TdHJpbmdgIG1ldGhvZCksIG9yIG9ic2VydmFibGUgdmFsdWUsIGFsb25nIHdpdGggYW4gb3B0aW9uYWwgYXJyYXkgb2YgKG9ic2VydmFibGUpIHN1YnN0aXR1dGlvbiBhcmd1bWVudHMgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgc3VjaCBhbiBhcnJheSBmb3IgYSBjb21wb25lbnQgdG8gYmluZCB0bywgYW5kIGEgTGFiZWwgYmFzZSBjbGFzcyB0aGF0IGlzIHVzZWQgaWYgbm90IG92ZXJyaWRkZW4gYnkgc3RyaW5nIGNvbnRlbnQgcHJlZml4ICovXG4gICAgZnVuY3Rpb24gVGV4dExhYmVsRmFjdG9yeSh0ZXh0LCBhcmdzLCBvYnNlcnZlQXJncywgYmFzZUNsYXNzKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGV4dDtcbiAgICAgICAgaWYgKGFyZ3MpXG4gICAgICAgICAgICB0aGlzLl9hcmdzID0gYXJncztcbiAgICAgICAgaWYgKG9ic2VydmVBcmdzKVxuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZSA9IHRydWU7XG4gICAgICAgIGlmIChiYXNlQ2xhc3MpXG4gICAgICAgICAgICB0aGlzLl9iYXNlQ2xhc3MgPSBiYXNlQ2xhc3M7XG4gICAgfVxuICAgIC8qKiBHZXQgdGhlICh0cmFuc2xhdGVkKSBlbmNhcHN1bGF0ZWQgdGV4dCBhcyBhIHN0cmluZzsgYWRkcyBhIGRlcGVuZGVuY3kgb24gdGhlIG9ic2VydmFibGUgdmFsdWUgaWYgY2FsbGVkIGZyb20gYW4gb2JzZXJ2YWJsZSB2YWx1ZSBnZXR0ZXI7IHRyaW1zIHsuLi59IHByZWZpeCBpZiBwcmVzZW50ICovXG4gICAgVGV4dExhYmVsRmFjdG9yeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJldHVybiBzdHJpbmcgKHVzZSBPYnNlcnZhYmxlVmFsdWU6dG9TdHJpbmcgaWYgbmVlZGVkKVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2FyZ3MgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGJpbmRpbmdzIGluIHRleHQgbGFiZWxcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl90b1N0cmluZyh0aGlzLl9hcmdzKS5yZXBsYWNlKC9eXFx7W15cXH1dXFx9LywgXCJcIik7XG4gICAgfTtcbiAgICAvKiogR2V0IHRoZSBlbmNhcHN1bGF0ZWQgdGV4dCB3cmFwcGVkIGluIGEgbmV3IExhYmVsIChvciBkZXJpdmVkKSBpbnN0YW5jZSwgb3IgYW4gb2JzZXJ2YWJsZSB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIGluc3RhbmNlOyB1c2VzIHsuLi59IHByZWZpeCB0byBjb250cm9sIGNvbXBvbmVudCB0eXBlIGFuZCBpdHMgcHJvcGVydGllczsgcGFyYW1ldGVycyBhcmUgdXNlZCBieSBjb21wb25lbnQgZmFjdG9yeSB0byBpbml0aWFsaXplIGJpbmRpbmdzIHVzZWQgaW4gYHRsYCBzdHJpbmdzLCBpZiBhbnkgKi9cbiAgICBUZXh0TGFiZWxGYWN0b3J5LnByb3RvdHlwZS5nZXRDb21wb25lbnQgPSBmdW5jdGlvbiAoYmFzZUNvbXBvbmVudCwgcHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gKHR5cGVvZiB0aGlzLl9hcmdzID09PSBcImZ1bmN0aW9uXCIpID9cbiAgICAgICAgICAgIHRoaXMuX2FyZ3MoYmFzZUNvbXBvbmVudCwgcHJvcGVydHlOYW1lKSA6IHRoaXMuX2FyZ3M7XG4gICAgICAgIGlmICh0aGlzLl9vYnNlcnZlKSB7XG4gICAgICAgICAgICAvLyBtYXAgdGhlIG9ic2VydmFibGUgdmFsdWUgdG8gYSBMYWJlbCBpbnN0YW5jZVxuICAgICAgICAgICAgdmFyIGxhYmVsO1xuICAgICAgICAgICAgcmV0dXJuIEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3RvU3RyaW5nKGFyZ3MpOyB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIChsYWJlbCA9IF90aGlzLl9jcmVhdGVDb21wb25lbnQodGV4dCwgbGFiZWwpKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBqdXN0IGNyZWF0ZSBhbmQgcmV0dXJuIHRoZSBjb21wb25lbnQgaXRzZWxmXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQ29tcG9uZW50KHRoaXMuX3RvU3RyaW5nKGFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCBJbmplY3RhYmxlIG1ldGhvZCB0byB0cmFuc2xhdGUgZ2l2ZW4gdGV4dCAoaW5jbHVkaW5nIHN1YnN0aXR1dGlvbiBhbmQgcGx1cmFsaXphdGlvbiBwbGFjZWhvbGRlcnMpOyBpbmplY3RlZCBieSBBcHAgc3ViIG1vZHVsZSB0byBwcm94eSB0aGUgYGN1bHR1cmVgIHNlcnZpY2UgKi9cbiAgICBUZXh0TGFiZWxGYWN0b3J5LnByb3RvdHlwZVtfYSA9IFwiQHRyYW5zbGF0ZVRleHRcIl0gPSBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gdGV4dDsgfTtcbiAgICAvKiogQGludGVybmFsIEluamVjdGFibGUgbWV0aG9kIHRvIHBpY2sgYSBwbHVyYWwgZm9ybSBmb3IgZ2l2ZW4gbnVtYmVyOyBkZWZhdWx0cyB0byBFbmdsaXNoIChzaW5ndWxhci9wbHVyYWwpIGZvcm1zOyBpbmplY3RlZCBieSBBcHAgc3ViIG1vZHVsZSB0byBwcm94eSB0aGUgYGN1bHR1cmVgIHNlcnZpY2UgKi9cbiAgICBUZXh0TGFiZWxGYWN0b3J5LnByb3RvdHlwZVtfYiA9IFwiQHBsdXJhbGl6ZVRleHRcIl0gPSBmdW5jdGlvbiAobiwgZm9ybXMpIHtcbiAgICAgICAgcmV0dXJuIChuID4gMSB8fCBuIDwgLTEpID8gKGZvcm1zWzFdIHx8IGZvcm1zWzBdKSA6IGZvcm1zWzBdO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgc3RyaW5nIHZhbHVlIHdpdGggc3BlY2lmaWMgc3Vic3RpdHV0ZWQgYXJndW1lbnRzICovXG4gICAgVGV4dExhYmVsRmFjdG9yeS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZhbCA9IFN0cmluZyh0aGlzLl92YWx1ZSk7XG4gICAgICAgIC8vIGZpbmQgb3V0IHdoZXJlIHByZWZpeCBlbmRzLCBpZiBhbnlcbiAgICAgICAgdmFyIHN0YXJ0ID0gdmFsWzBdID09PSBcIntcIiA/IHZhbC5pbmRleE9mKFwifVwiKSArIDEgOiAwO1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZhbC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAvLyB0cmFuc2xhdGUgdGV4dCBpdHNlbGZcbiAgICAgICAgdmFyIHRleHQgPSB2YWwuc2xpY2Uoc3RhcnQpO1xuICAgICAgICBpZiAoYXJncyAmJiBhcmdzLmxlbmd0aCAmJiB0ZXh0ID09PSBcIiV7MX1cIikge1xuICAgICAgICAgICAgLy8gc2hvcnRjdXQ6IHN1YnN0aXR1dGUgZmlyc3QgYXJndW1lbnQgcmlnaHQgYXdheVxuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgwLCBzdGFydCkgKyBhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSB0aGlzW1wiQHRyYW5zbGF0ZVRleHRcIl0odGV4dCk7XG4gICAgICAgIC8vIHJlcGxhY2Ugc3Vic3RpdHV0aW9ucyBhbmQgcHV0IHRoZSBzdHJpbmcgYmFjayB0b2dldGhlclxuICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDAsIHN0YXJ0KSArIHRleHQucmVwbGFjZSgvJVxceyhcXGQrKSgoPzpcXHxbXlxcfFxcfV0qKSspP1xcfS9nLCBmdW5jdGlvbiAocywgbiwgcGx1KSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgc3Vic3RpdHV0aW9uL3BsdXJhbGl6YXRpb24gcGxhY2Vob2xkZXIgaWYgbm8gYXJndW1lbnRcbiAgICAgICAgICAgIGlmICghYXJncyB8fCBhcmdzLmxlbmd0aCA8IG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAvLyBnZXQgdmFsdWUgYW5kIGVpdGhlciBwbHVyYWxpemUgb3Igc3Vic3RpdHV0ZVxuICAgICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbcGFyc2VJbnQobiwgMTApIC0gMV07XG4gICAgICAgICAgICBpZiAocGx1KVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpc1tcIkBwbHVyYWxpemVUZXh0XCJdKHZhbCwgcGx1LnNsaWNlKDEpLnNwbGl0KFwifFwiKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHVybiB0ZXh0IGludG8gYSBjb21wb25lbnQgaW5zdGFuY2UgKHBvc3NpYmx5IHJldXNpbmcgZ2l2ZW4gb2xkIExhYmVsIGluc3RhbmNlKSAqL1xuICAgIFRleHRMYWJlbEZhY3RvcnkucHJvdG90eXBlLl9jcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoc3RyLCBwcmV2KSB7XG4gICAgICAgIHZhciBMYWJlbENsYXNzID0gdGhpcy5fYmFzZUNsYXNzO1xuICAgICAgICB2YXIgaWNvbiwgd2lkdGg7XG4gICAgICAgIHZhciBzdHlsZTtcbiAgICAgICAgdmFyIHNldFN0eWxlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGUpXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBuZXcgU3R5bGUoKTtcbiAgICAgICAgICAgIHN0eWxlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBzdHIuaW5kZXhPZihcIn1cIik7XG4gICAgICAgICAgICBpZiAoaWR4ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGludGVycHJldCBmbGFncyB0byBjaGFuZ2UgbGFiZWwgY2xhc3Mgb3Igc3R5bGVzXG4gICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gc3RyLnNsaWNlKDEsIGlkeCkuc3BsaXQoXCJ8XCIpO1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZShpZHggKyAxKTtcbiAgICAgICAgICAgICAgICBmbGFncy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbENsYXNzID0gUGFyYWdyYXBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbENsYXNzID0gV2lkZUxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbENsYXNzID0gTGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaDFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbENsYXNzID0gSGVhZGluZzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaDJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbENsYXNzID0gSGVhZGluZzI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaDNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbENsYXNzID0gSGVhZGluZzM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaDRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbENsYXNzID0gSGVhZGluZzQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaDVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbENsYXNzID0gSGVhZGluZzU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaDZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbENsYXNzID0gSGVhZGluZzY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKFwiZm9udFdlaWdodFwiLCBcImJvbGRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKFwiZm9udFN0eWxlXCIsIFwiaXRhbGljXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdHlsZShcInRleHREZWNvcmF0aW9uXCIsIFwidW5kZXJsaW5lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGUoXCJ0ZXh0QWxpZ25cIiwgZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFMYWJlbENsYXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbENsYXNzID0gUGFyYWdyYXBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL15sOltcXGRcXC5dKyhcXCV8W2Etel0rKSQvLnRlc3QoZikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gZi5zbGljZSgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXiNcXHcrJC8udGVzdChmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGUoXCJjb2xvclwiLCBmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXmljb246Ly50ZXN0KGYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uID0gZi5zbGljZSg1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXlxcZCskLy50ZXN0KGYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdHlsZShcImZvbnRXZWlnaHRcIiwgZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL15bXFxkXFwuXSsoXFwlfFthLXpdKykkLy50ZXN0KGYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdHlsZShcImZvbnRTaXplXCIsIGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eXFwuLy50ZXN0KGYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLnNsaWNlKDEpLnNwbGl0KFwiLlwiKS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHN0eWxlIHx8IChzdHlsZSA9IG5ldyBTdHlsZSkpLmFkZENsYXNzKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gL14oW1xcdy1dKylcXHMqPVxccyooLiopJC8uZXhlYyhmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IG1hdGNoWzFdLnJlcGxhY2UoLy1cXHcvZywgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHNbMV0udG9VcHBlckNhc2UoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdHlsZShwcm9wLCAodmFsWzBdID09PSAnXCInKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZSh2YWwpIDogdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBvciByZXVzZSBMYWJlbCBpbnN0YW5jZVxuICAgICAgICBpZiAoIUxhYmVsQ2xhc3MpXG4gICAgICAgICAgICBMYWJlbENsYXNzID0gTGFiZWw7XG4gICAgICAgIHZhciByZXN1bHQgPSAocHJldiBpbnN0YW5jZW9mIExhYmVsQ2xhc3MpID8gcHJldiA6IG5ldyBMYWJlbENsYXNzKCk7XG4gICAgICAgIGlmIChpY29uKVxuICAgICAgICAgICAgcmVzdWx0Lmljb24gPSBpY29uO1xuICAgICAgICBpZiAoc3R5bGUpXG4gICAgICAgICAgICByZXN1bHQuc3R5bGUub3ZlcnJpZGUoc3R5bGUpO1xuICAgICAgICBpZiAod2lkdGgpXG4gICAgICAgICAgICByZXN1bHQud2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmVzdWx0LnRleHQgPSBzdHI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMuaW5qZWN0YWJsZVxuICAgIF0sIFRleHRMYWJlbEZhY3RvcnkucHJvdG90eXBlLCBfYSwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLmluamVjdGFibGVcbiAgICBdLCBUZXh0TGFiZWxGYWN0b3J5LnByb3RvdHlwZSwgX2IsIG51bGwpO1xuICAgIHJldHVybiBUZXh0TGFiZWxGYWN0b3J5O1xuICAgIHZhciBfYSwgX2I7XG59KCkpO1xuZXhwb3J0IHsgVGV4dExhYmVsRmFjdG9yeSB9O1xuLy8gaW1wbGVtZW50YXRpb246XG5leHBvcnQgZnVuY3Rpb24gdGwoc3RyaW5ncykge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmIChzdHJpbmdzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaWYgKHN0cmluZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBpZiBnaXZlbiBqdXN0IGEgc2luZ2xlIHRleHQsIHVzZSBhIHNob3J0Y3V0IGhlcmVcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExhYmVsRmFjdG9yeShzdHJpbmdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXAgYWxsIGZ1bmN0aW9uL2JpbmRpbmcgdmFsdWVzIHRvIG9ic2VydmFibGUgdmFsdWVzIHdpdGggZ2V0dGVyc1xuICAgICAgICB2YXIgaGFzQmluZGluZ3MgPSBmYWxzZSwgaGFzT2JzZXJ2YWJsZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFyZ3MgPSB2YWx1ZXMgJiYgdmFsdWVzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgZ2l2ZW4gZnVuY3Rpb24gYXMgYW4gb2JzZXJ2YWJsZSBnZXR0ZXJcbiAgICAgICAgICAgICAgICB2ID0gbmV3IEFzeW5jLk9ic2VydmFibGVWYWx1ZSh2KTtcbiAgICAgICAgICAgICAgICBoYXNPYnNlcnZhYmxlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQmluZGluZykge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byB0dXJuIGludG8gb2JzZXJ2YWJsZSBsYXRlclxuICAgICAgICAgICAgICAgIGhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBc3luYy5PYnNlcnZhYmxlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1lbWJlciB0byBvYnNlcnZlIGFueSBvdGhlciBvYnNlcnZhYmxlc1xuICAgICAgICAgICAgICAgIGhhc09ic2VydmFibGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc3Vic3RpdHV0ZSB2YWx1ZXMgd2l0aCBwbGFjZWhvbGRlcnMgaW4gdGhlIHRleHRcbiAgICAgICAgdmFyIHRleHQgPSBzdHJpbmdzLm1hcChmdW5jdGlvbiAocywgaSkgeyByZXR1cm4gaSA/IGkgKyBcIn1cIiArIHMgOiBzOyB9KS5qb2luKFwiJXtcIik7XG4gICAgICAgIGlmIChoYXNCaW5kaW5ncykge1xuICAgICAgICAgICAgLy8gcGFzcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc3Vic3RpdHV0aW9uIGFyZ3MsIGFmdGVyIGJpbmRpbmdcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExhYmVsRmFjdG9yeSh0ZXh0LCBmdW5jdGlvbiAoYmFzZUNvbXBvbmVudCwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2IGluc3RhbmNlb2YgQmluZGluZykgP1xuICAgICAgICAgICAgICAgICAgICB2Lm9ic2VydmVPbihiYXNlQ29tcG9uZW50LCBwcm9wTmFtZSkgOiB2OyB9KTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFzcyAob2JzZXJ2YWJsZSkgdmFsdWVzIGRpcmVjdGx5XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMYWJlbEZhY3RvcnkodGV4dCwgYXJncywgaGFzT2JzZXJ2YWJsZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzdHJpbmdzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gaWYgZ2l2ZW4gYSBnZXR0ZXIgZnVuY3Rpb24sIG1hcCBzaW5nbGUgb2JzZXJ2YWJsZVxuICAgICAgICByZXR1cm4gbmV3IFRleHRMYWJlbEZhY3RvcnkobmV3IEFzeW5jLk9ic2VydmFibGVWYWx1ZShzdHJpbmdzKSwgdW5kZWZpbmVkLCB0cnVlLCB2YWx1ZXNbMF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHJpbmdzIGluc3RhbmNlb2YgQmluZGluZykge1xuICAgICAgICAvLyBpZiBnaXZlbiBhIHNpbmdsZSBiaW5kaW5nLCBjcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgICAgLy8gdGhlIG9ic2VydmFibGUgdmFsdWUgdGhhdCByZXR1cm5zIHRoZSBmaW5hbCB0ZXh0XG4gICAgICAgIHJldHVybiBuZXcgVGV4dExhYmVsRmFjdG9yeShcIiV7MX1cIiwgZnVuY3Rpb24gKGJhc2VDb21wb25lbnQsIHByb3BOYW1lKSB7IHJldHVybiBbc3RyaW5ncy5vYnNlcnZlT24oYmFzZUNvbXBvbmVudCwgcHJvcE5hbWUpXTsgfSwgdHJ1ZSwgdmFsdWVzWzBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGlmIGdpdmVuIGp1c3QgYSBzaW5nbGUgdmFsdWUsIGp1c3QgdXNlIGEgc2luZ2xlIHBpZWNlIG9mIHRleHRcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGFiZWxGYWN0b3J5KHN0cmluZ3MsIHVuZGVmaW5lZCwgZmFsc2UsIHZhbHVlc1swXSk7XG4gICAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvVGV4dExhYmVsRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQXJyYXlCaW5kaW5nLCBCaW5kaW5nIH0gZnJvbSBcIi4uL0JpbmRpbmdcIjtcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSBcIi4uL1N0eWxlXCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi9Db21wb25lbnRcIjtcbmltcG9ydCB7IFRleHRMYWJlbEZhY3RvcnkgfSBmcm9tIFwiLi9UZXh0TGFiZWxGYWN0b3J5XCI7XG5pbXBvcnQgeyBCbG9jaywgQmxvY2tDb250cm9sLCBDb250YWluZXIsIENvbnRhaW5lckJsb2NrLCBDb250YWluZXJDb250cm9sLCBDb250cm9sRWxlbWVudCwgQ29udHJvbFN0YWNrLCBMYWJlbCwgUm93LCBUYWJsZUhlYWRlciwgVGFibGVSb3cgfSBmcm9tIFwiLi9cIjtcbi8qKiBOZXh0IGZhY3RvcnkgVUlEICovXG52YXIgX25leHRVSUQgPSAxO1xuZXhwb3J0IHZhciBDb21wb25lbnRGYWN0b3J5O1xuKGZ1bmN0aW9uIChDb21wb25lbnRGYWN0b3J5KSB7XG4gICAgLyoqIENob2ljZXMgZm9yIHRoZSBsZXZlbCBhdCB3aGljaCBjb21wb25lbnRzIGluIChhcnJheSkgcHJvcGVydGllcyBhcmUgZXhwZWN0ZWQgdG8gYmU7IHVzZWQgYnkgZmFjdG9yeSB0byBleHBhbmQvd3JhcCBpbml0aWFsaXplciBwcm9wZXJ0eSB2YWx1ZXMgYmVmb3JlIGFwcGVuZGluZyBhcyBjaGlsZCBub2RlcyBvbiBhIGNvbXBvbmVudCBkZWNvcmF0ZWQgd2l0aCBgYXBwZW5kQ2hpbGRDb21wb25lbnRzYCwgb3Igc3RvcmluZyB0aGVtIGluIGEgcHJvcGVydHkgZGVjb3JhdGVkIHdpdGggYGFwcGx5Q29tcG9uZW50c0FycmF5YCBvciBgYXBwbHlDb21wb25lbnRSZWZgICovXG4gICAgdmFyIENMZXZlbDtcbiAgICAoZnVuY3Rpb24gKENMZXZlbCkge1xuICAgICAgICBDTGV2ZWxbQ0xldmVsW1wiQ29udGFpbmVyXCJdID0gMF0gPSBcIkNvbnRhaW5lclwiO1xuICAgICAgICBDTGV2ZWxbQ0xldmVsW1wiQmxvY2tcIl0gPSAxXSA9IFwiQmxvY2tcIjtcbiAgICAgICAgQ0xldmVsW0NMZXZlbFtcIkNvbnRyb2xFbGVtZW50XCJdID0gMl0gPSBcIkNvbnRyb2xFbGVtZW50XCI7XG4gICAgICAgIENMZXZlbFtDTGV2ZWxbXCJUYWJsZVJvd1wiXSA9IDNdID0gXCJUYWJsZVJvd1wiO1xuICAgICAgICBDTGV2ZWxbQ0xldmVsW1wiVGFibGVIZWFkZXJcIl0gPSA0XSA9IFwiVGFibGVIZWFkZXJcIjtcbiAgICB9KShDTGV2ZWwgPSBDb21wb25lbnRGYWN0b3J5LkNMZXZlbCB8fCAoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwgPSB7fSkpO1xuICAgIC8qKiBfQ2xhc3MgZGVjb3JhdG9yXyBmb3IgYSBjb21wb25lbnQgY2xhc3MgdGhhdCBleHBlY3RzIGNoaWxkIGNvbXBvbmVudHMgKHRocm91Z2ggYGFwcGVuZENoaWxkYCBtZXRob2QpIG9mIGdpdmVuIHR5cGU7IHRoZSBmYWN0b3J5IHdpbGwgdGhlbiBleHBhbmQvd3JhcCByZWd1bGFyIGFuZCBvYnNlcnZhYmxlIG9iamVjdHMsIGZhY3RvcmllcywgY2xhc3Nlcywgb3IgY29tcG9uZW50cyBpbnRvIHRoZSBjb3JyZWN0IHR5cGU7IGlmIGBhY2NlcHRGcmFnbWVudHNgIGlzIHNldCwgdGhlbiBjb21wb25lbnRzIGNvbnN0cnVjdGVkIGZyb20gZmFjdG9yaWVzIHdpdGggdGhlIGBpc0ZyYWdtZW50RmFjdG9yeWAgYXJlIHBhc3NlZCBpbiBhcy1pczsgdXNlZCBvbiByb290IGNvbXBvbmVudCBjbGFzc2VzLCBzaG91bGQgbm90IG5lZWQgdG8gYmUgdXNlZCBpbiBhcHBsaWNhdGlvbiBjb2RlIFtkZWNvcmF0b3JdICovXG4gICAgZnVuY3Rpb24gYXBwZW5kQ2hpbGRDb21wb25lbnRzKHR5cGUsIGFjY2VwdEZyYWdtZW50cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgLy8gc3RvcmUgZ2l2ZW4gdHlwZSBpbiBmbGFnIHByb3BlcnR5XG4gICAgICAgICAgICB0YXJnZXRbXCJAQ29tcG9uZW50RmFjdG9yeS5jaGlsZFR5cGVcIl0gPSB0eXBlO1xuICAgICAgICAgICAgaWYgKGFjY2VwdEZyYWdtZW50cykge1xuICAgICAgICAgICAgICAgIC8vIHNldCBmbGFnIHRvIGFsc28gYWNjZXB0IGZyYWdtZW50IGNvbXBvbmVudHMgYXMtaXNcbiAgICAgICAgICAgICAgICB0YXJnZXRbXCJAQ29tcG9uZW50RmFjdG9yeS5hY2NlcHRGcmFnbWVudHNcIl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb21wb25lbnRGYWN0b3J5LmFwcGVuZENoaWxkQ29tcG9uZW50cyA9IGFwcGVuZENoaWxkQ29tcG9uZW50cztcbiAgICAvKiogX1Byb3BlcnR5IGRlY29yYXRvcl8gZm9yIGEgcHJvcGVydHkgd2hlcmUgdmFsdWVzIGZyb20gYW4gaW5pdGlhbGl6ZXIgc3BlYyBzaG91bGQgYmUgYXBwbGllZCBhcyBhbiAob2JzZXJ2YWJsZSkgYXJyYXkgb2YgY29tcG9uZW50cyBvZiBnaXZlbiB0eXBlIChlLmcuIGBCbG9ja2AsIGBDb250cm9sRWxlbWVudGAsIGBUYWJsZVJvd2ApOyB0aGUgZmFjdG9yeSB3aWxsIHRoZW4gZXhwYW5kL3dyYXAgcmVndWxhciBhbmQgb2JzZXJ2YWJsZSBhcnJheXMgb2Ygb2JqZWN0cywgZmFjdG9yaWVzLCBjbGFzc2VzLCBvciBjb21wb25lbnRzIGludG8gdGhlIGNvcnJlY3QgdHlwZSBbZGVjb3JhdG9yXSAqL1xuICAgIGZ1bmN0aW9uIGFwcGx5Q29tcG9uZW50c0FycmF5KHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgLy8gc3RvcmUgZ2l2ZW4gdHlwZSBpbiBmbGFnIHByb3BlcnR5XG4gICAgICAgICAgICB0YXJnZXRbXCJAQ29tcG9uZW50RmFjdG9yeS5hcHBseVtdOlwiICsga2V5XSA9IHR5cGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlDb21wb25lbnRzQXJyYXkgPSBhcHBseUNvbXBvbmVudHNBcnJheTtcbiAgICAvKiogX1Byb3BlcnR5IGRlY29yYXRvcl8gZm9yIGEgcHJvcGVydHkgd2hlcmUgdmFsdWVzIGZyb20gYW4gaW5pdGlhbGl6ZXIgc3BlYyBzaG91bGQgYmUgYXBwbGllZCBhcyBhIHJlZmVyZW5jZSB0byBhIGNvbXBvbmVudCBvZiBnaXZlbiB0eXBlIChlLmcuIGBCbG9ja2AsIGBDb250cm9sRWxlbWVudGApOyB0aGUgZmFjdG9yeSB3aWxsIHRoZW4gZXhwYW5kL3dyYXAgb2JqZWN0cywgZmFjdG9yaWVzLCBjbGFzc2VzLCBhbmQgY29tcG9uZW50cyBpbnRvIHRoZSBjb3JyZWN0IHR5cGUgW2RlY29yYXRvcl0gKi9cbiAgICBmdW5jdGlvbiBhcHBseUNvbXBvbmVudFJlZih0eXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIGdpdmVuIHR5cGUgaW4gZmxhZyBwcm9wZXJ0eVxuICAgICAgICAgICAgdGFyZ2V0W1wiQENvbXBvbmVudEZhY3RvcnkuYXBwbHk6XCIgKyBrZXldID0gdHlwZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29tcG9uZW50RmFjdG9yeS5hcHBseUNvbXBvbmVudFJlZiA9IGFwcGx5Q29tcG9uZW50UmVmO1xuICAgIC8qKiBfUHJvcGVydHkgZGVjb3JhdG9yXyBmb3IgYSBwcm9wZXJ0eSBmb3Igd2hpY2ggdmFsdWVzIGZyb20gYW4gaW5pdGlhbGl6ZXIgc3BlYyBzaG91bGQgYmUgYXBwbGllZCBhc3luY2hyb25vdXNseSAodXNpbmcgYW4gYEFzeW5jLmRlZmVyKC4uLilgIGNhbGwpLCBpbnN0ZWFkIG9mIGJlaW5nIHNldCBkaXJlY3RseSBbZGVjb3JhdG9yXSAqL1xuICAgIGZ1bmN0aW9uIGFwcGx5QXN5bmModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgLy8gc2V0IGEgZmxhZyBwcm9wZXJ0eVxuICAgICAgICB0YXJnZXRbXCJAQ29tcG9uZW50RmFjdG9yeS5hc3luYzpcIiArIGtleV0gPSB0cnVlO1xuICAgIH1cbiAgICBDb21wb25lbnRGYWN0b3J5LmFwcGx5QXN5bmMgPSBhcHBseUFzeW5jO1xuICAgIC8qKiBfTWV0aG9kIGRlY29yYXRvcl8gZm9yIHRoZSBtZXRob2QgdGhhdCBzaG91bGQgYmUgY2FsbGVkIHRvIGFwcGx5IHRoZSB2YWx1ZSBvZiBhbiBpbml0aWFsaXplciBzcGVjIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIHByb3BlcnR5IG5hbWU7IHRoZSBtZXRob2Qgc2hvdWxkIGFsd2F5cyBhY2NlcHQgdmFsdWVzIGFzIHdlbGwgYXMgaW5zdGFuY2VzIG9mIGBBc3luYy5PYnNlcnZhYmxlVmFsdWVgIFtkZWNvcmF0b3JdICovXG4gICAgZnVuY3Rpb24gc2V0dGVyRm9yKGluaXRpYWxpemVyUHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIG1ldGhvZCByZWZlcmVuY2UgaW4gZmxhZyBwcm9wZXJ0eVxuICAgICAgICAgICAgdGFyZ2V0W1wiQENvbXBvbmVudEZhY3Rvcnkuc2V0dGVyOlwiICsgaW5pdGlhbGl6ZXJQcm9wZXJ0eU5hbWVdID1cbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29tcG9uZW50RmFjdG9yeS5zZXR0ZXJGb3IgPSBzZXR0ZXJGb3I7XG4gICAgLyoqIEBpbnRlcm5hbCBJbml0aWFsaXplIGdpdmVuIGNvbXBvbmVudCB3aXRoIHByb3BlcnRpZXMgZnJvbSBnaXZlbiBzcGVjLCBhbmQgZm9yIGdpdmVuIGJhc2UgY29tcG9uZW50LCBpZiBhbnk7IHJldHVybnMgdGhlIGNvbXBvbmVudCBpdHNlbGYgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplV2l0aChzcGVjLCBiYXNlKSB7XG4gICAgICAgIGlmIChiYXNlID09PSB2b2lkIDApIHsgYmFzZSA9IHRoaXM7IH1cbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXM7XG4gICAgICAgIGlmIChzcGVjLmlkKVxuICAgICAgICAgICAgYmFzZVtzcGVjLmlkXSA9IGNvbXBvbmVudDtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb21wb25lbnRba2V5XTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikgJiYgKHZhbHVlLnByb3RvdHlwZSBpbnN0YW5jZW9mIEFzeW5jLlNpZ25hbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHNpZ25hbCBkaXJlY3RseSwgb3IgdXNlIHN0cmluZyB0byBmaW5kIGJhc2UgbWV0aG9kXG4gICAgICAgICAgICAgICAgdCA9IHR5cGVvZiBzcGVjW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09IFwiZnVuY3Rpb25cIiB8fCB0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmNvbm5lY3Qoc3BlY1trZXldLCBiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHN0eWxlIGFzIG92ZXJyaWRlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50W2tleV0gPSB2YWx1ZS5vdmVycmlkZSgoc3BlYyBpbnN0YW5jZW9mIEFzeW5jLk9ic2VydmFibGVPYmplY3QpID9cbiAgICAgICAgICAgICAgICAgICAgQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBfZ2V0QXN5bmNWYWx1ZShrZXksIHNwZWNba2V5XSwgYmFzZSk7IH0pIDpcbiAgICAgICAgICAgICAgICAgICAgX2dldEFzeW5jVmFsdWUoa2V5LCBzcGVjW2tleV0sIGJhc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfc2V0XzEgPSBmdW5jdGlvbiAodmFsdWUsIHN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZGVjb3JhdGVkIHdpdGggYXBwbHlBc3luYzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzeW5jICYmIGNvbXBvbmVudFtcIkBDb21wb25lbnRGYWN0b3J5LmFzeW5jOlwiICsga2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBc3luYy5kZWZlcihmdW5jdGlvbiAoKSB7IHJldHVybiBfc2V0XzEodmFsdWUsIHRydWUpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBhcnJheXMgYW5kIHJlZmVyZW5jZXMsIGlmIGRlY29yYXRlZCB3aXRoIGFwcGx5KlxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNvbXBvbmVudFtcIkBDb21wb25lbnRGYWN0b3J5LmFwcGx5W106XCIgKyBrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90cmFuc2Zvcm1GYWN0b3J5QXJyYXkoa2V5LCB2YWx1ZSwgdHlwZSwgYmFzZSwgY29tcG9uZW50IGluc3RhbmNlb2YgVGFibGVSb3cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBjb21wb25lbnRbXCJAQ29tcG9uZW50RmFjdG9yeS5hcHBseTpcIiArIGtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RyYW5zZm9ybU9ic2VydmFibGVJbml0aWFsaXplcihrZXksIHZhbHVlLCB0eXBlLCBiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgYSBzZXR0ZXIgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRbXCJAQ29tcG9uZW50RmFjdG9yeS5zZXR0ZXI6XCIgKyBrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnZva2Ugc2V0dGVyIHdpdGggKG9ic2VydmFibGUpIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRbXCJAQ29tcG9uZW50RmFjdG9yeS5zZXR0ZXI6XCIgKyBrZXldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiAob2JzZXJ2YWJsZSkgdmFsdWUgdG8gY29tcG9uZW50IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyB0YWtlIG9yIG9ic2VydmUgdmFsdWUgKG9yIGJpbmRpbmcsIG9yIHByb21pc2UpXG4gICAgICAgICAgICAgICAgaXNPYnNlcnZhYmxlID0gKHNwZWMgaW5zdGFuY2VvZiBBc3luYy5PYnNlcnZhYmxlT2JqZWN0KSAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaGFzT2JzZXJ2YWJsZVByb3BlcnR5KGtleSk7XG4gICAgICAgICAgICAgICAgX3NldF8xKGlzT2JzZXJ2YWJsZSA/XG4gICAgICAgICAgICAgICAgICAgIEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX2dldEFzeW5jVmFsdWUoa2V5LCBzcGVjW2tleV0sIGJhc2UpOyB9KSA6XG4gICAgICAgICAgICAgICAgICAgIF9nZXRBc3luY1ZhbHVlKGtleSwgc3BlY1trZXldLCBiYXNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0LCBpc09ic2VydmFibGU7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzcGVjKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG4gICAgQ29tcG9uZW50RmFjdG9yeS5pbml0aWFsaXplV2l0aCA9IGluaXRpYWxpemVXaXRoO1xuICAgIDtcbn0pKENvbXBvbmVudEZhY3RvcnkgfHwgKENvbXBvbmVudEZhY3RvcnkgPSB7fSkpO1xuLy8gPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LVxuLy8gSU5URVJOQUwgSU1QTEVNRU5UQVRJT05cbi8qKiBAaW50ZXJuYWwgSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGNvbXBvbmVudCBmYWN0b3J5IGZvciBnaXZlbiB0YXJnZXQgQ29tcG9uZW50IGNsYXNzIHVzaW5nIGdpdmVuIGZhY3Rvcnkgc3BlYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGYWN0b3J5KCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YWx1ZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIEZhY3RvcnlDb21wb25lbnQgPSB0aGlzO1xuICAgIHZhciBJbml0aWFsaXplZENvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhJbml0aWFsaXplZENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSW5pdGlhbGl6ZWRDb21wb25lbnQoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJncykgfHwgdGhpcztcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgcHJvcGVydGllcywgb25seSBpZiBpbiBoaWdoZXN0LWxldmVsIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAvLyAoaS5lLiBub3Qgb3ZlcnJpZGRlbiBieSBhbm90aGVyIGNvbXBvbmVudCBmYWN0b3J5LCBvciBwYXJ0IG9mXG4gICAgICAgICAgICAvLyBhbm90aGVyIGNvbXBvbmVudCBmYWN0b3J5IFVOTEVTUyBleHRlbmRlZCBpbnRvIGFub3RoZXIgY2xhc3MpXG4gICAgICAgICAgICB2YXIgQyA9IF90aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaWYgKEMuaXNCYXNlQ29tcG9uZW50ICYmIEMuRmFjdG9yeUNvbXBvbmVudCA9PT0gRmFjdG9yeUNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGJhc2UgY29tcG9uZW50LCBhdCB0aGUgaGlnaGVzdCBsZXZlbFxuICAgICAgICAgICAgICAgIF90aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQy5wcm90b3R5cGUsIFwiX2ZhY3RvcnlDb21wb25lbnRcIikpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBjbGFzcyBpcyBleHRlbmRlZCBpbnRvIGFuIGFwcGxpY2F0aW9uIGNsYXNzXG4gICAgICAgICAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIEluaXRpYWxpemVkQ29tcG9uZW50Lm92ZXJyaWRlID0gZnVuY3Rpb24gKG92ZXJyaWRlVmFsdWVzKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChvdmVycmlkZVZhbHVlcyk7XG4gICAgICAgIH07XG4gICAgICAgIEluaXRpYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgICAgIGlmIChiYXNlID09PSB2b2lkIDApIHsgYmFzZSA9IHRoaXM7IH1cbiAgICAgICAgICAgIGlmIChfc3VwZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBiYXNlKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgdmFsdWVzXzEgPSB2YWx1ZXM7IF9pIDwgdmFsdWVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGVjID0gdmFsdWVzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlYyAmJiBzcGVjLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgd2l0aCBnaXZlbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVXaXRoKHNwZWMsIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzcGVjID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEoc3BlYy5wcm90b3R5cGUgaW5zdGFuY2VvZiBDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBydW4gZ2l2ZW4gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWModGhpcywgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm0gYW5kIGFwcGVuZCBnaXZlbiBjaGlsZCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IEZhY3RvcnlDb21wb25lbnRbXCJAQ29tcG9uZW50RmFjdG9yeS5jaGlsZFR5cGVcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZyA9IEZhY3RvcnlDb21wb25lbnRbXCJAQ29tcG9uZW50RmFjdG9yeS5hY2NlcHRGcmFnbWVudHNcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKF90cmFuc2Zvcm1GYWN0b3J5U3BlYyhcImNoaWxkXCIsIHNwZWMsIGxldmVsLCBiYXNlLCBmYWxzZSwgZnJhZykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBJbml0aWFsaXplZENvbXBvbmVudC5GYWN0b3J5Q29tcG9uZW50ID0gRmFjdG9yeUNvbXBvbmVudDtcbiAgICAgICAgSW5pdGlhbGl6ZWRDb21wb25lbnQuY29tcG9uZW50RmFjdG9yeUlkID0gXCJGXCIgKyBfbmV4dFVJRCsrO1xuICAgICAgICBJbml0aWFsaXplZENvbXBvbmVudC5pc0NvbXBvbmVudEZhY3RvcnkgPSB0cnVlO1xuICAgICAgICBJbml0aWFsaXplZENvbXBvbmVudC5pc0Jhc2VDb21wb25lbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gSW5pdGlhbGl6ZWRDb21wb25lbnQ7XG4gICAgfShGYWN0b3J5Q29tcG9uZW50KSk7XG4gICAgLy8gYWRkIGEgcHJvcGVydHkgaW4gdGhlIHByb3RvdHlwZSB0byBpZGVudGlmeSB0aGlzIGV4YWN0IGNsYXNzIGFzIGEgZmFjdG9yeVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbml0aWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiX2ZhY3RvcnlDb21wb25lbnRcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IEZhY3RvcnlDb21wb25lbnRcbiAgICB9KTtcbiAgICByZXR1cm4gSW5pdGlhbGl6ZWRDb21wb25lbnQ7XG59XG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIHJlc29sdmUgUHJvbWlzZSBvciBCaW5kaW5nLCBvciBqdXN0IGdldCB2YWx1ZSAqL1xuZnVuY3Rpb24gX2dldEFzeW5jVmFsdWUoa2V5LCB2YWx1ZSwgYmFzZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QmluZGluZykge1xuICAgICAgICAvLyBhcHBseSBhcnJheSBiaW5kaW5nIG9uIGJhc2UgY29tcG9uZW50XG4gICAgICAgIHJldHVybiB2YWx1ZS5vYnNlcnZlQXJyYXlPbihiYXNlLCBrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpbmRpbmcpIHtcbiAgICAgICAgLy8gYXBwbHkgYmluZGluZyBvbiBiYXNlIGNvbXBvbmVudFxuICAgICAgICByZXR1cm4gdmFsdWUub2JzZXJ2ZU9uKGJhc2UsIGtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJvbWlzZSB0byBvYnNlcnZhYmxlIHZhbHVlXG4gICAgICAgIHJldHVybiBBc3luYy5PYnNlcnZhYmxlVmFsdWUuZnJvbVByb21pc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhIHNpbmdsZSBjb21wb25lbnQgZmFjdG9yeSBzcGVjIHRvIGEgVUkgY29tcG9uZW50LCBvciBhbiBvYnNlcnZhYmxlIHZhbHVlIChpZiBnaXZlbiBzb3VyY2UgaXMgUHJvbWlzZUxpa2UpOyBlaXRoZXIgdGhlIG9iamVjdCBhbmQgcHJvcGVydHkgbmFtZSBtdXN0IGJlIHNwZWNpZmllZCwgb3IgdGhlIHByb3BlcnR5IG5hbWUgYW5kIHZhbHVlIChpZiByZWN1cnNlZCkgKi9cbmZ1bmN0aW9uIF90cmFuc2Zvcm1GYWN0b3J5U3BlYyhrZXksIHNyYywgdGFyZ2V0TGV2ZWwsIGJhc2UsIGFzVGFibGVDb2wsIGFjY2VwdEZyYWdtZW50cykge1xuICAgIC8vIGdldCB2YWx1ZSBmcm9tIHByb3BlcnR5LCByZXNvbHZlIHByb21pc2VzL2JpbmRpbmdzIGFzIG9ic2VydmFibGUgdmFsdWVzXG4gICAgdmFyIHZhbHVlID0gX2dldEFzeW5jVmFsdWUoa2V5LCBzcmMsIGJhc2UpO1xuICAgIC8vIHJlY3Vyc2UgZm9yIG9ic2VydmFibGUgdmFsdWVzIChhbmQgcHJvbWlzZXMsIGJpbmRpbmdzLi4uKVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFzeW5jLk9ic2VydmFibGVWYWx1ZSlcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90cmFuc2Zvcm1GYWN0b3J5U3BlYyhrZXksIHZhbHVlLCB0YXJnZXRMZXZlbCwgYmFzZSwgYXNUYWJsZUNvbCk7IH0pO1xuICAgIC8vIHVzZSBmYWN0b3JpZXMgdG8gaW5zdGFudGlhdGUgbmVzdGVkIGVsZW1lbnRzXG4gICAgaWYgKHNyYyAmJiBzcmMuaXNDb21wb25lbnRGYWN0b3J5KSB7XG4gICAgICAgIHZhciBGID0gc3JjO1xuICAgICAgICBGLmlzQmFzZUNvbXBvbmVudCA9IGZhbHNlO1xuICAgICAgICBzcmMgPSBuZXcgRigpO1xuICAgICAgICBzcmMuaW5pdGlhbGl6ZShiYXNlKTtcbiAgICAgICAgLy8gcmV0dXJuIGNvbXBvbmVudCB3aXRob3V0IGNoZWNraW5nL3dyYXBwaW5nIGlmIGl0IGlzIGFuIGFjY2VwdGVkIGZyYWdtZW50XG4gICAgICAgIGlmIChhY2NlcHRGcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHJlZiA9IEY7IHJlZjsgcmVmID0gcmVmLkZhY3RvcnlDb21wb25lbnQpXG4gICAgICAgICAgICAgICAgaWYgKHJlZi5pc0ZyYWdtZW50RmFjdG9yeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjcmVhdGUgdmFsaWQgQ29tcG9uZW50XG4gICAgaWYgKHR5cGVvZiBzcmMgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygc3JjID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKCFhc1RhYmxlQ29sKVxuICAgICAgICAgICAgc3JjID0gbmV3IExhYmVsKFN0cmluZyhzcmMpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgLy8gY3JlYXRlIHN0YWNrIG9yICh0YWJsZSkgcm93IGNvbnRhaW5pbmcgZ2l2ZW4gY29tcG9uZW50c1xuICAgICAgICBpZiAodGFyZ2V0TGV2ZWwgPT09IENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLlRhYmxlUm93KVxuICAgICAgICAgICAgc3JjID0gbmV3IFRhYmxlUm93KF90cmFuc2Zvcm1GYWN0b3J5QXJyYXkoa2V5LCBzcmMsIENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkNvbnRyb2xFbGVtZW50LCBiYXNlLCB0cnVlKSk7XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldExldmVsID09PSBDb21wb25lbnRGYWN0b3J5LkNMZXZlbC5UYWJsZUhlYWRlcilcbiAgICAgICAgICAgIHNyYyA9IG5ldyBUYWJsZUhlYWRlcihfdHJhbnNmb3JtRmFjdG9yeUFycmF5KGtleSwgc3JjLCBDb21wb25lbnRGYWN0b3J5LkNMZXZlbC5Db250cm9sRWxlbWVudCwgYmFzZSwgdHJ1ZSkpO1xuICAgICAgICBlbHNlIGlmICh0YXJnZXRMZXZlbCA9PT0gQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udHJvbEVsZW1lbnQpXG4gICAgICAgICAgICBzcmMgPSBuZXcgQ29udHJvbFN0YWNrKF90cmFuc2Zvcm1GYWN0b3J5QXJyYXkoa2V5LCBzcmMsIENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkNvbnRyb2xFbGVtZW50LCBiYXNlKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNyYyA9IG5ldyBSb3coX3RyYW5zZm9ybUZhY3RvcnlBcnJheShrZXksIHNyYywgQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udHJvbEVsZW1lbnQsIGJhc2UpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHNyYyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSAmJlxuICAgICAgICAoc3JjLnByb3RvdHlwZSBpbnN0YW5jZW9mIENvbXBvbmVudCkpIHtcbiAgICAgICAgLy8gaW5zdGFudGlhdGUgZ2l2ZW4gY29tcG9uZW50IGNsYXNzXG4gICAgICAgIHNyYyA9IG5ldyBzcmMoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgVGV4dExhYmVsRmFjdG9yeSkge1xuICAgICAgICAvLyByZXR1cm4gKG9ic2VydmFibGUpIGNvbXBvbmVudCwgb3IgY3JlYXRlIFJvdyBvciBDb250YWluZXJcbiAgICAgICAgc3JjID0gc3JjLmdldENvbXBvbmVudChiYXNlLCBrZXkpO1xuICAgICAgICBpZiAodGFyZ2V0TGV2ZWwgIT09IENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkNvbnRyb2xFbGVtZW50KSB7XG4gICAgICAgICAgICBzcmMgPSBuZXcgUm93KFtzcmNdKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRMZXZlbCAhPT0gQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQmxvY2spXG4gICAgICAgICAgICAgICAgc3JjID0gbmV3IENvbnRhaW5lcihbc3JjXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgLy8gd3JhcCBpZiBuZWVkZWRcbiAgICBpZiAodGFyZ2V0TGV2ZWwgPT09IENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkNvbnRyb2xFbGVtZW50KSB7XG4gICAgICAgIC8vIHdyYXAgdG8gY2xhc3MgZG93biB0byBDb250cm9sRWxlbWVudFxuICAgICAgICBpZiAoc3JjIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbCA9IG5ldyBDb250YWluZXJDb250cm9sKHNyYyk7XG4gICAgICAgICAgICBpZiAoc3JjLndpZHRoICE9PSBcImF1dG9cIilcbiAgICAgICAgICAgICAgICBjb250cm9sLnNocmlua3dyYXAgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYyBpbnN0YW5jZW9mIEJsb2NrICYmICFhc1RhYmxlQ29sKSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbCA9IG5ldyBCbG9ja0NvbnRyb2woc3JjKTtcbiAgICAgICAgICAgIGlmIChzcmMud2lkdGggIT09IFwiYXV0b1wiKVxuICAgICAgICAgICAgICAgIGNvbnRyb2wuc2hyaW5rd3JhcCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXRMZXZlbCA9PT0gQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQmxvY2spIHtcbiAgICAgICAgLy8gd3JhcCBpbnRvIFJvdywgb3IgY2xhc3MgZG93biB0byBSb3dcbiAgICAgICAgaWYgKHNyYyBpbnN0YW5jZW9mIENvbnRyb2xFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSb3coW3NyY10pO1xuICAgICAgICBpZiAoc3JjIGluc3RhbmNlb2YgQ29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250YWluZXJCbG9jayhzcmMpO1xuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXRMZXZlbCA9PT0gQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuVGFibGVSb3cgfHxcbiAgICAgICAgdGFyZ2V0TGV2ZWwgPT09IENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLlRhYmxlSGVhZGVyKSB7XG4gICAgICAgIC8vIHdyYXAgaW50byB0YWJsZSByb3dcbiAgICAgICAgaWYgKChzcmMgaW5zdGFuY2VvZiBUYWJsZVJvdykgfHwgKHNyYyBpbnN0YW5jZW9mIFRhYmxlSGVhZGVyKSlcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIGlmIChzcmMgaW5zdGFuY2VvZiBDb250YWluZXIpXG4gICAgICAgICAgICBzcmMgPSBuZXcgQ29udGFpbmVyQ29udHJvbChzcmMpO1xuICAgICAgICBpZiAoc3JjICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhYmxlUm93KFtzcmNdKTtcbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHdyYXAgaW50byAoUm93LCBhbmQgdGhlbikgY29udGFpbmVyXG4gICAgICAgIGlmIChzcmMgaW5zdGFuY2VvZiBDb250cm9sRWxlbWVudClcbiAgICAgICAgICAgIHNyYyA9IG5ldyBSb3coW3NyY10pO1xuICAgICAgICBpZiAoc3JjIGluc3RhbmNlb2YgQmxvY2spIHtcbiAgICAgICAgICAgIHZhciBibG9ja18xID0gc3JjO1xuICAgICAgICAgICAgc3JjID0gbmV3IENvbnRhaW5lcihbYmxvY2tfMV0pO1xuICAgICAgICAgICAgc3JjLmhlaWdodCA9IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gYmxvY2tfMS5oZWlnaHQ7IH0pO1xuICAgICAgICAgICAgc3JjLndpZHRoID0gQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBibG9ja18xLndpZHRoO1xuICAgICAgICAgICAgICAgIHJldHVybiAodyAhPT0gXCJhdXRvXCIpID8gdyA6IFwiXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbn1cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGFuIChvYnNlcnZhYmxlKSBhcnJheSBvZiBjb21wb25lbnQgZmFjdG9yeSBzcGVjcyAqL1xuZnVuY3Rpb24gX3RyYW5zZm9ybUZhY3RvcnlBcnJheShrZXksIHNyYywgdGFyZ2V0TGV2ZWwsIGJhc2UsIGFzVGFibGVDb2wpIHtcbiAgICBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXlCaW5kaW5nKSB7XG4gICAgICAgIC8vIHVzZSBib3VuZCBhcnJheSBkaXJlY3RseSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICAgIHNyYyA9IHNyYy5vYnNlcnZlQXJyYXlPbihiYXNlLCBrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBCaW5kaW5nKSB7XG4gICAgICAgIC8vIHJlY3Vyc2UgZm9yIGJpbmRpbmdzXG4gICAgICAgIHJldHVybiBzcmMub2JzZXJ2ZU9uKGJhc2UsIGtleSkubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90cmFuc2Zvcm1GYWN0b3J5QXJyYXkoa2V5LCB2YWx1ZSwgdGFyZ2V0TGV2ZWwsIGJhc2UsIGFzVGFibGVDb2wpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXN5bmMuT2JzZXJ2YWJsZVZhbHVlKSB7XG4gICAgICAgIC8vIHJlY3Vyc2UgZm9yIG9ic2VydmFibGUgdmFsdWVzXG4gICAgICAgIHJldHVybiBzcmMubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RyYW5zZm9ybUZhY3RvcnlBcnJheShrZXksIHZhbHVlLCB0YXJnZXRMZXZlbCwgYmFzZSwgYXNUYWJsZUNvbCk7IH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHR5cGVvZiBzcmMudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIHJlY3Vyc2UgZm9yIHByb21pc2VzIG9mIChvYnNlcnZhYmxlKSBhcnJheXNcbiAgICAgICAgdmFyIG9idiA9IEFzeW5jLk9ic2VydmFibGVWYWx1ZS5mcm9tUHJvbWlzZShzcmMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtRmFjdG9yeUFycmF5KGtleSwgdmFsdWUsIHRhcmdldExldmVsLCBiYXNlLCBhc1RhYmxlQ29sKTtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyB1c2UgYW4gZW1wdHkgYXJyYXkgKHJhdGhlciB0aGFuIHVuZGVmaW5lZCkgaW5pdGlhbGx5LFxuICAgICAgICAvLyBpZiBwcm9taXNlIHdhcyBub3QgYWxyZWFkeSBmdWxmaWxsZWRcbiAgICAgICAgaWYgKCFvYnYuZ2V0TGFzdFZhbHVlKCkpXG4gICAgICAgICAgICBvYnYudmFsdWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIG9idjtcbiAgICB9XG4gICAgaWYgKHNyYyBpbnN0YW5jZW9mIEFzeW5jLk9ic2VydmFibGVBcnJheSkge1xuICAgICAgICAvLyBtYXAgb2JzZXJ2YWJsZSBhcnJheSBhc3luY2hyb25vdXNseSBhbmQgbGF6aWx5XG4gICAgICAgIHJldHVybiBzcmMubWFwQXN5bmMoZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIF90cmFuc2Zvcm1GYWN0b3J5U3BlYyhrZXkgKyBcIi5cIiArIGksIHYsIHRhcmdldExldmVsLCBiYXNlLCBhc1RhYmxlQ29sKTsgfSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgLy8gY3JlYXRlIGFuIG9ic2VydmFibGUgYXJyYXkgYnV0IG1hcCBvbmx5IG9uY2VcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBc3luYy5PYnNlcnZhYmxlQXJyYXkoKTtcbiAgICAgICAgcmVzdWx0Lmxlbmd0aCA9IHNyYy5sZW5ndGg7XG4gICAgICAgIHNyYy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBfdHJhbnNmb3JtRmFjdG9yeVNwZWMoa2V5ICsgXCIuXCIgKyBpLCB2LCB0YXJnZXRMZXZlbCwgYmFzZSwgYXNUYWJsZUNvbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyB0byBtYXAsIHJldHVybiBhbiBlbXB0eSBhcnJheVxuICAgICAgICByZXR1cm4gbmV3IEFzeW5jLk9ic2VydmFibGVBcnJheSgpO1xuICAgIH1cbn1cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGEgY29tcG9uZW50IGZhY3Rvcnkgc3BlYyB2YWx1ZSAqL1xuZnVuY3Rpb24gX3RyYW5zZm9ybU9ic2VydmFibGVJbml0aWFsaXplcihrZXksIHZhbHVlLCB0YXJnZXRMZXZlbCwgYmFzZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFzeW5jLk9ic2VydmFibGVWYWx1ZSkge1xuICAgICAgICAvLyByZWN1cnNlIGZvciBvYnNlcnZhYmxlIHZhbHVlc1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBfdHJhbnNmb3JtT2JzZXJ2YWJsZUluaXRpYWxpemVyKGtleSwgdiwgdGFyZ2V0TGV2ZWwsIGJhc2UpOyB9KTtcbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHRyYW5zZm9ybSBzcGVjIG5vd1xuICAgIHJldHVybiBfdHJhbnNmb3JtRmFjdG9yeVNwZWMoa2V5LCB2YWx1ZSwgdGFyZ2V0TGV2ZWwsIGJhc2UpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29tcG9uZW50RmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgU3R5bGUgfSBmcm9tIFwiLi4vU3R5bGVcIjtcbmltcG9ydCB7IENvbXBvbmVudFNpZ25hbCwgRHJhZ0V2ZW50U2lnbmFsLCBLZXlFdmVudFNpZ25hbCwgUG9pbnRlckV2ZW50U2lnbmFsLCBkZWZpbmVDb21wb25lbnRTaWduYWwgfSBmcm9tIFwiLi9Db21wb25lbnRTaWduYWxcIjtcbmltcG9ydCB7IENvbXBvbmVudEZhY3RvcnksIG1ha2VGYWN0b3J5IH0gZnJvbSBcIi4vQ29tcG9uZW50RmFjdG9yeVwiO1xuLyoqIE5leHQgY29tcG9uZW50IFVJRCAqL1xudmFyIF9uZXh0VUlEID0gMTtcbi8qKiBOZXh0IHNlbGVjdGlvbiBvcmRlciBudW1iZXIgKGluY3JlbWVudGVkIHdoZW4gYW4gZWxlbWVudCBpcyBzZWxlY3RlZCkgKi9cbnZhciBfc2VsZWN0aW9uT3JkZXIgPSAxO1xuLyoqIENvbXBvbmVudCBiYXNlIGNsYXNzIHRvIHJlcHJlc2VudCBldmVyeSBwYXJ0IG9mIHRoZSB1c2VyIGludGVyZmFjZSwgdG8gYmUgZXh0ZW5kZWQgYnkgYXBwbGljYXRpb24gY29kZSAoZS5nLiBhcyBhIHN1YiBjbGFzcyBvZiBgQ29udGFpbmVyYCBvciBhbm90aGVyIGNvbXBvbmVudCBjbGFzcykgb3IgY29uc3RydWN0ZWQgZnJvbSBkZXJpdmVkIGNvbXBvbmVudCBjbGFzc2VzIChlLmcuIGBCdXR0b25gKSAqL1xudmFyIENvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICAvKiogQWJzdHJhY3QgY29uc3RydWN0b3Igd2l0aCBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyAqL1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKiogR2xvYmFsbHkgdW5pcXVlIGNvbXBvbmVudCBpZGVudGlmaWVyICovXG4gICAgICAgIF90aGlzLnVpZCA9IFwiQ1wiICsgX25leHRVSUQrKztcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIGFmdGVyIHVwZGF0aW5nIERPTSAocmVuZGVyKSAqL1xuICAgICAgICBfdGhpcy5SZW5kZXJlZCA9IF90aGlzLmNyZWF0ZUNvbXBvbmVudFNpZ25hbCgpO1xuICAgICAgICAvKiogUmVhZC1vbmx5IHJlZmVyZW5jZSB0byBhbiBpbnN0YW5jZSBvZiBgU3R5bGVgLCBlbmNhcHN1bGF0aW5nIENTUyBzdHlsZXMgYW5kIGNsYXNzZXMgZm9yIHRoaXMgY29tcG9uZW50OyBmb3IgZXh0ZW5zaWJsZSBjb21wb25lbnQgY2xhc3NlcywgZG8gbm90IG92ZXJyaWRlIHRoaXMgcHJvcGVydHkgYnV0IHVzZSBzdGF0aWMgbWV0aG9kIGAuYWRkU3R5bGVPdmVycmlkZSguLi4pYCBpbnN0ZWFkICovXG4gICAgICAgIF90aGlzLnN0eWxlID0gX3RoaXNbXCJAb3ZlcnJpZGVTdHlsZVwiXShTdHlsZS53aXRoQ2xhc3MoXCJVSVwiKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gXl5eIGNvcGllZCBmcm9tIENvbXBvbmVudEZhY3RvcnkgYmVsb3dcbiAgICAvKiogSW5pdGlhbGl6ZSB0aGlzIGNvbXBvbmVudCwgaS5lLiBhcHBseSBwcm9wZXJ0aWVzIGZyb20gY29tcG9uZW50IGZhY3RvcmllcywgaWYgYW55OyBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgaGlnaGVzdC1sZXZlbCBjb21wb25lbnQgZmFjdG9yeSBjb25zdHJ1Y3RvciB3aXRoIHRoZSBiYXNlIGNvbXBvbmVudCBhcyBhcmd1bWVudCAoaS5lLiBjb21wb25lbnQgb24gd2hpY2ggYC53aXRoYCB3YXMgY2FsbGVkKSwgY2FuIGJlIG92ZXJyaWRkZW4gdG8gaW5pdGlhbGl6ZSBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aG9zZSBmcm9tIHRoZSBjb21wb25lbnQgZmFjdG9yeSAoYW5kIGludm9rZSBgc3VwZXIuaW5pdGlhbGl6ZSgpYCBtYW51YWxseSk7IHJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoaXMgY29tcG9uZW50IGhhZCBub3QgYmVlbiBpbml0aWFsaXplZCBiZWZvcmUgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6ZWQgPyBmYWxzZSA6ICh0aGlzLl9pbml0aWFsaXplZCA9IHRydWUpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBuZXcgY29tcG9uZW50IHNpZ25hbCBjbGFzcyBzcGVjaWZpYyB0byB0aGlzIGNvbXBvbmVudCwgd2l0aCBvcHRpb25hbCBzaWduYWwgYmFzZSBjbGFzcyB3aGljaCBtdXN0IGRlcml2ZSBmcm9tIENvbXBvbmVudFNpZ25hbDsgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGN1c3RvbSBzaWduYWxzIGluIGEgY29tcG9uZW50IGNvbnN0cnVjdG9yIG9yIHB1YmxpYyBwcm9wZXJ0eSBpbml0aWFsaXplciAob3IgbWVtb2l6ZWQgZ2V0LWFjY2Vzc29yIGZvciBsYXp5IGluaXRpYWxpemF0aW9uKTsgc2V0cyBzdGF0aWMgcHJvcGVydHkgYENvbXBvbmVudFNpZ25hbC5jb21wb25lbnRgIG9mIHRoZSBkZXJpdmVkIHNpZ25hbCBjbGFzcyB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLCBhcyB3ZWxsIGFzIGFueSBvdGhlciBzdGF0aWMgcHJvcGVydGllcyBnaXZlbiAqL1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlQ29tcG9uZW50U2lnbmFsID0gZnVuY3Rpb24gKGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMgPT09IHZvaWQgMCkgeyBwcm9wZXJ0aWVzID0ge307IH1cbiAgICAgICAgcmV0dXJuIGRlZmluZUNvbXBvbmVudFNpZ25hbChiYXNlIHx8IENvbXBvbmVudFNpZ25hbCwgdGhpcywgcHJvcGVydGllcyk7XG4gICAgfTtcbiAgICAvLyA9LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS1cbiAgICAvLyBISUVSQVJDSFkgTUVUSE9EU1xuICAgIC8qKiBBZGQgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhpcyBjb21wb25lbnQ7IG9ubHkgc3VwcG9ydGVkIGJ5IGNvbXBvbmVudHMgdGhhdCBhY3R1YWxseSBjb250YWluIG90aGVyIGNvbXBvbmVudHMgKGUuZy4gYENvbnRhaW5lcmApLCB0aHJvd3MgYW4gRXJyb3Igb3RoZXJ3aXNlOyByZXR1cm5zIHRoaXMgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRpcmVjdGx5IGNvbnRhaW5lZCBjb21wb25lbnRzIChvYnNlcnZhYmxlKSAqL1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgbGlzdCBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgZGlyZWN0bHkgY29udGFpbmVkIGNvbXBvbmVudHMsIGluIG9yZGVyIG9mIHNlbGVjdGlvbiAob2JzZXJ2YWJsZSkgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmdldFNlbGVjdGVkQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENoaWxkcmVuKCkuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNlbGVjdGVkOyB9KVxuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuX3NlbGVjdGlvbk9yZGVyIC0gYi5fc2VsZWN0aW9uT3JkZXI7IH0pO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdGhlIGxhc3Qgc2VsZWN0ZWQgZGlyZWN0bHkgY29udGFpbmVkIGNvbXBvbmVudCAob2JzZXJ2YWJsZSk7IGV2YWx1YXRlZCBhc3luY2hyb25vdXNseSBpZiBhdXRvbWF0aWMgc2VsZWN0aW9uIG1hbmFnZW1lbnQgbW9kZSBpcyBgSXRlbUNsaWNrYCBvciBgSXRlbUZvY3VzYCwgb3RoZXJ3aXNlIGV2YWx1YXRlZCBzeW5jaHJvbm91c2x5IGZyb20gY3VycmVudCBzZWxlY3Rpb24gc3RhdHVzIG9mIGNoaWxkIGNvbXBvbmVudHMgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmdldExhc3RTZWxlY3RlZENoaWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFzdFNlbGVjdGlvbkFzeW5jID8gdGhpcy5fbGFzdFNlbGVjdGlvbkFzeW5jLnZhbHVlIDpcbiAgICAgICAgICAgIHRoaXMuZ2V0U2VsZWN0ZWRDaGlsZHJlbigpLnBvcCgpO1xuICAgIH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDb21wb25lbnRCeUlkID0gZnVuY3Rpb24gKGlkLCBjb21wb25lbnRDbGFzcykge1xuICAgICAgICB2YXIgcXVldWUgPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChjICYmIGMuaWQgPT09IGlkICYmXG4gICAgICAgICAgICAgICAgKCFjb21wb25lbnRDbGFzcyB8fCBjIGluc3RhbmNlb2YgY29tcG9uZW50Q2xhc3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgYyAmJiBjLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gcXVldWUucHVzaChkKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGFsbCAocmVjdXJzaXZlKSBjaGlsZCBjb21wb25lbnRzIHRoYXQgYXJlIGFuIGluc3RhbmNlIG9mIGdpdmVuIGNsYXNzIChvYnNlcnZhYmxlKSAqL1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q29tcG9uZW50c0J5VHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIGNvbXBvbmVudENsYXNzKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgYyAmJiBjLmdldENvbXBvbmVudHNCeVR5cGUoY29tcG9uZW50Q2xhc3MpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKHIpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIGdpdmVuIGNvbXBvbmVudCBpcyBhIGNoaWxkIGNvbXBvbmVudCBvZiB0aGlzIGNvbXBvbmVudCBvciBhbnkgb2YgaXRzIGNoaWxkIGNvbXBvbmVudHMgKG9ic2VydmFibGUsIGJ1dCB0cmlnZ2VycyByZS1ldmFsdWF0aW9uIHVwb24gZXZlcnkgY2hhbmdlIGluIGNoaWxkIFtzdWJdIGNvbXBvbmVudHMpICovXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoYyA9PT0gY29tcG9uZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgYyAmJiBjLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gcXVldWUucHVzaChkKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGN1cnJlbnQgdmFsdWVzIG9mIGlucHV0IGVsZW1lbnRzIChvYnNlcnZhYmxlKSAqL1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Rm9ybVZhbHVlcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7IHJlc3VsdCA9IHt9OyB9XG4gICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHYuZ2V0Rm9ybVZhbHVlcyhyZXN1bHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBTZXQgYWxsIGlucHV0IHZhbHVlcyBieSBlbGVtZW50IG5hbWUgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldEZvcm1WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHYuc2V0Rm9ybVZhbHVlcyh2YWx1ZXMpOyB9KTtcbiAgICB9O1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uIChhbmltYXRpb24sIGNvbnRpbnVvdXMsIGFmdGVyKSB7XG4gICAgICAgIHZhciBhbmltID0gKHR5cGVvZiBhbmltYXRpb24gPT09IFwic3RyaW5nXCIpID9cbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyAmJiB0aGlzLmFuaW1hdGlvbnNbYW5pbWF0aW9uXSA6XG4gICAgICAgICAgICBhbmltYXRpb247XG4gICAgICAgIHZhciBjb250cm9sID0gYW5pbSA/XG4gICAgICAgICAgICBjb250aW51b3VzID8gYW5pbS5wbGF5KHRoaXMpIDogYW5pbS5wbGF5T25jZSh0aGlzKSA6XG4gICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChhZnRlcilcbiAgICAgICAgICAgIGNvbnRyb2wgPyBjb250cm9sLmRvbmUudGhlbihhZnRlcikgOiBBc3luYy5kZWZlcihhZnRlcik7XG4gICAgICAgIHJldHVybiBjb250cm9sO1xuICAgIH07XG4gICAgLyoqIFdhaXQgZm9yIHRoaXMgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkIGFuZCByZXR1cm4gYSBwcm9taXNlIGZvciBpdHMgb3V0cHV0ICh2YWx1ZSBvZiBgLm91dGApLCB1bmxlc3MgdGhlIGNvbXBvbmVudCBpcyBhbHJlYWR5IHJlbmRlcmVkLCBpbiB3aGljaCBjYXNlIHRoaXMgbWV0aG9kIHJldHVybnMgYSByZXNvbHZlZCBwcm9taXNlIGZvciB0aGUgbGFzdCByZW5kZXJlZCBvdXRwdXQ7IG5ldmVyIGZvcmNlcyB0aGUgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkICovXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRSZW5kZXJlZE91dHB1dEFzeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyB1c2Ugb3V0cHV0IHByb3BlcnR5IG9uIGN1cnJlbnQgcmVuZGVyZXJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3JlbmRlcmVyLm91dHB1dC5nZXRMYXN0VmFsdWUoKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGFzLWlzIChub3QgdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIEFzeW5jLlByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIGZpcnN0IG5vbi11bmRlZmluZWQgdmFsdWVcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXN5bmMuUHJvbWlzZShmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHZhciBjID0gX3RoaXMuX3JlbmRlcmVyLlJlbmRlcmVkLmNvbm5lY3QoZnVuY3Rpb24gKG91dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcihvdXQpLCBjLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgbGFzdCByZW5kZXJlZCBvdXRwdXQgZm9yIHRoaXMgY29tcG9uZW50LCBpZiBhbnkgKHZhbHVlIG9mIGAub3V0YCk7IGRvZXMgbm90IHRyaWdnZXIgYSByZW5kZXIgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmdldExhc3RSZW5kZXJlZE91dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLm91dHB1dC5nZXRMYXN0VmFsdWUoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIm91dFwiLCB7XG4gICAgICAgIC8qKiBSZW5kZXJlZCBvdXRwdXQgZm9yIHRoaXMgY29tcG9uZW50IChvYnNlcnZhYmxlKTsgcmV0cmlldmluZyB0aGlzIHZhbHVlIHRyaWdnZXJzIGEgcmVuZGVyIG9wZXJhdGlvbiwgaWYgaXQgd2FzIG5vdCBhbHJlYWR5IHN1YnNjcmliZWQgdG8sIGUuZy4gaWYgdGhlIGNvbXBvbmVudCBpcyBkaXNwbGF5ZWQgb24gc2NyZWVuOyB0aGUgcmVuZGVyZXIgaXMgbGF6aWx5IGNvbnN0cnVjdGVkIGZyb20gdGhlIGNsYXNzIHJlZmVyZW5jZSBpbmplY3RlZCBpbnRvIHRoZSBgLlJlbmRlcmVyYCBwcm9wZXJ0eSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5vdXRwdXQudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBSZW5kZXIgdGhpcyBjb21wb25lbnQgc3luY2hyb25vdXNseSwgYWx3YXlzIHVwZGF0aW5nIGFueSBleGlzdGluZyByZW5kZXJlZCBvdXRwdXQ7IHRoaXMgbWV0aG9kIHNob3VsZCBfbm90XyBiZSB1c2VkIHVubGVzcyBjaGFuZ2VzIG1heSBoYXZlIG9jY3VycmVkIG91dHNpZGUgb2YgdGhlIG9ic2VydmFibGUgY29udGV4dCwgb3RoZXJ3aXNlIHJlYWQgdGhlIHZhbHVlIGZyb20gYC5vdXRgLCBpbmNsdWRlIGl0IG9uIGEgYFBhZ2VgLCBvciB1c2UgdGhlIGAuZGlzcGxheSgpYCBtZXRob2Qgd2hlcmUgYXZhaWxhYmxlICovXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLm91dHB1dC51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLm91dHB1dC5nZXRMYXN0VmFsdWUoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIl9yZW5kZXJlclwiLCB7XG4gICAgICAgIC8qKiBDdXJyZW50IHJlbmRlcmVyIGluc3RhbmNlLCBjcmVhdGVkIHVwb24gYWNjZXNzICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5SZW5kZXJlciAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyByZW5kZXJlciBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgLy8gY29uc3RydWN0IHRoZSByZW5kZXJlciwgZm9yd2FyZCBpdHMgc2lnbmFsXG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBuZXcgdGhpcy5SZW5kZXJlcih0aGlzKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmJlZm9yZUZpcnN0UmVuZGVyID0gZnVuY3Rpb24gKCkgeyBfdGhpcy5iZWZvcmVGaXJzdFJlbmRlcihyZW5kZXJlcik7IH07XG4gICAgICAgICAgICByZW5kZXJlci5SZW5kZXJlZC5jb25uZWN0KHRoaXMuUmVuZGVyZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogTWV0aG9kIHRoYXQgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSByZW5kZXJlciBmb3IgdGhpcyBjb21wb25lbnQgaXMgY29uc3RydWN0ZWQ7IG92ZXJyaWRlIHRoaXMgbWV0aG9kIChhbmQgaW52b2tlIGBzdXBlci5iZWZvcmVGaXJzdFJlbmRlcmApIHRvIGJlIGFibGUgdG8gY2FsbCBvciBpbmplY3QgcmVuZGVyZXIgbWV0aG9kcyBiZWZvcmUgdGhpcyBjb21wb25lbnQgaXMgZmlyc3QgcmVuZGVyZWQgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmJlZm9yZUZpcnN0UmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX3dhdGNoRm9jdXNNb2RlKHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5fd2F0Y2hTZWxlY3Rpb25Nb2RlKHJlbmRlcmVyKTtcbiAgICB9O1xuICAgIC8qKiBIZWxwZXIgbWV0aG9kIHRvIHdhdGNoIGFuZCBhcHBseSBsaXN0IGZvY3VzIG1vZGUgb24gcmVuZGVyZXIgaW5zdGFuY2UgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLl93YXRjaEZvY3VzTW9kZSA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRDb25uZWN0aW9ucztcbiAgICAgICAgdmFyIHN1YnNjcmliZWQ7XG4gICAgICAgIHZhciBsaW5rcztcbiAgICAgICAgcmVuZGVyZXIud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLmZvY3VzTW9kZSA9PT0gQ29tcG9uZW50LkZvY3VzTW9kZS5JdGVtcyk7IH0sIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBpZiAoIXQgJiYgIWNoaWxkQ29ubmVjdGlvbnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgb2xkIGxpbmtzLCBhbmQgY29ubmVjdGlvbnMgdG8gdW5zdWJzY3JpYmUgZnJvbVxuICAgICAgICAgICAgdmFyIG9sZENoaWxkQ29ubmVjdGlvbnMgPSBjaGlsZENvbm5lY3Rpb25zO1xuICAgICAgICAgICAgdmFyIG9sZFN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xuICAgICAgICAgICAgbGlua3MgPSB7fTtcbiAgICAgICAgICAgIC8vIG1hbmFnZSBmb2N1cyBtb2RlIGZvciBhbGwgY2hpbGQgY29tcG9uZW50c1xuICAgICAgICAgICAgc3Vic2NyaWJlZCA9IHQgJiYgQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZENvbm5lY3Rpb25zID0gY2hpbGRDb25uZWN0aW9ucztcbiAgICAgICAgICAgICAgICBjaGlsZENvbm5lY3Rpb25zID0ge307XG4gICAgICAgICAgICAgICAgdmFyIG9sZExpbmtzID0gbGlua3M7XG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzYWJsZTtcbiAgICAgICAgICAgICAgICB2YXIgbm9BdXRvRm9jdXNDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3RoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gc2V0IG9uZSBjaGlsZCB0byBhdXRvIGZvY3VzLCByZXN0IHRvIGNsaWNrXG4gICAgICAgICAgICAgICAgdmFyIHNldFNpbmdsZUF1dG9Gb2N1cyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuZm9jdXNNb2RlID0gQ29tcG9uZW50LkZvY3VzTW9kZS5BdXRvO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgc2libGluZ3MgYmFjayB0byBjbGlja1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChzaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZyAhPT0gYyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuZm9jdXNNb2RlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQuRm9jdXNNb2RlLkF1dG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5mb2N1c01vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQuRm9jdXNNb2RlLkNsaWNrO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgYWxsIGNoaWxkcmVuIChyZS1ldmFsIHdoZW4gbGlzdCBjaGFuZ2VzKVxuICAgICAgICAgICAgICAgIHZhciBwcmV2TGluaztcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCB1bmZvY3VzYWJsZSBjb21wb25lbnRzLCByZW1lbWJlciBmaXJzdCBmb2N1c2FibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgY2xpY2sgYXMgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuZm9jdXNNb2RlID09PSBDb21wb25lbnQuRm9jdXNNb2RlLk5vbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuZm9jdXNNb2RlID09PSBDb21wb25lbnQuRm9jdXNNb2RlLkF1dG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9BdXRvRm9jdXNDaGlsZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKCFmb2N1c2FibGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZvY3VzYWJsZS5fc2VsZWN0aW9uT3JkZXIgPiBjLl9zZWxlY3Rpb25PcmRlcikpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5mb2N1c01vZGUgIT09IENvbXBvbmVudC5Gb2N1c01vZGUuSXRlbXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNhYmxlID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLmZvY3VzTW9kZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9jdXNNb2RlID0gQ29tcG9uZW50LkZvY3VzTW9kZS5DbGljaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1haW50YWluIGNoYWluIG9mIGNvbXBvbmVudHMgZm9yIG1vdmluZyB1cC9kb3duXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluayA9IG9sZExpbmtzICYmIG9sZExpbmtzW2MudWlkXSB8fCB7IGM6IGMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzW2MudWlkXSA9IGxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLnB2ID0gcHJldkxpbmsuYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2TGluay5ueCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2TGluayA9IGxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGNvbm5lY3Rpb25zIGZvciB0aGlzIGNvbXBvbmVudCwgaWYgYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkQ29ubmVjdGlvbnMgJiYgb2xkQ29ubmVjdGlvbnNbYy51aWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRDb25uZWN0aW9uc1tjLnVpZF0gPSBvbGRDb25uZWN0aW9uc1tjLnVpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9sZENvbm5lY3Rpb25zW2MudWlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gdGhpcyBjaGlsZCBjb21wb25lbnQncyBzaWduYWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRDb25uZWN0aW9uc1tjLnVpZF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZENvbm5lY3Rpb25zW2MudWlkXS5wdXNoKGMuRm9jdXNHYWluZWQuY29ubmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCB0byBhdXRvIGZvY3VzIHRvIGVuYWJsZSB0YWJiaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFNpbmdsZUF1dG9Gb2N1cyhjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgYy5BcnJvd1VwS2V5UHJlc3NlZC5jb25uZWN0KGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBwb3NzaWJsZSwgZm9jdXMgcHJldmlvdXMgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmsucHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsucHYuaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgYy5BcnJvd0Rvd25LZXlQcmVzc2VkLmNvbm5lY3QoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHBvc3NpYmxlLCBmb2N1cyBuZXh0IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5rLm54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLm54Lmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyB3YXRjaCBzaW5nbGUgc2VsZWN0ZWQgaXRlbSBhbmQgY2hhbmdlIGl0cyBmb2N1cyBtb2RlIHRvIGF1dG9cbiAgICAgICAgICAgICAgICAvLyB3cmFwIGluIHN0YXRpYyBvYnNlcnZhYmxlIHZhbHVlIHRvIG9ic2VydmUgYnV0IG5vdCByZWV2YWx1YXRlXG4gICAgICAgICAgICAgICAgLy8gKHRoaXMgaXMgdG8gY2F0Y2ggc2l0dWF0aW9ucyB3aGVyZSBzZWxlY3Rpb24gY2hhbmdlZCBpbiBjb2RlLFxuICAgICAgICAgICAgICAgIC8vIG5vdCBvbiBmb2N1cy9jbGljaywgYW5kIHVzZXIgZXhwZWN0cyB0byB0YWIgKGJhY2spIHRvIG5ld2x5XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0ZWQgaXRlbSwgbm90IGxhc3Qgb25lIGZvY3VzZWQpXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnNlbGVjdGlvbk1vZGUgPT09IENvbXBvbmVudC5TZWxlY3Rpb25Nb2RlLkl0ZW1DbGljayB8fFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3Rpb25Nb2RlID09PSBDb21wb25lbnQuU2VsZWN0aW9uTW9kZS5JdGVtRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nZXRMYXN0U2VsZWN0ZWRDaGlsZCgpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNlbCkgeyByZXR1cm4gc2VsICYmIHNldFNpbmdsZUF1dG9Gb2N1cyhzZWwpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNldCBmaXJzdCBmb2N1c2FibGUgY29tcG9uZW50IHRvIGF1dG8gaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgZm9jdXNhYmxlICYmIG5vQXV0b0ZvY3VzQ2hpbGQgJiYgQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzYWJsZS5mb2N1c01vZGUgPSBDb21wb25lbnQuRm9jdXNNb2RlLkF1dG87XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZGlzY29ubmVjdCBmcm9tIG9sZCBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gb2xkQ29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkQ29ubmVjdGlvbnNbaWRdLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuZGlzY29ubmVjdCgpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3Qgb2xkIGNvbm5lY3Rpb25zIChhZnRlciBjb25uZWN0aW5nIG5ldyBvbmVzLCB0byBwcmV2ZW50XG4gICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSBldmVudCBjb25uZWN0ZWQgc3RhdGUgZmxpcCBmbG9wcGluZylcbiAgICAgICAgICAgIG9sZFN1YnNjcmliZWQgJiYgb2xkU3Vic2NyaWJlZC5jbGVhcigpO1xuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gb2xkQ2hpbGRDb25uZWN0aW9ucylcbiAgICAgICAgICAgICAgICBvbGRDaGlsZENvbm5lY3Rpb25zW2lkXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmRpc2Nvbm5lY3QoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEhlbHBlciBtZXRob2QgdG8gd2F0Y2ggYW5kIGFwcGx5IHNlbGVjdGlvbiBtb2RlIG9uIHJlbmRlcmVyIGluc3RhbmNlICovXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5fd2F0Y2hTZWxlY3Rpb25Nb2RlID0gZnVuY3Rpb24gKHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb25uZWN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgc3Vic2NyaWJlZDtcbiAgICAgICAgcmVuZGVyZXIud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VsZWN0aW9uTW9kZTsgfSwgZnVuY3Rpb24gKHNlbGVjdGlvbk1vZGUpIHtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIGNvbm5lY3Rpb25zIHRvIHVuc3Vic2NyaWJlIGZyb21cbiAgICAgICAgICAgIF90aGlzLl9sYXN0U2VsZWN0aW9uQXN5bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgb2xkQ29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucy5zcGxpY2UoMCk7XG4gICAgICAgICAgICB2YXIgb2xkU3Vic2NyaWJlZCA9IHN1YnNjcmliZWQ7XG4gICAgICAgICAgICAvLyBjaGVjayB3aGF0IG5lZWRzIHRvIGJlIG1hbmFnZWQgaGVyZSAoY2xpY2svdG9nZ2xlL2ZvY3VzL2l0ZW1zKVxuICAgICAgICAgICAgc3dpdGNoIChzZWxlY3Rpb25Nb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFudWFsIHNlbGVjdGlvbiB1c2luZyBjbGljay90b3VjaCBvciBzcGFjZSBiYXI6XG4gICAgICAgICAgICAgICAgY2FzZSBDb21wb25lbnQuU2VsZWN0aW9uTW9kZS5DbGljazpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaWNrU2VsZWN0ID0gZnVuY3Rpb24gKCkgeyBfdGhpcy5zZWxlY3RlZCA9IHRydWU7IH07XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2goX3RoaXMuQ2xpY2tlZC5jb25uZWN0KGNsaWNrU2VsZWN0KSwgX3RoaXMuU3BhY2VCYXJQcmVzc2VkLmNvbm5lY3QoY2xpY2tTZWxlY3QpKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gbWFudWFsIHRvZ2dsZSBzZWxlY3Rpb24gdXNpbmcgY2xpY2svdG91Y2ggb3Igc3BhY2UgYmFyOlxuICAgICAgICAgICAgICAgIGNhc2UgQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUuVG9nZ2xlOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9nZ2xlXzEgPSBmdW5jdGlvbiAoKSB7IF90aGlzLnNlbGVjdGVkID0gIV90aGlzLnNlbGVjdGVkOyB9O1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9ucy5wdXNoKF90aGlzLkNsaWNrZWQuY29ubmVjdCh0b2dnbGVfMSksIF90aGlzLlNwYWNlQmFyUHJlc3NlZC5jb25uZWN0KGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljIHNlbGVjdGlvbiBvbiBmb2N1czpcbiAgICAgICAgICAgICAgICBjYXNlIENvbXBvbmVudC5TZWxlY3Rpb25Nb2RlLkZvY3VzOlxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9jdXNTZWxlY3QgPSBmdW5jdGlvbiAoKSB7IF90aGlzLnNlbGVjdGVkID0gdHJ1ZTsgfTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnMucHVzaChfdGhpcy5Gb2N1c0dhaW5lZC5jb25uZWN0KGZvY3VzU2VsZWN0KSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdCBvbmUgY2hpbGQgZWxlbWVudCBvbmx5LCBvbiBjbGljayBvciBmb2N1c1xuICAgICAgICAgICAgICAgIGNhc2UgQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUuSXRlbUNsaWNrOlxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDbGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSBDb21wb25lbnQuU2VsZWN0aW9uTW9kZS5JdGVtRm9jdXM6XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZWQgPSBfdGhpcy5fb2JzZXJ2ZVNpbmdsZVNlbGVjdGlvbihpc0NsaWNrID8gQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUuQ2xpY2sgOlxuICAgICAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUuRm9jdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fbGFzdFNlbGVjdGlvbkFzeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0U2VsZWN0aW9uQXN5bmMudmFsdWUgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIG9ic2VydmFibGUgdmFsdWUgd2l0aCBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbGFzdFNlbGVjdGlvbkFzeW5jID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEFzeW5jLk9ic2VydmFibGVWYWx1ZS5mcm9tVmFsdWUoc3Vic2NyaWJlZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgY2hpbGQgZWxlbWVudHMgdG9nZ2xlYWJsZVxuICAgICAgICAgICAgICAgIGNhc2UgQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUuSXRlbVRvZ2dsZTpcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlZCA9IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHNlbGVjdGlvbiBtb2RlIHRvIHRvZ2dsZSBmb3IgbmV3IGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnNlbGVjdGlvbk1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc2VsZWN0aW9uTW9kZSA9IENvbXBvbmVudC5TZWxlY3Rpb25Nb2RlLlRvZ2dsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3Qgb2xkIGNvbm5lY3Rpb25zIChhZnRlciBjb25uZWN0aW5nIG5ldyBvbmVzLCB0byBwcmV2ZW50XG4gICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSBldmVudCBjb25uZWN0ZWQgc3RhdGUgZmxpcCBmbG9wcGluZylcbiAgICAgICAgICAgIG9sZENvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuZGlzY29ubmVjdCgpOyB9KTtcbiAgICAgICAgICAgIGlmIChvbGRTdWJzY3JpYmVkKVxuICAgICAgICAgICAgICAgIG9sZFN1YnNjcmliZWQuY2xlYXIoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogSGVscGVyIG1ldGhvZCB0byBvYnNlcnZlIHNlbGVjdGVkIGNoaWxkIGNvbXBvbmVudChzKSwgYW5kIGRlc2VsZWN0IGFsbCBleGNlcHQgY29tcG9uZW50IHNlbGVjdGVkIGxhdGVzdDsgYWxzbyBvdmVycmlkZXMgc2VsZWN0aW9uIG1vZGUgZm9yIGNvbXBvbmVudHMgd2hlcmUgdGhpcyBwcm9wZXJ0eSBpcyB1bmRlZmluZWQ7IHJldHVybnMgYW4gb2JzZXJ2YWJsZSBmb3IgdGhlIHNpbmdsZSAobGFzdCkgc2VsZWN0ZWQgY29tcG9uZW50ICovXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5fb2JzZXJ2ZVNpbmdsZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZXRTZWxlY3Rpb25Nb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYXN0U2VsZWN0aW9uO1xuICAgICAgICAgICAgdmFyIGxhc3RTZWxlY3RlZE51bWJlcjtcbiAgICAgICAgICAgIF90aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIHZhciBpc1NlbGVjdGVkID0gYy5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuc2VsZWN0aW9uTW9kZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYy5zZWxlY3Rpb25Nb2RlID0gc2V0U2VsZWN0aW9uTW9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlc2VsZWN0IGNvbXBvbmVudCBpZiBzZWxlY3RlZCBlYXJsaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5fc2VsZWN0aW9uT3JkZXIgPCBsYXN0U2VsZWN0ZWROdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZXNlbGVjdCBjb21wb25lbnQgZm91bmQgZWFybGllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2VsZWN0aW9uLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWxlY3RlZE51bWJlciA9IGMuX3NlbGVjdGlvbk9yZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJldHVybiBsYXN0IHNlbGVjdGVkIGNvbXBvbmVudFxuICAgICAgICAgICAgcmV0dXJuIGxhc3RTZWxlY3Rpb247XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tXG4gICAgLy8gRElNRU5TSU9OUyAmIFNUWUxFXG4gICAgLyoqIEFkZCBhIG5ldyBzdHlsZSBvdmVycmlkZSB0byB0aGlzIGNvbXBvbmVudCBjbGFzcyAoYW5kIGRlcml2ZWQgY2xhc3Nlcyk7IGRvZXMgbm90IGhhdmUgYW55IGVmZmVjdCBvbiBleGlzdGluZyBjb21wb25lbnQgaW5zdGFuY2VzLCBidXQgY2hhbmdlcyB0byBwcmV2aW91c2x5IGFkZGVkIHN0eWxlIG92ZXJyaWRlcyBhcmUgYWx3YXlzIG9ic2VydmVkOyByZXR1cm5zIGdpdmVuIHN0eWxlIGluc3RhbmNlICovXG4gICAgQ29tcG9uZW50LmFkZFN0eWxlT3ZlcnJpZGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgdmFyIGNoYWluID0gQXN5bmMuaW5qZWN0KHRoaXMsIHtcbiAgICAgICAgICAgIFwiQG92ZXJyaWRlU3R5bGVcIjogZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW5bXCJAb3ZlcnJpZGVTdHlsZVwiXShwcmV2KS5vdmVycmlkZShzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsIEFkZHMgb3ZlcnJpZGVzIHRvIHRoZSBjdXJyZW50IGJhc2Ugc3R5bGUgZm9yIHRoaXMgY29tcG9uZW50IChpbmplY3RlZCB1c2luZyBgYWRkU3R5bGVPdmVycmlkZWAsIERPIE5PVCB1c2Ugb3Igb3ZlcnJpZGUgZGlyZWN0bHkpICovXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZVtfYSA9IFwiQG92ZXJyaWRlU3R5bGVcIl0gPSBmdW5jdGlvbiAoc3R5bGUpIHsgcmV0dXJuIHN0eWxlOyB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRpbWVuc2lvbnMgZm9yIHRoaXMgY29tcG9uZW50LCBpbiBsb2dpY2FsIChDU1MpIHBpeGVsIHVuaXRzOyBtYXkgcmV0dXJuIDB4MCBpZiB0aGlzIGNvbXBvbmVudCBpcyBub3QgeWV0IGRpc3BsYXllZCBvbiBzY3JlZW4gKGkuZS4gdXNlIHRoZSBgLlJlbmRlcmVkYCBzaWduYWwgYW5kL29yIGEgdGltZW91dCB0byBvYnRhaW4gYWNjdXJhdGUgcmVzdWx0cykgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlLmdldEFjdHVhbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHBsYXRmb3JtIGRlcGVuZGVudCBjb2RlXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB7XG4gICAgICAgIC8qKiBPdmVyYWxsIHRhcmdldCBoZWlnaHQgb2YgdGhpcyBjb21wb25lbnQgKENTUyBsZW5ndGg7IG9ic2VydmFibGUsIGRpcmVjdGx5IG1vZGlmaWVzIGAuc3R5bGVgIHByb3BlcnR5LCBkb2VzIF9ub3RfIHJldHJpZXZlIGFjdHVhbCBjb21wb25lbnQgaGVpZ2h0LCBtYXkgYmUgXCJhdXRvXCIpICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5oZWlnaHQgfHwgXCJhdXRvXCI7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIGlmIChoID09PSBcImF1dG9cIilcbiAgICAgICAgICAgICAgICBoID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KFwiaGVpZ2h0XCIsIHRoaXMuaGVpZ2h0ID0gaCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHtcbiAgICAgICAgLyoqIE92ZXJhbGwgdGFyZ2V0IHdpZHRoIG9mIHRoaXMgY29tcG9uZW50IChDU1MgbGVuZ3RoOyBvYnNlcnZhYmxlLCBkaXJlY3RseSBtb2RpZmllcyBgLnN0eWxlYCBwcm9wZXJ0eSwgZG9lcyBfbm90XyByZXRyaWV2ZSBhY3R1YWwgY29tcG9uZW50IHdpZHRoLCBtYXkgYmUgXCJhdXRvXCIpICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy53aWR0aCB8fCBcImF1dG9cIjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKHcgPT09IFwiYXV0b1wiKVxuICAgICAgICAgICAgICAgIHcgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQoXCJ3aWR0aFwiLCB0aGlzLndpZHRoID0gdyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcInNoYWRvd0VmZmVjdFwiLCB7XG4gICAgICAgIC8qKiBTZXQgdG8gYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHRvIGFkZCBhIGRyb3Agc2hhZG93IHRvIHRoaXMgY29tcG9uZW50IChzaGFkb3cgXCJkZXB0aFwiIG9mIDEgY3JlYXRlcyB0aGUgaWxsdXNpb24gb2YgYSBjb21wb25lbnQgbGlmdGVkIG9mZiB0aGUgY2FudmFzIHRoZSBmdXJ0aGVzdCwgMCBtZWFucyBubyBzaGFkb3cgYXQgYWxsOyBvYnNlcnZhYmxlLCBkaXJlY3RseSBhZGRzIHNoYWRvdyBlZmZlY3QgdG8gYC5zdHlsZWApICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zaGFkb3dFZmZlY3QgfHwgMDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5hZGRTaGFkb3dFZmZlY3QodGhpcy5zaGFkb3dFZmZlY3QgPSBkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIE92ZXJyaWRlIHRoZSBkcm9wIHNoYWRvdyBcImRlcHRoXCIgdmFsdWUgd2hpbGUgbW91c2UgY3Vyc29yIGlzIGhvdmVyaW5nIG92ZXIgdGhpcyBjb21wb25lbnQsIHdpdGggZ2l2ZW4gbnVtYmVyIGJldHdlZW4gMCBhbmQgMSAqL1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuYWRkU2hhZG93RWZmZWN0T25Ib3ZlciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGFkZCBhbiBvdmVycmlkaW5nIG9ic2VydmFibGUgZm9yIHRoZSBzaGFkb3cgZWZmZWN0IGRlcHRoXG4gICAgICAgIHZhciBvdmVycmlkZSA9IG5ldyBTdHlsZSgpLmFkZFNoYWRvd0VmZmVjdChkKTtcbiAgICAgICAgdGhpcy5zdHlsZS5vdmVycmlkZShBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ob3ZlclN0YXRlID8gb3ZlcnJpZGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIC8qKiBPdmVycmlkZSB0aGUgZHJvcCBzaGFkb3cgXCJkZXB0aFwiIHZhbHVlIHdoaWxlIHRoaXMgY29tcG9uZW50IG9yIGEgY2hpbGQgY29tcG9uZW50IGhhcyBpbnB1dCBmb2N1cywgd2l0aCBnaXZlbiBudW1iZXIgYmV0d2VlbiAwIGFuZCAxICovXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5hZGRTaGFkb3dFZmZlY3RPbkZvY3VzID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gYWRkIGFuIG92ZXJyaWRpbmcgb2JzZXJ2YWJsZSBmb3IgdGhlIHNoYWRvdyBlZmZlY3QgZGVwdGhcbiAgICAgICAgdmFyIG92ZXJyaWRlID0gbmV3IFN0eWxlKCkuYWRkU2hhZG93RWZmZWN0KGQpO1xuICAgICAgICB0aGlzLnN0eWxlLm92ZXJyaWRlKEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmhhc0ZvY3VzID8gb3ZlcnJpZGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcImhpZGRlblwiLCB7XG4gICAgICAgIC8qKiBTZXQgdG8gdHJ1ZSB0byBoaWRlIHRoaXMgY29tcG9uZW50IChvYnNlcnZhYmxlLCBkaXJlY3RseSBtb2RpZmllcyBoaWRkZW4gc3RhdGUgb2YgYC5zdHlsZWAgYW5kIHBsYXlzIHNob3cvaGlkZSBhbmltYXRpb25zKSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaGlkZGVuOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh5ZXNubykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIGNvbXBsZXhpdHkgaGVyZSBpcyBkdWUgdG8gYW5pbWF0aW9uOiB0aGUgZWxlbWVudCBpcyBoaWRkZW4gb25seVxuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXM7IHdoaWxlIHRoZSBTdHlsZSBvYmplY3Qgc2hvdWxkIHN0aWxsXG4gICAgICAgICAgICAvLyBvYnNlcnZlIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBpbmRpcmVjdGx5IGFzIHdlbGxcbiAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgdmFyIGRvSGlkZSA9IGZ1bmN0aW9uIChoaWRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5nZXRMYXN0UmVuZGVyZWRPdXRwdXQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgcmVuZGVyZWQgeWV0LCBkbyBub3QgYW5pbWF0ZVxuICAgICAgICAgICAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgICAgICAgICAgICAgIG8udmFsdWUgPSBoaWRlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZS5oaWRlKGhpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoaWRlICYmICFfdGhpcy5faGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGUsIHRoZW4gaGlkZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbmltYXRlKFwiaGlkZVwiLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgby52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaGlkZSAmJiBfdGhpcy5faGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3cgYW5kIGFuaW1hdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBvLnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0ZShcInNob3dcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9oaWRkZW4gPSAhIWhpZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHllc25vIGluc3RhbmNlb2YgQXN5bmMuT2JzZXJ2YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHNoYWRvdyBvYnNlcnZhYmxlIHRoYXQgY2hhbmdlcyBhZnRlciBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBvID0gQXN5bmMuT2JzZXJ2YWJsZVZhbHVlLmZyb21WYWx1ZSh0aGlzLl9oaWRkZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuaGlkZShBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuICEheWVzbm8udmFsdWU7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZG9IaWRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtb2RpZnkgc3R5bGUgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICBkb0hpZGUoeWVzbm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oaWRkZW4gPSB5ZXNubztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwge1xuICAgICAgICAvKiogU2V0IHRvIHRydWUgdG8gZGlzcGxheSB0aGlzIGNvbXBvbmVudCBpbiBhIHNlbGVjdGVkIHN0YXRlIChvYnNlcnZhYmxlLCBkaXJlY3RseSBtb2RpZmllcyBzZWxlY3RlZCBzdGF0ZSBvZiBgLnN0eWxlYCBhbmQgcGxheXMgc2VsZWN0L2Rlc2VsZWN0IGFuaW1hdGlvbnMpICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zZWxlY3RlZDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoeWVzbm8pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBjb21wbGV4aXR5IGhlcmUgaXMgZHVlIHRvIGFuaW1hdGlvbjogdGhlIGVsZW1lbnQgaXMgc2VsZWN0ZWQgb25seVxuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXM7IHdoaWxlIHRoZSBTdHlsZSBvYmplY3Qgc2hvdWxkIHN0aWxsXG4gICAgICAgICAgICAvLyBvYnNlcnZlIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBpbmRpcmVjdGx5IGFzIHdlbGxcbiAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgdmFyIGRvU2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHNlbGVjdGlvbiBtb2RlIGZpcnN0LCB1cGRhdGUgc2VsZWN0aW9uIG9yZGVyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2VsZWN0aW9uTW9kZSA9PT0gQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUuTm9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgY29tcG9uZW50IGNhbm5vdCBiZSBzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NlbGVjdGlvbk9yZGVyID0gX3NlbGVjdGlvbk9yZGVyKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuZ2V0TGFzdFJlbmRlcmVkT3V0cHV0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IHJlbmRlcmVkIHlldCwgZG8gbm90IGFuaW1hdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBvLnZhbHVlID0gc2VsZWN0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZS5zZWxlY3Qoc2VsZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNlbGVjdCAmJiBfdGhpcy5fc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5pbWF0ZSwgdGhlbiBkZXNlbGVjdFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbmltYXRlKFwiZGVzZWxlY3RcIiwgZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8udmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlLmRlc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxlY3QgJiYgIV90aGlzLl9zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3QgYW5kIGFuaW1hdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBvLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3R5bGUuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGUoXCJzZWxlY3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9zZWxlY3RlZCA9ICEhc2VsZWN0O1xuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh5ZXNubyBpbnN0YW5jZW9mIEFzeW5jLk9ic2VydmFibGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBzaGFkb3cgb2JzZXJ2YWJsZSB0aGF0IGNoYW5nZXMgYWZ0ZXIgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgbyA9IEFzeW5jLk9ic2VydmFibGVWYWx1ZS5mcm9tVmFsdWUodGhpcy5fc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuc2VsZWN0KEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gISF5ZXNuby52YWx1ZTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChkb1NlbGVjdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbW9kaWZ5IHN0eWxlIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgZG9TZWxlY3QoeWVzbm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHllc25vO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYXNGb2N1c1wiLCB7XG4gICAgICAgIC8qKiBUcnVlIGlmIHRoaXMgY29tcG9uZW50IF9vcl8gYSBjaGlsZCBjb21wb25lbnQgaGFzIGlucHV0IGZvY3VzLCBmYWxzZSBvdGhlcndpc2U7IHNldCB0byB0cnVlIHRvIGZvY3VzIHRoZSBjb21wb25lbnQgaXRzZWxmLCBpZiBhbmQgd2hlbiBhdmFpbGFibGUgKHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhpcyBjb21wb25lbnQgaXMgdW5hYmxlIHRvIHJlY2VpdmUgaW5wdXQgZm9jdXMpOyBzZXQgdG8gZmFsc2UgdG8gcmVtb3ZlIGZvY3VzIGZyb20gdGhpcyBjb21wb25lbnQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpdmVGb2N1cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2Nvbm5lY3RGb2N1cygpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0ZvY3VzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh3YW50Rm9jdXMpIHtcbiAgICAgICAgICAgIC8vIGNvbm5lY3QgdG8gcGxhdGZvcm0gZm9jdXMgZXZlbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5fbGl2ZUZvY3VzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdEZvY3VzKCk7XG4gICAgICAgICAgICAvLyBibHVyIG9yIGZvY3VzIHRoZSBjb21wb25lbnQgaXRzZWxmLCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgaWYgKCEoKHdhbnRGb2N1cyBpbnN0YW5jZW9mIEFzeW5jLk9ic2VydmFibGVWYWx1ZSkgP1xuICAgICAgICAgICAgICAgIHdhbnRGb2N1cy52YWx1ZSA6IHdhbnRGb2N1cykpXG4gICAgICAgICAgICAgICAgdGhpc1tcIkBibHVyTGl2ZUNvbXBvbmVudFwiXSgpO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2xpdmVGb2N1cykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzTW9kZSA9PT0gQ29tcG9uZW50LkZvY3VzTW9kZS5Ob25lKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGNvbXBvbmVudCBjYW5ub3QgYmUgZm9jdXNlZFwiKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJAZm9jdXNMaXZlQ29tcG9uZW50XCJdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhc0ZvY3VzID0gd2FudEZvY3VzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQGludGVybmFsIE1ldGhvZCB0byByZXRyaWV2ZSB0aGUgY3VycmVudCBmb2N1cyBzdGF0ZSBvZiBhIGNvbXBvbmVudCAoaW5qZWN0ZWQgYnkgcGxhdGZvcm0gc3BlY2lmaWMgY29kZSwgaWYgYXBwbGljYWJsZSkgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlW19iID0gXCJAZ2V0TGl2ZUNvbXBvbmVudEZvY3VzU3RhdGVcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAvKiogQGludGVybmFsIFNldCBpbnB1dCBmb2N1cyB0byB0aGlzIGNvbXBvbmVudCAoaW5qZWN0ZWQgYnkgcGxhdGZvcm0gc3BlY2lmaWMgY29kZSwgaWYgYXBwbGljYWJsZSkgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlW19jID0gXCJAZm9jdXNMaXZlQ29tcG9uZW50XCJdID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IH07XG4gICAgLyoqIEBpbnRlcm5hbCBSZW1vdmUgaW5wdXQgZm9jdXMgZnJvbSB0aGlzIGNvbXBvbmVudCAoaW5qZWN0ZWQgYnkgcGxhdGZvcm0gc3BlY2lmaWMgY29kZSwgaWYgYXBwbGljYWJsZSkgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlW19kID0gXCJAYmx1ckxpdmVDb21wb25lbnRcIl0gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqIENvbm5lY3QgRm9jdXMgYW5kIEJsdXIgc2lnbmFsIGhhbmRsZXJzIHRvIG1haW50YWluIGBfbGl2ZUZvY3VzYCBhbmQgYGhhc0ZvY3VzYCAqL1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuX2Nvbm5lY3RGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5oYXNGb2N1cyA9IHRoaXMuX2xpdmVGb2N1cyA9IHRoaXNbXCJAZ2V0TGl2ZUNvbXBvbmVudEZvY3VzU3RhdGVcIl0oKTtcbiAgICAgICAgdGhpcy5Gb2N1cy5jb25uZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9saXZlRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5CbHVyLmNvbm5lY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2xpdmVGb2N1cyA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuaGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3ZlclN0YXRlXCIsIHtcbiAgICAgICAgLyoqIFRydWUgaWYgdGhlIG1vdXNlIGN1cnNvciBpcyBob3ZlcmluZyBvdmVyIHRoaXMgY29tcG9uZW50LCBmYWxzZSBvdGhlcndpc2U7IGV2YWx1YXRlZCBsYXppbHkgdXNpbmcgYC5Nb3VzZUVudGVyYCBhbmQgYC5Nb3VzZUxlYXZlYCwgdmFsdWUgaXMgYGZhbHNlYCBpbml0aWFsbHkgdW50aWwgZmlyc3Qgc2lnbmFsIGlzIGVtaXR0ZWQgYWZ0ZXIgdGhpcyBwcm9wZXJ0eSBoYXMgYmVlbiByZWFkIG9uY2UgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9saXZlSG92ZXIpIHtcbiAgICAgICAgICAgICAgICBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xpdmVIb3ZlciA9IEFzeW5jLk9ic2VydmFibGVWYWx1ZS5mcm9tVmFsdWUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5Nb3VzZUVudGVyLmNvbm5lY3QoZnVuY3Rpb24gKCkgeyBfdGhpcy5fbGl2ZUhvdmVyLnZhbHVlID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLk1vdXNlTGVhdmUuY29ubmVjdChmdW5jdGlvbiAoKSB7IF90aGlzLl9saXZlSG92ZXIudmFsdWUgPSBmYWxzZTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGl2ZUhvdmVyLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyA9LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS1cbiAgICAvLyBFVkVOVCBTSUdOQUxTXG4gICAgLy8gTm90ZTogYWN0dWFsIGltcGxlbWVudGF0aW9uIGlzIGluamVjdGVkIGJ5IHBsYXRmb3JtIGRlcGVuZGVudCBjb2RlXG4gICAgLy8gKHNlZSBjcmVhdGVFdmVudFNpZ25hbClcbiAgICAvKiogQGludGVybmFsIE1ldGhvZCB0byBjcmVhdGUgZXZlbnQgc2lnbmFsIGZvciB0aGlzIGNvbXBvbmVudCAoaW5qZWN0ZWQgYnkgcGxhdGZvcm0gc3BlY2lmaWMgY29kZSkgKi9cbiAgICBDb21wb25lbnQucHJvdG90eXBlW19lID0gXCJAY3JlYXRlRXZlbnRTaWduYWxcIl0gPSBmdW5jdGlvbiAoaWQsIHNpZ25hbENsYXNzLCBvcHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIFwiQ2xpY2tcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBfb3JfIGEgY2hpbGQgY29tcG9uZW50IGlzIGNsaWNrZWQsIHRvdWNoZWQsIG9yIG90aGVyd2lzZSBhY3RpdmF0ZWQ7IGNhcHR1cmVkIGZyb20gY29udGFpbmVycyBkb3duIHRvIGNvbnRhaW5lZCBjb21wb25lbnRzLCBub3QgY29uc3VtZWQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIkBjcmVhdGVFdmVudFNpZ25hbFwiXShcIkNsaWNrXCIsIFBvaW50ZXJFdmVudFNpZ25hbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIkNsaWNrZWRcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhpcyBjb21wb25lbnQgX29yXyBhIGNoaWxkIGNvbXBvbmVudCBpcyBjbGlja2VkLCB0b3VjaGVkLCBvciBvdGhlcndpc2UgYWN0aXZhdGVkOyBwcm9wYWdhdGVzIGZyb20gY2hpbGQgY29tcG9uZW50cyB0byBwYXJlbnRzLCB1bnRpbCBhIGNvbXBvbmVudCBjb25zdW1lcyB0aGUgZXZlbnQgYnkgY29ubmVjdGluZyB0byB0aGlzIHNpZ25hbCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiQGNyZWF0ZUV2ZW50U2lnbmFsXCJdKFwiQ2xpY2tlZFwiLCBQb2ludGVyRXZlbnRTaWduYWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJEb3VibGVDbGlja1wiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCB3aGVuIHRoaXMgY29tcG9uZW50IF9vcl8gYSBjaGlsZCBjb21wb25lbnQgaXMgZG91YmxlLWNsaWNrZWQ7IGNhcHR1cmVkIGZyb20gY29udGFpbmVycyBkb3duIHRvIGNvbnRhaW5lZCBjb21wb25lbnRzLCBub3QgY29uc3VtZWQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIkBjcmVhdGVFdmVudFNpZ25hbFwiXShcIkRvdWJsZUNsaWNrXCIsIFBvaW50ZXJFdmVudFNpZ25hbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIkRvdWJsZUNsaWNrZWRcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhpcyBjb21wb25lbnQgX29yXyBhIGNoaWxkIGNvbXBvbmVudCBpcyBkb3VibGUtY2xpY2tlZDsgcHJvcGFnYXRlcyBmcm9tIGNoaWxkIGNvbXBvbmVudHMgdG8gcGFyZW50cywgdW50aWwgYSBjb21wb25lbnQgY29uc3VtZXMgdGhlIGV2ZW50IGJ5IGNvbm5lY3RpbmcgdG8gdGhpcyBzaWduYWwgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIkBjcmVhdGVFdmVudFNpZ25hbFwiXShcIkRvdWJsZUNsaWNrZWRcIiwgUG9pbnRlckV2ZW50U2lnbmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIFwiUHJlc3NcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiBhIG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkIGRvd24sIG9yIGEgdG91Y2ggb2NjdXJzLCBvbiB0aGlzIGNvbXBvbmVudCBfb3JfIGEgY2hpbGQgY29tcG9uZW50OyBjYXB0dXJlZCBmcm9tIGNvbnRhaW5lcnMgZG93biB0byBjb250YWluZWQgY29tcG9uZW50cywgbm90IGNvbnN1bWVkICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJAY3JlYXRlRXZlbnRTaWduYWxcIl0oXCJQcmVzc1wiLCBQb2ludGVyRXZlbnRTaWduYWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJQcmVzc2VkXCIsIHtcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIGEgbW91c2UgYnV0dG9uIGlzIHByZXNzZWQgZG93biwgb3IgYSB0b3VjaCBvY2N1cnMsIG9uIHRoaXMgY29tcG9uZW50IF9vcl8gYSBjaGlsZCBjb21wb25lbnQ7IHByb3BhZ2F0ZXMgZnJvbSBjaGlsZCBjb21wb25lbnRzIHRvIHBhcmVudHMsIHVudGlsIGEgY29tcG9uZW50IGNvbnN1bWVzIHRoZSBldmVudCBieSBjb25uZWN0aW5nIHRvIHRoaXMgc2lnbmFsICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJAY3JlYXRlRXZlbnRTaWduYWxcIl0oXCJQcmVzc2VkXCIsIFBvaW50ZXJFdmVudFNpZ25hbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIk1vdXNlRW50ZXJcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgY3Vyc29yIGJlZ2lucyB0byBob3ZlciBvdmVyIHRoaXMgY29tcG9uZW50OyBjYXB0dXJlZCBmcm9tIGNvbnRhaW5lcnMgZG93biB0byBjb250YWluZWQgY29tcG9uZW50cywgbm90IGNvbnN1bWVkICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJAY3JlYXRlRXZlbnRTaWduYWxcIl0oXCJNb3VzZUVudGVyXCIsIFBvaW50ZXJFdmVudFNpZ25hbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIk1vdXNlTGVhdmVcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgY3Vyc29yIGhhcyBsZWZ0IHRoaXMgY29tcG9uZW50OyBjYXB0dXJlZCBmcm9tIGNvbnRhaW5lcnMgZG93biB0byBjb250YWluZWQgY29tcG9uZW50cywgbm90IGNvbnN1bWVkICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJAY3JlYXRlRXZlbnRTaWduYWxcIl0oXCJNb3VzZUxlYXZlXCIsIFBvaW50ZXJFdmVudFNpZ25hbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIk1vdXNlQ29udGV4dE1lbnVcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiBhIGNvbnRleHQgbWVudSBpcyByZXF1ZXN0ZWQgZm9yIHRoaXMgY29tcG9uZW50IG9yIGEgY2hpbGQgY29tcG9uZW50ICh1c3VhbGx5IGJ5IHJpZ2h0LWNsaWNraW5nKTsgY2FwdHVyZWQgZnJvbSBjb250YWluZXJzIGRvd24gdG8gY29udGFpbmVkIGNvbXBvbmVudHMsIG5vdCBjb25zdW1lZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiQGNyZWF0ZUV2ZW50U2lnbmFsXCJdKFwiTW91c2VDb250ZXh0TWVudVwiLCBQb2ludGVyRXZlbnRTaWduYWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJLZXlEb3duXCIsIHtcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIHdoZW4gYSBrZXkgaXMgcHJlc3NlZCBkb3duICh3aGlsZSB0aGlzIGNvbXBvbmVudCBfb3JfIGEgY2hpbGQgY29tcG9uZW50IGlzIGZvY3VzZWQpOyBjYXB0dXJlZCBmcm9tIGNvbnRhaW5lcnMgZG93biB0byBjb250YWluZWQgY29tcG9uZW50cywgbm90IGNvbnN1bWVkICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJAY3JlYXRlRXZlbnRTaWduYWxcIl0oXCJLZXlEb3duXCIsIEtleUV2ZW50U2lnbmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIFwiS2V5UHJlc3NcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgYWZ0ZXIgYSBrZXkgaXMgcHJlc3NlZCAod2hpbGUgdGhpcyBjb21wb25lbnQgX29yXyBhIGNoaWxkIGNvbXBvbmVudCBpcyBmb2N1c2VkKTsgY2FwdHVyZWQgZnJvbSBjb250YWluZXJzIGRvd24gdG8gY29udGFpbmVkIGNvbXBvbmVudHMsIG5vdCBjb25zdW1lZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiQGNyZWF0ZUV2ZW50U2lnbmFsXCJdKFwiS2V5UHJlc3NcIiwgS2V5RXZlbnRTaWduYWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJGb2N1c1wiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCB3aGVuIHRoaXMgY29tcG9uZW50IF9vcl8gYSBjaGlsZCBjb21wb25lbnQgcmVjZWl2ZXMgZm9jdXM7IGNhcHR1cmVkIGZyb20gY29udGFpbmVycyBkb3duIHRvIGNvbnRhaW5lZCBjb21wb25lbnRzLCBub3QgY29uc3VtZWQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIkBjcmVhdGVFdmVudFNpZ25hbFwiXShcIkZvY3VzXCIsIENvbXBvbmVudFNpZ25hbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIkJsdXJcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGlzIGNvbXBvbmVudCBfb3JfIGEgY2hpbGQgY29tcG9uZW50IGxvc2VzIGZvY3VzOyBjYXB0dXJlZCBmcm9tIGNvbnRhaW5lcnMgZG93biB0byBjb250YWluZWQgY29tcG9uZW50cywgbm90IGNvbnN1bWVkICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJAY3JlYXRlRXZlbnRTaWduYWxcIl0oXCJCbHVyXCIsIENvbXBvbmVudFNpZ25hbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIkZvY3VzR2FpbmVkXCIsIHtcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHRoaXMgY29tcG9uZW50IHJlY2VpdmVzIGZvY3VzOyBwcm9wYWdhdGVzIGZyb20gY2hpbGQgY29tcG9uZW50cyB0byBwYXJlbnRzLCB1bnRpbCBhIGNvbXBvbmVudCBjb25zdW1lcyB0aGUgZXZlbnQgYnkgY29ubmVjdGluZyB0byB0aGlzIHNpZ25hbCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiQGNyZWF0ZUV2ZW50U2lnbmFsXCJdKFwiRm9jdXNHYWluZWRcIiwgQ29tcG9uZW50U2lnbmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIFwiRm9jdXNMb3N0XCIsIHtcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHRoaXMgY29tcG9uZW50IGxvc2VzIGZvY3VzLCBhbmQgb25seSBpZiBgLkZvY3VzR2FpbmVkYCB3YXMgZW1pdHRlZCBwcmV2aW91c2x5OyBwcm9wYWdhdGVzIGZyb20gY2hpbGQgY29tcG9uZW50cyB0byBwYXJlbnRzLCBub3QgY29uc3VtYWJsZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiQGNyZWF0ZUV2ZW50U2lnbmFsXCJdKFwiRm9jdXNMb3N0XCIsIENvbXBvbmVudFNpZ25hbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIkRyYWdTdGFydFwiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCB3aGVuIHRoaXMgY29tcG9uZW50IF9vcl8gYSBjaGlsZCBjb21wb25lbnQgY29tbWVuY2VzIGEgZHJhZyBvcGVyYXRpb247IGNhcHR1cmVkIGZyb20gY29udGFpbmVycyBkb3duIHRvIGNvbnRhaW5lZCBjb21wb25lbnRzLCBub3QgY29uc3VtZWQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIkBjcmVhdGVFdmVudFNpZ25hbFwiXShcIkRyYWdTdGFydFwiLCBEcmFnRXZlbnRTaWduYWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJEcmFnRW50ZXJcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiBhIGRyYWcgb3BlcmF0aW9uIGJlZ2lucyB0byBob3ZlciBvdmVyIHRoaXMgY29tcG9uZW50OyBjYXB0dXJlZCBmcm9tIGNvbnRhaW5lcnMgZG93biB0byBjb250YWluZWQgY29tcG9uZW50cywgbm90IGNvbnN1bWFibGUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIkBjcmVhdGVFdmVudFNpZ25hbFwiXShcIkRyYWdFbnRlclwiLCBEcmFnRXZlbnRTaWduYWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJEcmFnTGVhdmVcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiBhIGRyYWcgb3BlcmF0aW9uIGhhcyBsZWZ0IHRoaXMgY29tcG9uZW50OyBjYXB0dXJlZCBmcm9tIGNvbnRhaW5lcnMgZG93biB0byBjb250YWluZWQgY29tcG9uZW50cywgbm90IGNvbnN1bWFibGUgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcIkBjcmVhdGVFdmVudFNpZ25hbFwiXShcIkRyYWdMZWF2ZVwiLCBEcmFnRXZlbnRTaWduYWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJEcmFnRHJvcFwiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCB3aGVuIHRoaXMgZWxlbWVudCBvciBhIGNoaWxkIGVsZW1lbnQgaXMgdGhlIHRhcmdldCBvZiBhIGRyb3AgYWZ0ZXIgYSBkcmFnIG9wZXJhdGlvbjsgY2FwdHVyZWQgZnJvbSBjb250YWluZXJzIGRvd24gdG8gY29udGFpbmVkIGNvbXBvbmVudHMsIG5vdCBjb25zdW1lZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiQGNyZWF0ZUV2ZW50U2lnbmFsXCJdKFwiRHJhZ0Ryb3BcIiwgRHJhZ0V2ZW50U2lnbmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tXG4gICAgLy8gS0VZUFJFU1MgRVZFTlRTXG4gICAgLyoqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBrZXkgZXZlbnQgc2lnbmFsICovXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5fbWFrZUtleUV2ZW50ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpc1tcIkBjcmVhdGVFdmVudFNpZ25hbFwiXShcIkZuS2V5UHJlc3NlZFwiLCBLZXlFdmVudFNpZ25hbCwga2V5KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIkVudGVyS2V5UHJlc3NlZFwiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCBhZnRlciB0aGUgZW50ZXIga2V5IGlzIHByZXNzZWQgKHdoaWxlIGZvY3VzZWQpOyBwcm9wYWdhdGVzIGZyb20gY2hpbGQgY29tcG9uZW50cyB0byBwYXJlbnRzLCB1bnRpbCBhIGNvbXBvbmVudCBjb25zdW1lcyB0aGUgZXZlbnQgYnkgY29ubmVjdGluZyB0byB0aGlzIHNpZ25hbCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21ha2VLZXlFdmVudCgxMyk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIlNwYWNlQmFyUHJlc3NlZFwiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCBhZnRlciB0aGUgc3BhY2UgYmFyIGlzIHByZXNzZWQgKHdoaWxlIGZvY3VzZWQpOyBwcm9wYWdhdGVzIGZyb20gY2hpbGQgY29tcG9uZW50cyB0byBwYXJlbnRzLCB1bnRpbCBhIGNvbXBvbmVudCBjb25zdW1lcyB0aGUgZXZlbnQgYnkgY29ubmVjdGluZyB0byB0aGlzIHNpZ25hbCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21ha2VLZXlFdmVudCgzMik7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIkJhY2tzcGFjZUtleVByZXNzZWRcIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgYWZ0ZXIgdGhlIGJhY2tzcGFjZSBrZXkgaXMgcHJlc3NlZCAod2hpbGUgZm9jdXNlZCk7IHByb3BhZ2F0ZXMgZnJvbSBjaGlsZCBjb21wb25lbnRzIHRvIHBhcmVudHMsIHVudGlsIGEgY29tcG9uZW50IGNvbnN1bWVzIHRoZSBldmVudCBieSBjb25uZWN0aW5nIHRvIHRoaXMgc2lnbmFsICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFrZUtleUV2ZW50KDgpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJEZWxldGVLZXlQcmVzc2VkXCIsIHtcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIGFmdGVyIHRoZSBmb3J3YXJkLWRlbGV0ZSBrZXkgaXMgcHJlc3NlZCAod2hpbGUgZm9jdXNlZCk7IHByb3BhZ2F0ZXMgZnJvbSBjaGlsZCBjb21wb25lbnRzIHRvIHBhcmVudHMsIHVudGlsIGEgY29tcG9uZW50IGNvbnN1bWVzIHRoZSBldmVudCBieSBjb25uZWN0aW5nIHRvIHRoaXMgc2lnbmFsICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFrZUtleUV2ZW50KDQ2KTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIFwiRXNjYXBlS2V5UHJlc3NlZFwiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCBhZnRlciB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkICh3aGlsZSBmb2N1c2VkKTsgcHJvcGFnYXRlcyBmcm9tIGNoaWxkIGNvbXBvbmVudHMgdG8gcGFyZW50cywgdW50aWwgYSBjb21wb25lbnQgY29uc3VtZXMgdGhlIGV2ZW50IGJ5IGNvbm5lY3RpbmcgdG8gdGhpcyBzaWduYWwgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYWtlS2V5RXZlbnQoMjcpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJBcnJvd0xlZnRLZXlQcmVzc2VkXCIsIHtcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIGFmdGVyIHRoZSBsZWZ0IGFycm93L2QtcGFkIGtleSBpcyBwcmVzc2VkICh3aGlsZSBmb2N1c2VkKTsgcHJvcGFnYXRlcyBmcm9tIGNoaWxkIGNvbXBvbmVudHMgdG8gcGFyZW50cywgdW50aWwgYSBjb21wb25lbnQgY29uc3VtZXMgdGhlIGV2ZW50IGJ5IGNvbm5lY3RpbmcgdG8gdGhpcyBzaWduYWwgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYWtlS2V5RXZlbnQoMzcpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJBcnJvd1VwS2V5UHJlc3NlZFwiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCBhZnRlciB0aGUgdXAgYXJyb3cvZC1wYWQga2V5IGlzIHByZXNzZWQgKHdoaWxlIGZvY3VzZWQpOyBwcm9wYWdhdGVzIGZyb20gY2hpbGQgY29tcG9uZW50cyB0byBwYXJlbnRzLCB1bnRpbCBhIGNvbXBvbmVudCBjb25zdW1lcyB0aGUgZXZlbnQgYnkgY29ubmVjdGluZyB0byB0aGlzIHNpZ25hbCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21ha2VLZXlFdmVudCgzOCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBcIkFycm93UmlnaHRLZXlQcmVzc2VkXCIsIHtcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIGFmdGVyIHRoZSByaWdodCBhcnJvdy9kLXBhZCBrZXkgaXMgcHJlc3NlZCAod2hpbGUgZm9jdXNlZCk7IHByb3BhZ2F0ZXMgZnJvbSBjaGlsZCBjb21wb25lbnRzIHRvIHBhcmVudHMsIHVudGlsIGEgY29tcG9uZW50IGNvbnN1bWVzIHRoZSBldmVudCBieSBjb25uZWN0aW5nIHRvIHRoaXMgc2lnbmFsICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFrZUtleUV2ZW50KDM5KTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIFwiQXJyb3dEb3duS2V5UHJlc3NlZFwiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCBhZnRlciB0aGUgZG93biBhcnJvdy9kLXBhZCBrZXkgaXMgcHJlc3NlZCAod2hpbGUgZm9jdXNlZCk7IHByb3BhZ2F0ZXMgZnJvbSBjaGlsZCBjb21wb25lbnRzIHRvIHBhcmVudHMsIHVudGlsIGEgY29tcG9uZW50IGNvbnN1bWVzIHRoZSBldmVudCBieSBjb25uZWN0aW5nIHRvIHRoaXMgc2lnbmFsICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFrZUtleUV2ZW50KDQwKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcImRpc3BsYXlPcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcInJlbmRlck9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmxvd0RpcmVjdGlvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5pbmplY3RhYmxlXG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJSZW5kZXJlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcIl9yZW5kZXJlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMuaW5qZWN0YWJsZVxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIF9hLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMuaW5qZWN0YWJsZVxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2V0QWN0dWFsRGltZW5zaW9uc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hhZG93RWZmZWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LnNldHRlckZvcihcInNoYWRvd0VmZmVjdE9uSG92ZXJcIilcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcImFkZFNoYWRvd0VmZmVjdE9uSG92ZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3Rvcnkuc2V0dGVyRm9yKFwic2hhZG93RWZmZWN0T25Gb2N1c1wiKVxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWRkU2hhZG93RWZmZWN0T25Gb2N1c1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGlkZGVuXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0aW9uTW9kZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb2N1c01vZGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGFzRm9jdXNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLmluamVjdGFibGVcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBfYiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLmluamVjdGFibGVcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBfYywgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLmluamVjdGFibGVcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBfZCwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcImhvdmVyU3RhdGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLmluamVjdGFibGVcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBfZSwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiQ2xpY2tcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiQ2xpY2tlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJEb3VibGVDbGlja1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJEb3VibGVDbGlja2VkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcIlByZXNzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcIlByZXNzZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiTW91c2VFbnRlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJNb3VzZUxlYXZlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcIk1vdXNlQ29udGV4dE1lbnVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiS2V5RG93blwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJLZXlQcmVzc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJGb2N1c1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJCbHVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcIkZvY3VzR2FpbmVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcIkZvY3VzTG9zdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJEcmFnU3RhcnRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiRHJhZ0VudGVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcIkRyYWdMZWF2ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJEcmFnRHJvcFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJFbnRlcktleVByZXNzZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiU3BhY2VCYXJQcmVzc2VkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcIkJhY2tzcGFjZUtleVByZXNzZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiRGVsZXRlS2V5UHJlc3NlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29tcG9uZW50LnByb3RvdHlwZSwgXCJFc2NhcGVLZXlQcmVzc2VkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBDb21wb25lbnQucHJvdG90eXBlLCBcIkFycm93TGVmdEtleVByZXNzZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiQXJyb3dVcEtleVByZXNzZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiQXJyb3dSaWdodEtleVByZXNzZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbXBvbmVudC5wcm90b3R5cGUsIFwiQXJyb3dEb3duS2V5UHJlc3NlZFwiLCBudWxsKTtcbiAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG59KEFzeW5jLk9ic2VydmFibGVPYmplY3QpKTtcbmV4cG9ydCB7IENvbXBvbmVudCB9O1xuLy8gY29weSBtZXRob2RzIGZyb20gQ29tcG9uZW50RmFjdG9yeVxuQ29tcG9uZW50LndpdGggPSBtYWtlRmFjdG9yeTtcbkNvbXBvbmVudC5wcm90b3R5cGUuaW5pdGlhbGl6ZVdpdGggPSBDb21wb25lbnRGYWN0b3J5LmluaXRpYWxpemVXaXRoO1xuKGZ1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgICAvKiogT3B0aW9ucyBmb3IgYXV0b21hdGljIGZvY3VzIG1hbmFnZW1lbnQgKi9cbiAgICB2YXIgRm9jdXNNb2RlO1xuICAgIChmdW5jdGlvbiAoRm9jdXNNb2RlKSB7XG4gICAgICAgIC8qKiBVbmFibGUgdG8gZm9jdXMgdGhpcyBjb21wb25lbnQgKi9cbiAgICAgICAgRm9jdXNNb2RlW0ZvY3VzTW9kZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgICAgICAvKiogQ2xpY2sgb3IgdG91Y2ggdG8gZm9jdXMgKi9cbiAgICAgICAgRm9jdXNNb2RlW0ZvY3VzTW9kZVtcIkNsaWNrXCJdID0gMV0gPSBcIkNsaWNrXCI7XG4gICAgICAgIC8qKiBDbGljaywgdG91Y2gsIG9yIHVzZSBrZXlib2FyZCAodGFiIGtleSkgdG8gZm9jdXMgKi9cbiAgICAgICAgRm9jdXNNb2RlW0ZvY3VzTW9kZVtcIkF1dG9cIl0gPSAyXSA9IFwiQXV0b1wiO1xuICAgICAgICAvKiogRm9jdXMgYSBjaGlsZCBjb21wb25lbnQgb24gY2xpY2ssIHRvdWNoLCBvciB1cC9kb3duIGFycm93IGtleSBwcmVzczsgY2hpbGQgY29tcG9uZW50cyB3aXRoIGZvY3VzIG1vZGUgYE5vbmVgIGFyZSBpZ25vcmVkICovXG4gICAgICAgIEZvY3VzTW9kZVtGb2N1c01vZGVbXCJJdGVtc1wiXSA9IDNdID0gXCJJdGVtc1wiO1xuICAgIH0pKEZvY3VzTW9kZSA9IENvbXBvbmVudC5Gb2N1c01vZGUgfHwgKENvbXBvbmVudC5Gb2N1c01vZGUgPSB7fSkpO1xuICAgIC8qKiBPcHRpb25zIGZvciBhdXRvbWF0aWMgc2VsZWN0aW9uIG1hbmFnZW1lbnQgKi9cbiAgICB2YXIgU2VsZWN0aW9uTW9kZTtcbiAgICAoZnVuY3Rpb24gKFNlbGVjdGlvbk1vZGUpIHtcbiAgICAgICAgLyoqIFVuYWJsZSB0byBzZWxlY3QgdGhpcyBjb21wb25lbnQgKi9cbiAgICAgICAgU2VsZWN0aW9uTW9kZVtTZWxlY3Rpb25Nb2RlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgICAgIC8qKiBGb2N1cyB0byBzZWxlY3QgKi9cbiAgICAgICAgU2VsZWN0aW9uTW9kZVtTZWxlY3Rpb25Nb2RlW1wiRm9jdXNcIl0gPSAxXSA9IFwiRm9jdXNcIjtcbiAgICAgICAgLyoqIENsaWNrIG9yIHRvdWNoLCBvciB1c2Ugc3BhY2UgYmFyICh3aGlsZSBmb2N1c2VkKSB0byBzZWxlY3QgKi9cbiAgICAgICAgU2VsZWN0aW9uTW9kZVtTZWxlY3Rpb25Nb2RlW1wiQ2xpY2tcIl0gPSAyXSA9IFwiQ2xpY2tcIjtcbiAgICAgICAgLyoqIENsaWNrIG9yIHRvdWNoLCBvciB1c2Ugc3BhY2UgYmFyICh3aGlsZSBmb2N1c2VkKSB0byB0b2dnbGUgc2VsZWN0aW9uICovXG4gICAgICAgIFNlbGVjdGlvbk1vZGVbU2VsZWN0aW9uTW9kZVtcIlRvZ2dsZVwiXSA9IDNdID0gXCJUb2dnbGVcIjtcbiAgICAgICAgLyoqIFNlbGVjdCBfb25lXyBjaGlsZCBjb21wb25lbnQgb24gY2xpY2sgb3IgdG91Y2g7IHNldCBzZWxlY3Rpb24gbW9kZSBvZiBjaGlsZCBjb21wb25lbnRzIHRvIGBDbGlja2AgaWYgdW5kZWZpbmVkICovXG4gICAgICAgIFNlbGVjdGlvbk1vZGVbU2VsZWN0aW9uTW9kZVtcIkl0ZW1DbGlja1wiXSA9IDRdID0gXCJJdGVtQ2xpY2tcIjtcbiAgICAgICAgLyoqIFNlbGVjdCBfb25lXyBjaGlsZCBjb21wb25lbnQgb24gZm9jdXM7IHNldCBzZWxlY3Rpb24gbW9kZSBvZiBjaGlsZCBjb21wb25lbnRzIHRvIGBGb2N1c2AgaWYgdW5kZWZpbmVkOyB0byBiZSBjb21iaW5lZCB3aXRoIGZvY3VzIG1vZGUgYEl0ZW1zYCBmb3IgZGlyZWN0aW9uYWwga2V5Ym9hcmQgbmF2aWdhdGlvbiAqL1xuICAgICAgICBTZWxlY3Rpb25Nb2RlW1NlbGVjdGlvbk1vZGVbXCJJdGVtRm9jdXNcIl0gPSA1XSA9IFwiSXRlbUZvY3VzXCI7XG4gICAgICAgIC8qKiBUb2dnbGUgc2VsZWN0aW9uIG9uIGNoaWxkIGNvbXBvbmVudHMgb24gY2xpY2sgb3IgdG91Y2gsIG9yIHNwYWNlIGJhciAod2hpbGUgZm9jdXNlZCk6IHNldCBzZWxlY3Rpb24gbW9kZSBvZiBjaGlsZCBjb21wb25lbnRzIHRvIGBUb2dnbGVgIGlmIHVuZGVmaW5lZCAqL1xuICAgICAgICBTZWxlY3Rpb25Nb2RlW1NlbGVjdGlvbk1vZGVbXCJJdGVtVG9nZ2xlXCJdID0gNl0gPSBcIkl0ZW1Ub2dnbGVcIjtcbiAgICB9KShTZWxlY3Rpb25Nb2RlID0gQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUgfHwgKENvbXBvbmVudC5TZWxlY3Rpb25Nb2RlID0ge30pKTtcbn0pKENvbXBvbmVudCB8fCAoQ29tcG9uZW50ID0ge30pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IEFzeW5jLCB7IFNpZ25hbCB9IGZyb20gXCIuLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50U2lnbmFsSGFuZGxlciB9IGZyb20gXCIuL0NvbXBvbmVudFNpZ25hbFwiO1xuLyoqIENsYXNzIHRoYXQgY29udGFpbnMgdGhlIGNvZGUgbmVjZXNzYXJ5IHRvIHJlbmRlciBhIGNvbXBvbmVudDsgdG8gcmV0cmlldmUgcmVuZGVyaW5nIG91dHB1dCwgQ29tcG9uZW50IG1ldGhvZHMgb25seSB1c2UgdGhlIGAub3V0cHV0YCBwcm9wZXJ0eSwgd2hpY2ggaXMgYW4gT2JzZXJ2YWJsZVZhbHVlIGluc3RhbmNlIHRoYXQgaXMgcG9wdWxhdGVkIHVzaW5nIHRoZSAocHJvdGVjdGVkKSBgLnJlbmRlcmAgbWV0aG9kICovXG52YXIgQ29tcG9uZW50UmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgcmVuZGVyZXIgaW5zdGFuY2UgZm9yIGdpdmVuIGNvbXBvbmVudCAqL1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlbmRlcmVyKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCBhZnRlciB1cGRhdGluZyBgLm91dHB1dGAgKGJ1dCBub3QgaWYgdW5kZWZpbmVkKSBhbmQvb3Igd2hlbiB0aGUgYHVwZGF0ZWRgIHByb21pc2Ugb24gdGhlIHJlbmRlcmVkIG91dHB1dCBpcyByZXNvbHZlZCAqL1xuICAgICAgICB0aGlzLlJlbmRlcmVkID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgLy8gY3JlYXRlIG9ic2VydmFibGUgdmFsdWUgd2l0aCBhIGdldHRlciBmb3IgcmVuZGVyZWQgb3V0cHV0XG4gICAgICAgIHZhciByZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm91dHB1dCA9IG5ldyBBc3luYy5PYnNlcnZhYmxlVmFsdWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFyZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYmVmb3JlRmlyc3RSZW5kZXIpXG4gICAgICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoX3RoaXMuYmVmb3JlRmlyc3RSZW5kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLm91dHB1dC52YWx1ZSA9IF90aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgLy8gYWRkIGRlcGVuZGVuY2llcyBmb3IgYWxsIHdhdGNoZXJzXG4gICAgICAgICAgICBpZiAoX3RoaXMuX3dhdGNoZXMpXG4gICAgICAgICAgICAgICAgX3RoaXMuX3dhdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAoZikgeyByZXR1cm4gZi52YWx1ZTsgfSk7XG4gICAgICAgICAgICAvLyBlbWl0IG93biBzaWduYWwsIGRpcmVjdGx5IG9yIGFzeW5jaHJvbm91c2x5IGJhc2VkIG9uIHByb21pc2VcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudXBkYXRlZClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVwZGF0ZWQudGhlbihmdW5jdGlvbiAoKSB7IF90aGlzLlJlbmRlcmVkKHJlc3VsdCk7IH0pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuUmVuZGVyZWQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBDb21wb25lbnQgcmVuZGVyZXIgZnVuY3Rpb247IHRvIGJlIG92ZXJyaWRkZW4sICptdXN0KiBiZSBhIHB1cmUgZnVuY3Rpb24sIGJhc2VkIG9uIHRoZSBjdXJyZW50IGAuY29tcG9uZW50YCBhbmQgYC5vdXRwdXRgIHByb3BlcnRpZXMgKG90aGVyd2lzZSAqY3JlYXRpbmcqIG9yICpzZXR0aW5nKiBPYnNlcnZhYmxlVmFsdWUgaW5zdGFuY2VzIHNob3VsZCBiZSBkb25lIHdpdGhpbiBhIGZ1bmN0aW9uIHRoYXQgaXMgcGFzc2VkIHRvIGB1bm9ic2VydmVkYCkgKi9cbiAgICBDb21wb25lbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5vdXRwdXQudmFsdWU7IH07XG4gICAgLyoqIEFkZCBhIG1ldGhvZCB0aGF0IHdpbGwgYmUgY2FsbGVkIChzeW5jaHJvbm91c2x5IGFuZCBhc3luY2hyb25vdXNseSkgZnJvbSBhIG5ldyBvYnNlcnZhYmxlIGNvbnRleHQsIGFmdGVyIHByZXZpb3VzbHkgYWRkZWQgbWV0aG9kcywgaW1tZWRpYXRlbHkgKmFmdGVyKiB0aGUgYC5yZW5kZXJgIG1ldGhvZCBoYXMgcnVuIG9uY2UsIGFsb25nIHdpdGggYW4gb3B0aW9uYWwgbWV0aG9kIHRoYXQgd2lsbCBiZSBjYWxsZWQgKHN5bmNocm9ub3VzbHksIHVub2JzZXJ2ZWQpIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QgbWV0aG9kOyBpLmUuIG9ic2VydmFibGUgdmFsdWVzIHVzZWQgaW4gdGhlIGZpcnN0IG1ldGhvZCB3aWxsIGJlIHN1YnNjcmliZWQgdG8gd2hpbGUgdGhlIG91dHB1dCBpcyBzdWJzY3JpYmVkIHRvLCBidXQgY2hhbmdlcyB0byB0aGVzZSB2YWx1ZXMgd2lsbCBuZXZlciB0cmlnZ2VyIHJlLXJlbmRlcmluZyB0aGUgZW50aXJlIGNvbXBvbmVudCAtLSBpbnN0ZWFkLCB0aGUgc2Vjb25kIGZ1bmN0aW9uIGlzIGludm9rZWQ7IHVzZWZ1bCBmb3IgcGFydGlhbGx5IHVwZGF0aW5nIGV4aXN0aW5nIG91dHB1dCB1c2luZyBhIHN1YnNldCBvZiBjb21wb25lbnQgcHJvcGVydGllczsgc2hvdWxkIGJlIGNhbGxlZCBfYmVmb3JlXyByZW5kZXJpbmcgdGFrZXMgcGxhY2UgKi9cbiAgICBDb21wb25lbnRSZW5kZXJlci5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiAoZ2V0dGVyLCBtYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl93YXRjaGVzKVxuICAgICAgICAgICAgdGhpcy5fd2F0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLl93YXRjaGVzLnB1c2gobWFwID9cbiAgICAgICAgICAgIEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZ2V0dGVyIChvYnNlcnZlZCkgYW5kIGZvcndhcmQgcmVzdWx0ICh1bm9ic2VydmVkKVxuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQobWFwLmJpbmQoX3RoaXMsIGdldHRlci5jYWxsKF90aGlzKSkpO1xuICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8ganVzdCBjYWxsIGdldHRlciAob2JzZXJ2ZWQpLCBkb24ndCBjYXJlIGFib3V0IHJlc3VsdFxuICAgICAgICAgICAgICAgIGdldHRlci5jYWxsKF90aGlzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBDb21wb25lbnRSZW5kZXJlcjtcbn0oKSk7XG5leHBvcnQgeyBDb21wb25lbnRSZW5kZXJlciB9O1xuKGZ1bmN0aW9uIChDb21wb25lbnRSZW5kZXJlcikge1xuICAgIC8qKiBFbmNhcHN1bGF0ZXMgb3V0cHV0IGZvciBhIHJlbmRlcmVkIGNvbXBvbmVudDsgY2xhc3MgdHlwZSBwYXJhbWV0ZXJzIGluZGljYXRlIHRoZSB0eXBlIG9mIGNvbXBvbmVudCByZW5kZXJlZCwgYW5kIHRoZSBvdXRwdXQgdHlwZSAoZS5nLiBIVE1MRWxlbWVudCkgKi9cbiAgICB2YXIgT3V0cHV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBmb3IgZ2l2ZW4gY29tcG9uZW50LCB3aXRoIGdpdmVuIGVsZW1lbnQgKHNob3VsZCBub3QgYmUgdW5kZWZpbmVkKSAqL1xuICAgICAgICBmdW5jdGlvbiBPdXRwdXQoY29tcG9uZW50LCBlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgICAgICAvKiogRmxhZyB0aGF0IGNhbiBiZSB1c2VkIGZvciBkdWNrIHR5cGluZyAqL1xuICAgICAgICAgICAgdGhpcy5pc0NvbXBvbmVudE91dHB1dCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzW1wiQGNvbnRleHRcIl0gPSBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPdXRwdXQ7XG4gICAgfSgpKTtcbiAgICBDb21wb25lbnRSZW5kZXJlci5PdXRwdXQgPSBPdXRwdXQ7XG59KShDb21wb25lbnRSZW5kZXJlciB8fCAoQ29tcG9uZW50UmVuZGVyZXIgPSB7fSkpO1xuLyoqIENvbnN0cnVjdG9yIGZvciBhIGNvbXBvbmVudCByZW5kZXIgZXZlbnQgaGFuZGxlciAqL1xudmFyIENvbXBvbmVudFJlbmRlckhhbmRsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21wb25lbnRSZW5kZXJIYW5kbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlbmRlckhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBvbmVudFJlbmRlckhhbmRsZXI7XG59KENvbXBvbmVudFNpZ25hbEhhbmRsZXIpKTtcbmV4cG9ydCB7IENvbXBvbmVudFJlbmRlckhhbmRsZXIgfTtcbi8qKiBfQ2xhc3MgZGVjb3JhdG9yXywgbWFwcyB0aGUgZGVjb3JhdGVkIGBDb21wb25lbnRSZW5kZXJlcmAgY2xhc3MgdG8gYSBgQ29tcG9uZW50YCBjbGFzcyBhcyBpdHMgcHJpbWFyeSByZW5kZXJlcjsgdGhlIHJlbmRlcmVyIGNsYXNzIGNvbnN0cnVjdG9yIG11c3QgaGF2ZSBhIHNpbmdsZSBhcmd1bWVudCwgYmVpbmcgdGhlIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZDsgb3ZlcnJpZGVzIHByZXZpb3VzbHkgbWFwcGVkIHJlbmRlcmVyIGVudGlyZWx5LCB0byBleHRlbmQgc3VwZXIgY2xhc3MgcmVuZGVyZXIgZnVuY3Rpb25hbGl0eSBpbmplY3QgYSBjbGFzcyB0aGF0IGV4dGVuZHMgdGhlIHByZXZpb3VzIHJlbmRlcmVyIGNsYXNzIFtkZWNvcmF0b3JdICovXG5leHBvcnQgZnVuY3Rpb24gbWFwQ29tcG9uZW50UmVuZGVyZXIoY29tcG9uZW50Q2xhc3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBBc3luYy5pbmplY3QoY29tcG9uZW50Q2xhc3MsIHsgUmVuZGVyZXI6IHRhcmdldCB9KTtcbiAgICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29tcG9uZW50UmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IExpc3QgfSBmcm9tIFwiLi4vXCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBDb21wb25lbnRGYWN0b3J5IH0gZnJvbSBcIi4uL0NvbXBvbmVudEZhY3RvcnlcIjtcbi8qKiBSZXByZXNlbnRzIGEgY29udGFpbmVyIHdpdGggdmVydGljYWxseSBzdGFja2VkIGJsb2NrcyAqL1xudmFyIENvbnRhaW5lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgY29udGFpbmVyIHdpdGggZ2l2ZW4gY29udGVudCwgaWYgYW55ICovXG4gICAgZnVuY3Rpb24gQ29udGFpbmVyKGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCkgeyBjb250ZW50ID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIC8vIGNvbnRhaW5lcnMgYXJlIG5vdCBmb2N1c2FibGUgYnkgZGVmYXVsdDpcbiAgICAgICAgX3RoaXMuZm9jdXNNb2RlID0gQ29tcG9uZW50LkZvY3VzTW9kZS5Ob25lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250YWluZXIucHJvdG90eXBlLCBcInNjcm9sbGVkVG9Ub3BcIiwge1xuICAgICAgICAvKiogRmxhZyB0aGF0IGJlY29tZXMgdHJ1ZSB3aGVuIHRoZSBjb250YWluZXIgY29udGVudCBpcyBzY3JvbGxlZCBhbGwgdGhlIHdheSB0byB0aGUgdG9wIChvYnNlcnZhYmxlKTsgc2Nyb2xsIHBvc2l0aW9uIGlzIGNvbnRpbnVvdXNseSBtb25pdG9yZWQgYWZ0ZXIgdGhpcyB2YWx1ZSBpcyByZWFkIG9uY2UgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbGVkVG9Ub3ApXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9uaXRvclBsYXRmb3JtU2Nyb2xsKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsZWRUb1RvcC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwic2Nyb2xsZWRUb0JvdHRvbVwiLCB7XG4gICAgICAgIC8qKiBGbGFnIHRoYXQgYmVjb21lcyB0cnVlIHdoZW4gdGhlIGNvbnRhaW5lciBjb250ZW50IGlzIHNjcm9sbGVkIGFsbCB0aGUgd2F5IHRvIHRoZSBib3R0b20sIG9yIHRvIHRoZSB0aHJlc2hvbGQgZGVmaW5lZCBieSBgLnNjcm9sbEJvdHRvbVRocmVzaG9sZGAgKG9ic2VydmFibGUpOyBzY3JvbGwgcG9zaXRpb24gaXMgY29udGludW91c2x5IG1vbml0b3JlZCBhZnRlciB0aGlzIHZhbHVlIGlzIHJlYWQgb25jZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2Nyb2xsZWRUb0JvdHRvbSlcbiAgICAgICAgICAgICAgICB0aGlzLl9tb25pdG9yUGxhdGZvcm1TY3JvbGwoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxlZFRvQm90dG9tLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJzY3JvbGxlZFRvTGVmdFwiLCB7XG4gICAgICAgIC8qKiBGbGFnIHRoYXQgYmVjb21lcyB0cnVlIHdoZW4gdGhlIGNvbnRhaW5lciBjb250ZW50IGlzIHNjcm9sbGVkIGFsbCB0aGUgd2F5IHRvIHRoZSBsZWZ0IChvYnNlcnZhYmxlKTsgc2Nyb2xsIHBvc2l0aW9uIGlzIGNvbnRpbnVvdXNseSBtb25pdG9yZWQgYWZ0ZXIgdGhpcyB2YWx1ZSBpcyByZWFkIG9uY2UgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbGVkVG9MZWZ0KVxuICAgICAgICAgICAgICAgIHRoaXMuX21vbml0b3JQbGF0Zm9ybVNjcm9sbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbGVkVG9MZWZ0LnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJzY3JvbGxlZFRvUmlnaHRcIiwge1xuICAgICAgICAvKiogRmxhZyB0aGF0IGJlY29tZXMgdHJ1ZSB3aGVuIHRoZSBjb250YWluZXIgY29udGVudCBpcyBzY3JvbGxlZCBhbGwgdGhlIHdheSB0byB0aGUgcmlnaHQgKG9ic2VydmFibGUpOyBzY3JvbGwgcG9zaXRpb24gaXMgY29udGludW91c2x5IG1vbml0b3JlZCBhZnRlciB0aGlzIHZhbHVlIGlzIHJlYWQgb25jZSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2Nyb2xsZWRUb1JpZ2h0KVxuICAgICAgICAgICAgICAgIHRoaXMuX21vbml0b3JQbGF0Zm9ybVNjcm9sbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbGVkVG9SaWdodC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lci5wcm90b3R5cGUsIFwiU2Nyb2xsZWRVcFwiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBjb250YWluZXIgY29udGVudCBpcyBzY3JvbGxlZCB1cCAoaS5lLiBjb250ZW50IG1vdmVzIGRvd24gcmVsYXRpdmUgdG8gdGhlIHZpZXdhYmxlIGFyZWEgb2YgdGhlIGNvbnRhaW5lciksIG9ubHkgb25jZSBvbiBmaXJzdCBzY3JvbGwgb3IgYWZ0ZXIgY2hhbmdpbmcgZGlyZWN0aW9uOyBzY3JvbGwgcG9zaXRpb24gaXMgY29udGludW91c2x5IG1vbml0b3JlZCBvbmx5IGFmdGVyIHRoaXMgc2lnbmFsIGlzIGNvbm5lY3RlZCB0byAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2Nyb2xsZWRUb1RvcClcbiAgICAgICAgICAgICAgICB0aGlzLl9tb25pdG9yUGxhdGZvcm1TY3JvbGwoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNvbXBvbmVudFNpZ25hbCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyLnByb3RvdHlwZSwgXCJTY3JvbGxlZERvd25cIiwge1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgY29udGFpbmVyIGNvbnRlbnQgaXMgc2Nyb2xsZWQgZG93biAoaS5lLiBjb250ZW50IG1vdmVzIHVwIHJlbGF0aXZlIHRvIHRoZSB2aWV3YWJsZSBhcmVhIG9mIHRoZSBjb250YWluZXIpLCBvbmx5IG9uY2Ugb24gZmlyc3Qgc2Nyb2xsIG9yIGFmdGVyIGNoYW5naW5nIGRpcmVjdGlvbjsgc2Nyb2xsIHBvc2l0aW9uIGlzIGNvbnRpbnVvdXNseSBtb25pdG9yZWQgb25seSBhZnRlciB0aGlzIHNpZ25hbCBpcyBjb25uZWN0ZWQgdG8gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbGVkVG9Ub3ApXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9uaXRvclBsYXRmb3JtU2Nyb2xsKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21wb25lbnRTaWduYWwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbnRhaW5lciBjb250YWlucyBhIExpc3QgY29tcG9uZW50IHdpdGhvdXQgaXRlbXMsIG9wdGlvbmFsbHkgb2YgZ2l2ZW4gdHlwZSAob2JzZXJ2YWJsZSBpZiB1c2VkIGluIGdldHRlcik7IHVzZWZ1bCBhcyBhIHNob3J0Y3V0IGluIGEgZ2V0dGVyIGZvciAuaGlkZGVuIG9uIGEgXCJibGFuay1zbGF0ZVwiIGJsb2NrICovXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS5oYXNFbXB0eUxpc3QgPSBmdW5jdGlvbiAobGlzdENvbXBvbmVudENsYXNzKSB7XG4gICAgICAgIGlmIChsaXN0Q29tcG9uZW50Q2xhc3MgPT09IHZvaWQgMCkgeyBsaXN0Q29tcG9uZW50Q2xhc3MgPSBMaXN0OyB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudHNCeVR5cGUobGlzdENvbXBvbmVudENsYXNzKVxuICAgICAgICAgICAgLnNvbWUoZnVuY3Rpb24gKGwpIHsgcmV0dXJuICEobC5pdGVtcyAmJiBsLml0ZW1zLmxlbmd0aCk7IH0pO1xuICAgIH07XG4gICAgLyoqIEFwcGVuZCBhIGJsb2NrIHRvIHRoaXMgY29udGFpbmVyOyByZXR1cm5zIHRoaXMgKi9cbiAgICBDb250YWluZXIucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5wdXNoKGJsb2NrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBhcnJheSBvZiBkaXJlY3RseSBjb250YWluZWQgY29tcG9uZW50cyAob2JzZXJ2YWJsZSkgKi9cbiAgICBDb250YWluZXIucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMgaW5zdGFuY2VvZiBDb21wb25lbnQpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgTW9uaXRvciBzY3JvbGwgcG9zaXRpb24gdG8ga2VlcCBfc2Nyb2xsZWRUb1RvcCBhbmQgX3Njcm9sbGVkVG9Cb3R0b20gdXBkYXRlZCAqL1xuICAgIENvbnRhaW5lci5wcm90b3R5cGUuX21vbml0b3JQbGF0Zm9ybVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fc2Nyb2xsZWRUb1RvcCA9IG5ldyBBc3luYy5PYnNlcnZhYmxlVmFsdWUoKTtcbiAgICAgICAgICAgIF90aGlzLl9zY3JvbGxlZFRvQm90dG9tID0gbmV3IEFzeW5jLk9ic2VydmFibGVWYWx1ZSgpO1xuICAgICAgICAgICAgX3RoaXMuX3Njcm9sbGVkVG9MZWZ0ID0gbmV3IEFzeW5jLk9ic2VydmFibGVWYWx1ZSgpO1xuICAgICAgICAgICAgX3RoaXMuX3Njcm9sbGVkVG9SaWdodCA9IG5ldyBBc3luYy5PYnNlcnZhYmxlVmFsdWUoKTtcbiAgICAgICAgICAgIHZhciBvbGRUb3AsIHdhc1VwID0gZmFsc2UsIHdhc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBhdFRvcCwgYXRCb3R0b207XG4gICAgICAgICAgICB2YXIgYXRMZWZ0LCBhdFJpZ2h0O1xuICAgICAgICAgICAgX3RoaXNbXCJAbW9uaXRvclBsYXRmb3JtU2Nyb2xsXCJdKGZ1bmN0aW9uICh0LCBiLCBsLCByKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1pdCBzaWduYWwgZm9yIHNjcm9sbCBkaXJlY3Rpb24gaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKHQgPiBvbGRUb3AgJiYgIXdhc0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgd2FzRG93biA9IHRydWUsIHdhc1VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLlNjcm9sbGVkRG93bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0IDwgb2xkVG9wICYmICF3YXNVcCkge1xuICAgICAgICAgICAgICAgICAgICB3YXNVcCA9IHRydWUsIHdhc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuU2Nyb2xsZWRVcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbGRUb3AgPSB0O1xuICAgICAgICAgICAgICAgIC8vIHNldCBvYnNlcnZhYmxlIHRvcCBmbGFnIG9ubHkgaWYgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHZhciB0VGhyID0gX3RoaXMuc2Nyb2xsVG9wVGhyZXNob2xkIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHQgPD0gdFRociAmJiAhYXRUb3ApXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY3JvbGxlZFRvVG9wLnZhbHVlID0gYXRUb3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPiB0VGhyICYmIGF0VG9wICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njcm9sbGVkVG9Ub3AudmFsdWUgPSBhdFRvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIHNldCBvYnNlcnZhYmxlIGJvdHRvbSBmbGFnIG9ubHkgaWYgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHZhciBiVGhyID0gX3RoaXMuc2Nyb2xsQm90dG9tVGhyZXNob2xkIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGIgPD0gYlRociAmJiAhYXRCb3R0b20pXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY3JvbGxlZFRvQm90dG9tLnZhbHVlID0gYXRCb3R0b20gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIgPiBiVGhyICYmIGF0Qm90dG9tICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njcm9sbGVkVG9Cb3R0b20udmFsdWUgPSBhdEJvdHRvbSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIHNldCBvYnNlcnZhYmxlIGxlZnQgZmxhZyBvbmx5IGlmIGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAobCA8PSAwICYmICFhdExlZnQpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY3JvbGxlZFRvTGVmdC52YWx1ZSA9IGF0TGVmdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobCA+IDAgJiYgYXRMZWZ0ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njcm9sbGVkVG9MZWZ0LnZhbHVlID0gYXRMZWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gc2V0IG9ic2VydmFibGUgcmlnaHQgZmxhZyBvbmx5IGlmIGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAociA8PSAwICYmICFhdFJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2Nyb2xsZWRUb1JpZ2h0LnZhbHVlID0gYXRSaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAociA+IDAgJiYgYXRSaWdodCAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY3JvbGxlZFRvUmlnaHQudmFsdWUgPSBhdFJpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsIFJlZ2lzdGVyIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aXRoIGN1cnJlbnQgYW5kIGZvbGxvd2luZyB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb25zOyBpbmplY3RlZCBieSBwbGF0Zm9ybSByZW5kZXJlciAqL1xuICAgIENvbnRhaW5lci5wcm90b3R5cGVbX2EgPSBcIkBtb25pdG9yUGxhdGZvcm1TY3JvbGxcIl0gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgLy8gZG8gbm90aGluZyBpZiBub3QgaW5qZWN0ZWRcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LmFwcGx5Q29tcG9uZW50c0FycmF5KENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkJsb2NrKSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9ub3RfbnVsbFxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJ2ZXJ0QWxpZ25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwiaG9yekFsaWduXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc3RyaW5nXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJtYXhDb250ZW50V2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwic2Nyb2xsYWJsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJzY3JvbGxlZFRvVG9wXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJzY3JvbGxlZFRvQm90dG9tXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJzY3JvbGxlZFRvTGVmdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwic2Nyb2xsZWRUb1JpZ2h0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJzY3JvbGxCb3R0b21UaHJlc2hvbGRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwic2Nyb2xsVG9wVGhyZXNob2xkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIENvbnRhaW5lci5wcm90b3R5cGUsIFwiU2Nyb2xsZWRVcFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMudW5vYnNlcnZhYmxlX21lbW9pemVfZ2V0XG4gICAgXSwgQ29udGFpbmVyLnByb3RvdHlwZSwgXCJTY3JvbGxlZERvd25cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBDb250YWluZXIucHJvdG90eXBlLCBcImRpc3BsYXlPcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLmluamVjdGFibGVcbiAgICBdLCBDb250YWluZXIucHJvdG90eXBlLCBfYSwgbnVsbCk7XG4gICAgQ29udGFpbmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwZW5kQ2hpbGRDb21wb25lbnRzKENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkJsb2NrKVxuICAgIF0sIENvbnRhaW5lcik7XG4gICAgcmV0dXJuIENvbnRhaW5lcjtcbiAgICB2YXIgX2E7XG59KENvbXBvbmVudCkpO1xuZXhwb3J0IHsgQ29udGFpbmVyIH07XG4vKiogUmVwcmVzZW50cyBhIGNvbnRhaW5lciB3aXRoIGJsb2NrcyB0aGF0IGFyZSBsYWlkIG91dCBob3Jpem9udGFsbHkgKGp1c3QgbGlrZSB0ZXh0KSwgYXV0b21hdGljYWxseSBzcGFubmluZyBtdWx0aXBsZSByb3dzIGlmIG5lY2Vzc2FyeSAqL1xudmFyIEZsb3dDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGbG93Q29udGFpbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZsb3dDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEZsb3dDb250YWluZXI7XG59KENvbnRhaW5lcikpO1xuZXhwb3J0IHsgRmxvd0NvbnRhaW5lciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udGFpbmVycy9Db250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMsIHsgU2lnbmFsIH0gZnJvbSBcIi4uL0FzeW5jXCI7XG4vKiogQ3VycmVudCBkcmFnIG9wZXJhdGlvbihzKSAqL1xudmFyIGluc3RhbmNlcyA9IFtdO1xuLyoqIFJlcHJlc2VudHMgYSBkcmFnIG9wZXJhdGlvbiAoY3JlYXRlZCBieSBzdGF0aWMgLnN0YXJ0KC4uLikgbWV0aG9kKSAqL1xudmFyIERyYWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERyYWcoKSB7XG4gICAgICAgIC8qKiBFdmVudCBwYXlsb2FkIGRhdGEgZm9yIHRoaXMgb3BlcmF0aW9uIChzZWFsZWQgb2JzZXJ2YWJsZSBvYmplY3QpICovXG4gICAgICAgIHRoaXMuZGV0YWlsID0ge1xuICAgICAgICAgICAgaWQ6IHVuZGVmaW5lZCwgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBkcmFnIG9wZXJhdGlvbiBjb21wbGV0ZXMgc3VjY2Vzc2Z1bGx5ICovXG4gICAgICAgIHRoaXMuRHJvcHBlZCA9IFNpZ25hbC5jcmVhdGUoKTtcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIGRyYWcgb3BlcmF0aW9uIGlzIGNhbmNlbGVkICovXG4gICAgICAgIHRoaXMuQ2FuY2VsZWQgPSBTaWduYWwuY3JlYXRlKCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgbGlzdCBvZiBjdXJyZW50IGRyYWcgb3BlcmF0aW9ucyAoZm9yIGZvcndhcmRzIGNvbXBhdGliaWxpdHksIHN1cHBvcnRpbmcgbXVsdGkgdG91Y2gpOyB1c2UgdGhpcyB3aGlsZSBoYW5kbGluZyBkcmFnIGV2ZW50cywgZS5nLiBnZXQvc2V0IC5kZXRhaWwgd2l0aCBjdXN0b20gZGF0YSwgb3Igb2JzZXJ2ZSBjb29yZGluYXRlcykgKi9cbiAgICBEcmFnLmdldEN1cnJlbnRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXMuc2xpY2UoKTtcbiAgICB9O1xuICAgIC8qKiBTdGFydCB0cmFja2luZyBtb3VzZSBtb3ZlbWVudCBiYXNlZCBvbiBnaXZlbiBldmVudCAod2l0aCBpbml0aWFsIHNjcmVlbiBjb29yZGluYXRlcyk7IGNyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBwbGF0Zm9ybSBzcGVjaWZpYyBjbGFzcyBkZXJpdmVkIGZyb20gRHJhZyB3aXRoIGdpdmVuIHBheWxvYWQgZGF0YTsgRHJvcCB0YXJnZXRzIG1heSBsaXN0ZW4gZm9yIGRyYWcgZXZlbnRzIChlbnRlci9sZWF2ZS9kcm9wKSwgYW5kIHVzZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBkYXRhIG9iamVjdCB0byByZXNwb25kICovXG4gICAgRHJhZy5zdGFydCA9IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IERyYWcuQmFzZUNsYXNzKGV2ZW50KTtcbiAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICByZXN1bHQuZGV0YWlsLmRhdGEgPSBkYXRhO1xuICAgICAgICBpbnN0YW5jZXMucHVzaChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqIFN0b3AgdGhpcyBkcmFnIG9wZXJhdGlvbiwgZW1pdHMgdGhlIGAuQ2FuY2VsZWRgIHNpZ25hbDsgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGlzIG9wZXJhdGlvbiB3YXMgYWxyZWFkeSBjYW5jZWxlZCBvciBkcm9wcGVkICovXG4gICAgRHJhZy5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWluc3RhbmNlcy5zb21lKGZ1bmN0aW9uIChvKSB7IHJldHVybiBvID09PSBfdGhpczsgfSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEcmFnIG9wZXJhdGlvbiBhbHJlYWR5IHN0b3BwZWRcIik7XG4gICAgICAgIGluc3RhbmNlcyA9IGluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gIT09IF90aGlzOyB9KTtcbiAgICAgICAgdGhpcy5DYW5jZWxlZCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKiBBY2NlcHQgdGhlIGN1cnJlbnQgZHJvcCB0YXJnZXQgKGkuZS4gcGVyZm9ybSB0aGUgZHJvcCwgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaW5wdXQgZXZlbnRzLCBidXQgY2FuIGJlIGNhbGxlZCBtYW51YWxseSBhcyB3ZWxsKSwgZW1pdHMgdGhlIGAuRHJvcHBlZGAgc2lnbmFsOyB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoaXMgb3BlcmF0aW9uIHdhcyBhbHJlYWR5IGNhbmNlbGVkIG9yIGRyb3BwZWQgKi9cbiAgICBEcmFnLnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWluc3RhbmNlcy5zb21lKGZ1bmN0aW9uIChvKSB7IHJldHVybiBvID09PSBfdGhpczsgfSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEcmFnIG9wZXJhdGlvbiBhbHJlYWR5IHN0b3BwZWRcIik7XG4gICAgICAgIGluc3RhbmNlcyA9IGluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gIT09IF90aGlzOyB9KTtcbiAgICAgICAgdGhpcy5Ecm9wcGVkKHRoaXMpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc2VhbFxuICAgIF0sIERyYWcucHJvdG90eXBlLCBcImRldGFpbFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBEcmFnO1xufSgpKTtcbmV4cG9ydCB7IERyYWcgfTtcbihmdW5jdGlvbiAoRHJhZykge1xuICAgIDtcbn0pKERyYWcgfHwgKERyYWcgPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0RyYWcuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgQXN5bmMgZnJvbSBcIi4uL0FzeW5jXCI7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSBcIi4vXCI7XG4vKiogTWV0aG9kcyBmb3IgbWFuYWdpbmcgdGhlIGF2YWlsYWJsZSAoZml4ZWQpIHNjcmVlbiBzcGFjZSBpbiB0aGUgYXBwbGljYXRpb24gdmlld3BvcnQgKi9cbmV4cG9ydCB2YXIgU2NyZWVuO1xuKGZ1bmN0aW9uIChTY3JlZW4pIHtcbiAgICAvKiogRGlzcGxheSBnaXZlbiB2aWV3IGluIHRoZSBmb3JlZ3JvdW5kLCByZXBsYWNpbmcgdGhlIGN1cnJlbnQgcGFnZSBvciBhZGRpbmcgdG8gaXQgKG9yIHRvIGEgbmV3IGJsYW5rIHBhZ2UsIGlmIG5vbmUgd2FzIGRpc3BsYXllZCk7IHJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIGFmdGVyIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyZWQgKi9cbiAgICBmdW5jdGlvbiBkaXNwbGF5QXN5bmModmlldykge1xuICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIFBhZ2UpIHtcbiAgICAgICAgICAgIC8vIGRpc3BsYXkgZ2l2ZW4gcGFnZVxuICAgICAgICAgICAgcmV0dXJuIHZpZXcuZGlzcGxheUFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYmxhbmsgcGFnZSBpZiBub25lIGRpc3BsYXllZFxuICAgICAgICAgICAgdmFyIHBhZ2UgPSBQYWdlLmdldEN1cnJlbnRQYWdlKCkgfHwgbmV3IFBhZ2UoKTtcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBjdXJyZW50IHBhZ2UsIHRvIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICAvLyAoYW5kIHJlbW92ZSBjb21wb25lbnQgZnJvbSBhbm90aGVyIHBhZ2UgaWYgbmVlZGVkKVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZpZXcuZ2V0UmVuZGVyZWRPdXRwdXRBc3luYygpLnRoZW4oZnVuY3Rpb24gKG91dCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gb3V0W1wiQFNjcmVlbi5wYWdlXCJdO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYgIT09IHBhZ2UpXG4gICAgICAgICAgICAgICAgICAgIFNjcmVlbi5yZW1vdmUodmlldyk7XG4gICAgICAgICAgICAgICAgb3V0W1wiQFNjcmVlbi5wYWdlXCJdID0gcGFnZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYWRkIGNvbXBvbmVudCBhcyBjb250ZW50LCBtb3ZlIHRvIGJhY2sgaWYgYWxyZWFkeSBhZGRlZFxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBwYWdlLmNvbnRlbnQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFtpXSA9PT0gdmlldylcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhZ2UuY29udGVudC5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIHBhZ2UuZGlzcGxheUFzeW5jKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXN1bHQ7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNjcmVlbi5kaXNwbGF5QXN5bmMgPSBkaXNwbGF5QXN5bmM7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBQYWdlIGlzIGN1cnJlbnRseSBkaXNwbGF5ZWQsIG9yIGdpdmVuIENvbXBvbmVudCBpcyBkaXNwbGF5ZWQgX2RpcmVjdGx5XyBvbiB0aGUgY3VycmVudCBwYWdlIChpLmUuIG5vdCBhcyBhIGNoaWxkIGNvbXBvbmVudCkgKi9cbiAgICBmdW5jdGlvbiBpc0Rpc3BsYXllZCh2aWV3KSB7XG4gICAgICAgIGlmICh2aWV3IGluc3RhbmNlb2YgUGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIFBhZ2UuZ2V0Q3VycmVudFBhZ2UoKSA9PT0gdmlldztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYWdlID0gUGFnZS5nZXRDdXJyZW50UGFnZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHBhZ2UgJiYgcGFnZS5jb250YWlucyh2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTY3JlZW4uaXNEaXNwbGF5ZWQgPSBpc0Rpc3BsYXllZDtcbiAgICBmdW5jdGlvbiByZW1vdmUodmlldykge1xuICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIFBhZ2UpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBnaXZlbiBwYWdlXG4gICAgICAgICAgICBpZiAoUGFnZS5nZXRDdXJyZW50UGFnZSgpID09PSB2aWV3KVxuICAgICAgICAgICAgICAgIHZpZXcucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZ2l2ZW4gY29tcG9uZW50IGZyb20gdGhlIHBhZ2UgaXQgYmVsb25ncyB0b1xuICAgICAgICAgICAgdmFyIG91dCA9IHZpZXcuZ2V0TGFzdFJlbmRlcmVkT3V0cHV0KCk7XG4gICAgICAgICAgICB2YXIgcGFnZSA9IG91dCAmJiBvdXRbXCJAU2NyZWVuLnBhZ2VcIl07XG4gICAgICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gcGFnZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFtpXSA9PT0gdmlldylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dFtcIkBTY3JlZW4ucGFnZVwiXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBTY3JlZW4ucmVtb3ZlID0gcmVtb3ZlO1xuICAgIC8qKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSB3aGVuIHJlYWR5IHRvIGRpc3BsYXkgdGhlIFVJLCBhZnRlciBhbGwgc3RhdGljIHJlc291cmNlcyBoYXZlIGJlZW4gbG9hZGVkICovXG4gICAgU2NyZWVuLnJlYWR5ID0gbmV3IEFzeW5jLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgU2NyZWVuLnJlc29sdmVSZWFkeSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgLyoqIFZpZXdwb3J0IGRpbWVuc2lvbnMgKHNlYWxlZCBvYnNlcnZhYmxlIG9iamVjdCkgKi9cbiAgICBTY3JlZW4uZGltZW5zaW9ucyA9IEFzeW5jLm9ic2VydmUoT2JqZWN0LnNlYWwoe1xuICAgICAgICB3aWR0aDogTmFOLFxuICAgICAgICBoZWlnaHQ6IE5hTixcbiAgICAgICAgZ2V0IGlzTGFuZHNjYXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPiB0aGlzLmhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzTmFycm93KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPCBTY3JlZW4uTkFSUk9XX1dJRFRIO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNTbWFsbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoIDwgU2NyZWVuLlNNQUxMX1dJRFRIO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNXaWRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPiBTY3JlZW4uV0lERV9XSURUSDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzRXh0cmFXaWRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPiBTY3JlZW4uRVhUUkFXSURFX1dJRFRIO1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIC8qKiBcIk5hcnJvd1wiIGhvcml6b250YWwgcm9vdCB3aWR0aCBpbiBsb2dpY2FsIHBpeGVscywgZGVmYXVsdCA1NTAgKi9cbiAgICBTY3JlZW4uTkFSUk9XX1dJRFRIID0gNTUwO1xuICAgIC8qKiBcIlNtYWxsXCIgaG9yaXpvbnRhbCByb290IHdpZHRoIGluIGxvZ2ljYWwgcGl4ZWxzLCBkZWZhdWx0IDcyMCAqL1xuICAgIFNjcmVlbi5TTUFMTF9XSURUSCA9IDcyMDtcbiAgICAvKiogXCJXaWRlXCIgaG9yaXpvbnRhbCByb290IHdpZHRoIGluIGxvZ2ljYWwgcGl4ZWxzLCBkZWZhdWx0IDk2MCAqL1xuICAgIFNjcmVlbi5XSURFX1dJRFRIID0gOTYwO1xuICAgIC8qKiBcIkV4dHJhIHdpZGVcIiBob3Jpem9udGFsIHJvb3Qgd2lkdGggaW4gbG9naWNhbCBwaXhlbHMsIGRlZmF1bHQgMTIwMCAqL1xuICAgIFNjcmVlbi5FWFRSQVdJREVfV0lEVEggPSAxMjAwO1xufSkoU2NyZWVuIHx8IChTY3JlZW4gPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL1NjcmVlbi5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jLCB7IFNpZ25hbCB9IGZyb20gXCIuLi9Bc3luY1wiO1xuaW1wb3J0IHsgU2NyZWVuIH0gZnJvbSBcIi4vU2NyZWVuXCI7XG4vKiogTmV4dCBwYWdlIFVJRCAqL1xudmFyIF9uZXh0VUlEID0gMTtcbi8qKiBSZWZlcmVuY2VzIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHBhZ2UgKi9cbnZhciBjdXJyZW50ID0gbmV3IEFzeW5jLk9ic2VydmFibGVWYWx1ZSgpO1xuLyoqIFJlcHJlc2VudHMgYSBwYWdlIHRvIGJlIGRpc3BsYXllZCBvbiBzY3JlZW4gKi9cbnZhciBQYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQ3JlYXRlIGEgcGFnZSB3aXRoIGdpdmVuIGNvbnRlbnQsIGlmIGFueSAqL1xuICAgIGZ1bmN0aW9uIFBhZ2UoY29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwKSB7IGNvbnRlbnQgPSBbXTsgfVxuICAgICAgICAvKiogR2xvYmFsbHkgdW5pcXVlIHBhZ2UgaWRlbnRpZmllciAqL1xuICAgICAgICB0aGlzLnVpZCA9IFwiUEdcIiArIF9uZXh0VUlEKys7XG4gICAgICAgIC8qKiBTaWduYWwgdGhhdCBpcyBlbWl0dGVkIGFmdGVyIHRoaXMgcGFnZSBpcyBkaXNwbGF5ZWQgb24gc2NyZWVuICovXG4gICAgICAgIHRoaXMuRGlzcGxheWVkID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICAvKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCBhZnRlciB0aGlzIHBhZ2UgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBzY3JlZW4gKi9cbiAgICAgICAgdGhpcy5SZW1vdmVkID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICAvKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCBhZnRlciB0aGUgY29udGVudCBvZiB0aGlzIHBhZ2UgaGFzIGJlZW4gKHJlLSkgcmVuZGVyZWQsIGUuZy4gd2hlbiBhIGNvbXBvbmVudCBpcyBhZGRlZCBvciByZW1vdmVkIChidXQgbm90IHdoZW4gb25lIG9mIHRoZSBjb21wb25lbnRzIGl0c2VsZiBpcyByZS1yZW5kZXJlZCBkdWUgdG8gY2hhbmdlcyBpbiBpdHMgb3duIHN1YiBjb250ZW50LCB1c2UgdGhlIGBDb21wb25lbnQjUmVuZGVyZWRgIHNpZ25hbCBmb3IgdGhhdCkgKi9cbiAgICAgICAgLy8gTk9URTogZW1pdHRlZCBieSBwYWdlIHJlbmRlcmVyIGFmdGVyIHVwZGF0aW5nIGNvbnRlbnQsIG5vdCBoZXJlIVxuICAgICAgICB0aGlzLlJlbmRlcmVkID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICAvKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCB3aGVuIGEga2V5IGlzIGJlaW5nIHByZXNzZWQgb24gdGhlIGtleWJvYXJkLCB3aGlsZSB0aGlzIHBhZ2UgaXMgZGlzcGxheWVkIGluIHRoZSBmb3JlZ3JvdW5kICovXG4gICAgICAgIHRoaXMuS2V5RG93biA9IFNpZ25hbC5jcmVhdGUoKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIHBhZ2UgY3VycmVudGx5IGRpc3BsYXllZCBvbiBzY3JlZW4sIGlmIGFueSAob2JzZXJ2YWJsZSkgKi9cbiAgICBQYWdlLmdldEN1cnJlbnRQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgbmV3IFBhZ2UgY2xhc3Mgd2l0aCBhIGNvbnN0cnVjdG9yIHRoYXQgY3JlYXRlcyBpbnN0YW5jZXMgb2YgZ2l2ZW4gY29tcG9uZW50IGNsYXNzZXMgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGUgcGFnZSBjb250ZW50IGFycmF5ICovXG4gICAgUGFnZS53aXRoQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudENsYXNzZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvbmVudENsYXNzZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhQYWdlV2l0aENvbnRlbnQsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBQYWdlV2l0aENvbnRlbnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgICAgICAgICBjb21wb25lbnRDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udGVudC5wdXNoKG5ldyBjKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQYWdlV2l0aENvbnRlbnQ7XG4gICAgICAgIH0oUGFnZSkpO1xuICAgIH07XG4gICAgUGFnZS5wcm90b3R5cGUuZ2V0Q29tcG9uZW50QnlJZCA9IGZ1bmN0aW9uIChpZCwgY29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY29udGVudDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gYyAmJiBjLmdldENvbXBvbmVudEJ5SWQoaWQsIGNvbXBvbmVudENsYXNzKTtcbiAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGFsbCAocmVjdXJzaXZlKSBjaGlsZCBlbGVtZW50cyB0aGF0IGFyZSBhbiBpbnN0YW5jZSBvZiBnaXZlbiBjbGFzcyAob2JzZXJ2YWJsZSkgKi9cbiAgICBQYWdlLnByb3RvdHlwZS5nZXRDb21wb25lbnRzQnlUeXBlID0gZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5jb250ZW50LmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29tcG9uZW50Q2xhc3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjICYmIGMuZ2V0Q29tcG9uZW50c0J5VHlwZShjb21wb25lbnRDbGFzcylcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocikgeyByZXR1cm4gcmVzdWx0LnB1c2gocik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gY29tcG9uZW50IGlzIGEgY2hpbGQgY29tcG9uZW50IG9mIHRoaXMgcGFnZSBvciBhbnkgb2YgaXRzIGNoaWxkIGNvbXBvbmVudHMgKG9ic2VydmFibGUsIGJ1dCB0cmlnZ2VycyByZS1ldmFsdWF0aW9uIHVwb24gZXZlcnkgY2hhbmdlIGluIGNoaWxkIFtzdWJdIGNvbXBvbmVudHMpICovXG4gICAgUGFnZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gISFjICYmIGMuY29udGFpbnMoY29tcG9uZW50KTsgfSk7XG4gICAgfTtcbiAgICAvKiogSW52b2tlIHRoZSBgb25Fc2NgIGhhbmRsZXIgb2YgdGhlIGNvbXBvbmVudCBjbG9zZXN0IHRvIHRoZSBmb3JlZ3JvdW5kIHRoYXQgZGVmaW5lcyBpdCAodXN1YWxseSBhIG1vZGFsIGRpYWxvZyBjb250YWluZXIgaW4gdGhlIGZvcmVncm91bmQpOyByZXR1cm5zIHRydWUgaWYgaGFuZGxlciB3YXMgY2FsbGVkLCBvdGhlcndpc2UgZG9lcyBub3RoaW5nIGFuZCByZXR1cm5zIGZhbHNlICovXG4gICAgUGFnZS5wcm90b3R5cGUuaGFuZGxlRXNjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jb250ZW50Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb250ZW50W2ldO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gY29tcG9uZW50LmRpc3BsYXlPcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmICh0eXBlb2Ygb3B0aW9ucy5vbkVzYyA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXNjLmNhbGwodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKiBTY3JvbGwgdGhlIHBhZ2UgYW5kIGFsbCBwYXJlbnQgY29tcG9uZW50cyBvZiBnaXZlbiBjb21wb25lbnQsIHN1Y2ggdGhhdCB0aGUgZW50aXJlIGNvbXBvbmVudCBiZWNvbWVzIHZpc2libGUgKi9cbiAgICBQYWdlLnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2Nyb2xsVG8oY29tcG9uZW50KTtcbiAgICB9O1xuICAgIC8qKiBEaXNwbGF5IHRoaXMgcGFnZSBvbiBzY3JlZW47IGFsc28gcmUtZW5hYmxlcyB0aGUgcGFnZSBpZiBpbnB1dCB3YXMgYmxvY2tlZDsgcmVwbGFjZXMgdGhlIGN1cnJlbnRseSBkaXNwbGF5aW5nIHBhZ2Ugb24gc2NyZWVuLCB3aGljaCBpcyByZW1vdmVkIGF1dG9tYXRpY2FsbHksIGJ1dCB0aGUgcmVzdWx0IG1heSBiZSBhbiBlbXB0eSBzY3JlZW4gaWYgdGhpcyBwYWdlIGhhcyBubyBjb250ZW50OyBhbHdheXMgd2FpdHMgZm9yIGBTY3JlZW4ucmVhZHlgOyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIHRoZSBjb21wb25lbnRzIG9uIHRoaXMgcGFnZSBoYXZlIGJlZW4gcmVuZGVyZWQgKi9cbiAgICBQYWdlLnByb3RvdHlwZS5kaXNwbGF5QXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQXN5bmMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgdmFyIGRpc3BsYXllZCA9IGN1cnJlbnQudmFsdWU7XG4gICAgICAgICAgICBpZiAoX3RoaXMgPT09IGRpc3BsYXllZCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgcGFnZSBpcyBhbHJlYWR5IGRpc3BsYXllZCAob3Igbm93IGRpc3BsYXlpbmcpXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW50IHBhZ2UgYW5kIHVuYmxvY2sgaW5wdXQgaWYgbmVlZGVkXG4gICAgICAgICAgICBkaXNwbGF5ZWQgJiYgZGlzcGxheWVkLnJlbW92ZSgpO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXJlci5lbmFibGVJbnB1dCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudC52YWx1ZSA9IF90aGlzO1xuICAgICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGFuIG9ic2VydmFibGUgdGhhdCBkZXBlbmRzIG9uIGFsbCBwYWdlIGNvbnRlbnRcbiAgICAgICAgICAgIHZhciBzY3JlZW5Jc1JlYWR5ID0gQXN5bmMub2JzZXJ2ZShTY3JlZW4ucmVhZHkpO1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fc3ViID0gQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcmVlbklzUmVhZHkudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlcmVyLnVwZGF0ZUFzeW5jKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIGFuZCBlbWl0IGlmIHJlbmRlcmVkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5EaXNwbGF5ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJlbW92ZSB0aGlzIHBhZ2UgZnJvbSB0aGUgc2NyZWVuLCBpZiBjdXJyZW50bHkgZGlzcGxheWVkOyByZXR1cm5zIHRoaXMgKi9cbiAgICBQYWdlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWIpIHtcbiAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gY29udGVudCBjb21wb25lbnRzIChkZWZlcnJlZCwgdG8gYWxsb3dcbiAgICAgICAgICAgIC8vIHJlLWNvbm5lY3Rpb24gYnkgYW5vdGhlciBwYWdlIGltbWVkaWF0ZWx5KVxuICAgICAgICAgICAgdmFyIHN1YiA9IHRoaXMuX3N1YjtcbiAgICAgICAgICAgIEFzeW5jLmRlZmVyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1Yi5jbGVhcigpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX3N1YiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudC52YWx1ZSA9PT0gdGhpcykge1xuICAgICAgICAgICAgY3VycmVudC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5SZW1vdmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogQmxvY2sgYWxsIGlucHV0IGV2ZW50cyBvbiB0aGlzIHBhZ2UsIHVudGlsIGdpdmVuIHByb21pc2UgaXMgcmVzb2x2ZWQsIG9yIHVudGlsIHBhZ2UgaXMgcmUtZGlzcGxheWVkICovXG4gICAgUGFnZS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9kaXNhYmxlZCB8fCAhdGhpcy5fc3ViKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5kaXNhYmxlSW5wdXQoKTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2Rpc2FibGVkICYmIF90aGlzLl9zdWIpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXJlci5lbmFibGVJbnB1dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlLnByb3RvdHlwZSwgXCJfcmVuZGVyZXJcIiwge1xuICAgICAgICAvKiogQGludGVybmFsIFRoZSBjdXJyZW50IHBhZ2UgcmVuZGVyZXIgaW5zdGFuY2UgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcmVuZGVyZXIgKG9uY2UpIGFuZCBmb3J3YXJkIEtleURvd24gc2lnbmFsXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IHRoaXMuUmVuZGVyZXIodGhpcyk7XG4gICAgICAgICAgICByZXN1bHQuS2V5RG93bi5jb25uZWN0KHRoaXMuS2V5RG93bik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9ub3RfbnVsbFxuICAgIF0sIFBhZ2UucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIFBhZ2UucHJvdG90eXBlLCBcImZsb3dEaXJlY3Rpb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMuaW5qZWN0YWJsZVxuICAgIF0sIFBhZ2UucHJvdG90eXBlLCBcIlJlbmRlcmVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIFBhZ2UucHJvdG90eXBlLCBcIl9yZW5kZXJlclwiLCBudWxsKTtcbiAgICByZXR1cm4gUGFnZTtcbn0oKSk7XG5leHBvcnQgeyBQYWdlIH07XG4vKiogQGludGVybmFsIFBsYXRmb3JtIGRlcGVuZGVudCBwYWdlIHJlbmRlcmluZy9kaXNwbGF5IGltcGxlbWVudGF0aW9uICovXG52YXIgUGFnZVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQ3JlYXRlIHRoZSByZW5kZXJlciBmb3IgZ2l2ZW4gcGFnZSAqL1xuICAgIGZ1bmN0aW9uIFBhZ2VSZW5kZXJlcihwYWdlKSB7XG4gICAgICAgIC8qKiBTaWduYWwgdGhhdCBzaG91bGQgYmUgZW1pdHRlZCB3aGVuIGEga2V5IGlzIGJlaW5nIHByZXNzZWQgb24gdGhlIGtleWJvYXJkLCB3aGlsZSB0aGUgcmVuZGVyZWQgcGFnZSBpcyBkaXNwbGF5ZWQgaW4gdGhlIGZvcmVncm91bmQgKi9cbiAgICAgICAgdGhpcy5LZXlEb3duID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgIH1cbiAgICByZXR1cm4gUGFnZVJlbmRlcmVyO1xufSgpKTtcbmV4cG9ydCB7IFBhZ2VSZW5kZXJlciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL1BhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvKiogQ29udGFpbnMgbWV0aG9kcyBmb3IgZGlzcGxheWluZyBkcm9wZG93biBtZW51cyBhbmQgY29udGV4dCBtZW51cyAqL1xuZXhwb3J0IHZhciBNZW51O1xuKGZ1bmN0aW9uIChNZW51KSB7XG4gICAgLyoqIERpc3BsYXkgYSBtb2RhbCBjb250ZXh0IG1lbnU7IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGluZGV4KGJhc2UgMSkva2V5IG9mIHRoZSBzZWxlY3RlZCBtZW51IGl0ZW0sIG9yIGlzIHJlamVjdGVkIGlmIHRoZSB1c2VyIGNhbmNlbHMgdGhlIGNvbnRleHQgbWVudSAqL1xuICAgIGZ1bmN0aW9uIGRpc3BsYXlDb250ZXh0TWVudShvcHRpb25zLCBldmVudCkge1xuICAgICAgICAvKiBpbXBsZW1lbnRlZCBieSBwbGF0Zm9ybSBkZXBlbmRlbnQgY29kZSAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgTWVudS5kaXNwbGF5Q29udGV4dE1lbnUgPSBkaXNwbGF5Q29udGV4dE1lbnU7XG4gICAgLyoqIERpc3BsYXkgYSBtb2RhbCBkcm9wZG93biBtZW51IGJlbG93IHRoZSBnaXZlbiBjb21wb25lbnQgKG9yIGFib3ZlLCBkZXBlbmRpbmcgb24gYXZhaWxhYmxlIHNjcmVlbiBzcGFjZSk7IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGluZGV4KGJhc2UgMSkva2V5IG9mIHRoZSBzZWxlY3RlZCBtZW51IGl0ZW0sIG9yIGlzIHJlamVjdGVkIGlmIHRoZSB1c2VyIGNhbmNlbHMgdGhlIGNvbnRleHQgbWVudSAqL1xuICAgIGZ1bmN0aW9uIGRpc3BsYXlEcm9wZG93bihvcHRpb25zLCBjb21wb25lbnQpIHtcbiAgICAgICAgLyogaW1wbGVtZW50ZWQgYnkgcGxhdGZvcm0gZGVwZW5kZW50IGNvZGUgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIE1lbnUuZGlzcGxheURyb3Bkb3duID0gZGlzcGxheURyb3Bkb3duO1xuICAgIC8qKiBEaXNtaXNzIHRoZSBtZW51IGN1cnJlbnRseSBvbiBzY3JlZW4sIGlmIGFueSAqL1xuICAgIGZ1bmN0aW9uIGRpc21pc3MoKSB7XG4gICAgICAgIC8qIGltcGxlbWVudGVkIGJ5IHBsYXRmb3JtIGRlcGVuZGVudCBjb2RlICovXG4gICAgfVxuICAgIE1lbnUuZGlzbWlzcyA9IGRpc21pc3M7XG59KShNZW51IHx8IChNZW51ID0ge30pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9NZW51LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG4vKiogVUkgY29udHJvbCBlbGVtZW50IGJhc2UgY2xhc3MgKi9cbnZhciBDb250cm9sRWxlbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnRyb2xFbGVtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnRyb2xFbGVtZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLyoqIFdpZHRoIChDU1MgbGVuZ3RoKSwgZGVmYXVsdCBcImF1dG9cIiAob2JzZXJ2ZWQpICovXG4gICAgICAgIF90aGlzLndpZHRoID0gXCJhdXRvXCI7XG4gICAgICAgIC8qKiBTZXQgdG8gdHJ1ZSB0byBzaHJpbmsgdGhpcyBlbGVtZW50IHRvIHVzZSBhcyBsaXR0bGUgaG9yaXpvbnRhbCBzcGFjZSBhcyBwb3NzaWJsZSBpbiBhIHJvdzsgc2V0IHRvIGZhbHNlIHRvIGV4cGFuZCAob2JzZXJ2ZWQpICovXG4gICAgICAgIF90aGlzLnNocmlua3dyYXAgPSBmYWxzZTtcbiAgICAgICAgLyoqIFNldCB0byB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgYnJlYWsgdGV4dCBhY3Jvc3MgbGluZXMgKG9ic2VydmVkKSAqL1xuICAgICAgICBfdGhpcy53cmFwVGV4dCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIENvbnRyb2xFbGVtZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ29udHJvbEVsZW1lbnQucHJvdG90eXBlLCBcInNocmlua3dyYXBcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbnRyb2xFbGVtZW50LnByb3RvdHlwZSwgXCJ3cmFwVGV4dFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBDb250cm9sRWxlbWVudDtcbn0oQ29tcG9uZW50KSk7XG5leHBvcnQgeyBDb250cm9sRWxlbWVudCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvQ29udHJvbEVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSBcIi4uLy4uL1N0eWxlXCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBDb21wb25lbnRTaWduYWxIYW5kbGVyLCBDb21wb25lbnRTaWduYWwgfSBmcm9tIFwiLi4vQ29tcG9uZW50U2lnbmFsXCI7XG5pbXBvcnQgeyBNZW51IH0gZnJvbSBcIi4uLy4uL01lbnVcIjtcbmltcG9ydCB7IENvbnRyb2xFbGVtZW50IH0gZnJvbSBcIi4vQ29udHJvbEVsZW1lbnRcIjtcbi8qKiBSZXByZXNlbnRzIGEgYnV0dG9uIGNvbnRyb2wgKi9cbnZhciBCdXR0b24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b24sIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhIGJ1dHRvbiBjb250cm9sIGVsZW1lbnQgKi9cbiAgICBmdW5jdGlvbiBCdXR0b24obGFiZWwsIGljb24pIHtcbiAgICAgICAgaWYgKGxhYmVsID09PSB2b2lkIDApIHsgbGFiZWwgPSBcIlwiOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBTZXQgdG8gZmFsc2UgdG8gZXhwYW5kIGhvcml6b250YWxseSB3aXRoaW4gcm93IChvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMuc2hyaW5rd3JhcCA9IHRydWU7XG4gICAgICAgIC8qKiBFbmNhcHN1bGF0aW9uIG9mIGJ1dHRvbiBlbGVtZW50IHN0eWxlIChvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMuc3R5bGVfYnV0dG9uID0gbmV3IFN0eWxlKCk7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCB3aGVuIGEgZHJvcGRvd24gb3B0aW9uIGhhcyBiZWVuIHNlbGVjdGVkICovXG4gICAgICAgIF90aGlzLkRyb3Bkb3duQ2xpY2tlZCA9IF90aGlzLmNyZWF0ZUNvbXBvbmVudFNpZ25hbChCdXR0b24uRHJvcGRvd25DbGlja1NpZ25hbCk7XG4gICAgICAgIF90aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIF90aGlzLmljb24gPSBpY29uO1xuICAgICAgICAvLyBjb25uZWN0IHRvIENsaWNrIHNpZ25hbCB0byBzaG93IGRyb3Bkb3duIGFuZC9vciBhY3RpdmF0ZSB0YXJnZXRcbiAgICAgICAgX3RoaXMuQ2xpY2suY29ubmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZHJvcGRvd24gJiYgX3RoaXMuZHJvcGRvd24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG1lbnUgYW5kIGRpc3BsYXksIHRoZW4gZW1pdCBzaWduYWwgb24gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgTWVudS5kaXNwbGF5RHJvcGRvd24oX3RoaXMuZHJvcGRvd24sIF90aGlzKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2hvaWNlKSB7IHJldHVybiBfdGhpcy5Ecm9wZG93bkNsaWNrZWQoY2hvaWNlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZSBnaXZlbiB0YXJnZXRcbiAgICAgICAgICAgICAgICBuZXcgQnV0dG9uLkFjdGl2YXRpb24oKS5hY3RpdmF0ZShfdGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogSW5pdGlhbGl6ZSBhIGJ1dHRvbiBjb250cm9sIGZhY3Rvcnkgd2l0aCBnaXZlbiBsYWJlbCBhbmQgaGFuZGxlciAqL1xuICAgIEJ1dHRvbi53aXRoTGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIGNsaWNrZWRIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGgoeyBsYWJlbDogbGFiZWwsIENsaWNrZWQ6IGNsaWNrZWRIYW5kbGVyIH0pO1xuICAgIH07XG4gICAgLyoqIEluaXRpYWxpemUgYSBidXR0b24gY29udHJvbCBmYWN0b3J5IHdpdGggZ2l2ZW4gaWNvbiBhbmQgaGFuZGxlciAqL1xuICAgIEJ1dHRvbi53aXRoSWNvbiA9IGZ1bmN0aW9uIChpY29uLCBjbGlja2VkSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoKHsgbGFiZWw6IFwiXCIsIGljb246IGljb24sIENsaWNrZWQ6IGNsaWNrZWRIYW5kbGVyIH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc3RyaW5nXG4gICAgXSwgQnV0dG9uLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQnV0dG9uLnByb3RvdHlwZSwgXCJpY29uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBCdXR0b24ucHJvdG90eXBlLCBcImljb25BZnRlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQnV0dG9uLnByb3RvdHlwZSwgXCJyZW1HdXR0ZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBCdXR0b24ucHJvdG90eXBlLCBcImJhZGdlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc3RyaW5nXG4gICAgXSwgQnV0dG9uLnByb3RvdHlwZSwgXCJ0b29sdGlwVGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQnV0dG9uLnByb3RvdHlwZSwgXCJwcmltYXJ5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBCdXR0b24ucHJvdG90eXBlLCBcImRyb3Bkb3duXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBCdXR0b24ucHJvdG90eXBlLCBcInRhcmdldFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX25vdF9udWxsXG4gICAgXSwgQnV0dG9uLnByb3RvdHlwZSwgXCJzdHlsZV9idXR0b25cIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQnV0dG9uO1xufShDb250cm9sRWxlbWVudCkpO1xuZXhwb3J0IHsgQnV0dG9uIH07XG4oZnVuY3Rpb24gKEJ1dHRvbikge1xuICAgIC8qKiBTaWduYWwgdGhhdCBpcyBlbWl0dGVkIHdoZW4gYSBkcm9wZG93biBpdGVtIGhhcyBiZWVuIHNlbGVjdGVkICovXG4gICAgdmFyIERyb3Bkb3duQ2xpY2tTaWduYWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRHJvcGRvd25DbGlja1NpZ25hbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRHJvcGRvd25DbGlja1NpZ25hbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRHJvcGRvd25DbGlja1NpZ25hbDtcbiAgICB9KENvbXBvbmVudFNpZ25hbCkpO1xuICAgIEJ1dHRvbi5Ecm9wZG93bkNsaWNrU2lnbmFsID0gRHJvcGRvd25DbGlja1NpZ25hbDtcbiAgICAvKiogQ29udGFpbnMgaW5qZWN0YWJsZSBtZXRob2QgZm9yIGFjdGl2YXRpbmcgdGFyZ2V0czsgaW5zdGFudGlhdGVkIGJ5IGBCdXR0b25gICovXG4gICAgdmFyIEFjdGl2YXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBY3RpdmF0aW9uKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKiBJbmplY3RhYmxlIG1ldGhvZCB0byBhY3RpdmF0ZSBnaXZlbiB0YXJnZXQgKGUuZy4gVVJMLCBvciBBY3Rpdml0eSBpbnN0YW5jZSBvciBjbGFzcyk7IGRlZmF1bHQgb255IGhhbmRsZXMgVVJMcywgYEFwcGxpY2F0aW9uYCBpbnN0YW5jZSBpbmplY3RzIG1vcmUgZnVuY3Rpb25hbGl0eSBoZXJlICovXG4gICAgICAgIEFjdGl2YXRpb24ucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKHRhcmdldCkgeyB9O1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIEFzeW5jLmluamVjdGFibGVcbiAgICAgICAgXSwgQWN0aXZhdGlvbi5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgbnVsbCk7XG4gICAgICAgIHJldHVybiBBY3RpdmF0aW9uO1xuICAgIH0oKSk7XG4gICAgQnV0dG9uLkFjdGl2YXRpb24gPSBBY3RpdmF0aW9uO1xufSkoQnV0dG9uIHx8IChCdXR0b24gPSB7fSkpO1xuLyoqIENvbnN0cnVjdG9yIGZvciBhIGJ1dHRvbiBkcm9wZG93biBjbGljayBldmVudCBoYW5kbGVyICovXG52YXIgQnV0dG9uRHJvcGRvd25DbGlja0hhbmRsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdXR0b25Ecm9wZG93bkNsaWNrSGFuZGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXR0b25Ecm9wZG93bkNsaWNrSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnV0dG9uRHJvcGRvd25DbGlja0hhbmRsZXI7XG59KENvbXBvbmVudFNpZ25hbEhhbmRsZXIpKTtcbmV4cG9ydCB7IEJ1dHRvbkRyb3Bkb3duQ2xpY2tIYW5kbGVyIH07XG4vKiogUHJpbWFyeSBidXR0b24gY29udHJvbCAoc2hvcnRjdXQgZm9yIHNldHRpbmcgYC5wcmltYXJ5YCBvbiByZWd1bGFyIGBCdXR0b25gIGNsYXNzKSAqL1xudmFyIFByaW1hcnlCdXR0b24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmltYXJ5QnV0dG9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByaW1hcnlCdXR0b24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcmltYXJ5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUHJpbWFyeUJ1dHRvbjtcbn0oQnV0dG9uKSk7XG5leHBvcnQgeyBQcmltYXJ5QnV0dG9uIH07XG4vKiogQnV0dG9uIHRoYXQgc3dpdGNoZXMgYmV0d2VlbiBzZWxlY3RlZCAoYWN0aXZlKSBhbmQgZGVzZWxlY3RlZCAoaW5hY3RpdmUpIHdoZW4gY2xpY2tlZCAoc2hvcnRjdXQgZm9yIHNldHRpbmcgYHRvZ2dsZU1vZGVgIG9uIHJlZ3VsYXIgYEJ1dHRvbmAgY2xhc3MpICovXG52YXIgVG9nZ2xlQnV0dG9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVG9nZ2xlQnV0dG9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvZ2dsZUJ1dHRvbihsYWJlbCwgaWNvbikge1xuICAgICAgICBpZiAobGFiZWwgPT09IHZvaWQgMCkgeyBsYWJlbCA9IFwiXCI7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGFiZWwsIGljb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlbGVjdGlvbk1vZGUgPSBDb21wb25lbnQuU2VsZWN0aW9uTW9kZS5Ub2dnbGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRvZ2dsZUJ1dHRvbjtcbn0oQnV0dG9uKSk7XG5leHBvcnQgeyBUb2dnbGVCdXR0b24gfTtcbi8qKiBMaW5rLXN0eWxlZCBidXR0b24gY29udHJvbCAoXCJidG4tbGlua1wiIGNsYXNzKSAqL1xudmFyIExpbmtCdXR0b24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5rQnV0dG9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmtCdXR0b24oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpbmtCdXR0b247XG59KEJ1dHRvbikpO1xuZXhwb3J0IHsgTGlua0J1dHRvbiB9O1xuLyoqIEJ1dHRvbiBjb250cm9sIHRoYXQgaXMgbm90IGRlY29yYXRlZCBhcyBhIGJ1dHRvbiAqL1xudmFyIFRleHRCdXR0b24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZXh0QnV0dG9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHRCdXR0b24oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRleHRCdXR0b247XG59KEJ1dHRvbikpO1xuZXhwb3J0IHsgVGV4dEJ1dHRvbiB9O1xuLyoqIFJvdW5kIGJ1dHRvbiBjb250cm9sIChlLmcuIHdpdGggYW4gaWNvbikgKi9cbnZhciBSb3VuZEJ1dHRvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvdW5kQnV0dG9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvdW5kQnV0dG9uKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBSb3VuZEJ1dHRvbjtcbn0oQnV0dG9uKSk7XG5leHBvcnQgeyBSb3VuZEJ1dHRvbiB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvQnV0dG9uLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBEcmFnIH0gZnJvbSBcIi4uLy4uL0RyYWdcIjtcbmltcG9ydCB7IFBhZ2UgfSBmcm9tIFwiLi4vLi4vUGFnZVwiO1xuaW1wb3J0IHsgU2NyZWVuIH0gZnJvbSBcIi4uLy4uL1NjcmVlblwiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi9Db21wb25lbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tIFwiLi9Db250YWluZXJcIjtcbi8vIFRleHRCdXR0b24gaXMgbmVlZGVkIGRpcmVjdGx5IGluIHN0YXRpYyBpbml0IG9mIFRvcENsb3NlQnV0dG9uOlxuaW1wb3J0IHsgVGV4dEJ1dHRvbiB9IGZyb20gXCIuLi9Db250cm9scy9CdXR0b25cIjtcbi8qKiBSZXByZXNlbnRzIGEgbW9kYWwgZGlhbG9nIGNvbnRhaW5lciAqL1xudmFyIERpYWxvZ0NvbnRhaW5lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpYWxvZ0NvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgbmV3IG1vZGFsIGRpYWxvZyB3aXRoIGdpdmVuIGNvbnRlbnQsIGlmIGFueSAqL1xuICAgIGZ1bmN0aW9uIERpYWxvZ0NvbnRhaW5lcihjb250ZW50LCB3aWR0aCkge1xuICAgICAgICBpZiAod2lkdGggPT09IHZvaWQgMCkgeyB3aWR0aCA9IFwiMjdyZW1cIjsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb250ZW50KSB8fCB0aGlzO1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgYnkgdGhlIGAub3BlbmAgbWV0aG9kIGJlZm9yZSBkaXNwbGF5aW5nIHRoZSBkaWFsb2c7IGlmIGFueSBoYW5kbGVyIHRocm93cyBhbiBlcnJvciB0aGVuIHRoZSBkaWFsb2cgd2lsbCBub3Qgb3BlbiAqL1xuICAgICAgICBfdGhpcy5PcGVuaW5nID0gX3RoaXMuY3JlYXRlQ29tcG9uZW50U2lnbmFsKCk7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCB3aGVuIHVzZXIgY2xpY2tzIG91dHNpZGUgZGlhbG9nLCBwcmVzc2VzIGVzYyBvciBjbGlja3MgRGlhbG9nQ29udGFpbmVyLlRvcENsb3NlQnV0dG9uOyBpZiBhbnkgaGFuZGxlciB0aHJvd3MgYW4gZXJyb3IgdGhlbiB0aGUgZGlhbG9nIHdpbGwgbm90IGNsb3NlICovXG4gICAgICAgIF90aGlzLkNsb3NpbmcgPSBfdGhpcy5jcmVhdGVDb21wb25lbnRTaWduYWwoKTtcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIHdoZW4gdGhpcyBkaWFsb2cgaGFzIGJlZW4gY2xvc2VkICovXG4gICAgICAgIF90aGlzLkNsb3NlZCA9IF90aGlzLmNyZWF0ZUNvbXBvbmVudFNpZ25hbCgpO1xuICAgICAgICAvKiogQGludGVybmFsIFRydWUgaWYgYSBkcmFnIGhhbmRsZSBoYXMgYmVlbiAodW4pc2V0IGV4cGxpY2l0bHkgKi9cbiAgICAgICAgX3RoaXMuX2RyYWdIYW5kbGVTZXQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgLy8gc2V0IGRlZmF1bHQgZGlzcGxheSBvcHRpb25zXG4gICAgICAgIF90aGlzLmRpc3BsYXlPcHRpb25zID0ge1xuICAgICAgICAgICAgbW9kYWw6IHRydWUsXG4gICAgICAgICAgICBzaGFkZTogdHJ1ZSxcbiAgICAgICAgICAgIG1vZGFsSG9yekFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgb3V0ZXJNYXJnaW46IFwiLjVyZW1cIixcbiAgICAgICAgICAgIG9uRXNjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgQXN5bmMuUHJvbWlzZS5hbGwobmV3IF90aGlzLkNsb3Npbmcoe30pLmVtaXQoKS5yZXN1bHRzKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jbG9zZSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gYWRkIGRlZmF1bHQgYW5pbWF0aW9uc1xuICAgICAgICBpZiAoIV90aGlzLmFuaW1hdGlvbnMpXG4gICAgICAgICAgICBfdGhpcy5hbmltYXRpb25zID0ge307XG4gICAgICAgIF90aGlzLmFuaW1hdGlvbnMuYXBwZWFyID0gRGlhbG9nQ29udGFpbmVyLkFQUEVBUl9BTklNQVRJT047XG4gICAgICAgIF90aGlzLmFuaW1hdGlvbnMuZGlzYXBwZWFyID0gRGlhbG9nQ29udGFpbmVyLkRJU0FQUEVBUl9BTklNQVRJT047XG4gICAgICAgIC8vIHNldCBoZWFkZXIgYXMgZHJhZyBoYW5kbGUgaWYgbm9uZSBzZXQgZXhwbGljaXRseVxuICAgICAgICBfdGhpcy5SZW5kZXJlZC5jb25uZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2RyYWdIYW5kbGVTZXQgJiYgX3RoaXMuaGVhZGVyKVxuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkgeyBfdGhpcy5zZXREcmFnSGFuZGxlKF90aGlzLmhlYWRlcik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogU2hvdyB0aGUgZGlhbG9nIG9uIHNjcmVlbiAoaW4gZnJvbnQgb2Ygb3RoZXIgY29tcG9uZW50cyBvbiB0aGUgY3VycmVudCBwYWdlLCBpZiBhbnkpLCBhc3luY2hyb25vdXNseSBhZnRlciBlbWl0dGluZyB0aGUgYC5PcGVuaW5nYCBzaWduYWw7IHJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gcmVuZGVyZWQgKi9cbiAgICBEaWFsb2dDb250YWluZXIucHJvdG90eXBlLm9wZW5Bc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIEFzeW5jLlByb21pc2UuYWxsKG5ldyB0aGlzLk9wZW5pbmcoe30pLnJlc3VsdHMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBTY3JlZW4uZGlzcGxheUFzeW5jKF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKiogUmVtb3ZlIHRoZSBkaWFsb2cgZnJvbSBzY3JlZW4gKGRvZXMgbm90IGVtaXQgb3Igd2FpdCBmb3IgYC5DbG9zaW5nYCBzaWduYWwsIG9ubHkgZW1pdHMgYC5DbG9zZWRgKTsgcmV0dXJucyB0aGlzICovXG4gICAgRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgU2NyZWVuLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5DbG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogVXNlIGdpdmVuIGNvbXBvbmVudCBhcyBhIGRyYWcgaGFuZGxlIGZvciB0aGlzIGRpYWxvZyAoYW5kIHJlbGVhc2VzIGhhbmRsZSBjdXJyZW50bHkgaW4gdXNlOyBkZWZhdWx0cyB0byAuaGVhZGVyKSAqL1xuICAgIERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUuc2V0RHJhZ0hhbmRsZSA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZHJhZ0hhbmRsZVNldCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9kcmFnSGFuZGxlQ29ubmVjdGlvbilcbiAgICAgICAgICAgIHRoaXMuX2RyYWdIYW5kbGVDb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgLy8gbGlzdGVuIHRvIG1vdXNlIGRvd24gYW5kIHN0YXJ0IGRyYWcsIHRoZW4gcGljayB1cCBjb250YWluZXJcbiAgICAgICAgaWYgKGhhbmRsZSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0hhbmRsZUNvbm5lY3Rpb24gPSBoYW5kbGUuUHJlc3NlZC5jb25uZWN0KGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuYnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICBEcmFnLnN0YXJ0KGV2ZW50KS5waWNrVXAoX3RoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRpcmVjdGx5IGNvbnRhaW5lZCBjb21wb25lbnRzIChvYnNlcnZhYmxlKSAqL1xuICAgIERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLmdldENoaWxkcmVuLmNhbGwodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlciBpbnN0YW5jZW9mIENvbXBvbmVudClcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHRoaXMuaGVhZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuZm9vdGVyIGluc3RhbmNlb2YgQ29tcG9uZW50KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5mb290ZXIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlDb21wb25lbnRSZWYoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQmxvY2spLFxuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZSwgXCJoZWFkZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBseUNvbXBvbmVudFJlZihDb21wb25lbnRGYWN0b3J5LkNMZXZlbC5CbG9jayksXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBEaWFsb2dDb250YWluZXIucHJvdG90eXBlLCBcImZvb3RlclwiLCB2b2lkIDApO1xuICAgIHJldHVybiBEaWFsb2dDb250YWluZXI7XG59KENvbnRhaW5lcikpO1xuZXhwb3J0IHsgRGlhbG9nQ29udGFpbmVyIH07XG4oZnVuY3Rpb24gKERpYWxvZ0NvbnRhaW5lcikge1xuICAgIC8qKiBQcmVkZWZpbmVkIG1vZGFsIGNsb3NlIGJ1dHRvbiAoXCJYXCIpIGNvbnRyb2wsIGJhc2VkIG9uIGBUZXh0QnV0dG9uYCAqL1xuICAgIHZhciBUb3BDbG9zZUJ1dHRvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhUb3BDbG9zZUJ1dHRvbiwgX3N1cGVyKTtcbiAgICAgICAgLyoqIENyZWF0ZSBhIG1vZGFsIGNsb3NlIGJ1dHRvbiAoXCJYXCIpIGNvbnRyb2wgKi9cbiAgICAgICAgZnVuY3Rpb24gVG9wQ2xvc2VCdXR0b24oKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMubGFiZWwgPSBcIlxcdTAwRDdcIjtcbiAgICAgICAgICAgIF90aGlzLnRvb2x0aXBUZXh0ID0gXCJDbG9zZVwiO1xuICAgICAgICAgICAgX3RoaXMuQ2xpY2suY29ubmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2UgPSBQYWdlLmdldEN1cnJlbnRQYWdlKCk7XG4gICAgICAgICAgICAgICAgcGFnZSAmJiBwYWdlLmhhbmRsZUVzYygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRvcENsb3NlQnV0dG9uO1xuICAgIH0oVGV4dEJ1dHRvbikpO1xuICAgIERpYWxvZ0NvbnRhaW5lci5Ub3BDbG9zZUJ1dHRvbiA9IFRvcENsb3NlQnV0dG9uO1xufSkoRGlhbG9nQ29udGFpbmVyIHx8IChEaWFsb2dDb250YWluZXIgPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udGFpbmVycy9EaWFsb2dDb250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCB7IERpYWxvZ0NvbnRhaW5lciB9IGZyb20gXCIuL0RpYWxvZ0NvbnRhaW5lclwiO1xuLyoqIFJlcHJlc2VudHMgYSBtb2RhbCBjb250YWluZXIgZGlzcGxheWVkIG9uIHRoZSBzaWRlIG9mIHRoZSBzY3JlZW4gKi9cbnZhciBEcmF3ZXJDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmF3ZXJDb250YWluZXIsIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhIGRyYXdlciBjb21wb25lbnQgd2l0aCBnaXZlbiBjb250ZW50LCBpZiBhbnkgKi9cbiAgICBmdW5jdGlvbiBEcmF3ZXJDb250YWluZXIoY29udGVudCwgd2lkdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29udGVudCkgfHwgdGhpcztcbiAgICAgICAgaWYgKHdpZHRoKVxuICAgICAgICAgICAgX3RoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgLy8gYW1lbmQgYWxpZ25tZW50IGFuZCBtYXJnaW5cbiAgICAgICAgX3RoaXMuZGlzcGxheU9wdGlvbnMubW9kYWxIb3J6QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgX3RoaXMuZGlzcGxheU9wdGlvbnMub3V0ZXJNYXJnaW4gPSBcIjEuNXJlbVwiO1xuICAgICAgICAvLyBhbWVuZCBkZWZhdWx0IGFuaW1hdGlvbnNcbiAgICAgICAgaWYgKCFfdGhpcy5hbmltYXRpb25zKVxuICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW9ucyA9IHt9O1xuICAgICAgICBfdGhpcy5hbmltYXRpb25zLmFwcGVhciA9IERyYXdlckNvbnRhaW5lci5BUFBFQVJfQU5JTUFUSU9OO1xuICAgICAgICBfdGhpcy5hbmltYXRpb25zLmRpc2FwcGVhciA9IERyYXdlckNvbnRhaW5lci5ESVNBUFBFQVJfQU5JTUFUSU9OO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBEcmF3ZXJDb250YWluZXI7XG59KERpYWxvZ0NvbnRhaW5lcikpO1xuZXhwb3J0IHsgRHJhd2VyQ29udGFpbmVyIH07XG4vKiogUmVwcmVzZW50cyBhIG1vZGFsIGNvbnRhaW5lciBkaXNwbGF5ZWQgb24gdGhlIHJpZ2h0IGhhbmQgc2lkZSBvZiB0aGUgc2NyZWVuIChpLmUuIERyYXdlckNvbnRhaW5lciB3aXRoIGRpZmZlcmVudCBhbGlnbm1lbnQgYW5kIGFuaW1hdGlvbnMpICovXG52YXIgT3Bwb3NpdGVEcmF3ZXJDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPcHBvc2l0ZURyYXdlckNvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgZHJhd2VyIGNvbXBvbmVudCB3aXRoIGdpdmVuIGNvbnRlbnQsIGlmIGFueSAqL1xuICAgIGZ1bmN0aW9uIE9wcG9zaXRlRHJhd2VyQ29udGFpbmVyKGNvbnRlbnQsIHdpZHRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbnRlbnQsIHdpZHRoKSB8fCB0aGlzO1xuICAgICAgICAvLyBhbWVuZCBhbGlnbm1lbnRcbiAgICAgICAgX3RoaXMuZGlzcGxheU9wdGlvbnMubW9kYWxIb3J6QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgIC8vIGFtZW5kIGRlZmF1bHQgYW5pbWF0aW9uc1xuICAgICAgICBpZiAoIV90aGlzLmFuaW1hdGlvbnMpXG4gICAgICAgICAgICBfdGhpcy5hbmltYXRpb25zID0ge307XG4gICAgICAgIF90aGlzLmFuaW1hdGlvbnMuYXBwZWFyID0gT3Bwb3NpdGVEcmF3ZXJDb250YWluZXIuQVBQRUFSX0FOSU1BVElPTjtcbiAgICAgICAgX3RoaXMuYW5pbWF0aW9ucy5kaXNhcHBlYXIgPSBPcHBvc2l0ZURyYXdlckNvbnRhaW5lci5ESVNBUFBFQVJfQU5JTUFUSU9OO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBPcHBvc2l0ZURyYXdlckNvbnRhaW5lcjtcbn0oRHJhd2VyQ29udGFpbmVyKSk7XG5leHBvcnQgeyBPcHBvc2l0ZURyYXdlckNvbnRhaW5lciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udGFpbmVycy9EcmF3ZXJDb250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IENvbnRhaW5lciB9IGZyb20gXCIuL0NvbnRhaW5lclwiO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi9Db21wb25lbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG4vKiogUmVwcmVzZW50cyBhIGNvbnRhaW5lciB3aXRoIHN1YiBjb250YWluZXJzIG9uIHVwIHRvIGZvdXIgc2lkZXMsIGFuZCBhIG1haW4gYXJlYSB3aXRoIHZlcnRpY2FsbHkgc3RhY2tlZCBibG9ja3MgKi9cbnZhciBMYXlvdXRDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXlvdXRDb250YWluZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGF5b3V0Q29udGFpbmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLyoqIFNldCB0byB0cnVlIHRvIG1ha2UgY29udGVudCB3aXRoaW4gY29udGFpbmVyIHNjcm9sbGFibGU7IGRlZmF1bHRzIHRvIHRydWUgZm9yIGBMYXlvdXRDb250YWluZXJgIChvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMuc2Nyb2xsYWJsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYW4gYXJyYXkgb2YgZGlyZWN0bHkgY29udGFpbmVkIGNvbXBvbmVudHMgKG9ic2VydmFibGUpICovXG4gICAgTGF5b3V0Q29udGFpbmVyLnByb3RvdHlwZS5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4uY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyIGluc3RhbmNlb2YgQ29tcG9uZW50KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5oZWFkZXIpO1xuICAgICAgICBpZiAodGhpcy5mb290ZXIgaW5zdGFuY2VvZiBDb21wb25lbnQpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmZvb3Rlcik7XG4gICAgICAgIGlmICh0aGlzLmluc2lkZUd1dHRlciBpbnN0YW5jZW9mIENvbXBvbmVudClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuaW5zaWRlR3V0dGVyKTtcbiAgICAgICAgaWYgKHRoaXMub3V0c2lkZUd1dHRlciBpbnN0YW5jZW9mIENvbXBvbmVudClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMub3V0c2lkZUd1dHRlcik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogRGVmYXVsdCBpbnNpZGUgZ3V0dGVyIHdpZHRoLCB1c2VkIHdoZW4gaW5zaWRlIGd1dHRlciBjb250YWluZXIgaGFzIG5vIGRlZmluZWQgd2lkdGggKENTUyB2YWx1ZSwgaW5pdGlhbGx5IDE4cmVtKSAqL1xuICAgIExheW91dENvbnRhaW5lci5JTlNJREVfR1VUVEVSX1dJRFRIID0gXCIxOHJlbVwiO1xuICAgIC8qKiBEZWZhdWx0IG91dHNpZGUgZ3V0dGVyIHdpZHRoLCB1c2VkIHdoZW4gb3V0c2lkZSBndXR0ZXIgY29udGFpbmVyIGhhcyBubyBkZWZpbmVkIHdpZHRoIChDU1MgdmFsdWUsIGluaXRpYWxseSAyMnJlbSkgKi9cbiAgICBMYXlvdXRDb250YWluZXIuT1VUU0lERV9HVVRURVJfV0lEVEggPSBcIjIycmVtXCI7XG4gICAgLyoqIERlZmF1bHQgaGVhZGVyIGhlaWdodCwgdXNlZCB3aGVuIGhlYWRlciBjb250YWluZXIgaGFzIG5vIGRlZmluZWQgaGVpZ2h0IChDU1MgdmFsdWUsIGluaXRpYWxseSA0cmVtKSAqL1xuICAgIExheW91dENvbnRhaW5lci5IRUFERVJfSEVJR0hUID0gXCI0cmVtXCI7XG4gICAgLyoqIERlZmF1bHQgZm9vdGVyIGhlaWdodCwgdXNlZCB3aGVuIGZvb3RlciBjb250YWluZXIgaGFzIG5vIGRlZmluZWQgaGVpZ2h0IChDU1MgdmFsdWUsIGluaXRpYWxseSAycmVtKSAqL1xuICAgIExheW91dENvbnRhaW5lci5GT09URVJfSEVJR0hUID0gXCIycmVtXCI7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlDb21wb25lbnRSZWYoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udGFpbmVyKSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIExheW91dENvbnRhaW5lci5wcm90b3R5cGUsIFwiaGVhZGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlDb21wb25lbnRSZWYoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udGFpbmVyKSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIExheW91dENvbnRhaW5lci5wcm90b3R5cGUsIFwiZm9vdGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlDb21wb25lbnRSZWYoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udGFpbmVyKSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIExheW91dENvbnRhaW5lci5wcm90b3R5cGUsIFwiaW5zaWRlR3V0dGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlDb21wb25lbnRSZWYoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udGFpbmVyKSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIExheW91dENvbnRhaW5lci5wcm90b3R5cGUsIFwib3V0c2lkZUd1dHRlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgTGF5b3V0Q29udGFpbmVyLnByb3RvdHlwZSwgXCJzY3JvbGxhYmxlXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIExheW91dENvbnRhaW5lcjtcbn0oQ29udGFpbmVyKSk7XG5leHBvcnQgeyBMYXlvdXRDb250YWluZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0NvbnRhaW5lcnMvTGF5b3V0Q29udGFpbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG4vKiogQmxvY2sgYmFzZSBjbGFzczogZnVsbC13aWR0aCBibG9jayBjb21wb25lbnQgKi9cbnZhciBCbG9jayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrLCBfc3VwZXIpO1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgZW1wdHkgYmxvY2sgY29tcG9uZW50ICovXG4gICAgZnVuY3Rpb24gQmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBub3RoaW5nIGhlcmVcbiAgICB9XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBCbG9jay5wcm90b3R5cGUsIFwib3ZlcmxheVBvc2l0aW9uXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEJsb2NrO1xufShDb21wb25lbnQpKTtcbmV4cG9ydCB7IEJsb2NrIH07XG4oZnVuY3Rpb24gKEJsb2NrKSB7XG4gICAgLyoqIE92ZXJsYXkgcG9zaXRpb25pbmcgb3B0aW9ucyAqL1xuICAgIHZhciBPdmVybGF5UG9zaXRpb247XG4gICAgKGZ1bmN0aW9uIChPdmVybGF5UG9zaXRpb24pIHtcbiAgICAgICAgLyoqIFRvcCAoZnVsbCB3aWR0aCkgKi9cbiAgICAgICAgT3ZlcmxheVBvc2l0aW9uW092ZXJsYXlQb3NpdGlvbltcIlRvcFwiXSA9IDBdID0gXCJUb3BcIjtcbiAgICAgICAgLyoqIFRvcCBsZWZ0IGNvcm5lciAqL1xuICAgICAgICBPdmVybGF5UG9zaXRpb25bT3ZlcmxheVBvc2l0aW9uW1wiVG9wTGVmdFwiXSA9IDFdID0gXCJUb3BMZWZ0XCI7XG4gICAgICAgIC8qKiBUb3AgcmlnaHQgY29ybmVyICovXG4gICAgICAgIE92ZXJsYXlQb3NpdGlvbltPdmVybGF5UG9zaXRpb25bXCJUb3BSaWdodFwiXSA9IDJdID0gXCJUb3BSaWdodFwiO1xuICAgICAgICAvKiogVG9wIGluc2lkZSBjb3JuZXIgKGxlZnQgZm9yIGRlZmF1bHQgbHRyIG1vZGUpICovXG4gICAgICAgIE92ZXJsYXlQb3NpdGlvbltPdmVybGF5UG9zaXRpb25bXCJUb3BTdGFydFwiXSA9IDNdID0gXCJUb3BTdGFydFwiO1xuICAgICAgICAvKiogVG9wIG91dHNpZGUgY29ybmVyIChyaWdodCBmb3IgZGVmYXVsdCBsdHIgbW9kZSkgKi9cbiAgICAgICAgT3ZlcmxheVBvc2l0aW9uW092ZXJsYXlQb3NpdGlvbltcIlRvcEVuZFwiXSA9IDRdID0gXCJUb3BFbmRcIjtcbiAgICAgICAgLyoqIEJvdHRvbSAoZnVsbCB3aWR0aCkgKi9cbiAgICAgICAgT3ZlcmxheVBvc2l0aW9uW092ZXJsYXlQb3NpdGlvbltcIkJvdHRvbVwiXSA9IDVdID0gXCJCb3R0b21cIjtcbiAgICAgICAgLyoqIEJvdHRvbSBsZWZ0IGNvcm5lciAqL1xuICAgICAgICBPdmVybGF5UG9zaXRpb25bT3ZlcmxheVBvc2l0aW9uW1wiQm90dG9tTGVmdFwiXSA9IDZdID0gXCJCb3R0b21MZWZ0XCI7XG4gICAgICAgIC8qKiBCb3R0b20gcmlnaHQgY29ybmVyICovXG4gICAgICAgIE92ZXJsYXlQb3NpdGlvbltPdmVybGF5UG9zaXRpb25bXCJCb3R0b21SaWdodFwiXSA9IDddID0gXCJCb3R0b21SaWdodFwiO1xuICAgICAgICAvKiogQm90dG9tIGluc2lkZSBjb3JuZXIgKGxlZnQgZm9yIGRlZmF1bHQgbHRyIG1vZGUpICovXG4gICAgICAgIE92ZXJsYXlQb3NpdGlvbltPdmVybGF5UG9zaXRpb25bXCJCb3R0b21TdGFydFwiXSA9IDhdID0gXCJCb3R0b21TdGFydFwiO1xuICAgICAgICAvKiogQm90dG9tIG91dHNpZGUgY29ybmVyIChyaWdodCBmb3IgZGVmYXVsdCBsdHIgbW9kZSkgKi9cbiAgICAgICAgT3ZlcmxheVBvc2l0aW9uW092ZXJsYXlQb3NpdGlvbltcIkJvdHRvbUVuZFwiXSA9IDldID0gXCJCb3R0b21FbmRcIjtcbiAgICB9KShPdmVybGF5UG9zaXRpb24gPSBCbG9jay5PdmVybGF5UG9zaXRpb24gfHwgKEJsb2NrLk92ZXJsYXlQb3NpdGlvbiA9IHt9KSk7XG4gICAgO1xufSkoQmxvY2sgfHwgKEJsb2NrID0ge30pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0Jsb2Nrcy9CbG9jay5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tIFwiLi4vXCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBDb21wb25lbnRGYWN0b3J5IH0gZnJvbSBcIi4uL0NvbXBvbmVudEZhY3RvcnlcIjtcbi8qKiBSZXByZXNlbnRzIGEgY2FyZCBibG9jayBjb250YWluaW5nIGEgaGVhZGVyLCBjb250ZW50LCBhbmQgYSBmb290ZXIgKi9cbnZhciBDYXJkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FyZCwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgY2FyZCBibG9jayB3aXRoIGdpdmVuIGNvbnRlbnQsIGlmIGFueSAqL1xuICAgIGZ1bmN0aW9uIENhcmQoY29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwKSB7IGNvbnRlbnQgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogQXBwZW5kIGEgYmxvY2sgdG8gdGhpcyBjb21wb25lbnQgKi9cbiAgICBDYXJkLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB0aGlzLmNvbnRlbnQucHVzaChibG9jayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYW4gYXJyYXkgb2YgZGlyZWN0bHkgY29udGFpbmVkIGNvbXBvbmVudHMgKG9ic2VydmFibGUpICovXG4gICAgQ2FyZC5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnQuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoYyBpbnN0YW5jZW9mIENvbXBvbmVudCk7IH0pO1xuICAgICAgICBpZiAodGhpcy5oZWFkZXIgaW5zdGFuY2VvZiBDb21wb25lbnQpXG4gICAgICAgICAgICByZXN1bHQudW5zaGlmdCh0aGlzLmhlYWRlcik7XG4gICAgICAgIGlmICh0aGlzLmZvb3RlciBpbnN0YW5jZW9mIENvbXBvbmVudClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZm9vdGVyKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LmFwcGx5Q29tcG9uZW50UmVmKENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkJsb2NrKSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENhcmQucHJvdG90eXBlLCBcImhlYWRlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LmFwcGx5Q29tcG9uZW50UmVmKENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkJsb2NrKSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENhcmQucHJvdG90eXBlLCBcImZvb3RlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LmFwcGx5Q29tcG9uZW50c0FycmF5KENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkJsb2NrKSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9ub3RfbnVsbFxuICAgIF0sIENhcmQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbiAgICBDYXJkID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwZW5kQ2hpbGRDb21wb25lbnRzKENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkJsb2NrKVxuICAgIF0sIENhcmQpO1xuICAgIHJldHVybiBDYXJkO1xufShCbG9jaykpO1xuZXhwb3J0IHsgQ2FyZCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQmxvY2tzL0NhcmQuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IENvbnRhaW5lciwgTGF5b3V0Q29udGFpbmVyIH0gZnJvbSBcIi4uL1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi9Db21wb25lbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gXCIuL0Jsb2NrXCI7XG4vKiogUmVwcmVzZW50cyBhIGJsb2NrIHdpdGggYW4gZW1iZWRkZWQgc3ViIGNvbnRhaW5lciB3aXRoaW4gaXRzIG1hcmdpbnMvcGFkZGluZyAqL1xudmFyIENvbnRhaW5lckJsb2NrID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udGFpbmVyQmxvY2ssIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhIGNvbnRhaW5lciBibG9jayBjb21wb25lbnQgd2l0aCBnaXZlbiBjb250YWluZXIsIGlmIGFueSAqL1xuICAgIGZ1bmN0aW9uIENvbnRhaW5lckJsb2NrKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBpZiAoY29udGFpbmVyKVxuICAgICAgICAgICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAvLyBhcHBseSBhdXRvbWF0aWMgaGVpZ2h0IHRvIHN0YXJ0IHdpdGhcbiAgICAgICAgX3RoaXMuc3R5bGUuc2V0KFwiaGVpZ2h0XCIsIEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaGVpZ2h0OyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lckJsb2NrLnByb3RvdHlwZSwgXCJjb250YWluZXJcIiwge1xuICAgICAgICAvKiogQ29udGFpbmVyIGVsZW1lbnQgKGNyZWF0ZWQgaWYgbm90IHNldCwgbmV2ZXIgdW5kZWZpbmVkOyBvYnNlcnZlZCkgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBnZXQgdW5kZXJseWluZyBwcm9wZXJ0eSBvciBjcmVhdGUgYSBuZXcgY29udGFpbmVyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIgfHwgKHRoaXMuY29udGFpbmVyID0gQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQ29udGFpbmVyKCk7IH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgLy8gc2V0IHVuZGVybHlpbmcgcHJvcGVydHlcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gYztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lckJsb2NrLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwge1xuICAgICAgICAvKiogT3ZlcmFsbCB0YXJnZXQgaGVpZ2h0IG9mIHRoaXMgY29tcG9uZW50IChDU1MgbGVuZ3RoOyBvYnNlcnZhYmxlLCBkaXJlY3RseSBtb2RpZmllcyBgLnN0eWxlYCBwcm9wZXJ0eSwgZG9lcyBfbm90XyByZXRyaWV2ZSBhY3R1YWwgY29tcG9uZW50IGhlaWdodCwgbWF5IGJlIFwiYXV0b1wiKTsgaWYgYSBoZWlnaHQgaGFzIG5vdCBiZWVuIHNldCBleHBsaWNpdGx5LCBvciBpcyBzZXQgdG8gXCJhdXRvXCIsIHRoZW4gdGhlIHZhbHVlIGlzIHRha2VuIGZyb20gdGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyOyBmb3IgYExheW91dENvbnRhaW5lcmAsIGEgdmFsdWUgb2YgXCIxMDAlXCIgaXMgdXNlZCBpZiB0aGUgY29udGFpbmVyJ3MgaGVpZ2h0IGlzIGFsc28gXCJhdXRvXCIgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIC8vIHdoaWxlIG5vIGhlaWdodCBzZXQsIG9ic2VydmUgY29udGFpbmVyIGhlaWdodCBhbmQgdHlwZVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29udGFpbmVyICYmIHRoaXMuY29udGFpbmVyLmhlaWdodCB8fCBcImF1dG9cIjtcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuY29udGFpbmVyIGluc3RhbmNlb2YgTGF5b3V0Q29udGFpbmVyKSAmJlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPT09IFwiYXV0b1wiKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIjEwMCVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoaCA9PT0gXCJhdXRvXCIpXG4gICAgICAgICAgICAgICAgaCA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNldChcImhlaWdodFwiLCBoID8gaCA6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaGVpZ2h0OyB9KSk7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBTZXQgdGhlIGNvbnRhaW5lciBmb3IgdGhpcyBjb21wb25lbnQgKG92ZXJ3cml0ZXMgZXhpc3RpbmcgdmFsdWUsIGlmIGFueSk7IHJldHVybnMgdGhpcyAqL1xuICAgIENvbnRhaW5lckJsb2NrLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gYztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBhcnJheSBvZiBkaXJlY3RseSBjb250YWluZWQgY29tcG9uZW50cyAob2JzZXJ2YWJsZSkgKi9cbiAgICBDb250YWluZXJCbG9jay5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5jb250YWluZXJdO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlDb21wb25lbnRSZWYoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udGFpbmVyKSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbnRhaW5lckJsb2NrLnByb3RvdHlwZSwgXCJjb250YWluZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBDb250YWluZXJCbG9jay5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIG51bGwpO1xuICAgIENvbnRhaW5lckJsb2NrID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwZW5kQ2hpbGRDb21wb25lbnRzKENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkNvbnRhaW5lcilcbiAgICBdLCBDb250YWluZXJCbG9jayk7XG4gICAgcmV0dXJuIENvbnRhaW5lckJsb2NrO1xufShCbG9jaykpO1xuZXhwb3J0IHsgQ29udGFpbmVyQmxvY2sgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0Jsb2Nrcy9Db250YWluZXJCbG9jay5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tIFwiLi9CbG9ja1wiO1xuLyoqIFJlcHJlc2VudHMgYSBkaXZpZGVyIGJsb2NrIGVsZW1lbnQgKGhvcml6b250YWwgbGluZSBwbGFjZWQgYmV0d2VlbiBibG9ja3MpICovXG52YXIgRGl2aWRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpdmlkZXIsIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhIG5ldyBkaXZpZGVyIHdpdGggZ2l2ZW4gKG9wdGlvbmFsKSBwcm9wZXJ0aWVzICovXG4gICAgZnVuY3Rpb24gRGl2aWRlcihjb2xvciwgdGhpY2tuZXNzLCBtYXJnaW4sIGluc2V0U3RhcnQsIGluc2V0RW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIGlmIChjb2xvcilcbiAgICAgICAgICAgIF90aGlzLmNvbG9yID0gY29sb3I7XG4gICAgICAgIGlmICh0aGlja25lc3MpXG4gICAgICAgICAgICBfdGhpcy50aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgICAgIGlmIChtYXJnaW4pXG4gICAgICAgICAgICBfdGhpcy5tYXJnaW4gPSBtYXJnaW47XG4gICAgICAgIGlmIChpbnNldFN0YXJ0KVxuICAgICAgICAgICAgX3RoaXMuaW5zZXRTdGFydCA9IGluc2V0U3RhcnQ7XG4gICAgICAgIGlmIChpbnNldEVuZClcbiAgICAgICAgICAgIF90aGlzLmluc2V0RW5kID0gaW5zZXRFbmQ7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGlzIGNvbXBvbmVudCBjYW5ub3QgYmUgZm9jdXNlZCAoZS5nLiBpbiBhIExpc3QpXG4gICAgICAgIF90aGlzLmZvY3VzTW9kZSA9IENvbXBvbmVudC5Gb2N1c01vZGUuTm9uZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBEaXZpZGVyLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIERpdmlkZXIucHJvdG90eXBlLCBcInRoaWNrbmVzc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIERpdmlkZXIucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIERpdmlkZXIucHJvdG90eXBlLCBcImluc2V0U3RhcnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBEaXZpZGVyLnByb3RvdHlwZSwgXCJpbnNldEVuZFwiLCB2b2lkIDApO1xuICAgIHJldHVybiBEaXZpZGVyO1xufShCbG9jaykpO1xuZXhwb3J0IHsgRGl2aWRlciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQmxvY2tzL0RpdmlkZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCIuLi9Db21wb25lbnRcIjtcbmltcG9ydCB7IENvbXBvbmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vQ29tcG9uZW50RmFjdG9yeVwiO1xuaW1wb3J0IHsgQ29tcG9uZW50U2lnbmFsLCBDb21wb25lbnRTaWduYWxIYW5kbGVyIH0gZnJvbSBcIi4uL0NvbXBvbmVudFNpZ25hbFwiO1xuaW1wb3J0IHsgQmxvY2sgfSBmcm9tIFwiLi9CbG9ja1wiO1xuaW1wb3J0IHsgRGl2aWRlciB9IGZyb20gXCIuL0RpdmlkZXJcIjtcbi8qKiBSZXByZXNlbnRzIGEgbGlzdCBvZiBibG9ja3MgKi9cbnZhciBMaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGlzdCwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgbGlzdCBjb21wb25lbnQgd2l0aCBnaXZlbiBpdGVtcyAqL1xuICAgIGZ1bmN0aW9uIExpc3QoaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgbGlzdCBzZWxlY3Rpb24gY2hhbmdlcywgd2hpbGUgZGlzcGxheWVkIG9uIHNjcmVlbiAqL1xuICAgICAgICBfdGhpcy5TZWxlY3Rpb25DaGFuZ2UgPSBfdGhpcy5jcmVhdGVDb21wb25lbnRTaWduYWwoTGlzdF8xLlNlbGVjdGlvblNpZ25hbCk7XG4gICAgICAgIF90aGlzLl9kaXZpZGVycyA9IHt9O1xuICAgICAgICBfdGhpcy5pdGVtcyA9IGl0ZW1zLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGlzdF8xID0gTGlzdDtcbiAgICAvKiogTWV0aG9kIHRoYXQgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSByZW5kZXJlciBmb3IgdGhpcyBsaXN0IGlzIGNvbnN0cnVjdGVkOyBhZGRzIG9ic2VydmVycyBmb3IgaXRlbSBzZWxlY3Rpb24gKi9cbiAgICBMaXN0LnByb3RvdHlwZS5iZWZvcmVGaXJzdFJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUZpcnN0UmVuZGVyLmNhbGwodGhpcywgcmVuZGVyZXIpO1xuICAgICAgICAvLyBlbWl0IFNlbGVjdGlvbkNoYW5nZSBpZiBzZWxlY3Rpb24gY2hhbmdlcyAoYmFzZWQgb24gbGlzdCBvZiBjaGlsZFxuICAgICAgICAvLyBjb21wb25lbnRzIGFuZCB0aGVpciBzZWxlY3Rpb24gc3RhdHVzKVxuICAgICAgICB2YXIgbGFzdEluZGV4ID0gLTEsIGxhc3RJdGVtO1xuICAgICAgICByZW5kZXJlci53YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzLmdldExhc3RTZWxlY3RlZENoaWxkKCk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpdGVtID8gX3RoaXMuaXRlbXMuaW5kZXhPZihpdGVtKSA6IC0xO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgICAgICBpdGVtID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5kZXg6IGluZGV4LCBpdGVtOiBpdGVtIH07XG4gICAgICAgIH0sIGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChsYXN0SW5kZXggIT09IGNoYW5nZS5pbmRleCB8fCBsYXN0SXRlbSAhPT0gY2hhbmdlLml0ZW0pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5TZWxlY3Rpb25DaGFuZ2UoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBjaGFuZ2UuaW5kZXg7XG4gICAgICAgICAgICAgICAgbGFzdEl0ZW0gPSBjaGFuZ2UuaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzZWxlY3RlZCBpbmRleCBhc3luY2hyb25vdXNseVxuICAgICAgICAgICAgX3RoaXMuc2VsZWN0ZWRJbmRleCA9IGNoYW5nZS5pbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHdhdGNoIHNlbGVjdGVkSW5kZXgsIHVwZGF0ZSBzZWxlY3Rpb24gYXN5bmNocm9ub3VzbHkgaWYgbmVlZGVkXG4gICAgICAgIC8vIChlLmcuIGlmIHNlbGVjdGVkSW5kZXggaXMgc2V0IHRvIGFuIG9ic2VydmFibGUgdXNpbmcgYSBiaW5kaW5nKVxuICAgICAgICByZW5kZXJlci53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWxlY3RlZEluZGV4OyB9LCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IF90aGlzLnNlbGVjdGVkSW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBhdm9pZCByYWNlL2xvb3BcbiAgICAgICAgICAgIHZhciBpdGVtID0gKGkgPj0gMCAmJiBpIDwgX3RoaXMuaXRlbXMubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICAgX3RoaXMuaXRlbXNbaV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXRlbSlcbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBfdGhpcy5kZXNlbGVjdEFsbCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0LnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCIsIHtcbiAgICAgICAgLyoqIEN1cnJlbnQgKGxhc3QpIHNlbGVjdGVkIGl0ZW0gaW5kZXggKGJhc2UgMCksIG9yIC0xIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQgKG9ic2VydmVkKSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBsYXN0IHNlbGVjdGVkIGluZGV4IChtYW51YWxseSwgYXN5bmMgZnJvbSBiZWZvcmVGaXJzdFJlbmRlcixcbiAgICAgICAgICAgIC8vIG9yIHJldHVybiB0aGUgb2JzZXJ2YWJsZSB2YWx1ZSBnaXZlbiB0byBzZXR0ZXIgYmVsb3cpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICBpZiAoKGkgaW5zdGFuY2VvZiBBc3luYy5PYnNlcnZhYmxlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdW5kZXJseWluZyB2YWx1ZSBvciBzZXQgb2JzZXJ2YWJsZSB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vYnNlcnZhYmxlU2VsZWN0ZWRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2JzZXJ2YWJsZVNlbGVjdGVkSW5kZXgud3JpdGFibGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU2VsZWN0ZWRJbmRleC52YWx1ZSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBvYnNlcnZhYmxlIGJvdW5kLCBqdXN0IHNldCBvd24gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXNlIC0xIGZvciBhbnkgb3RoZXIgaW52YWxpZCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSB0aGlzLml0ZW1zLmxlbmd0aCB8fCAhdGhpcy5pdGVtc1t2YWx1ZV0pXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAtMTtcbiAgICAgICAgICAgIC8vIHNlbGVjdCBnaXZlbiBpdGVtIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0SXRlbSh2YWx1ZSA+PSAwID8gdGhpcy5pdGVtc1t2YWx1ZV0gOiB1bmRlZmluZWQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogRGVzZWxlY3QgYWxsIGl0ZW1zIGN1cnJlbnRseSBpbiB0aGlzIGxpc3QgKi9cbiAgICBMaXN0LnByb3RvdHlwZS5kZXNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IGlmIChjKVxuICAgICAgICAgICAgYy5zZWxlY3RlZCA9IGZhbHNlOyB9KTtcbiAgICB9O1xuICAgIC8qKiBTZWxlY3QgZ2l2ZW4gaXRlbSAoYmxvY2spLCBhbmQgaW1tZWRpYXRlbHkgZGVzZWxlY3Qgb3RoZXJzIGlmIGAuc2VsZWN0aW9uTW9kZWAgaXMgYEl0ZW1DbGlja2Agb3IgYEl0ZW1Gb2N1c2A7IGRvZXMgX25vdF8gY2hlY2sgaWYgdGhlIGl0ZW0gaXMgaW5jbHVkZWQgaW4gYC5pdGVtc2AgYXQgYWxsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zICovXG4gICAgTGlzdC5wcm90b3R5cGUuc2VsZWN0SXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIC8vIHNlbGVjdCBnaXZlbiBpdGVtXG4gICAgICAgIGlmIChpdGVtKVxuICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIC8vIGNoZWNrIGlmIG5lZWQgdG8gZGVzZWxlY3Qgb3RoZXJzIChkbyBub3Qgd2FpdCBmb3IgYXN5bmMpXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09IENvbXBvbmVudC5TZWxlY3Rpb25Nb2RlLkl0ZW1DbGljayB8fFxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSBDb21wb25lbnQuU2VsZWN0aW9uTW9kZS5JdGVtRm9jdXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSB0aGlzLml0ZW1zLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2pdICYmIHRoaXMuaXRlbXNbal0gIT09IGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbal0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEFwcGVuZCBhIGJsb2NrIHRvIHRoaXMgbGlzdCAqL1xuICAgIExpc3QucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaChibG9jayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYW4gYXJyYXkgb2YgZGlyZWN0bHkgY29udGFpbmVkIGNvbXBvbmVudHMgKG9ic2VydmFibGUpICovXG4gICAgTGlzdC5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGRpdmlkZXJzID0ge307XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKCFpdGVtKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGFkZCBhIGRpdmlkZXIgaWYgbmVlZGVkIChub3QgYmVmb3JlIGZpcnN0IGl0ZW0pXG4gICAgICAgICAgICBpZiAoX3RoaXMuZGl2aWRlciAmJiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpdmlkZXIgPSBkaXZpZGVyc1tpdGVtLnVpZF0gPVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGl2aWRlcnNbaXRlbS51aWRdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbXBvbmVudEZhY3RvcnkuaW5pdGlhbGl6ZVdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FsbChuZXcgRGl2aWRlcigpLCBfdGhpcy5kaXZpZGVyKTsgfSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZGl2aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgdGhlIGl0ZW0gaXRzZWxmXG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RpdmlkZXJzID0gZGl2aWRlcnM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgY3VycmVudCB2YWx1ZXMgb2YgaW5wdXQgZWxlbWVudHMgKG9ic2VydmFibGUpICovXG4gICAgTGlzdC5wcm90b3R5cGUuZ2V0Rm9ybVZhbHVlcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7IHJlc3VsdCA9IHt9OyB9XG4gICAgICAgIGlmICh0aGlzLm5hbWUpXG4gICAgICAgICAgICByZXN1bHRbdGhpcy5uYW1lXSA9IHRoaXMuaXRlbXNcbiAgICAgICAgICAgICAgICAubWFwQXN5bmNWYWx1ZXMoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlbS5nZXRGb3JtVmFsdWVzKCk7IH0pOyB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5nZXRGb3JtVmFsdWVzLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBTZXQgYWxsIGlucHV0IHZhbHVlcyBieSBlbGVtZW50IG5hbWUgKi9cbiAgICBMaXN0LnByb3RvdHlwZS5zZXRGb3JtVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5uYW1lKSB7XG4gICAgICAgICAgICB2YWx1ZXMgJiYgdmFsdWVzW3RoaXMubmFtZV0gJiYgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgaXRlbSAmJiBpdGVtLnNldEZvcm1WYWx1ZXModmFsdWVzW190aGlzLm5hbWVdW2ldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0Rm9ybVZhbHVlcy5jYWxsKHRoaXMsIHZhbHVlcyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBseUNvbXBvbmVudHNBcnJheShDb21wb25lbnRGYWN0b3J5LkNMZXZlbC5CbG9jayksXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfbm90X251bGxcbiAgICBdLCBMaXN0LnByb3RvdHlwZSwgXCJpdGVtc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LmFwcGx5QXN5bmMsXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBMaXN0LnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgTGlzdC5wcm90b3R5cGUsIFwiZGl2aWRlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgTGlzdC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgIExpc3QgPSBMaXN0XzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBlbmRDaGlsZENvbXBvbmVudHMoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQmxvY2spXG4gICAgXSwgTGlzdCk7XG4gICAgcmV0dXJuIExpc3Q7XG4gICAgdmFyIExpc3RfMTtcbn0oQmxvY2spKTtcbmV4cG9ydCB7IExpc3QgfTtcbihmdW5jdGlvbiAoTGlzdCkge1xuICAgIC8qKiBTaWduYWwgdGhhdCBpcyBlbWl0dGVkIHdoZW4gYSBsaXN0IHNlbGVjdGlvbiBldmVudCBvY2N1cnMgKi9cbiAgICB2YXIgU2VsZWN0aW9uU2lnbmFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFNlbGVjdGlvblNpZ25hbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU2VsZWN0aW9uU2lnbmFsKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb25TaWduYWw7XG4gICAgfShDb21wb25lbnRTaWduYWwpKTtcbiAgICBMaXN0LlNlbGVjdGlvblNpZ25hbCA9IFNlbGVjdGlvblNpZ25hbDtcbn0pKExpc3QgfHwgKExpc3QgPSB7fSkpO1xuLyoqIENvbnN0cnVjdG9yIGZvciBhIGxpc3Qgc2VsZWN0aW9uIGV2ZW50IGhhbmRsZXIgKi9cbnZhciBMaXN0U2VsZWN0aW9uSGFuZGxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpc3RTZWxlY3Rpb25IYW5kbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3RTZWxlY3Rpb25IYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaXN0U2VsZWN0aW9uSGFuZGxlcjtcbn0oQ29tcG9uZW50U2lnbmFsSGFuZGxlcikpO1xuZXhwb3J0IHsgTGlzdFNlbGVjdGlvbkhhbmRsZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0Jsb2Nrcy9MaXN0LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBDb21wb25lbnRGYWN0b3J5IH0gZnJvbSBcIi4uL0NvbXBvbmVudEZhY3RvcnlcIjtcbmltcG9ydCB7IENvbXBvbmVudFNpZ25hbCwgQ29tcG9uZW50U2lnbmFsSGFuZGxlciB9IGZyb20gXCIuLi9Db21wb25lbnRTaWduYWxcIjtcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSBcIi4vQmxvY2tcIjtcbi8qKiBSZXByZXNlbnRzIGEgaGllcmFyY2hpY2FsIGxpc3Qgb2YgYmxvY2tzICovXG52YXIgVHJlZUxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmVlTGlzdCwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgdHJlZSBsaXN0IGNvbXBvbmVudCB3aXRoIGdpdmVuIGl0ZW1zICovXG4gICAgZnVuY3Rpb24gVHJlZUxpc3QoaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiB0aGUgbGlzdCBzZWxlY3Rpb24gY2hhbmdlcywgd2hpbGUgZGlzcGxheWVkIG9uIHNjcmVlbiAqL1xuICAgICAgICBfdGhpcy5TZWxlY3Rpb25DaGFuZ2UgPSBfdGhpcy5jcmVhdGVDb21wb25lbnRTaWduYWwoVHJlZUxpc3RfMS5TZWxlY3Rpb25TaWduYWwpO1xuICAgICAgICAvKiogU2lnbmFsIGVtaXR0ZWQgd2hlbiBhIHRyZWUgbGlzdCBpdGVtIGlzIGNvbGxhcHNlZCwgd2hpbGUgZGlzcGxheWVkIG9uIHNjcmVlbiAqL1xuICAgICAgICBfdGhpcy5JdGVtQ29sbGFwc2VkID0gX3RoaXMuY3JlYXRlQ29tcG9uZW50U2lnbmFsKFRyZWVMaXN0XzEuRm9sZFNpZ25hbCk7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCB3aGVuIGEgdHJlZSBsaXN0IGl0ZW0gaXMgZXhwYW5kZWQsIHdoaWxlIGRpc3BsYXllZCBvbiBzY3JlZW4gKi9cbiAgICAgICAgX3RoaXMuSXRlbUV4cGFuZGVkID0gX3RoaXMuY3JlYXRlQ29tcG9uZW50U2lnbmFsKFRyZWVMaXN0XzEuRm9sZFNpZ25hbCk7XG4gICAgICAgIF90aGlzLml0ZW1zID0gaXRlbXMuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUcmVlTGlzdF8xID0gVHJlZUxpc3Q7XG4gICAgLyoqIE1ldGhvZCB0aGF0IGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgcmVuZGVyZXIgZm9yIHRoaXMgbGlzdCBpcyBjb25zdHJ1Y3RlZDsgYWRkcyBvYnNlcnZlcnMgZm9yIGl0ZW0gc2VsZWN0aW9uICovXG4gICAgVHJlZUxpc3QucHJvdG90eXBlLmJlZm9yZUZpcnN0UmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlRmlyc3RSZW5kZXIuY2FsbCh0aGlzLCByZW5kZXJlcik7XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBvYnNlcnZhYmxlIGZsYXR0ZW5lZCBhcnJheSB3aXRoIGFsbCBvcGVuIGl0ZW1zXG4gICAgICAgIHRoaXMuX2ZsYXR0ZW5lZCA9IHJlY3Vyc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaXRlbXM7IH0pLmZsYXR0ZW5Bc3luYyh0cnVlKTtcbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzZShmKSB7XG4gICAgICAgICAgICByZXR1cm4gQXN5bmMub2JzZXJ2ZUFycmF5KGYpLm1hcEFzeW5jVmFsdWVzKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViID0gcmVjdXJzZShmdW5jdGlvbiAoKSB7IHJldHVybiBiLnRyZWVMaXN0SXRlbXM7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCFiLmNvbGxhcHNlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIudHJlZUxpc3RJdGVtcykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtiLCBzdWJdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgZXhwYW5kZWQgYW5kIGNvbGxhcHNlZCBpdGVtc1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICB2YXIgaXRlbXMgPSB7fTtcbiAgICAgICAgdmFyIGV4cGFuZGVkID0ge307XG4gICAgICAgIHZhciB2aXNpYmxlID0ge307XG4gICAgICAgIHZhciB0cmFja0l0ZW1zID0gQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgX3RoaXMuX2ZsYXR0ZW5lZCAmJiBfdGhpcy5fZmxhdHRlbmVkLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tiLnVpZF0gPSBiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2FzVmlzaWJsZSA9IHZpc2libGVbYi51aWRdO1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlW2IudWlkXSA9IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWIuY29sbGFwc2VkICYmIGIudHJlZUxpc3RJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IG1hcmtlciB0byBjdXJyZW50IGNvdW50LCBvciAwIGlmIG5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhc0V4cGFuZGVkID0gZXhwYW5kZWRbYi51aWRdID4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkW2IudWlkXSA9ICh3YXNFeHBhbmRlZCB8fCAhd2FzVmlzaWJsZSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50IDogMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyZXIud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhY2tJdGVtcy52YWx1ZTsgfSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGlmIChjICE9PSBjb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIG92ZXJ0YWtlblxuICAgICAgICAgICAgLy8gZmluZCBuZXdseSBleHBhbmRlZCBpdGVtcyBhbmQgbmV3bHkgY29sbGFwc2VkIHZpc2libGUgaXRlbXNcbiAgICAgICAgICAgIGZvciAodmFyIHVpZCBpbiB2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2libGVbdWlkXSA8IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHZpc2libGUsIGZvcmdldCBhYm91dCB0aGlzIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1zW3VpZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2aXNpYmxlW3VpZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBleHBhbmRlZFt1aWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChleHBhbmRlZFt1aWRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5ld2x5IGV4cGFuZGVkICh3aGlsZSBhbHJlYWR5IHZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkW3VpZF0gPSBjO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5JdGVtRXhwYW5kZWQoeyBpdGVtOiBpdGVtc1t1aWRdIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChleHBhbmRlZFt1aWRdIDwgYykge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgZXhwYW5kZWQgYnV0IHN0aWxsIHZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuSXRlbUNvbGxhcHNlZCh7IGl0ZW06IGl0ZW1zW3VpZF0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBleHBhbmRlZFt1aWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVtaXQgU2VsZWN0aW9uQ2hhbmdlIGlmIHNlbGVjdGlvbiBjaGFuZ2VzIChiYXNlZCBvbiBsaXN0IG9mIGNoaWxkXG4gICAgICAgIC8vIGNvbXBvbmVudHMgYW5kIHRoZWlyIHNlbGVjdGlvbiBzdGF0dXMpXG4gICAgICAgIHZhciBsYXN0SXRlbTtcbiAgICAgICAgcmVuZGVyZXIud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0TGFzdFNlbGVjdGVkQ2hpbGQoKTsgfSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghaXRlbSB8fCBpdGVtLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IGxhc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuU2VsZWN0aW9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGl0ZW0gJiYgaXRlbS5rZXlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBTZWxlY3QgZ2l2ZW4gaXRlbSAoYmxvY2spLCBhbmQgaW1tZWRpYXRlbHkgZGVzZWxlY3Qgb3RoZXJzIGlmIGAuc2VsZWN0aW9uTW9kZWAgaXMgYEl0ZW1DbGlja2Agb3IgYEl0ZW1Gb2N1c2A7IGRvZXMgX25vdF8gY2hlY2sgaWYgdGhlIGl0ZW0gaXMgaW5jbHVkZWQgaW4gYC5pdGVtc2AgYXQgYWxsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zICovXG4gICAgVHJlZUxpc3QucHJvdG90eXBlLnNlbGVjdEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAvLyBzZWxlY3QgZ2l2ZW4gaXRlbVxuICAgICAgICBpZiAoaXRlbSlcbiAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBjaGVjayBpZiBuZWVkIHRvIGRlc2VsZWN0IG90aGVycyAoZG8gbm90IHdhaXQgZm9yIGFzeW5jKVxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSBDb21wb25lbnQuU2VsZWN0aW9uTW9kZS5JdGVtQ2xpY2sgfHxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUuSXRlbUZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLl9mbGF0dGVuZWQgJiYgdGhpcy5fZmxhdHRlbmVkLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgIGlmIChiICYmIGIgIT09IGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIGIuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJlZUxpc3QucHJvdG90eXBlLCBcInNlbGVjdGVkS2V5XCIsIHtcbiAgICAgICAgLyoqIEtleSAoc3RyaW5nIHZhbHVlKSBvZiBzZWxlY3RlZCBpdGVtLCBpZiBhbnkgKG9ic2VydmFibGUpOyBzZWUgYFRyZWVMaXN0LkJsb2NrSXRlbS9rZXlgOyBpZiBzZXQgdG8gYSBzdHJpbmcgdmFsdWUsIGFsbCBpdGVtcyBpbiB0aGUgaGllcmFyY2h5IHdpbGwgYmUgY2hlY2tlZCBmb3IgYSBtYXRjaGluZyBrZXksIGFuZCBzZWxlY3RlZCBvciBkZXNlbGVjdGVkOyBmb3Igc2VsZWN0ZWQgaXRlbXMsIHBhcmVudCBpdGVtcyB3aWxsIGJlIGV4cGFuZGVkIGF1dG9tYXRpY2FsbHk7IGlucHV0IGZvY3VzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGRlc2VsZWN0ZWQgaXRlbXMgYXMgd2VsbCwgYnV0IHNlbGVjdGVkIGl0ZW1zIGFyZSBub3QgZm9jdXNlZCBhdXRvbWF0aWNhbGx5ICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZmluZCBzZWxlY3RlZCBpdGVtIGFuZCByZXR1cm4gaXRzIGtleSwgaWYgYW55XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0TGFzdFNlbGVjdGVkQ2hpbGQoKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5rZXkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIHVzZSBhbiBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0IGluc3RlYWQgb2YgdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gc28gdGhhdCBub25lIHdpbGwgbWF0Y2hcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBrZXkgPSB7fTtcbiAgICAgICAgICAgIC8vIGNsZWFyIHByZXZpb3VzIG9ic2VydmFibGUsIGRvIG5vdCBrZWVwIGxvb2tpbmcgZm9yIG9sZCBrZXlcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkS2V5U2V0dGVyICYmIHRoaXMuX3NlbGVjdGVkS2V5U2V0dGVyLmNsZWFyKCk7XG4gICAgICAgICAgICAvLyByZWN1cnNlIG92ZXIgKmFsbCogaXRlbXMgYW5kIHNlbGVjdCBvciBkZXNlbGVjdFxuICAgICAgICAgICAgdmFyIGhhc1VuZGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVjdXJzZShsaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZFNlbGVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzVW5kZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBkZXNlbGVjdCBvciBzZWxlY3QgYW5kIGZvY3VzL2JsdXIgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvU2VsZWN0ID0gKGJsb2NrLmtleSA9PT0ga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvU2VsZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvU2VsZWN0ICE9PSAoYmxvY2suc2VsZWN0ZWQgfHwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay5zZWxlY3RlZCA9IGRvU2VsZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9TZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2suZm9jdXNNb2RlICE9PSBDb21wb25lbnQuRm9jdXNNb2RlLk5vbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLmhhc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sudHJlZUxpc3RJdGVtcyAmJiBibG9jay50cmVlTGlzdEl0ZW1zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZShibG9jay50cmVlTGlzdEl0ZW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cGFuZCBwYXJlbnQgaXRlbXMgb2YgbWF0Y2hpbmcgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkgeyBibG9jay5jb2xsYXBzZWQgPSBmYWxzZTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlkU2VsZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VlcCB3YXRjaCBvbiB1bmRlZmluZWQgaXRlbXNcbiAgICAgICAgICAgIHZhciB3YXRjaGVyID0gdGhpcy5fc2VsZWN0ZWRLZXlTZXR0ZXIgPSBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlY3Vyc2UoX3RoaXMuaXRlbXMpOyB9KVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGRpZFNlbGVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChkaWRTZWxlY3QgfHwgIWhhc1VuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBvYnNlcnZhYmxlLCBkbyBub3Qga2VlcCBsb29raW5nXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRpZFNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGxvb2tpbmcgdW50aWwgYW5vdGhlciBpdGVtIGhhcyBiZWVuIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGhhc1VuZGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5TZWxlY3Rpb25DaGFuZ2UuY29ubmVjdE9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlci5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEFwcGVuZCBhIHRyZWUgbGlzdCBibG9jayB0byB0aGlzIGxpc3QgKi9cbiAgICBUcmVlTGlzdC5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBhcnJheSBvZiBkaXJlY3RseSBjb250YWluZWQgY29tcG9uZW50cyAob2JzZXJ2YWJsZSk7IGkuZS4gYSBmbGF0dGVuZWQgbGlzdCBvZiBhbGwgX3Zpc2libGVfIHRyZWUgbGlzdCBpdGVtcyAqL1xuICAgIFRyZWVMaXN0LnByb3RvdHlwZS5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYXR0ZW5lZCA/IHRoaXMuX2ZsYXR0ZW5lZC5zbGljZSgpIDogW107XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBseUNvbXBvbmVudHNBcnJheShDb21wb25lbnRGYWN0b3J5LkNMZXZlbC5CbG9jayksXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfbm90X251bGxcbiAgICBdLCBUcmVlTGlzdC5wcm90b3R5cGUsIFwiaXRlbXNcIiwgdm9pZCAwKTtcbiAgICBUcmVlTGlzdCA9IFRyZWVMaXN0XzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBlbmRDaGlsZENvbXBvbmVudHMoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQmxvY2spXG4gICAgXSwgVHJlZUxpc3QpO1xuICAgIHJldHVybiBUcmVlTGlzdDtcbiAgICB2YXIgVHJlZUxpc3RfMTtcbn0oQmxvY2spKTtcbmV4cG9ydCB7IFRyZWVMaXN0IH07XG4oZnVuY3Rpb24gKFRyZWVMaXN0KSB7XG4gICAgLyoqIFNpZ25hbCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBhIHRyZWUgbGlzdCBzZWxlY3Rpb24gZXZlbnQgb2NjdXJzICovXG4gICAgdmFyIFNlbGVjdGlvblNpZ25hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhTZWxlY3Rpb25TaWduYWwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNlbGVjdGlvblNpZ25hbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2VsZWN0aW9uU2lnbmFsO1xuICAgIH0oQ29tcG9uZW50U2lnbmFsKSk7XG4gICAgVHJlZUxpc3QuU2VsZWN0aW9uU2lnbmFsID0gU2VsZWN0aW9uU2lnbmFsO1xuICAgIC8qKiBTaWduYWwgdGhhdCBpcyBlbWl0dGVkIHdoZW4gYSB0cmVlIGxpc3QgaXRlbSBpcyBjb2xsYXBzZWQgb3IgZXhwYW5kZWQgKi9cbiAgICB2YXIgRm9sZFNpZ25hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhGb2xkU2lnbmFsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb2xkU2lnbmFsKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGb2xkU2lnbmFsO1xuICAgIH0oQ29tcG9uZW50U2lnbmFsKSk7XG4gICAgVHJlZUxpc3QuRm9sZFNpZ25hbCA9IEZvbGRTaWduYWw7XG59KShUcmVlTGlzdCB8fCAoVHJlZUxpc3QgPSB7fSkpO1xuLyoqIENvbnN0cnVjdG9yIGZvciBhIHRyZWUgbGlzdCBzZWxlY3Rpb24gZXZlbnQgaGFuZGxlciAqL1xudmFyIFRyZWVMaXN0U2VsZWN0aW9uSGFuZGxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyZWVMaXN0U2VsZWN0aW9uSGFuZGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmVlTGlzdFNlbGVjdGlvbkhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRyZWVMaXN0U2VsZWN0aW9uSGFuZGxlcjtcbn0oQ29tcG9uZW50U2lnbmFsSGFuZGxlcikpO1xuZXhwb3J0IHsgVHJlZUxpc3RTZWxlY3Rpb25IYW5kbGVyIH07XG4vKiogQ29uc3RydWN0b3IgZm9yIGEgdHJlZSBsaXN0IGZvbGQgKGNvbGxhcHNlL2V4cGFuZCkgZXZlbnQgaGFuZGxlciAqL1xudmFyIFRyZWVMaXN0Rm9sZEhhbmRsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmVlTGlzdEZvbGRIYW5kbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyZWVMaXN0Rm9sZEhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRyZWVMaXN0Rm9sZEhhbmRsZXI7XG59KENvbXBvbmVudFNpZ25hbEhhbmRsZXIpKTtcbmV4cG9ydCB7IFRyZWVMaXN0Rm9sZEhhbmRsZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0Jsb2Nrcy9UcmVlTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi9Db21wb25lbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gXCIuL0Jsb2NrXCI7XG4vKiogUmVwcmVzZW50cyBhIHJvdyBjb250YWluaW5nIGNvbnRyb2wgZWxlbWVudHMgcGxhY2VkIGhvcml6b250YWxseSAqL1xudmFyIFJvdyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJvdywgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgcm93IGJsb2NrIHdpdGggZ2l2ZW4gY29udGVudCwgaWYgYW55ICovXG4gICAgZnVuY3Rpb24gUm93KGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCkgeyBjb250ZW50ID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEFwcGVuZCBhIGNvbnRyb2wgZWxlbWVudCB0byB0aGlzIHJvdyAqL1xuICAgIFJvdy5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoY29udHJvbEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50LnB1c2goY29udHJvbEVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRpcmVjdGx5IGNvbnRhaW5lZCBjb21wb25lbnRzIChvYnNlcnZhYmxlKSAqL1xuICAgIFJvdy5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoYyBpbnN0YW5jZW9mIENvbXBvbmVudCk7IH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlDb21wb25lbnRzQXJyYXkoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udHJvbEVsZW1lbnQpLFxuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX25vdF9udWxsXG4gICAgXSwgUm93LnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc3RyaW5nXG4gICAgXSwgUm93LnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc3RyaW5nXG4gICAgXSwgUm93LnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFNwYWNpbmdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIFJvdy5wcm90b3R5cGUsIFwiaG9yekFsaWduXCIsIHZvaWQgMCk7XG4gICAgUm93ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwZW5kQ2hpbGRDb21wb25lbnRzKENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkNvbnRyb2xFbGVtZW50KVxuICAgIF0sIFJvdyk7XG4gICAgcmV0dXJuIFJvdztcbn0oQmxvY2spKTtcbmV4cG9ydCB7IFJvdyB9O1xuLyoqIFJlcHJlc2VudHMgYSByb3cgY29udGFpbmluZyBjb250cm9sIGVsZW1lbnRzIHBsYWNlZCBob3Jpem9udGFsbHksIHdpdGggc3BhY2luZyBzZXQgdG8gYDBgIChubyBtYXJnaW4pICovXG52YXIgQ2xvc2VSb3cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbG9zZVJvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDbG9zZVJvdygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNwYWNpbmcgPSBcIjBcIjtcbiAgICAgICAgX3RoaXMudmVydGljYWxTcGFjaW5nID0gXCIwXCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENsb3NlUm93O1xufShSb3cpKTtcbmV4cG9ydCB7IENsb3NlUm93IH07XG4vKiogQSByb3cgZWxlbWVudCB3aXRoIGNvbXBvbmVudHMgYWxpZ25lZCB0byB0aGUgb3Bwb3NpdGUgc2lkZSAoXCJlbmRcIiBhbGlnbm1lbnQsIGkuZS4gcmlnaHQtYWxpZ25lZCBmb3IgbGVmdC10by1yaWdodCBsYW5ndWFnZXMpICovXG52YXIgT3Bwb3NpdGVSb3cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPcHBvc2l0ZVJvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPcHBvc2l0ZVJvdygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBIb3Jpem9udGFsIHBvc2l0aW9uaW5nIG9mIGNvbnRlbnQgd2l0aGluIHRoZSBvdXRlciBib3VuZGFyaWVzIG9mIHRoZSByb3cgKG9ic2VydmVkKSwgc2V0IHRvIFwiZW5kXCIgZm9yIGBPcHBvc2l0ZVJvd2AgaW5zdGFuY2VzICovXG4gICAgICAgIF90aGlzLmhvcnpBbGlnbiA9IFwiZW5kXCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE9wcG9zaXRlUm93O1xufShSb3cpKTtcbmV4cG9ydCB7IE9wcG9zaXRlUm93IH07XG4vKiogQSByb3cgZWxlbWVudCB3aXRoIGNvbXBvbmVudHMgYWxpZ25lZCBpbiB0aGUgY2VudGVyICovXG52YXIgQ2VudGVyUm93ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2VudGVyUm93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENlbnRlclJvdygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBIb3Jpem9udGFsIHBvc2l0aW9uaW5nIG9mIGNvbnRlbnQgd2l0aGluIHRoZSBvdXRlciBib3VuZGFyaWVzIG9mIHRoZSByb3cgKG9ic2VydmVkKSwgc2V0IHRvIFwiY2VudGVyXCIgZm9yIGBDZW50ZXJSb3dgIGluc3RhbmNlcyAqL1xuICAgICAgICBfdGhpcy5ob3J6QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDZW50ZXJSb3c7XG59KFJvdykpO1xuZXhwb3J0IHsgQ2VudGVyUm93IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9CbG9ja3MvUm93LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBBcnJheUJpbmRpbmcsIF9nZXRCYXRjaFRyYW5zZm9ybWVyIH0gZnJvbSBcIi4uLy4uL0JpbmRpbmdcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgU3BhY2VyLCBJY29uLCBXaWRlTGFiZWwgfSBmcm9tIFwiLi4vXCI7XG5pbXBvcnQgeyBDbG9zZVJvdyB9IGZyb20gXCIuL1Jvd1wiO1xuLyoqIFJlcHJlc2VudHMgYSB0cmVlIGxpc3Qgcm93LCB3aXRoIGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3ViIHJvd3M7IGltcGxlbWVudHMgdGhlIGBUcmVlTGlzdC5CbG9ja0l0ZW1gIGludGVyZmFjZSAqL1xudmFyIFRyZWVMaXN0Um93ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJlZUxpc3RSb3csIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgdHJlZSBsaXN0IHJvdyBmb3IgZ2l2ZW4gaXRlbSBkYXRhLCB3aXRoIGdpdmVuIG9wZW4vY2xvc2VkIGljb24gbmFtZXMgYW5kIG1lYXN1cmVtZW50czsgc2V0IHRoZSBgYmF0Y2hTaXplYCBhcmd1bWVudCB0byBhIHZhbHVlIGdyZWF0ZXIgdGhhbiAwIHRvIGNyZWF0ZSBjaGlsZCByb3dzIGluIGJhdGNoZXMgZm9yIGZhc3RlciBpbml0aWFsIHJlbmRlcmluZyAqL1xuICAgIGZ1bmN0aW9uIFRyZWVMaXN0Um93KGl0ZW1EYXRhLCBvcGVuSWNvbiwgY2xvc2VkSWNvbiwgcmVtR3V0dGVyLCBoZWlnaHQsIGJhdGNoU2l6ZSkge1xuICAgICAgICBpZiAocmVtR3V0dGVyID09PSB2b2lkIDApIHsgcmVtR3V0dGVyID0gVHJlZUxpc3RSb3cuUkVNX0dVVFRFUjsgfVxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB2b2lkIDApIHsgaGVpZ2h0ID0gVHJlZUxpc3RSb3cuSEVJR0hUOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBUcnVlIGlmIHRoaXMgcm93IGlzIGNvbGxhcHNlZCAoZGVmYXVsdHMgdG8gdHJ1ZTsgb2JzZXJ2YWJsZSkgKi9cbiAgICAgICAgX3RoaXMuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpdGVtRGF0YSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICBfdGhpcy5pdGVtRGF0YSA9IGl0ZW1EYXRhO1xuICAgICAgICBfdGhpcy5vcGVuSWNvbiA9IG9wZW5JY29uO1xuICAgICAgICBfdGhpcy5jbG9zZWRJY29uID0gY2xvc2VkSWNvbjtcbiAgICAgICAgX3RoaXMucmVtR3V0dGVyID0gcmVtR3V0dGVyO1xuICAgICAgICBfdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmIChpdGVtRGF0YS5hdXRvRXhwYW5kKVxuICAgICAgICAgICAgX3RoaXMuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIHBvcHVsYXRlIGxpc3QgYW5kIGNvbnRlbnQgd2l0aCBvYnNlcnZhYmxlc1xuICAgICAgICBfdGhpcy50cmVlTGlzdEl0ZW1zID0gX3RoaXMuX2dldFRyZWVMaXN0SXRlbXMoYmF0Y2hTaXplKTtcbiAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZVdpdGgoe1xuICAgICAgICAgICAgY29udGVudDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZ2V0Q29udGVudFNwZWMoKTsgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGFkZCBldmVudCBoYW5kbGVyc1xuICAgICAgICBfdGhpcy5DbGlja2VkLmNvbm5lY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gb3BlbiBvbiBjbGljayAob3V0c2lkZSB0b2dnbGUgaWNvbilcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb2xsYXBzZWQgJiYgX3RoaXMuaXRlbURhdGEgJiYgX3RoaXMuaXRlbURhdGEuaXRlbXMpXG4gICAgICAgICAgICAgICAgX3RoaXMuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5BcnJvd0xlZnRLZXlQcmVzc2VkLmNvbm5lY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gb24gbGVmdCBhcnJvdyBwcmVzcywgY2xvc2UgYW5kIHRoZW4gbW92ZSB1cFxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbGxhcHNlZCAmJiBfdGhpcy50cmVlTGlzdFJvd1BhcmVudCAmJlxuICAgICAgICAgICAgICAgIF90aGlzLnRyZWVMaXN0Um93UGFyZW50LmZvY3VzTW9kZSAhPT0gQ29tcG9uZW50LkZvY3VzTW9kZS5Ob25lKVxuICAgICAgICAgICAgICAgIF90aGlzLnRyZWVMaXN0Um93UGFyZW50Lmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuQXJyb3dSaWdodEtleVByZXNzZWQuY29ubmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBvbiByaWdodCBhcnJvdyBwcmVzcywgb3BlbiBhbmQgdGhlbiBtb3ZlIGRvd25cbiAgICAgICAgICAgIGlmIChfdGhpcy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXRlbURhdGEgJiYgX3RoaXMuaXRlbURhdGEuaXRlbXMpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMudHJlZUxpc3RJdGVtcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgX3RoaXMudHJlZUxpc3RJdGVtc1swXS5mb2N1c01vZGUgIT09IENvbXBvbmVudC5Gb2N1c01vZGUuTm9uZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRyZWVMaXN0SXRlbXNbMF0uaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGFuIF9hcnJheV8gb2YgdHJlZSBsaXN0IHJvdyBjb21wb25lbnRzIGZyb20gdGhlIGdpdmVuIGFycmF5IG9mIHRyZWUgaXRlbSBkYXRhIG9iamVjdHMsIHdpdGggZ2l2ZW4gaWNvbnMgYW5kIG1lYXN1cmVtZW50cyAqL1xuICAgIFRyZWVMaXN0Um93LmFycmF5RnJvbUl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1EYXRhLCBvcGVuSWNvbiwgY2xvc2VkSWNvbiwgcmVtR3V0dGVyLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1EYXRhLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlTGlzdFJvdyhpdGVtLCBvcGVuSWNvbiwgY2xvc2VkSWNvbiwgcmVtR3V0dGVyLCBoZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgYEFycmF5QmluZGluZ2AgZm9yIGdpdmVuIHByb3BlcnR5IG5hbWUvcGF0aCBvbiB0aGUgYmFzZSBjb21wb25lbnQsIHdoaWNoIHNob3VsZCBjb250YWluIGFuIGFycmF5IG9mIHVuaXF1ZSB0cmVlIGl0ZW0gZGF0YSBvYmplY3RzOyB0aGUgYmluZGluZyByZXNvbHZlcyB0byBhbiBvYnNlcnZhYmxlIGFycmF5IG9mIGBUcmVlTGlzdFJvd2AgaW5zdGFuY2VzOyBmb3IgdXNlIGluIGEgY29tcG9uZW50IGluaXRpYWxpemVyOyBzZXQgdGhlIGBiYXRjaFNpemVgIGFyZ3VtZW50IHRvIGEgdmFsdWUgZ3JlYXRlciB0aGFuIDAgdG8gY3JlYXRlIHJvd3MgaW4gYmF0Y2hlcyBmb3IgZmFzdGVyIGluaXRpYWwgcmVuZGVyaW5nICovXG4gICAgVHJlZUxpc3RSb3cuYXJyYXlGcm9tQmluZGluZyA9IGZ1bmN0aW9uIChzb3VyY2VQYXRoLCBvcGVuSWNvbiwgY2xvc2VkSWNvbiwgcmVtR3V0dGVyLCBoZWlnaHQsIGJhdGNoU2l6ZSkge1xuICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgVHJlZUxpc3RSb3codiwgb3Blbkljb24sIGNsb3NlZEljb24sIHJlbUd1dHRlciwgaGVpZ2h0LCBiYXRjaFNpemUpOyB9O1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5QmluZGluZyhzb3VyY2VQYXRoLCB1bmRlZmluZWQsIF9nZXRCYXRjaFRyYW5zZm9ybWVyKGYsIGJhdGNoU2l6ZSksIHRydWUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWVMaXN0Um93LnByb3RvdHlwZSwgXCJrZXlcIiwge1xuICAgICAgICAvKiogSXRlbSBrZXkgZm9yIHRoaXMgcm93IChyZWFkLW9ubHksIHRha2VuIGRpcmVjdGx5IGZyb20gdGhlIGBpdGVtRGF0YWAgb2JqZWN0OyBvYnNlcnZhYmxlKSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1EYXRhID8gdGhpcy5pdGVtRGF0YS5rZXkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBHZW5lcmF0ZSB0aGUgY29udGVudCBmYWN0b3J5IGluaXRpYWxpemVyIHNwZWMgZm9yIHRoaXMgcm93ICh1c2VkIGFzIGFuIG9ic2VydmFibGUgZ2V0dGVyKSAqL1xuICAgIFRyZWVMaXN0Um93LnByb3RvdHlwZS5fZ2V0Q29udGVudFNwZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pdGVtRGF0YSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgaW5kZW50YXRpb24gb2YgdGhpcyByb3dcbiAgICAgICAgaWYgKCF0aGlzLl9pbmRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGVudCA9IDE7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy50cmVlTGlzdFJvd1BhcmVudDtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Ll9pbmRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZW50ICs9IHBhcmVudC5faW5kZW50O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZW50Kys7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnRyZWVMaXN0Um93UGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBhbGwgb2JzZXJ2YWJsZSB2YWx1ZXMgZmlyc3RcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtRGF0YS5pdGVtcztcbiAgICAgICAgdmFyIHJlbUd1dHRlciA9IHRoaXMucmVtR3V0dGVyO1xuICAgICAgICB2YXIgaWNvbiA9IHRoaXMuaXRlbURhdGEuaWNvbiwgbmFtZSA9IHRoaXMuaXRlbURhdGEubmFtZTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLml0ZW1EYXRhLmNvbnRlbnQ7XG4gICAgICAgIC8vIHJldHVybiBhIGZ1bGwgZmFjdG9yeSBpbml0aWFsaXplciBzcGVjXG4gICAgICAgIHJldHVybiBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGluc2VydCBhIHNwYWNlciBvZiB0aGUgY29ycmVjdCB3aWR0aCwgYW5kIHRoZSBpY29uc1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLl9jb250ZW50U3BlYyB8fCAoX3RoaXMuX2NvbnRlbnRTcGVjID0gW10pO1xuICAgICAgICAgICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gX3RoaXMuX2luZGVudCB8fCAxO1xuICAgICAgICAgICAgaW5kZW50ID0gaW5kZW50IC0gKGluZGVudCAqIC41KSArIChpdGVtcyA/IDAgOiAxKTtcbiAgICAgICAgICAgIHZhciBzcGFjZXIgPSBfdGhpcy5fY29udGVudFNwZWNTcGFjZXIgfHwgbmV3IFNwYWNlcigpO1xuICAgICAgICAgICAgc3BhY2VyLndpZHRoID0gKGluZGVudCAqIHJlbUd1dHRlcikudG9GaXhlZCg0KSArIFwicmVtXCI7XG4gICAgICAgICAgICBzcGFjZXIuc2hyaW5rd3JhcCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZXIpO1xuICAgICAgICAgICAgX3RoaXMuX2NvbnRlbnRTcGVjU3BhY2VyID0gc3BhY2VyO1xuICAgICAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvZ2dsZSA9IF90aGlzLl9jb250ZW50U3BlY1RvZ2dsZUljb24gfHwgbmV3IEljb24oKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUuaWNvbiA9IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF90aGlzLmNvbGxhcHNlZCA/IF90aGlzLmNsb3NlZEljb24gOiBfdGhpcy5vcGVuSWNvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLndpZHRoID0gcmVtR3V0dGVyICsgXCJyZW1cIjtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0b2dnbGUpO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2NvbnRlbnRTcGVjVG9nZ2xlSWNvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY29udGVudFNwZWNUb2dnbGVJY29uID0gdG9nZ2xlO1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGUuQ2xpY2tlZC5jb25uZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbGxhcHNlZCA9ICFfdGhpcy5jb2xsYXBzZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpY29uKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goSWNvbi53aXRoKHsgaWNvbjogaWNvbiwgd2lkdGg6IHJlbUd1dHRlciArIFwicmVtXCIgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGZ1cnRoZXIgY29udGVudCwgb3IganVzdCBhIGxhYmVsIHdpdGggdGhlIGl0ZW0gbmFtZVxuICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBqb2luIHdpdGggY29udGVudCBpbml0aWFsaXplciBzcGVjIGFycmF5XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBhIFdpZGVMYWJlbCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IF90aGlzLl9jb250ZW50U3BlY0xhYmVsIHx8IG5ldyBXaWRlTGFiZWwoKTtcbiAgICAgICAgICAgICAgICBsYWJlbC50ZXh0ID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYWJlbCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NvbnRlbnRTcGVjTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEdlbmVyYXRlIHRoZSBvYnNlcnZhYmxlIGFycmF5IHRoYXQgY29udGFpbnMgYFRyZWVMaXN0Um93YCBpbnN0YW5jZXMgZm9yIGNoaWxkIGl0ZW1zICovXG4gICAgVHJlZUxpc3RSb3cucHJvdG90eXBlLl9nZXRUcmVlTGlzdEl0ZW1zID0gZnVuY3Rpb24gKGJhdGNoU2l6ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZiA9IF9nZXRCYXRjaFRyYW5zZm9ybWVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gbmV3IFRyZWVMaXN0Um93KGl0ZW0sIF90aGlzLm9wZW5JY29uLCBfdGhpcy5jbG9zZWRJY29uLCBfdGhpcy5yZW1HdXR0ZXIsIF90aGlzLmhlaWdodCwgYmF0Y2hTaXplKTtcbiAgICAgICAgICAgIHJvdy50cmVlTGlzdFJvd1BhcmVudCA9IF90aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfSwgYmF0Y2hTaXplKTtcbiAgICAgICAgcmV0dXJuIEFzeW5jLm9ic2VydmVBcnJheShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pdGVtRGF0YSAmJiBfdGhpcy5pdGVtRGF0YS5pdGVtczsgfSlcbiAgICAgICAgICAgIC5tYXBBc3luY1ZhbHVlcyhmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGl0ZW0gZGF0YSB0byBhIHJvdyAob3Igb2JzZXJ2ZSB0aGUgcmVzdWx0aW5nIHByb21pc2UpXG4gICAgICAgICAgICB2YXIgcm93ID0gZih2KTtcbiAgICAgICAgICAgIHJldHVybiByb3cudGhlbiA/IEFzeW5jLm9ic2VydmUocm93KSA6IHJvdztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogRGVmYXVsdCBoZWlnaHQgZm9yIG5ldyBpbnN0YW5jZXMgKENTUyBsZW5ndGgsIGluaXRpYWxseSAxLjc1ZW0pICovXG4gICAgVHJlZUxpc3RSb3cuSEVJR0hUID0gXCIxLjc1ZW1cIjtcbiAgICAvKiogRGVmYXVsdCBndXR0ZXIgd2lkdGggZm9yIG5ldyBpbnN0YW5jZXMgKENTUyBsZW5ndGggaW4gcmVtIHVuaXRzLCBpbml0aWFsbHkgMS41KSAqL1xuICAgIFRyZWVMaXN0Um93LlJFTV9HVVRURVIgPSAxLjU7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc2hhbGxvd1xuICAgIF0sIFRyZWVMaXN0Um93LnByb3RvdHlwZSwgXCJpdGVtRGF0YVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgVHJlZUxpc3RSb3cucHJvdG90eXBlLCBcInJlbUd1dHRlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIFRyZWVMaXN0Um93LnByb3RvdHlwZSwgXCJvcGVuSWNvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIFRyZWVMaXN0Um93LnByb3RvdHlwZSwgXCJjbG9zZWRJY29uXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBUcmVlTGlzdFJvdy5wcm90b3R5cGUsIFwiY29sbGFwc2VkXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFRyZWVMaXN0Um93O1xufShDbG9zZVJvdykpO1xuZXhwb3J0IHsgVHJlZUxpc3RSb3cgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0Jsb2Nrcy9UcmVlTGlzdFJvdy5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi9Db21wb25lbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBDb21wb25lbnRTaWduYWxIYW5kbGVyLCBDb21wb25lbnRTaWduYWwgfSBmcm9tIFwiLi4vQ29tcG9uZW50U2lnbmFsXCI7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gXCIuL0Jsb2NrXCI7XG5pbXBvcnQgeyBDb250YWluZXJCbG9jayB9IGZyb20gXCIuL0NvbnRhaW5lckJsb2NrXCI7XG4vKiogUmVwcmVzZW50cyBhIGxpc3Qgb2YgdGFicyBvciBsaW5rcyAqL1xudmFyIE5hdkxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOYXZMaXN0LCBfc3VwZXIpO1xuICAgIC8qKiBDcmVhdGUgYSBuYXZpZ2F0aW9uIGxpc3QgY29tcG9uZW50ICovXG4gICAgZnVuY3Rpb24gTmF2TGlzdChuYXZJdGVtcywgdHlwZSwgc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBpZiAobmF2SXRlbXMgPT09IHZvaWQgMCkgeyBuYXZJdGVtcyA9IFtdOyB9XG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ID09PSB2b2lkIDApIHsgc2VsZWN0ZWRJbmRleCA9IC0xOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBUeXBlIG9mIG5hdjogdGFicyBvciBwaWxscywgaW5saW5lIG9yIHN0YWNrZWQ7IGRlZmF1bHQgdGFicyAob2JzZXJ2ZWQpICovXG4gICAgICAgIF90aGlzLnR5cGUgPSBOYXZMaXN0LlR5cGUuVGFicztcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdGVkIG5hdiBpdGVtIGNoYW5nZXMsIHdoaWxlIGRpc3BsYXllZCBvbiBzY3JlZW4gKi9cbiAgICAgICAgX3RoaXMuTmF2Q2hhbmdlID0gX3RoaXMuY3JlYXRlQ29tcG9uZW50U2lnbmFsKE5hdkxpc3QuU2VsZWN0aW9uU2lnbmFsKTtcbiAgICAgICAgLyoqIENvbnRhaW5lciBibG9jayB0aGF0IGNvbnRhaW5zIHRoZSBjb250YWluZXIgZm9yIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLCBpZiBhbnkgKi9cbiAgICAgICAgX3RoaXMuX2NvbnRhaW5lckJsb2NrID0gbmV3IENvbnRhaW5lckJsb2NrKCk7XG4gICAgICAgIC8qKiBBY3RpdmF0aW9uIGluc3RhbmNlLCB3aXRoIGluamVjdGVkIG1ldGhvZHMgKi9cbiAgICAgICAgX3RoaXMuX2FjdGl2YXRpb24gPSBuZXcgTmF2TGlzdC5BY3RpdmF0aW9uKCk7XG4gICAgICAgIF90aGlzLm5hdkl0ZW1zID0gbmF2SXRlbXM7XG4gICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBfdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgX3RoaXMuc2VsZWN0ZWRJbmRleCA9IHNlbGVjdGVkSW5kZXg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIE1ldGhvZCB0aGF0IGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgcmVuZGVyZXIgZm9yIHRoaXMgY29tcG9uZW50IGlzIGNvbnN0cnVjdGVkOyBhZGRzIG9ic2VydmVycyBmb3IgbmF2IGl0ZW0gc2VsZWN0aW9uICovXG4gICAgTmF2TGlzdC5wcm90b3R5cGUuYmVmb3JlRmlyc3RSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVGaXJzdFJlbmRlci5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcbiAgICAgICAgLy8gd2F0Y2ggZm9yIGNoYW5nZXMgdG8gc2VsZWN0ZWQgaXRlbVxuICAgICAgICByZW5kZXJlci53YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSAoaW5kZXggPj0gMCAmJiBpbmRleCA8IF90aGlzLm5hdkl0ZW1zLmxlbmd0aCkgP1xuICAgICAgICAgICAgICAgIF90aGlzLm5hdkl0ZW1zW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIGZpbmQgKG9yIHBvc3NpYmx5IGNyZWF0ZSkgY29udGFpbmVyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gaXRlbSAmJiBpdGVtLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIgJiZcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaXNDb21wb25lbnRGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCBjdXJyZW50IGNvbnRhaW5lciBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIGNyZWF0ZVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9XG4gICAgICAgICAgICAgICAgICAgIChjb250YWluZXIuY29tcG9uZW50RmFjdG9yeUlkID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2ZhY3RvcnlVSUQpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jb250YWluZXJCbG9jay5jb250YWluZXIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgY29udGFpbmVyKCk7IH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLl9mYWN0b3J5VUlEID1cbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNvbXBvbmVudEZhY3RvcnlJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHN0b3JlZCBmYWN0b3J5IFVJRCBpZiBub3QgY3JlYXRlZCBmcm9tIGZhY3RvcnlcbiAgICAgICAgICAgICAgICBfdGhpcy5fZmFjdG9yeVVJRCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGl0ZW0gPyBpbmRleCA6IC0xLFxuICAgICAgICAgICAgICAgIGtleTogaXRlbSAmJiBpdGVtLmtleSxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgLy8gc2V0IGN1cnJlbnQgY29udGFpbmVyIGFzIGNvbnRhaW5lciBibG9jayBjb250ZW50XG4gICAgICAgICAgICBfdGhpcy5fY29udGFpbmVyQmxvY2suY29udGFpbmVyID0gY2hhbmdlLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIC8vIGVtaXQgY2hhbmdlIHNpZ25hbFxuICAgICAgICAgICAgX3RoaXMuTmF2Q2hhbmdlKGNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB3YXRjaCBmb3IgdGFyZ2V0cyBhY3RpdmF0ZWQgZXh0ZXJuYWxseSAoZS5nLiBVUkwsIGFjdGl2aXRpZXMpXG4gICAgICAgIHJlbmRlcmVyLndhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gX3RoaXMuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIF90aGlzLm5hdkl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBzZWxlY3RlZEluZGV4ICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3RpdmF0aW9uLmlzQWN0aXZlKGl0ZW0udGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3QgaXRlbSBhY3RpdmF0ZWQgZXh0ZXJuYWxseVxuICAgICAgICAgICAgICAgICAgICBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5hdkxpc3QucHJvdG90eXBlLCBcInNlbGVjdGVkSW5kZXhcIiwge1xuICAgICAgICAvKiogSW5kZXggb2Ygc2VsZWN0ZWQgbmF2IGl0ZW0gKGJhc2UgMCksIG9yIC0xIGlmIG5vIHNlbGVjdGlvbiAob2JzZXJ2ZWQpOyBkb2VzIG5vdCBhdXRvbWF0aWNhbGx5IGFjdGl2YXRlIG5hdiBpdGVtIHRhcmdldHM7IHRvIGRvIHNvLCB1c2UgdGhlIGAuYWN0aXZhdGUoLi4uKWAgZnVuY3Rpb24gaW5zdGVhZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBsYXN0IHNlbGVjdGVkIGluZGV4IChtYW51YWxseSwgYXN5bmMgZnJvbSBiZWZvcmVGaXJzdFJlbmRlcixcbiAgICAgICAgICAgIC8vIG9yIHJldHVybiB0aGUgb2JzZXJ2YWJsZSB2YWx1ZSBnaXZlbiB0byBzZXR0ZXIgYmVsb3cpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICBpZiAoKGkgaW5zdGFuY2VvZiBBc3luYy5PYnNlcnZhYmxlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgLTEgZm9yIGFueSBvdGhlciBpbnZhbGlkIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5uYXZJdGVtcy5sZW5ndGggfHwgIXRoaXMubmF2SXRlbXNbaV0pXG4gICAgICAgICAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdW5kZXJseWluZyB2YWx1ZSBvciBzZXQgb2JzZXJ2YWJsZSB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vYnNlcnZhYmxlU2VsZWN0ZWRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2JzZXJ2YWJsZVNlbGVjdGVkSW5kZXgud3JpdGFibGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU2VsZWN0ZWRJbmRleC52YWx1ZSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBvYnNlcnZhYmxlIGJvdW5kLCBqdXN0IHNldCBvd24gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmF2TGlzdC5wcm90b3R5cGUsIFwic2VsZWN0ZWRLZXlcIiwge1xuICAgICAgICAvKiogS2V5IChzdHJpbmcgdmFsdWUpIG9mIHNlbGVjdGVkIGl0ZW0sIGlmIGFueSAocmVhZC1vbmx5LCBvYnNlcnZhYmxlKSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgc2VsZWN0ZWQgaXRlbSBhbmQgcmV0dXJuIGl0cyBrZXksIGlmIGFueVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMubmF2SXRlbXMubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZJdGVtc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0ua2V5IDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogU2VsZWN0IG5hdiBpdGVtIGJ5IGluZGV4IG9yIGtleSwgZGlzcGxheSBhc3NvY2lhdGVkIGNvbnRhaW5lciBpZiBhbnksIGFuZC9vciBzdGFydCBhc3NvY2lhdGVkIGFjdGl2aXR5IGlmIGFueTsgcmV0dXJucyB0aGlzICovXG4gICAgTmF2TGlzdC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciBpbmRleCA9ICh0eXBlb2Ygc2VsZWN0aW9uID09PSBcInN0cmluZ1wiKSA/XG4gICAgICAgICAgICB0aGlzLm5hdkl0ZW1zLnJlZHVjZShmdW5jdGlvbiAodiwgaXRlbSwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmtleSA9PSBzZWxlY3Rpb24gPyBpIDogdjtcbiAgICAgICAgICAgIH0sIC0xKSA6XG4gICAgICAgICAgICBzZWxlY3Rpb247XG4gICAgICAgIHZhciBpdGVtID0gKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLm5hdkl0ZW1zLmxlbmd0aCkgP1xuICAgICAgICAgICAgdGhpcy5uYXZJdGVtc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgLy8gbm8gYWN0aXZlIHNlbGVjdGlvblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgaW5kZXhcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgLy8gYWN0aXZhdGUgaXRlbSB1c2luZyBBcHBsaWNhdGlvbiBpbnN0YW5jZVxuICAgICAgICAgICAgaWYgKGl0ZW0udGFyZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRpb24uYWN0aXZhdGUoaXRlbS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYW4gYXJyYXkgb2YgZGlyZWN0bHkgY29udGFpbmVkIGNvbXBvbmVudHMgKG9ic2VydmFibGUpICovXG4gICAgTmF2TGlzdC5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXJCbG9jay5jb250YWluZXIgPyBbdGhpcy5fY29udGFpbmVyQmxvY2tdIDogW107XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9ub3RfbnVsbFxuICAgIF0sIE5hdkxpc3QucHJvdG90eXBlLCBcIm5hdkl0ZW1zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBOYXZMaXN0LnByb3RvdHlwZSwgXCJyZW1HdXR0ZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBseUFzeW5jLFxuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgTmF2TGlzdC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIE5hdkxpc3QucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIE5hdkxpc3QucHJvdG90eXBlLCBcImp1c3RpZmllZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LmFwcGx5QXN5bmMsXG4gICAgICAgIENvbXBvbmVudEZhY3Rvcnkuc2V0dGVyRm9yKFwiYWN0aXZhdGVcIilcbiAgICBdLCBOYXZMaXN0LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCBudWxsKTtcbiAgICByZXR1cm4gTmF2TGlzdDtcbn0oQmxvY2spKTtcbmV4cG9ydCB7IE5hdkxpc3QgfTtcbihmdW5jdGlvbiAoTmF2TGlzdCkge1xuICAgIC8qKiBDb250YWlucyBpbmplY3RhYmxlIG1ldGhvZHMgZm9yIGFjdGl2YXRpbmcgdGFyZ2V0cyBhbmQgcXVlcnlpbmcgYWN0aXZhdGlvbiBzdGF0ZTsgaW5zdGFudGlhdGVkIGJ5IGBOYXZMaXN0YCAqL1xuICAgIHZhciBBY3RpdmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWN0aXZhdGlvbigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKiogSW5qZWN0YWJsZSBtZXRob2QgdG8gYWN0aXZhdGUgZ2l2ZW4gdGFyZ2V0IChlLmcuIFVSTCwgb3IgQWN0aXZpdHkgaW5zdGFuY2Ugb3IgY2xhc3MpOyBkZWZhdWx0IG9ueSBoYW5kbGVzIFVSTHMsIGBBcHBsaWNhdGlvbmAgaW5zdGFuY2UgaW5qZWN0cyBtb3JlIGZ1bmN0aW9uYWxpdHkgaGVyZSAqL1xuICAgICAgICBBY3RpdmF0aW9uLnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgfTtcbiAgICAgICAgLyoqIEluamVjdGFibGUgbWV0aG9kIHRoYXQgcmV0dXJucyB0cnVlIChvYnNlcnZhYmxlKSBpZiBhbmQgd2hlbiBnaXZlbiB0YXJnZXQgbWF0Y2hlcyB0aGUgY3VycmVudCB0YXJnZXQsIGkuZS4gVVJML3BhdGggbWF0Y2hlcywgb3IgYWN0aXZpdHkvY2xhc3MgbWF0Y2hlcyBjdXJyZW50IGFjdGl2aXR5IG9yIG9uZSBvZiBpdHMgcGFyZW50IGFjdGl2aXRpZXM7IHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBmcm9tIHdpdGhpbiBhbiBvYnNlcnZhYmxlIGNvbnRleHQgdG8gYmUgYWJsZSB0byBvYnNlcnZlIGNoYW5nZXMgdG8gdGFyZ2V0IHN0YXRlcyAqL1xuICAgICAgICBBY3RpdmF0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgICAgIEFzeW5jLmluamVjdGFibGVcbiAgICAgICAgXSwgQWN0aXZhdGlvbi5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgbnVsbCk7XG4gICAgICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICAgICAgQXN5bmMuaW5qZWN0YWJsZVxuICAgICAgICBdLCBBY3RpdmF0aW9uLnByb3RvdHlwZSwgXCJpc0FjdGl2ZVwiLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIEFjdGl2YXRpb247XG4gICAgfSgpKTtcbiAgICBOYXZMaXN0LkFjdGl2YXRpb24gPSBBY3RpdmF0aW9uO1xuICAgIDtcbiAgICAvKiogTmF2TGlzdCBkaXNwbGF5IHR5cGUgKi9cbiAgICB2YXIgVHlwZTtcbiAgICAoZnVuY3Rpb24gKFR5cGUpIHtcbiAgICAgICAgLyoqIERpc3BsYXkgYXMgYSByb3cgb2YgdGFicyAqL1xuICAgICAgICBUeXBlW1R5cGVbXCJUYWJzXCJdID0gMF0gPSBcIlRhYnNcIjtcbiAgICAgICAgLyoqIERpc3BsYXkgYXMgYSByb3cgb2YgcGlsbHMgKi9cbiAgICAgICAgVHlwZVtUeXBlW1wiUGlsbHNcIl0gPSAxXSA9IFwiUGlsbHNcIjtcbiAgICAgICAgLyoqIERpc3BsYXkgYXMgYSBsaXN0IG9mIHBpbGxzICovXG4gICAgICAgIFR5cGVbVHlwZVtcIlN0YWNrZWRQaWxsc1wiXSA9IDJdID0gXCJTdGFja2VkUGlsbHNcIjtcbiAgICB9KShUeXBlID0gTmF2TGlzdC5UeXBlIHx8IChOYXZMaXN0LlR5cGUgPSB7fSkpO1xuICAgIDtcbiAgICAvKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCB3aGVuIGEgbmF2bGlzdCdzIHNlbGVjdGlvbiBjaGFuZ2VzICovXG4gICAgdmFyIFNlbGVjdGlvblNpZ25hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhTZWxlY3Rpb25TaWduYWwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNlbGVjdGlvblNpZ25hbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2VsZWN0aW9uU2lnbmFsO1xuICAgIH0oQ29tcG9uZW50U2lnbmFsKSk7XG4gICAgTmF2TGlzdC5TZWxlY3Rpb25TaWduYWwgPSBTZWxlY3Rpb25TaWduYWw7XG59KShOYXZMaXN0IHx8IChOYXZMaXN0ID0ge30pKTtcbi8qKiBDb25zdHJ1Y3RvciBmb3IgYSBuYXZsaXN0IHNlbGVjdGlvbiBldmVudCBoYW5kbGVyICovXG52YXIgTmF2TGlzdFNlbGVjdGlvbkhhbmRsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOYXZMaXN0U2VsZWN0aW9uSGFuZGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOYXZMaXN0U2VsZWN0aW9uSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTmF2TGlzdFNlbGVjdGlvbkhhbmRsZXI7XG59KENvbXBvbmVudFNpZ25hbEhhbmRsZXIpKTtcbmV4cG9ydCB7IE5hdkxpc3RTZWxlY3Rpb25IYW5kbGVyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9CbG9ja3MvTmF2TGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi9Db21wb25lbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBCbG9jayB9IGZyb20gXCIuL0Jsb2NrXCI7XG4vKiogUmVwcmVzZW50cyBhIHJvdyB3aXRoaW4gYSBgVGFibGVgIGNvbXBvbmVudCAqL1xudmFyIFRhYmxlUm93ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVSb3csIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhIHRhYmxlIHJvdyB3aXRoIGdpdmVuIGNvbHVtbnMsIGlmIGFueSAqL1xuICAgIGZ1bmN0aW9uIFRhYmxlUm93KGNvbHVtbnMsIHdpZHRocywgc3R5bGVzKSB7XG4gICAgICAgIGlmIChjb2x1bW5zID09PSB2b2lkIDApIHsgY29sdW1ucyA9IFtdOyB9XG4gICAgICAgIGlmICh3aWR0aHMgPT09IHZvaWQgMCkgeyB3aWR0aHMgPSBbXTsgfVxuICAgICAgICBpZiAoc3R5bGVzID09PSB2b2lkIDApIHsgc3R5bGVzID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLyoqIFJvdyBpbmRleCAoYmFzZSAwKSB0aGUgbGFzdCB0aW1lIHRoaXMgcm93IHdhcyByZW5kZXJlZCwgb3IgLTEgKG9ic2VydmFibGUpICovXG4gICAgICAgIF90aGlzLnJvd0luZGV4ID0gLTE7XG4gICAgICAgIF90aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgICBfdGhpcy53aWR0aHMgPSB3aWR0aHM7XG4gICAgICAgIF90aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogQXBwZW5kIGEgdGFibGUgY2VsbCB0byB0aGlzIHJvdyAqL1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKGNlbGwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRpcmVjdGx5IGNvbnRhaW5lZCBjb21wb25lbnRzICovXG4gICAgVGFibGVSb3cucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgaW5zdGFuY2VvZiBDb21wb25lbnQpOyB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LmFwcGx5Q29tcG9uZW50c0FycmF5KENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkNvbnRyb2xFbGVtZW50KSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9ub3RfbnVsbFxuICAgIF0sIFRhYmxlUm93LnByb3RvdHlwZSwgXCJjb2x1bW5zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfbm90X251bGxcbiAgICBdLCBUYWJsZVJvdy5wcm90b3R5cGUsIFwid2lkdGhzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfbm90X251bGxcbiAgICBdLCBUYWJsZVJvdy5wcm90b3R5cGUsIFwic3R5bGVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBUYWJsZVJvdy5wcm90b3R5cGUsIFwicm93SW5kZXhcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gVGFibGVSb3c7XG59KEJsb2NrKSk7XG5leHBvcnQgeyBUYWJsZVJvdyB9O1xuLyoqIEEgdGFibGUgaGVhZGVyIGF0IHRoZSB0b3Agb2YgYSB0YWJsZSAqL1xudmFyIFRhYmxlSGVhZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFibGVIZWFkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVIZWFkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvKiogQXV0b21hdGljIHNlbGVjdGlvbiBtYW5hZ2VtZW50IG1vZGU6IHRhYmxlIGhlYWRlciByb3dzIGFyZSBub3Qgc2VsZWN0YWJsZSAqL1xuICAgICAgICBfdGhpcy5zZWxlY3Rpb25Nb2RlID0gQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUuTm9uZTtcbiAgICAgICAgLyoqIEF1dG9tYXRpYyBmb2N1cyBtYW5hZ2VtZW50IG1vZGU6IHRhYmxlIGhlYWRlciByb3dzIGFyZSBub3QgZm9jdXNhYmxlICovXG4gICAgICAgIF90aGlzLmZvY3VzTW9kZSA9IENvbXBvbmVudC5Gb2N1c01vZGUuTm9uZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAvLyBpbXBsZW1lbnRlZCBieSBwbGF0Zm9ybSBzcGVjaWZpYyByZW5kZXJlclxuICAgIH1cbiAgICByZXR1cm4gVGFibGVIZWFkZXI7XG59KFRhYmxlUm93KSk7XG5leHBvcnQgeyBUYWJsZUhlYWRlciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQmxvY2tzL1RhYmxlUm93LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBDb21wb25lbnRGYWN0b3J5IH0gZnJvbSBcIi4uL0NvbXBvbmVudEZhY3RvcnlcIjtcbmltcG9ydCB7IEJsb2NrIH0gZnJvbSBcIi4vQmxvY2tcIjtcbmltcG9ydCB7IFRhYmxlSGVhZGVyIH0gZnJvbSBcIi4vVGFibGVSb3dcIjtcbi8qKiBSZXByZXNlbnRzIGEgdGFibGUgYmxvY2sgY29tcG9uZW50ICovXG52YXIgVGFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZSwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgdGFibGUgd2l0aCBnaXZlbiBoZWFkZXIgYW5kIHJvd3MsIGlmIGFueSAqL1xuICAgIGZ1bmN0aW9uIFRhYmxlKGhlYWRlckNvbHVtbnMsIHdpZHRocywgcm93cykge1xuICAgICAgICBpZiAocm93cyA9PT0gdm9pZCAwKSB7IHJvd3MgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oZWFkZXIgPSBuZXcgVGFibGVIZWFkZXIoaGVhZGVyQ29sdW1ucywgd2lkdGhzKTtcbiAgICAgICAgX3RoaXMucm93cyA9IHJvd3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEFwcGVuZCBhIHJvdyB0byB0aGlzIHRhYmxlICovXG4gICAgVGFibGUucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKHRhYmxlUm93KSB7XG4gICAgICAgIHRoaXMucm93cy5wdXNoKHRhYmxlUm93KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBhcnJheSBvZiBkaXJlY3RseSBjb250YWluZWQgY29tcG9uZW50cyAob2JzZXJ2YWJsZSkgKi9cbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gdGhpcy5yb3dzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMgaW5zdGFuY2VvZiBDb21wb25lbnQpOyB9KTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyKVxuICAgICAgICAgICAgcmVzdWx0cy51bnNoaWZ0KHRoaXMuaGVhZGVyKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgY3VycmVudCB2YWx1ZXMgb2YgaW5wdXQgZWxlbWVudHMgKG9ic2VydmFibGUpICovXG4gICAgVGFibGUucHJvdG90eXBlLmdldEZvcm1WYWx1ZXMgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgeyByZXN1bHQgPSB7fTsgfVxuICAgICAgICBpZiAodGhpcy5uYW1lKVxuICAgICAgICAgICAgcmVzdWx0W3RoaXMubmFtZV0gPSB0aGlzLnJvd3NcbiAgICAgICAgICAgICAgICAubWFwQXN5bmNWYWx1ZXMoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlbS5nZXRGb3JtVmFsdWVzKCk7IH0pOyB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5nZXRGb3JtVmFsdWVzLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBTZXQgYWxsIGlucHV0IHZhbHVlcyBieSBlbGVtZW50IG5hbWUgKi9cbiAgICBUYWJsZS5wcm90b3R5cGUuc2V0Rm9ybVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMubmFtZSAmJiB2YWx1ZXMgJiYgdmFsdWVzW3RoaXMubmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMucm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIGkpIHtcbiAgICAgICAgICAgICAgICByb3cgJiYgcm93LnNldEZvcm1WYWx1ZXModmFsdWVzW190aGlzLm5hbWVdW2ldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0Rm9ybVZhbHVlcy5jYWxsKHRoaXMsIHZhbHVlcyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBseUNvbXBvbmVudFJlZihDb21wb25lbnRGYWN0b3J5LkNMZXZlbC5UYWJsZUhlYWRlciksXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBUYWJsZS5wcm90b3R5cGUsIFwiaGVhZGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlDb21wb25lbnRzQXJyYXkoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuVGFibGVSb3cpLFxuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX25vdF9udWxsXG4gICAgXSwgVGFibGUucHJvdG90eXBlLCBcInJvd3NcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIFRhYmxlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgVGFibGUgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBlbmRDaGlsZENvbXBvbmVudHMoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuVGFibGVSb3cpXG4gICAgXSwgVGFibGUpO1xuICAgIHJldHVybiBUYWJsZTtcbn0oQmxvY2spKTtcbmV4cG9ydCB7IFRhYmxlIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9CbG9ja3MvVGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IENvbnRyb2xFbGVtZW50IH0gZnJvbSBcIi4vQ29udHJvbEVsZW1lbnRcIjtcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCIuLi9Db21wb25lbnRcIjtcbmltcG9ydCB7IENvbXBvbmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vQ29tcG9uZW50RmFjdG9yeVwiO1xuLyoqIFJlcHJlc2VudHMgYSBjb250cm9sIGVsZW1lbnQgdGhhdCBjb250YWlucyBhIGJsb2NrICovXG52YXIgQmxvY2tDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tDb250cm9sLCBfc3VwZXIpO1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgYmxvY2sgY29udHJvbCBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGdpdmVuIGJsb2NrLCBpZiBhbnkgKi9cbiAgICBmdW5jdGlvbiBCbG9ja0NvbnRyb2woYmxvY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgLy8gYXBwbHkgYXV0b21hdGljIHdpZHRoIHRvIHN0YXJ0IHdpdGhcbiAgICAgICAgX3RoaXMuc3R5bGUuc2V0KFwid2lkdGhcIiwgQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy53aWR0aDsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9ja0NvbnRyb2wucHJvdG90eXBlLCBcIndpZHRoXCIsIHtcbiAgICAgICAgLyoqIE92ZXJhbGwgdGFyZ2V0IHdpZHRoIG9mIHRoaXMgY29tcG9uZW50IChDU1MgbGVuZ3RoOyBvYnNlcnZhYmxlLCBkaXJlY3RseSBtb2RpZmllcyBgLnN0eWxlYCBwcm9wZXJ0eSwgZG9lcyBfbm90XyByZXRyaWV2ZSBhY3R1YWwgY29tcG9uZW50IGhlaWdodCwgbWF5IGJlIFwiYXV0b1wiKTsgaWYgYSB3aWR0aCBoYXMgbm90IGJlZW4gc2V0IGV4cGxpY2l0bHksIG9yIGlzIHNldCB0byBcImF1dG9cIiwgdGhlbiB0aGUgdmFsdWUgaXMgdGFrZW4gZnJvbSB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lciAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHdoaWxlIG5vIHdpZHRoIHNldCwgb2JzZXJ2ZSBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9jayAmJiB0aGlzLmJsb2NrLndpZHRoIHx8XG4gICAgICAgICAgICAgICAgXCJhdXRvXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodyA9PT0gXCJhdXRvXCIpXG4gICAgICAgICAgICAgICAgdyA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNldChcIndpZHRoXCIsIHcgPyB3IDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy53aWR0aDsgfSkpO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBTZXQgdGhlIGJsb2NrIGZvciB0aGlzIGNvbXBvbmVudCAob3ZlcndyaXRlcyBleGlzdGluZyB2YWx1ZSwgaWYgYW55KTsgcmV0dXJucyB0aGlzICovXG4gICAgQmxvY2tDb250cm9sLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBjO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRpcmVjdGx5IGNvbnRhaW5lZCBjb21wb25lbnRzIChvYnNlcnZhYmxlKSAqL1xuICAgIEJsb2NrQ29udHJvbC5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ibG9jayBpbnN0YW5jZW9mIENvbXBvbmVudCkgP1xuICAgICAgICAgICAgW3RoaXMuYmxvY2tdIDogW107XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBseUNvbXBvbmVudFJlZihDb21wb25lbnRGYWN0b3J5LkNMZXZlbC5CbG9jayksXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBCbG9ja0NvbnRyb2wucHJvdG90eXBlLCBcImJsb2NrXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBCbG9ja0NvbnRyb2wucHJvdG90eXBlLCBcIndpZHRoXCIsIG51bGwpO1xuICAgIEJsb2NrQ29udHJvbCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LmFwcGVuZENoaWxkQ29tcG9uZW50cyhDb21wb25lbnRGYWN0b3J5LkNMZXZlbC5CbG9jaylcbiAgICBdLCBCbG9ja0NvbnRyb2wpO1xuICAgIHJldHVybiBCbG9ja0NvbnRyb2w7XG59KENvbnRyb2xFbGVtZW50KSk7XG5leHBvcnQgeyBCbG9ja0NvbnRyb2wgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0NvbnRyb2xzL0Jsb2NrQ29udHJvbC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi9Db21wb25lbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBDb250cm9sRWxlbWVudCB9IGZyb20gXCIuL0NvbnRyb2xFbGVtZW50XCI7XG4vKiogUmVwcmVzZW50cyBhIGJ1dHRvbiBncm91cCAodG9nZ2xlLCB0YWIsIG9yIHRvb2xiYXIpIGNvbnRyb2wgKi9cbnZhciBCdXR0b25Hcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1dHRvbkdyb3VwLCBfc3VwZXIpO1xuICAgIC8qKiBDcmVhdGUgYSBidXR0b24gZ3JvdXAgZWxlbWVudCAqL1xuICAgIGZ1bmN0aW9uIEJ1dHRvbkdyb3VwKGJ1dHRvbnMpIHtcbiAgICAgICAgaWYgKGJ1dHRvbnMgPT09IHZvaWQgMCkgeyBidXR0b25zID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLyoqIFNldCB0byBmYWxzZSB0byBleHBhbmQgaG9yaXpvbnRhbGx5IHdpdGhpbiByb3cgKG9ic2VydmVkKSAqL1xuICAgICAgICBfdGhpcy5zaHJpbmt3cmFwID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuYnV0dG9ucyA9IGJ1dHRvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIE1ldGhvZCB0aGF0IGlzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgcmVuZGVyZXIgZm9yIHRoaXMgYnV0dG9uIGdyb3VwIGlzIGNvbnN0cnVjdGVkOyBhZGRzIG9ic2VydmVycyBmb3IgYnV0dG9uIGFjdGl2YXRpb24gKi9cbiAgICBCdXR0b25Hcm91cC5wcm90b3R5cGUuYmVmb3JlRmlyc3RSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVGaXJzdFJlbmRlci5jYWxsKHRoaXMsIHJlbmRlcmVyKTtcbiAgICAgICAgcmVuZGVyZXIud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0TGFzdFNlbGVjdGVkQ2hpbGQoKTsgfSwgZnVuY3Rpb24gKGJ1dHRvbikge1xuICAgICAgICAgICAgX3RoaXMuc2VsZWN0ZWRJbmRleCA9IGJ1dHRvbiA/XG4gICAgICAgICAgICAgICAgX3RoaXMuYnV0dG9ucy5pbmRleE9mKGJ1dHRvbikgOiAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlcmVyLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlbGVjdGVkSW5kZXg7IH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2VsZWN0ZWRJbmRleCA9PT0gaSAmJiBfdGhpcy5idXR0b25zW2ldKVxuICAgICAgICAgICAgICAgIF90aGlzLmJ1dHRvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIF90aGlzLmJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbiAoYikgeyByZXR1cm4gYiAmJiAoYi5zZWxlY3RlZCA9IGZhbHNlKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1dHRvbkdyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCIsIHtcbiAgICAgICAgLyoqIEN1cnJlbnRseSBzZWxlY3RlZCBidXR0b24gaW5kZXggKGJhc2UgMCkgb3IgLTEgaWYgbm8gc2VsZWN0aW9uIChvYnNlcnZlZCkgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gbGFzdCBzZWxlY3RlZCBpbmRleCAobWFudWFsbHksIGFzeW5jIGZyb20gYmVmb3JlRmlyc3RSZW5kZXIsXG4gICAgICAgICAgICAvLyBvciByZXR1cm4gdGhlIG9ic2VydmFibGUgdmFsdWUgZ2l2ZW4gdG8gc2V0dGVyIGJlbG93KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgaWYgKChpIGluc3RhbmNlb2YgQXN5bmMuT2JzZXJ2YWJsZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29ic2VydmFibGVTZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHVuZGVybHlpbmcgdmFsdWUgb3Igc2V0IG9ic2VydmFibGUgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2JzZXJ2YWJsZVNlbGVjdGVkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29ic2VydmFibGVTZWxlY3RlZEluZGV4LndyaXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlbGVjdGVkSW5kZXgudmFsdWUgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gb2JzZXJ2YWJsZSBib3VuZCwganVzdCBzZXQgb3duIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVzZSAtMSBmb3IgYW55IG90aGVyIGludmFsaWQgdmFsdWVcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gdGhpcy5idXR0b25zLmxlbmd0aCB8fCAhdGhpcy5idXR0b25zW3ZhbHVlXSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IC0xO1xuICAgICAgICAgICAgLy8gc2VsZWN0IGdpdmVuIGJ1dHRvbiBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gdmFsdWUgPj0gMCA/IHRoaXMuYnV0dG9uc1t2YWx1ZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoYnV0dG9uKVxuICAgICAgICAgICAgICAgIGJ1dHRvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBuZWVkIHRvIGRlc2VsZWN0IG90aGVycyAoZG8gbm90IHdhaXQgZm9yIGFzeW5jKVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUuSXRlbUNsaWNrIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSBDb21wb25lbnQuU2VsZWN0aW9uTW9kZS5JdGVtRm9jdXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gdGhpcy5idXR0b25zLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5idXR0b25zW2pdICYmIHRoaXMuYnV0dG9uc1tqXSAhPT0gYnV0dG9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zW2pdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBBcHBlbmQgYSBidXR0b24gdG8gdGhpcyBncm91cDsgcmV0dXJucyB0aGlzICovXG4gICAgQnV0dG9uR3JvdXAucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGJ1dHRvbikge1xuICAgICAgICB0aGlzLmJ1dHRvbnMucHVzaChidXR0b24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRpcmVjdGx5IGNvbnRhaW5lZCBjb21wb25lbnRzIChvYnNlcnZhYmxlKSAqL1xuICAgIEJ1dHRvbkdyb3VwLnByb3RvdHlwZS5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnV0dG9ucy5maWx0ZXIoZnVuY3Rpb24gKGIpIHsgcmV0dXJuIChiIGluc3RhbmNlb2YgQ29tcG9uZW50KTsgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBseUNvbXBvbmVudHNBcnJheShDb21wb25lbnRGYWN0b3J5LkNMZXZlbC5Db250cm9sRWxlbWVudCksXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfbm90X251bGxcbiAgICBdLCBCdXR0b25Hcm91cC5wcm90b3R5cGUsIFwiYnV0dG9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQnV0dG9uR3JvdXAucHJvdG90eXBlLCBcInZlcnRpY2FsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlBc3luYyxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIEJ1dHRvbkdyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwpO1xuICAgIEJ1dHRvbkdyb3VwID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwZW5kQ2hpbGRDb21wb25lbnRzKENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkNvbnRyb2xFbGVtZW50KVxuICAgIF0sIEJ1dHRvbkdyb3VwKTtcbiAgICByZXR1cm4gQnV0dG9uR3JvdXA7XG59KENvbnRyb2xFbGVtZW50KSk7XG5leHBvcnQgeyBCdXR0b25Hcm91cCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvQnV0dG9uR3JvdXAuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IENvbnRhaW5lciwgTGF5b3V0Q29udGFpbmVyIH0gZnJvbSBcIi4uL1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi9Db21wb25lbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBDb250cm9sRWxlbWVudCB9IGZyb20gXCIuL0NvbnRyb2xFbGVtZW50XCI7XG4vKiogUmVwcmVzZW50cyBhIGNvbnRyb2wgZWxlbWVudCB0aGF0IGNvbnRhaW5zIGEgY29udGFpbmVyICovXG52YXIgQ29udGFpbmVyQ29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnRhaW5lckNvbnRyb2wsIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhIGNvbnRhaW5lciBjb250cm9sIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgZ2l2ZW4gY29udGFpbmVyLCBpZiBhbnkgKi9cbiAgICBmdW5jdGlvbiBDb250YWluZXJDb250cm9sKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBpZiAoY29udGFpbmVyKVxuICAgICAgICAgICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAvLyBhcHBseSBhdXRvbWF0aWMgaGVpZ2h0IGFuZCB3aWR0aCB0byBzdGFydCB3aXRoXG4gICAgICAgIF90aGlzLnN0eWxlLnNldChcImhlaWdodFwiLCBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmhlaWdodDsgfSkpO1xuICAgICAgICBfdGhpcy5zdHlsZS5zZXQoXCJ3aWR0aFwiLCBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLndpZHRoOyB9KSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRhaW5lckNvbnRyb2wucHJvdG90eXBlLCBcImNvbnRhaW5lclwiLCB7XG4gICAgICAgIC8qKiBDb250YWluZXIgZWxlbWVudCAoY3JlYXRlZCBpZiBub3Qgc2V0LCBuZXZlciB1bmRlZmluZWQ7IG9ic2VydmVkKTsgaWYgc2V0IHRvIGEgY29udGFpbmVyIChvdGhlciB0aGFuIExheW91dENvbnRhaW5lcikgd2l0aCBtYXhDb250ZW50V2lkdGggb3RoZXIgdGhhbiBhdXRvLCBhbmQgdGhpcyBjb250cm9sJ3Mgd2lkdGggaXMgc2V0IHRvIGF1dG8sIHRoaXMgY29udHJvbCB3aWxsIHNocmlua3dyYXAgdG8gdGhlIHNhbWUgd2lkdGggYXMgdGhlIGNvbnRhaW5lciAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGdldCB1bmRlcmx5aW5nIHByb3BlcnR5IG9yIGNyZWF0ZSBhIG5ldyBjb250YWluZXJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lciB8fCAodGhpcy5jb250YWluZXIgPSBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBDb250YWluZXIoKTsgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAvLyBzZXQgdW5kZXJseWluZyBwcm9wZXJ0eVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBjO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyQ29udHJvbC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHtcbiAgICAgICAgLyoqIE92ZXJhbGwgdGFyZ2V0IGhlaWdodCBvZiB0aGlzIGNvbXBvbmVudCAoQ1NTIGxlbmd0aDsgb2JzZXJ2YWJsZSwgZGlyZWN0bHkgbW9kaWZpZXMgYC5zdHlsZWAgcHJvcGVydHksIGRvZXMgX25vdF8gcmV0cmlldmUgYWN0dWFsIGNvbXBvbmVudCBoZWlnaHQsIG1heSBiZSBcImF1dG9cIik7IGlmIGEgaGVpZ2h0IGhhcyBub3QgYmVlbiBzZXQgZXhwbGljaXRseSwgb3IgaXMgc2V0IHRvIFwiYXV0b1wiLCB0aGVuIHRoZSB2YWx1ZSBpcyB0YWtlbiBmcm9tIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lcjsgZm9yIGBMYXlvdXRDb250YWluZXJgLCBhIHZhbHVlIG9mIFwiMTAwJVwiIGlzIHVzZWQgaWYgdGhlIGNvbnRhaW5lcidzIGhlaWdodCBpcyBhbHNvIFwiYXV0b1wiICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSBubyBoZWlnaHQgc2V0LCBvYnNlcnZlIGNvbnRhaW5lciBoZWlnaHQgYW5kIHR5cGVcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5oZWlnaHQgfHwgXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLmNvbnRhaW5lciBpbnN0YW5jZW9mIExheW91dENvbnRhaW5lcikgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID09PSBcImF1dG9cIilcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXCIxMDAlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGggPT09IFwiYXV0b1wiKVxuICAgICAgICAgICAgICAgIGggPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQoXCJoZWlnaHRcIiwgaCA/IGggOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmhlaWdodDsgfSkpO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29udGFpbmVyQ29udHJvbC5wcm90b3R5cGUsIFwid2lkdGhcIiwge1xuICAgICAgICAvKiogT3ZlcmFsbCB0YXJnZXQgd2lkdGggb2YgdGhpcyBjb21wb25lbnQgKENTUyBsZW5ndGg7IG9ic2VydmFibGUsIGRpcmVjdGx5IG1vZGlmaWVzIGAuc3R5bGVgIHByb3BlcnR5LCBkb2VzIF9ub3RfIHJldHJpZXZlIGFjdHVhbCBjb21wb25lbnQgaGVpZ2h0LCBtYXkgYmUgXCJhdXRvXCIpOyBpZiBhIHdpZHRoIGhhcyBub3QgYmVlbiBzZXQgZXhwbGljaXRseSwgb3IgaXMgc2V0IHRvIFwiYXV0b1wiLCB0aGVuIHRoZSB2YWx1ZSBpcyB0YWtlbiBmcm9tIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gd2hpbGUgbm8gd2lkdGggc2V0LCBvYnNlcnZlIGNvbnRhaW5lciB3aWR0aFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci53aWR0aCB8fFxuICAgICAgICAgICAgICAgIFwiYXV0b1wiO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHcgPT09IFwiYXV0b1wiKVxuICAgICAgICAgICAgICAgIHcgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQoXCJ3aWR0aFwiLCB3ID8gdyA6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMud2lkdGg7IH0pKTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogU2V0IHRoZSBjb250YWluZXIgZm9yIHRoaXMgY29tcG9uZW50IChvdmVyd3JpdGVzIGV4aXN0aW5nIHZhbHVlLCBpZiBhbnkpOyByZXR1cm5zIHRoaXMgKi9cbiAgICBDb250YWluZXJDb250cm9sLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gYztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBhcnJheSBvZiBkaXJlY3RseSBjb250YWluZWQgY29tcG9uZW50cyAob2JzZXJ2YWJsZSkgKi9cbiAgICBDb250YWluZXJDb250cm9sLnByb3RvdHlwZS5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbnRhaW5lciBpbnN0YW5jZW9mIENvbXBvbmVudCkgP1xuICAgICAgICAgICAgW3RoaXMuY29udGFpbmVyXSA6IFtdO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwbHlDb21wb25lbnRSZWYoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udGFpbmVyKSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbnRhaW5lckNvbnRyb2wucHJvdG90eXBlLCBcImNvbnRhaW5lclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbnRhaW5lckNvbnRyb2wucHJvdG90eXBlLCBcImhlaWdodFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENvbnRhaW5lckNvbnRyb2wucHJvdG90eXBlLCBcIndpZHRoXCIsIG51bGwpO1xuICAgIENvbnRhaW5lckNvbnRyb2wgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBlbmRDaGlsZENvbXBvbmVudHMoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udGFpbmVyKVxuICAgIF0sIENvbnRhaW5lckNvbnRyb2wpO1xuICAgIHJldHVybiBDb250YWluZXJDb250cm9sO1xufShDb250cm9sRWxlbWVudCkpO1xuZXhwb3J0IHsgQ29udGFpbmVyQ29udHJvbCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvQ29udGFpbmVyQ29udHJvbC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi9Db21wb25lbnRGYWN0b3J5XCI7XG5pbXBvcnQgeyBDb250cm9sRWxlbWVudCB9IGZyb20gXCIuL0NvbnRyb2xFbGVtZW50XCI7XG4vKiogUmVwcmVzZW50cyBhIHN0YWNrIGNvbnRyb2wgY29udGFpbmluZyBjb250cm9sIGVsZW1lbnRzIHdpdGggZXF1YWwgd2lkdGhzIHBsYWNlZCBmcm9tIHRvcCB0byBib3R0b20gKi9cbnZhciBDb250cm9sU3RhY2sgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb250cm9sU3RhY2ssIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhIHN0YWNrIGVsZW1lbnQgd2l0aCBnaXZlbiBjb250ZW50LCBpZiBhbnkgKi9cbiAgICBmdW5jdGlvbiBDb250cm9sU3RhY2soY29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwKSB7IGNvbnRlbnQgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKiogU2V0IHRvIHRydWUgdG8gc2hyaW5rIHRoaXMgY29tcG9uZW50IGhvcml6b250YWxseSBzdWNoIHRoYXQgaXQgb2NjdXBpZXMgYXMgbGl0dGxlIHNwYWNlIGFzIHBvc3NpYmxlOyBzZXQgdG8gZmFsc2UgdG8gZXhwYW5kIGhvcml6b250YWxseSB3aXRoaW4gcm93IChvYnNlcnZlZCk7IG5vdGUgdGhhdCBzaHJpbmt3cmFwcGluZyBhIGNvbnRyb2wgc3RhY2sgd2l0aCBub24tc2hyaW5rd3JhcHBlZCBjb250cm9scyBtYXkgbGVhZCB0byB1bmV4cGVjdGVkIHJlc3VsdHM7IGJ5IGRlZmF1bHQsIHRoaXMgY29tcG9uZW50IG9ic2VydmVzIGNoaWxkIGNvbXBvbmVudHMgYW5kIGlzIG9ubHkgc2hyaW5rd3JhcHBlZCBpZiBhbGwgY2hpbGQgY29tcG9uZW50cyBhcmUgc2hyaW5rd3JhcHBlZCAqL1xuICAgICAgICBfdGhpcy5zaHJpbmt3cmFwID0gQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nZXRDaGlsZHJlbigpXG4gICAgICAgICAgICAuZXZlcnkoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICgoYyBpbnN0YW5jZW9mIENvbnRyb2xFbGVtZW50KSAmJiBjLnNocmlua3dyYXApOyB9KTsgfSk7XG4gICAgICAgIF90aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBBcHBlbmQgYSBjb250cm9sIHRvIHRoaXMgc3RhY2s7IHJldHVybnMgdGhpcyAqL1xuICAgIENvbnRyb2xTdGFjay5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQucHVzaChjb250cm9sKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBhcnJheSBvZiBkaXJlY3RseSBjb250YWluZWQgY29tcG9uZW50cyAob2JzZXJ2YWJsZSkgKi9cbiAgICBDb250cm9sU3RhY2sucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMgaW5zdGFuY2VvZiBDb21wb25lbnQpOyB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LmFwcGx5Q29tcG9uZW50c0FycmF5KENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkNvbnRyb2xFbGVtZW50KSxcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9ub3RfbnVsbFxuICAgIF0sIENvbnRyb2xTdGFjay5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIENvbnRyb2xTdGFjay5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ29udHJvbFN0YWNrLnByb3RvdHlwZSwgXCJob3J6QWxpZ25cIiwgdm9pZCAwKTtcbiAgICBDb250cm9sU3RhY2sgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBlbmRDaGlsZENvbXBvbmVudHMoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQ29udHJvbEVsZW1lbnQpXG4gICAgXSwgQ29udHJvbFN0YWNrKTtcbiAgICByZXR1cm4gQ29udHJvbFN0YWNrO1xufShDb250cm9sRWxlbWVudCkpO1xuZXhwb3J0IHsgQ29udHJvbFN0YWNrIH07XG4vKiogUmVwcmVzZW50cyBhIHN0YWNrIGNvbnRhaW5pbmcgY29udHJvbCBlbGVtZW50cyB3aXRoIGVxdWFsIHdpZHRoIHBsYWNlZCBmcm9tIHRvcCB0byBib3R0b20sIHdpdGggc3BhY2luZyBzZXQgdG8gMCAobm8gbWFyZ2luKSAqL1xudmFyIENsb3NlQ29udHJvbFN0YWNrID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xvc2VDb250cm9sU3RhY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xvc2VDb250cm9sU3RhY2soKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zcGFjaW5nID0gXCIwXCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENsb3NlQ29udHJvbFN0YWNrO1xufShDb250cm9sU3RhY2spKTtcbmV4cG9ydCB7IENsb3NlQ29udHJvbFN0YWNrIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9Db250cm9sU3RhY2suanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IENvbnRyb2xFbGVtZW50IH0gZnJvbSBcIi4vQ29udHJvbEVsZW1lbnRcIjtcbi8qKiBSZXByZXNlbnRzIGFuIGljb24gY29udHJvbCAoaG9yaXpvbnRhbGx5IGNlbnRlcmVkKSAqL1xudmFyIEljb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJY29uLCBfc3VwZXIpO1xuICAgIC8qKiBDcmVhdGUgYW4gaWNvbiBlbGVtZW50ICovXG4gICAgZnVuY3Rpb24gSWNvbihpY29uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBTZXQgdG8gZmFsc2UgdG8gZXhwYW5kIGhvcml6b250YWxseSB3aXRoaW4gcm93IChvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMuc2hyaW5rd3JhcCA9IHRydWU7XG4gICAgICAgIF90aGlzLmljb24gPSBpY29uIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEluaXRpYWxpemUgYW4gaWNvbiBjb250cm9sIHdpdGggZ2l2ZW4gaWNvbiBuYW1lICovXG4gICAgSWNvbi53aXRoSWNvbiA9IGZ1bmN0aW9uIChpY29uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGgoeyBpY29uOiBpY29uIH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc3RyaW5nXG4gICAgXSwgSWNvbi5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIEljb24ucHJvdG90eXBlLCBcInRvb2x0aXBUZXh0XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIEljb247XG59KENvbnRyb2xFbGVtZW50KSk7XG5leHBvcnQgeyBJY29uIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9JY29uLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gXCIuLi8uLi9TdHlsZVwiO1xuaW1wb3J0IHsgQ29udHJvbEVsZW1lbnQgfSBmcm9tIFwiLi9Db250cm9sRWxlbWVudFwiO1xuLyoqIFJlcHJlc2VudHMgYW4gaW1hZ2UgY29udHJvbCAqL1xudmFyIEltYWdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW1hZ2UsIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhbiBpbWFnZSBlbGVtZW50ICovXG4gICAgZnVuY3Rpb24gSW1hZ2UoaW1hZ2VVcmwpIHtcbiAgICAgICAgaWYgKGltYWdlVXJsID09PSB2b2lkIDApIHsgaW1hZ2VVcmwgPSBcIlwiOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBTZXQgdG8gZmFsc2UgdG8gZXhwYW5kIGhvcml6b250YWxseSB3aXRoaW4gcm93IChvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMuc2hyaW5rd3JhcCA9IHRydWU7XG4gICAgICAgIC8qKiBFbmNhcHN1bGF0aW9uIG9mIGltYWdlIGVsZW1lbnQgc3R5bGUgKG9ic2VydmVkKSAqL1xuICAgICAgICBfdGhpcy5zdHlsZV9pbWcgPSBuZXcgU3R5bGUoKTtcbiAgICAgICAgLyoqIFRydWUgaWYgYSBsb2FkIGVycm9yIG9jY3VycmVkIChvYnNlcnZhYmxlKSAqL1xuICAgICAgICBfdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICAvKiogUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGltYWdlIGlzIGxvYWRlZCwgb3IgaWYgYW4gZXJyb3Igb2NjdXJyZWQgKHNlZSAuaGFzRXJyb3IpICovXG4gICAgICAgIF90aGlzLnJlYWR5ID0gbmV3IEFzeW5jLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF90aGlzLnJlc29sdmVSZWFkeSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5pbWFnZVVybCA9IGltYWdlVXJsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBJbml0aWFsaXplIGFuIGltYWdlIGNvbnRyb2wgd2l0aCBnaXZlbiBVUkwgKi9cbiAgICBJbWFnZS53aXRoVXJsID0gZnVuY3Rpb24gKGltYWdlVXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGgoeyBpbWFnZVVybDogaW1hZ2VVcmwgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBJbWFnZS5wcm90b3R5cGUsIFwiaW1hZ2VVcmxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBJbWFnZS5wcm90b3R5cGUsIFwidG9vbHRpcFRleHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9ub3RfbnVsbFxuICAgIF0sIEltYWdlLnByb3RvdHlwZSwgXCJzdHlsZV9pbWdcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIEltYWdlLnByb3RvdHlwZSwgXCJoYXNFcnJvclwiLCB2b2lkIDApO1xuICAgIHJldHVybiBJbWFnZTtcbn0oQ29udHJvbEVsZW1lbnQpKTtcbmV4cG9ydCB7IEltYWdlIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9JbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IHsgQ29udHJvbEVsZW1lbnQgfSBmcm9tIFwiLi9Db250cm9sRWxlbWVudFwiO1xuLyoqIFJlcHJlc2VudHMgYSBtaW5pbWFsIHRleHQgY29udHJvbCB3aXRoIGljb24gYW5kIGJhZGdlICovXG52YXIgTGFiZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYWJlbCwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgbGFiZWwgZWxlbWVudCAqL1xuICAgIGZ1bmN0aW9uIExhYmVsKHRleHQsIGljb24sIHJlbUd1dHRlciwgYmFkZ2UpIHtcbiAgICAgICAgaWYgKHRleHQgPT09IHZvaWQgMCkgeyB0ZXh0ID0gXCJcIjsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKiogU2V0IHRvIGZhbHNlIHRvIGV4cGFuZCBob3Jpem9udGFsbHkgd2l0aGluIHJvdyAoZGVmYXVsdCB0cnVlOyBvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMuc2hyaW5rd3JhcCA9IHRydWU7XG4gICAgICAgIF90aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICBfdGhpcy5pY29uID0gaWNvbjtcbiAgICAgICAgX3RoaXMuYmFkZ2UgPSBiYWRnZTtcbiAgICAgICAgaWYgKHJlbUd1dHRlciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgX3RoaXMucmVtR3V0dGVyID0gcmVtR3V0dGVyO1xuICAgICAgICAvLyBzZXQgZm9jdXMgbW9kZSBzbyBsYWJlbCBpcyBub3QgZm9jdXNhYmxlIGJ5IGRlZmF1bHRcbiAgICAgICAgX3RoaXMuZm9jdXNNb2RlID0gQ29tcG9uZW50LkZvY3VzTW9kZS5Ob25lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBJbml0aWFsaXplIGEgdGV4dCBjb250cm9sIGZhY3Rvcnkgd2l0aCBnaXZlbiB0ZXh0IGFuZCBzdHlsZSAqL1xuICAgIExhYmVsLndpdGhUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGgoeyB0ZXh0OiB0ZXh0LCBzdHlsZTogc3R5bGUgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBMYWJlbC5wcm90b3R5cGUsIFwidGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIExhYmVsLnByb3RvdHlwZSwgXCJ0ZXh0QmVmb3JlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc3RyaW5nXG4gICAgXSwgTGFiZWwucHJvdG90eXBlLCBcInRleHRBZnRlclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgTGFiZWwucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIExhYmVsLnByb3RvdHlwZSwgXCJyZW1HdXR0ZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBMYWJlbC5wcm90b3R5cGUsIFwiYmFkZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBMYWJlbC5wcm90b3R5cGUsIFwidG9vbHRpcFRleHRcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gTGFiZWw7XG59KENvbnRyb2xFbGVtZW50KSk7XG5leHBvcnQgeyBMYWJlbCB9O1xuLy8gPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tPS09LT0tXG4vKiogU3RyZXRjaGVkIGxhYmVsIGNvbnRyb2w6IGEgbGFiZWwgdGhhdCBleHBhbmRzIGhvcml6b250YWxseSwgd2hpbGUgbm90IGJyZWFraW5nIGFjcm9zcyBsaW5lcyAodXNlcyBlbGxpcHNpcyBpZiBhdmFpbGFibGUpICovXG52YXIgV2lkZUxhYmVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2lkZUxhYmVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpZGVMYWJlbCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBTZXQgdG8gdHJ1ZSB0byBzaHJpbmsgaG9yaXpvbnRhbGx5IChkZWZhdWx0IGZhbHNlOyBvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMuc2hyaW5rd3JhcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBXaWRlTGFiZWw7XG59KExhYmVsKSk7XG5leHBvcnQgeyBXaWRlTGFiZWwgfTtcbi8qKiBQYXJhZ3JhcGggY29udHJvbDogYSBsYWJlbCB0aGF0IGV4cGFuZHMgaG9yaXpvbnRhbGx5LCB3aXRoIHRleHQgdGhhdCBicmVha3MgYXV0b21hdGljYWxseSBhY3Jvc3MgbGluZXMsIGFuZCBhZGRlZCBsaW5lIHNwYWNpbmcgZm9yIGVuaGFuY2VkIHJlYWRhYmlsaXR5ICovXG52YXIgUGFyYWdyYXBoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFyYWdyYXBoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcmFncmFwaCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBTZXQgdG8gdHJ1ZSB0byBzaHJpbmsgaG9yaXpvbnRhbGx5IChkZWZhdWx0IGZhbHNlOyBvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMuc2hyaW5rd3JhcCA9IGZhbHNlO1xuICAgICAgICAvKiogQXV0b21hdGljYWxseSBicmVhayB0ZXh0IGFjcm9zcyBsaW5lcyAoZGVmYXVsdCB0cnVlLCBvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMud3JhcFRleHQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXJhZ3JhcGg7XG59KExhYmVsKSk7XG5leHBvcnQgeyBQYXJhZ3JhcGggfTtcbi8qKiBIMSBsYWJlbCBjb250cm9sICovXG52YXIgSGVhZGluZzEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkaW5nMSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkaW5nMSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGluZzE7XG59KExhYmVsKSk7XG5leHBvcnQgeyBIZWFkaW5nMSB9O1xuLyoqIEgyIGxhYmVsIGNvbnRyb2wgKi9cbnZhciBIZWFkaW5nMiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYWRpbmcyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRpbmcyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkaW5nMjtcbn0oTGFiZWwpKTtcbmV4cG9ydCB7IEhlYWRpbmcyIH07XG4vKiogSDMgbGFiZWwgY29udHJvbCAqL1xudmFyIEhlYWRpbmczID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGVhZGluZzMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGluZzMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRpbmczO1xufShMYWJlbCkpO1xuZXhwb3J0IHsgSGVhZGluZzMgfTtcbi8qKiBINCBsYWJlbCBjb250cm9sICovXG52YXIgSGVhZGluZzQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkaW5nNCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkaW5nNCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGluZzQ7XG59KExhYmVsKSk7XG5leHBvcnQgeyBIZWFkaW5nNCB9O1xuLyoqIEg1IGxhYmVsIGNvbnRyb2wgKi9cbnZhciBIZWFkaW5nNSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhlYWRpbmc1LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWRpbmc1KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkaW5nNTtcbn0oTGFiZWwpKTtcbmV4cG9ydCB7IEhlYWRpbmc1IH07XG4vKiogSDYgbGFiZWwgY29udHJvbCAqL1xudmFyIEhlYWRpbmc2ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGVhZGluZzYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGluZzYoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRpbmc2O1xufShMYWJlbCkpO1xuZXhwb3J0IHsgSGVhZGluZzYgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0NvbnRyb2xzL0xhYmVsLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBTdHlsZSB9IGZyb20gXCIuLi8uLi9TdHlsZVwiO1xuaW1wb3J0IHsgQ29udHJvbEVsZW1lbnQgfSBmcm9tIFwiLi9Db250cm9sRWxlbWVudFwiO1xuLyoqIFJlcHJlc2VudHMgYSBwcm9ncmVzcyBiYXIgY29udHJvbCAoZnVsbCB3aWR0aCBieSBkZWZhdWx0KSAqL1xudmFyIFByb2dyZXNzQmFyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvZ3Jlc3NCYXIsIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhIHByb2dyZXNzIGJhciBjb250cm9sIGVsZW1lbnQgKi9cbiAgICBmdW5jdGlvbiBQcm9ncmVzc0Jhcihwcm9ncmVzcykge1xuICAgICAgICBpZiAocHJvZ3Jlc3MgPT09IHZvaWQgMCkgeyBwcm9ncmVzcyA9IDA7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLyoqIEVuY2Fwc3VsYXRpb24gb2YgaW5uZXIgYmFyIHN0eWxlIChvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMuc3R5bGVfYmFyID0gbmV3IFN0eWxlKCk7XG4gICAgICAgIF90aGlzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEluaXRpYWxpemUgYSBwcm9ncmVzcyBiYXIgY29udHJvbCBmYWN0b3J5IHdpdGggZ2l2ZW4gcHJvZ3Jlc3MgdmFsdWUgKDAtMSkgKi9cbiAgICBQcm9ncmVzc0Jhci53aXRoUHJvZ3Jlc3MgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aCh7IHByb2dyZXNzOiBwcm9ncmVzcyB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX251bWJlclxuICAgIF0sIFByb2dyZXNzQmFyLnByb3RvdHlwZSwgXCJwcm9ncmVzc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIFByb2dyZXNzQmFyLnByb3RvdHlwZSwgXCJ0b29sdGlwVGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX25vdF9udWxsXG4gICAgXSwgUHJvZ3Jlc3NCYXIucHJvdG90eXBlLCBcInN0eWxlX2JhclwiLCB2b2lkIDApO1xuICAgIHJldHVybiBQcm9ncmVzc0Jhcjtcbn0oQ29udHJvbEVsZW1lbnQpKTtcbmV4cG9ydCB7IFByb2dyZXNzQmFyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9Qcm9ncmVzc0Jhci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IHsgQ29udHJvbEVsZW1lbnQgfSBmcm9tIFwiLi9Db250cm9sRWxlbWVudFwiO1xuLyoqIFJlcHJlc2VudHMgYW4gZW1wdHkgY29udHJvbCBlbGVtZW50IHRvIHRha2UgdXAgaG9yaXpvbnRhbCBzcGFjZSB3aXRoaW4gYSByb3cgKi9cbnZhciBTcGFjZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTcGFjZXIsIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhIHNwYWNlciBlbGVtZW50IHdpdGggZ2l2ZW4gaGVpZ2h0IChkZWZhdWx0IDFweCkgKi9cbiAgICBmdW5jdGlvbiBTcGFjZXIoaGVpZ2h0KSB7XG4gICAgICAgIGlmIChoZWlnaHQgPT09IHZvaWQgMCkgeyBoZWlnaHQgPSBcIjFweFwiOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogSW5pdGlhbGl6ZSBhIHNwYWNlciBjb250cm9sIGZhY3Rvcnkgd2l0aCBnaXZlbiBzaXplIChDU1MgbGVuZ3Rocyk7IGFsc28gc2V0cyBgLnNocmlua3dyYXBgIHRvIHRydWUgaWYgYSB3aWR0aCBpcyBnaXZlbiAqL1xuICAgIFNwYWNlci53aXRoU2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGgod2lkdGggP1xuICAgICAgICAgICAgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBzaHJpbmt3cmFwOiB0cnVlIH0gOlxuICAgICAgICAgICAgeyBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTcGFjZXI7XG59KENvbnRyb2xFbGVtZW50KSk7XG5leHBvcnQgeyBTcGFjZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9VSS9Db21wb25lbnRzL0NvbnRyb2xzL1NwYWNlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jIGZyb20gXCIuLi8uLi8uLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgU3R5bGUgfSBmcm9tIFwiLi4vLi4vLi4vU3R5bGVcIjtcbmltcG9ydCB7IENvbXBvbmVudFNpZ25hbCB9IGZyb20gXCIuLi8uLi9Db21wb25lbnRTaWduYWxcIjtcbmltcG9ydCB7IENvbnRyb2xFbGVtZW50IH0gZnJvbSBcIi4uL0NvbnRyb2xFbGVtZW50XCI7XG4vKiogSW5wdXQgZmllbGQgY29udHJvbCBiYXNlIGNsYXNzIChhYnN0cmFjdCkgKi9cbnZhciBJbnB1dENvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnB1dENvbnRyb2wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5wdXRDb250cm9sKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgLyoqIEVuY2Fwc3VsYXRpb24gb2YgbGFiZWwgZWxlbWVudCBzdHlsZSAob2JzZXJ2ZWQpICovXG4gICAgICAgIF90aGlzLnN0eWxlX2xhYmVsID0gbmV3IFN0eWxlKCk7XG4gICAgICAgIC8qKiBFbmNhcHN1bGF0aW9uIG9mIGlucHV0IGVsZW1lbnQgc3R5bGUgKG9ic2VydmVkKSAqL1xuICAgICAgICBfdGhpcy5zdHlsZV9pbnB1dCA9IG5ldyBTdHlsZSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dENvbnRyb2wucHJvdG90eXBlLCBcIlZhbHVlQ2hhbmdlXCIsIHtcbiAgICAgICAgLyoqIFNpZ25hbCBlbWl0dGVkIHdoZW4gdGhlIGlucHV0IHZhbHVlIGlzIGNvbW1pdHRlZCAob24gY2hhbmdlKTsgY2FwdHVyZWQgZnJvbSBjb250YWluZXJzIGRvd24gdG8gY29udGFpbmVkIGNvbXBvbmVudHMsIG5vdCBjb25zdW1lZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiQGNyZWF0ZUV2ZW50U2lnbmFsXCJdKFwiVmFsdWVDaGFuZ2VcIiwgQ29tcG9uZW50U2lnbmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0Q29udHJvbC5wcm90b3R5cGUsIFwiVmFsdWVJbnB1dFwiLCB7XG4gICAgICAgIC8qKiBTaWduYWwgZW1pdHRlZCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGlucHV0IHZhbHVlIGNoYW5nZXMgKG9uIGlucHV0KTsgY2FwdHVyZWQgZnJvbSBjb250YWluZXJzIGRvd24gdG8gY29udGFpbmVkIGNvbXBvbmVudHMsIG5vdCBjb25zdW1lZCAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wiQGNyZWF0ZUV2ZW50U2lnbmFsXCJdKFwiVmFsdWVJbnB1dFwiLCBDb21wb25lbnRTaWduYWwpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBJbnB1dENvbnRyb2wucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBJbnB1dENvbnRyb2wucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc3RyaW5nXG4gICAgXSwgSW5wdXRDb250cm9sLnByb3RvdHlwZSwgXCJ0b29sdGlwVGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgSW5wdXRDb250cm9sLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX25vdF9udWxsXG4gICAgXSwgSW5wdXRDb250cm9sLnByb3RvdHlwZSwgXCJzdHlsZV9sYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX25vdF9udWxsXG4gICAgXSwgSW5wdXRDb250cm9sLnByb3RvdHlwZSwgXCJzdHlsZV9pbnB1dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBJbnB1dENvbnRyb2wucHJvdG90eXBlLCBcIlZhbHVlQ2hhbmdlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy51bm9ic2VydmFibGVfbWVtb2l6ZV9nZXRcbiAgICBdLCBJbnB1dENvbnRyb2wucHJvdG90eXBlLCBcIlZhbHVlSW5wdXRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIElucHV0Q29udHJvbDtcbn0oQ29udHJvbEVsZW1lbnQpKTtcbmV4cG9ydCB7IElucHV0Q29udHJvbCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvSW5wdXRDb250cm9scy9JbnB1dENvbnRyb2wuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IFN0eWxlIH0gZnJvbSBcIi4uLy4uLy4uL1N0eWxlXCI7XG5pbXBvcnQgeyBJbnB1dENvbnRyb2wgfSBmcm9tIFwiLi9JbnB1dENvbnRyb2xcIjtcbi8qKiBSZXByZXNlbnRzIGEgc2luZ2xlIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbiBjb250cm9sICovXG52YXIgQ2hlY2tib3ggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGVja2JveCwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgY2hlY2tib3ggZWxlbWVudCAqL1xuICAgIGZ1bmN0aW9uIENoZWNrYm94KG5hbWUsIGxhYmVsLCB0eXBlLCBjaGVja2VkKSB7XG4gICAgICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IFwiY2hlY2tib3hcIjsgfVxuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBDaGVja2JveC5UeXBlLkNoZWNrYm94OyB9XG4gICAgICAgIGlmIChjaGVja2VkID09PSB2b2lkIDApIHsgY2hlY2tlZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBUZXh0IHZhbHVlIHVzZWQgd2hlbiBzZWxlY3RlZCAob2JzZXJ2ZWQpLCBkZWZhdWx0cyB0byBcImNoZWNrZWRcIiAqL1xuICAgICAgICBfdGhpcy52YWx1ZSA9IFwiY2hlY2tlZFwiO1xuICAgICAgICAvKiogU2V0IHRvIGZhbHNlIHRvIGV4cGFuZCBob3Jpem9udGFsbHkgd2l0aGluIHJvdyAob2JzZXJ2ZWQpICovXG4gICAgICAgIF90aGlzLnNocmlua3dyYXAgPSB0cnVlO1xuICAgICAgICAvKiogRW5jYXBzdWxhdGlvbiBvZiBpbm5lciB0ZXh0IGVsZW1lbnQgc3R5bGUgKG9ic2VydmVkKSAqL1xuICAgICAgICBfdGhpcy5zdHlsZV90ZXh0ID0gbmV3IFN0eWxlKCk7XG4gICAgICAgIF90aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgX3RoaXMuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEluaXRpYWxpemUgYSBjaGVja2JveCBjb250cm9sIGZhY3Rvcnkgd2l0aCBnaXZlbiB2YWx1ZXMgKi9cbiAgICBDaGVja2JveC53aXRoTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBsYWJlbCwgY2hlY2tlZCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aCh7IG5hbWU6IG5hbWUsIGxhYmVsOiBsYWJlbCwgY2hlY2tlZDogY2hlY2tlZCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgIH07XG4gICAgLyoqIEluaXRpYWxpemUgYSByYWRpbyBidXR0b24gY29udHJvbCBmYWN0b3J5IHdpdGggZ2l2ZW4gdmFsdWVzICovXG4gICAgQ2hlY2tib3gud2l0aFJhZGlvTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBsYWJlbCwgY2hlY2tlZCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aCh7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLCBsYWJlbDogbGFiZWwsIGNoZWNrZWQ6IGNoZWNrZWQsIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IENoZWNrYm94LlR5cGUuUmFkaW9cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgY3VycmVudCB2YWx1ZXMgb2YgaW5wdXQgZWxlbWVudHMgKG9ic2VydmFibGUpICovXG4gICAgQ2hlY2tib3gucHJvdG90eXBlLmdldEZvcm1WYWx1ZXMgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgeyByZXN1bHQgPSB7fTsgfVxuICAgICAgICBpZiAodGhpcy5uYW1lICYmICh0aGlzLmNoZWNrZWQgfHwgIXRoaXMudHlwZSkpXG4gICAgICAgICAgICByZXN1bHRbdGhpcy5uYW1lXSA9IHRoaXMuY2hlY2tlZCA/XG4gICAgICAgICAgICAgICAgKHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiBcImNoZWNrZWRcIikgOlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBTZXRzIGFsbCBpbnB1dCB2YWx1ZXMgYnkgZWxlbWVudCBuYW1lICovXG4gICAgQ2hlY2tib3gucHJvdG90eXBlLnNldEZvcm1WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgJiYgdmFsdWVzICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVzLCB0aGlzLm5hbWUpKVxuICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gdGhpcy50eXBlID9cbiAgICAgICAgICAgICAgICAodGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3RoaXMubmFtZV0gPT09IHRoaXMudmFsdWUgOlxuICAgICAgICAgICAgICAgICAgICAhIXZhbHVlc1t0aGlzLm5hbWVdKSA6XG4gICAgICAgICAgICAgICAgISF2YWx1ZXNbdGhpcy5uYW1lXTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ2hlY2tib3gucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIENoZWNrYm94LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgQ2hlY2tib3gucHJvdG90eXBlLCBcImNoZWNrZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9ub3RfbnVsbFxuICAgIF0sIENoZWNrYm94LnByb3RvdHlwZSwgXCJzdHlsZV90ZXh0XCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIENoZWNrYm94O1xufShJbnB1dENvbnRyb2wpKTtcbmV4cG9ydCB7IENoZWNrYm94IH07XG4oZnVuY3Rpb24gKENoZWNrYm94KSB7XG4gICAgdmFyIFR5cGU7XG4gICAgKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgICAgIFR5cGVbVHlwZVtcIkNoZWNrYm94XCJdID0gMF0gPSBcIkNoZWNrYm94XCI7XG4gICAgICAgIFR5cGVbVHlwZVtcIlJhZGlvXCJdID0gMV0gPSBcIlJhZGlvXCI7XG4gICAgfSkoVHlwZSA9IENoZWNrYm94LlR5cGUgfHwgKENoZWNrYm94LlR5cGUgPSB7fSkpO1xuICAgIDtcbn0pKENoZWNrYm94IHx8IChDaGVja2JveCA9IHt9KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9JbnB1dENvbnRyb2xzL0NoZWNrYm94LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBJbnB1dENvbnRyb2wgfSBmcm9tIFwiLi9JbnB1dENvbnRyb2xcIjtcbi8qKiBSZXByZXNlbnRzIGEgbmF0aXZlIGRyb3Bkb3duIHNlbGVjdGlvbiBmaWVsZCBjb250cm9sICovXG52YXIgU2VsZWN0RmllbGQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWxlY3RGaWVsZCwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgc2VsZWN0IGZpZWxkIGVsZW1lbnQgKi9cbiAgICBmdW5jdGlvbiBTZWxlY3RGaWVsZChuYW1lLCBsYWJlbCwgb3B0aW9ucykge1xuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcInNlbGVjdFwiOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IFtdO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogSW5pdGlhbGl6ZSBhIHNlbGVjdCBmaWVsZCBjb250cm9sIGZhY3Rvcnkgd2l0aCBnaXZlbiBuYW1lLCBsYWJlbCwgYW5kIG9wdGlvbnMgKi9cbiAgICBTZWxlY3RGaWVsZC53aXRoT3B0aW9ucyA9IGZ1bmN0aW9uIChuYW1lLCBsYWJlbCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBbXTsgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoKHsgbmFtZTogbmFtZSwgbGFiZWw6IGxhYmVsLCBvcHRpb25zOiBvcHRpb25zIH0pO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGN1cnJlbnQgdmFsdWVzIG9mIGlucHV0IGVsZW1lbnRzIChvYnNlcnZhYmxlKSAqL1xuICAgIFNlbGVjdEZpZWxkLnByb3RvdHlwZS5nZXRGb3JtVmFsdWVzID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsgcmVzdWx0ID0ge307IH1cbiAgICAgICAgaWYgKHRoaXMubmFtZSlcbiAgICAgICAgICAgIHJlc3VsdFt0aGlzLm5hbWVdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBTZXRzIGFsbCBpbnB1dCB2YWx1ZXMgYnkgZWxlbWVudCBuYW1lICovXG4gICAgU2VsZWN0RmllbGQucHJvdG90eXBlLnNldEZvcm1WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgJiYgdmFsdWVzICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVzLCB0aGlzLm5hbWUpKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlc1t0aGlzLm5hbWVdO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfbm90X251bGxcbiAgICBdLCBTZWxlY3RGaWVsZC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlXG4gICAgXSwgU2VsZWN0RmllbGQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFNlbGVjdEZpZWxkO1xufShJbnB1dENvbnRyb2wpKTtcbmV4cG9ydCB7IFNlbGVjdEZpZWxkIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQ29tcG9uZW50cy9Db250cm9scy9JbnB1dENvbnRyb2xzL1NlbGVjdEZpZWxkLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBJbnB1dENvbnRyb2wgfSBmcm9tIFwiLi9JbnB1dENvbnRyb2xcIjtcbi8qKiBSZXByZXNlbnRzIGEgc2luZ2xlLSBvciBtdWx0aS1saW5lIHRleHQgaW5wdXQgZmllbGQgY29udHJvbCAqL1xudmFyIFRleHRGaWVsZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHRGaWVsZCwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgdGV4dCBmaWVsZCAqL1xuICAgIGZ1bmN0aW9uIFRleHRGaWVsZChuYW1lLCBsYWJlbCwgdGV4dGFyZWFMaW5lcykge1xuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBcInRleHRcIjsgfVxuICAgICAgICBpZiAodGV4dGFyZWFMaW5lcyA9PT0gdm9pZCAwKSB7IHRleHRhcmVhTGluZXMgPSAwOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBUZXh0IGZpZWxkIHR5cGUgKHRleHQsIHBhc3N3b3JkLCBudW1iZXIsIGV0Yy47IG9ic2VydmVkKSAqL1xuICAgICAgICBfdGhpcy50eXBlID0gVGV4dEZpZWxkLlR5cGUuVGV4dDtcbiAgICAgICAgX3RoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnRleHRhcmVhTGluZXMgPSB0ZXh0YXJlYUxpbmVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBJbml0aWFsaXplIGEgdGV4dCBmaWVsZCBjb250cm9sIGZhY3Rvcnkgd2l0aCBnaXZlbiBuYW1lLCBsYWJlbCwgYW5kIHBsYWNlaG9sZGVyICovXG4gICAgVGV4dEZpZWxkLndpdGhOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGxhYmVsLCBwbGFjZWhvbGRlclRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aCh7IG5hbWU6IG5hbWUsIGxhYmVsOiBsYWJlbCwgcGxhY2Vob2xkZXJUZXh0OiBwbGFjZWhvbGRlclRleHQgfSk7XG4gICAgfTtcbiAgICAvKiogU2VsZWN0IChhIHBhcnQgb2YpIHRoZSB0ZXh0IGluIHRoaXMgdGV4dCBmaWVsZCwgcmV0dXJucyB0aGlzICovXG4gICAgVGV4dEZpZWxkLnByb3RvdHlwZS5zZWxlY3RUZXh0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgLyoqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGN1cnJlbnQgdmFsdWVzIG9mIGlucHV0IGVsZW1lbnRzIChvYnNlcnZhYmxlKSAqL1xuICAgIFRleHRGaWVsZC5wcm90b3R5cGUuZ2V0Rm9ybVZhbHVlcyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7IHJlc3VsdCA9IHt9OyB9XG4gICAgICAgIGlmICh0aGlzLm5hbWUpXG4gICAgICAgICAgICByZXN1bHRbdGhpcy5uYW1lXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogU2V0cyBhbGwgaW5wdXQgdmFsdWVzIGJ5IGVsZW1lbnQgbmFtZSAqL1xuICAgIFRleHRGaWVsZC5wcm90b3R5cGUuc2V0Rm9ybVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZSAmJiB2YWx1ZXMgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZXMsIHRoaXMubmFtZSkpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWVzW3RoaXMubmFtZV07XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZVxuICAgIF0sIFRleHRGaWVsZC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIFRleHRGaWVsZC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMub2JzZXJ2YWJsZV9zdHJpbmdcbiAgICBdLCBUZXh0RmllbGQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyVGV4dFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIFRleHRGaWVsZC5wcm90b3R5cGUsIFwiaW1tZWRpYXRlVmFsdWVVcGRhdGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMuaW5qZWN0YWJsZVxuICAgIF0sIFRleHRGaWVsZC5wcm90b3R5cGUsIFwic2VsZWN0VGV4dFwiLCBudWxsKTtcbiAgICByZXR1cm4gVGV4dEZpZWxkO1xufShJbnB1dENvbnRyb2wpKTtcbmV4cG9ydCB7IFRleHRGaWVsZCB9O1xuKGZ1bmN0aW9uIChUZXh0RmllbGQpIHtcbiAgICAvKiogVGV4dCBmaWVsZCB0eXBlIG9wdGlvbnMgKGUuZy4gVGV4dCwgUGFzc3dvcmQsIEVtYWlsIGV0Yy4pICovXG4gICAgdmFyIFR5cGU7XG4gICAgKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgICAgIFR5cGVbVHlwZVtcIlRleHRcIl0gPSAwXSA9IFwiVGV4dFwiO1xuICAgICAgICBUeXBlW1R5cGVbXCJQYXNzd29yZFwiXSA9IDFdID0gXCJQYXNzd29yZFwiO1xuICAgICAgICBUeXBlW1R5cGVbXCJEYXRlVGltZVwiXSA9IDJdID0gXCJEYXRlVGltZVwiO1xuICAgICAgICBUeXBlW1R5cGVbXCJEYXRlXCJdID0gM10gPSBcIkRhdGVcIjtcbiAgICAgICAgVHlwZVtUeXBlW1wiTW9udGhcIl0gPSA0XSA9IFwiTW9udGhcIjtcbiAgICAgICAgVHlwZVtUeXBlW1wiVGltZVwiXSA9IDVdID0gXCJUaW1lXCI7XG4gICAgICAgIFR5cGVbVHlwZVtcIldlZWtcIl0gPSA2XSA9IFwiV2Vla1wiO1xuICAgICAgICBUeXBlW1R5cGVbXCJOdW1iZXJcIl0gPSA3XSA9IFwiTnVtYmVyXCI7XG4gICAgICAgIFR5cGVbVHlwZVtcIkVtYWlsXCJdID0gOF0gPSBcIkVtYWlsXCI7XG4gICAgICAgIFR5cGVbVHlwZVtcIlVybFwiXSA9IDldID0gXCJVcmxcIjtcbiAgICAgICAgVHlwZVtUeXBlW1wiU2VhcmNoXCJdID0gMTBdID0gXCJTZWFyY2hcIjtcbiAgICAgICAgVHlwZVtUeXBlW1wiVGVsXCJdID0gMTFdID0gXCJUZWxcIjtcbiAgICAgICAgVHlwZVtUeXBlW1wiQ29sb3JcIl0gPSAxMl0gPSBcIkNvbG9yXCI7XG4gICAgfSkoVHlwZSA9IFRleHRGaWVsZC5UeXBlIHx8IChUZXh0RmllbGQuVHlwZSA9IHt9KSk7XG4gICAgO1xufSkoVGV4dEZpZWxkIHx8IChUZXh0RmllbGQgPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvQ29udHJvbHMvSW5wdXRDb250cm9scy9UZXh0RmllbGQuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvLyBiYXNlIGNsYXNzZXM6XG5leHBvcnQgKiBmcm9tIFwiLi9Db21wb25lbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NvbXBvbmVudFNpZ25hbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ29tcG9uZW50RmFjdG9yeVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ29tcG9uZW50UmVuZGVyZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1RleHRMYWJlbEZhY3RvcnlcIjtcbi8vIGNvbnRhaW5lcnM6XG5leHBvcnQgKiBmcm9tIFwiLi9Db250YWluZXJzL0NvbnRhaW5lclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ29udGFpbmVycy9EaWFsb2dDb250YWluZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NvbnRhaW5lcnMvRHJhd2VyQ29udGFpbmVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Db250YWluZXJzL0xheW91dENvbnRhaW5lclwiO1xuLy8gYmxvY2tzOlxuZXhwb3J0ICogZnJvbSBcIi4vQmxvY2tzL0Jsb2NrXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9CbG9ja3MvQ2FyZFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQmxvY2tzL0NvbnRhaW5lckJsb2NrXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9CbG9ja3MvRGl2aWRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQmxvY2tzL0xpc3RcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0Jsb2Nrcy9UcmVlTGlzdFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQmxvY2tzL1RyZWVMaXN0Um93XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9CbG9ja3MvTmF2TGlzdFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQmxvY2tzL1Jvd1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vQmxvY2tzL1RhYmxlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9CbG9ja3MvVGFibGVSb3dcIjtcbi8vIGNvbnRyb2xzOlxuZXhwb3J0ICogZnJvbSBcIi4vQ29udHJvbHMvQ29udHJvbEVsZW1lbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NvbnRyb2xzL0Jsb2NrQ29udHJvbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ29udHJvbHMvQnV0dG9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Db250cm9scy9CdXR0b25Hcm91cFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ29udHJvbHMvQ29udGFpbmVyQ29udHJvbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ29udHJvbHMvQ29udHJvbFN0YWNrXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Db250cm9scy9JY29uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Db250cm9scy9JbWFnZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ29udHJvbHMvTGFiZWxcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NvbnRyb2xzL1Byb2dyZXNzQmFyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Db250cm9scy9TcGFjZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NvbnRyb2xzL0lucHV0Q29udHJvbHMvSW5wdXRDb250cm9sXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Db250cm9scy9JbnB1dENvbnRyb2xzL0NoZWNrYm94XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Db250cm9scy9JbnB1dENvbnRyb2xzL1NlbGVjdEZpZWxkXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Db250cm9scy9JbnB1dENvbnRyb2xzL1RleHRGaWVsZFwiO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJL0NvbXBvbmVudHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCIvKiogQ3VycmVudCB1bmlxdWUgSUQsIGFwcGVuZGVkIHRvIG5hbWUgKi9cbnZhciBfdWlkID0gMDtcbi8qKiBDdXJyZW50IHN0YXR1czogYWxsIGVuYWJsZWQgb3IgZGlzYWJsZWQgKi9cbnZhciBfZW5hYmxlZCA9IHRydWU7XG4vKiogUmVwcmVzZW50cyBhIFVJIGNvbXBvbmVudCBhbmltYXRpb24gKi9cbnZhciBBbmltYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbihuYW1lKSB7XG4gICAgICAgIC8qKiBUb3RhbCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgb2YgKHRoZSBsb29waW5nIHNlZ21lbnQgb2YpIHRoaXMgYW5pbWF0aW9uLCBzZXQgYnkgaW1wbGVtZW50YXRpb24gKi9cbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaWQgPSBTdHJpbmcobmFtZSkucmVwbGFjZSgvXFxXL2csIFwiX1wiKSArIFwiX19cIiArIF91aWQrKztcbiAgICB9XG4gICAgQW5pbWF0aW9uLmVuYWJsZUFsbCA9IGZ1bmN0aW9uICgpIHsgX2VuYWJsZWQgPSB0cnVlOyB9O1xuICAgIEFuaW1hdGlvbi5kaXNhYmxlQWxsID0gZnVuY3Rpb24gKCkgeyBfZW5hYmxlZCA9IGZhbHNlOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb24sIFwiaXNFbmFibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIFBsYXkgdGhlIGFuaW1hdGlvbiBvbmNlIGZvciB0aGUgZW50aXJlIGR1cmF0aW9uLCBhbmQgdGhlbiBzdG9wIGl0ICovXG4gICAgQW5pbWF0aW9uLnByb3RvdHlwZS5wbGF5T25jZSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGFuaW0gPSB0aGlzLnBsYXkoY29tcG9uZW50KTtcbiAgICAgICAgYW5pbS5kb25lLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gYW5pbS5zdG9wKCk7IH0pO1xuICAgICAgICByZXR1cm4gYW5pbTtcbiAgICB9O1xuICAgIHJldHVybiBBbmltYXRpb247XG59KCkpO1xuZXhwb3J0IHsgQW5pbWF0aW9uIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvQW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZXhwb3J0ICogZnJvbSBcIi4vQ29tcG9uZW50c1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vU3R5bGVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1BhZ2VcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1NjcmVlblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQmluZGluZ1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vQW5pbWF0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9EcmFnXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9NZW51XCI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvVUkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJleHBvcnQgKiBmcm9tIFwiLi9VSS9pbmRleFwiO1xuaW1wb3J0ICogYXMgVUkgZnJvbSBcIi4vVUkvaW5kZXhcIjtcbmV4cG9ydCBkZWZhdWx0IFVJO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL1VJLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0ICogYXMgQXN5bmMgZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9Bc3luY1wiO1xuaW1wb3J0IHsgU3R5bGUgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG4vKiogTGFzdCBzZWxlY3Rpb24gY2xhc3Mgc2V0LCBkZWZhdWx0IGJsYW5rICovXG52YXIgX3NlbGVjdGlvbkNsYXNzID0gXCJcIjtcbi8qKiBVbmlxdWUgcmFuZG9tIGlkZW50aWZpZXIgZm9yIHRoaXMgcnVudGltZSBpbnN0YW5jZSBvZiB0aGUgbGlicmFyeSwgdXNlZCBhcyBhbiBpZGVudGlmaWVyIG9uIHBhZ2Ugcm9vdCBlbGVtZW50cyAqL1xuZXhwb3J0IHZhciB1aWQgPSBcIl9fYVwiICsgTWF0aC5yYW5kb20oKS50b0ZpeGVkKDgpLnJlcGxhY2UoL1xcRC8sIFwiXCIpO1xuLyoqIFJlcHJlc2VudHMgYSAobGl2ZSB1cGRhdGluZykgc3R5bGUgc2hlZXQsIHdpdGggYW4gb3B0aW9uYWwgYmFzZSBjbGFzcyBuYW1lOyB0aGUgc3R5bGUgc2hlZXQgY29uc2lzdHMgb2Ygb25lIG9yIG1vcmUgQ1NTIHNlbGVjdG9ycyB0aGF0IGVhY2ggY29udGFpbiBhIHJlZmVyZW5jZSB0byBhIGBTdHlsZWAgaW5zdGFuY2UgKi9cbnZhciBTdHlsZXNoZWV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQ3JlYXRlIGEgbmV3IHN0eWxlIHNoZWV0LCB3aXRoIGdpdmVuIGJhc2UgY2xhc3MgbmFtZShzKSAob3B0aW9uYWwpIGFuZCBnaXZlbiBzZWxlY3RvcnMgYW5kIHN0eWxlczsgc2VsZWN0b3JzIG1heSBiZSB3cml0dGVuIGFzIGBcIkAuLi4geyBzZWxlY3RvciB9XCJgIGZvciBlLmcuIEBrZXlmcmFtZSBhbmQgQG1lZGlhIG5lc3RlZCBhdC1ydWxlczsgYWxzbywgYC5+fmAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBmdWxsIGJhc2UgY2xhc3MgbmFtZSBhbmQgYC5+YCB3aXRoIHRoZSBmaW5hbCBwYXJ0LCBvciBpZiBub3QgaW5jbHVkZWQgdGhlbiB0aGUgYmFzZSBjbGFzcyBuYW1lIHdpbGwgYmUgcHJlcGVuZGVkICovXG4gICAgZnVuY3Rpb24gU3R5bGVzaGVldChiYXNlQ2xhc3NOYW1lLCBzaGVldCkge1xuICAgICAgICB0aGlzLl9rZXlzID0gbmV3IEFzeW5jLk9ic2VydmFibGVBcnJheSgpO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IG5ldyBBc3luYy5PYnNlcnZhYmxlVmFsdWUoKTtcbiAgICAgICAgdGhpcy5iYXNlQ2xhc3NOYW1lID0gYmFzZUNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3JzID0gbmV3IEFzeW5jLk9ic2VydmFibGVPYmplY3QoKTtcbiAgICAgICAgaWYgKHNoZWV0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2hlZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hlZXRba2V5XSAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2hlZXQsIGtleSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lKGtleSwgc2hlZXRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHNldWRvLWx1bWluYW5jZSBvZiBnaXZlbiBjb2xvciAoaW4gaGV4IGZvcm1hdCBgIzExMjIzM2Agb3IgYCMxMjNgIG9yIHJnYiBmb3JtYXQgYHJnYigyNTUsIDI1NSwgMjU1KWAgb3IgaHNsIGZvcm1hdCBgaHNsKDI1NSwgMCUsIDAlKWApIGlzIGdyZWF0ZXIgdGhhbiA1NSU7IGNhbiBiZSB1c2VkIGUuZy4gdG8gZGVjaWRlIG9uIGEgY29udHJhc3RpbmcgdGV4dCBjb2xvciBmb3IgYSBnaXZlbiBiYWNrZ3JvdW5kIGNvbG9yICovXG4gICAgU3R5bGVzaGVldC5pc0JyaWdodENvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gU3RyaW5nKGNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yWzBdID09PSBcIiNcIikge1xuICAgICAgICAgICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjXCIgKyBjb2xvclsxXSArIGNvbG9yWzFdICtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JbMl0gKyBjb2xvclsyXSArXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yWzNdICsgY29sb3JbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgciA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEsIDMpLCAxNik7XG4gICAgICAgICAgICB2YXIgZyA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDMsIDUpLCAxNik7XG4gICAgICAgICAgICB2YXIgYiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDUsIDcpLCAxNik7XG4gICAgICAgICAgICByZXR1cm4gKDAuMyAqIHIgKyAwLjYgKiBnICsgMC4xICogYikgPiAxNDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29sb3Iuc2xpY2UoMCwgNCkgPT09IFwicmdiKFwiKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGNvbG9yLnNsaWNlKDQpLnNwbGl0KFwiLFwiKS5tYXAocGFyc2VGbG9hdCk7XG4gICAgICAgICAgICByZXR1cm4gKDAuMyAqIHZbMF0gKyAwLjYgKiB2WzFdICsgMC4xICogdlsyXSkgPiAxNDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29sb3Iuc2xpY2UoMCwgNCkgPT09IFwiaHNsKFwiKSB7XG4gICAgICAgICAgICB2YXIgbHVtID0gcGFyc2VGbG9hdChjb2xvci5zbGljZSg0KS5zcGxpdChcIixcIilbMl0pO1xuICAgICAgICAgICAgcmV0dXJuIGx1bSA+IDU1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgY29sb3IgaW4gaGV4IGZvcm1hdCAoZS5nLiBgIzExMjIzM2ApIHRoYXQgbGllcyBiZXR3ZWVuIGdpdmVuIGNvbG9ycyAoaW4gaGV4IGZvcm1hdCBgIzExMjIzM2Agb3IgYCMxMjNgIG9yIHJnYiBmb3JtYXQgYHJnYigyNTUsIDI1NSwgMjU1KWApIGF0IGdpdmVuIHBvaW50ICgwLTEsIHdpdGggMCBiZWluZyB0aGUgc2FtZSBhcyB0aGUgZmlyc3QgY29sb3IsIDEgYmVpbmcgdGhlIHNhbWUgYXMgdGhlIHNlY29uZCBjb2xvciwgYW5kIDAuNSBiZWluZyBhbiBlcXVhbCBtaXgpICovXG4gICAgU3R5bGVzaGVldC5taXhDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIsIHApIHtcbiAgICAgICAgZnVuY3Rpb24gcGFyc2UoY29sb3IpIHtcbiAgICAgICAgICAgIGNvbG9yID0gU3RyaW5nKGNvbG9yKTtcbiAgICAgICAgICAgIGlmIChjb2xvclswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3IubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjXCIgKyBjb2xvclsxXSArIGNvbG9yWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yWzJdICsgY29sb3JbMl0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JbM10gKyBjb2xvclszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSwgMyksIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoY29sb3Iuc2xpY2UoMywgNSksIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoY29sb3Iuc2xpY2UoNSwgNyksIDE2KVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvci5zbGljZSgwLCA0KSA9PT0gXCJyZ2IoXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3Iuc2xpY2UoNCkuc3BsaXQoXCIsXCIpLm1hcChwYXJzZUZsb2F0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxID0gMSAtIHA7XG4gICAgICAgIHZhciBjMSA9IHBhcnNlKGNvbG9yMSk7XG4gICAgICAgIHZhciBjMiA9IHBhcnNlKGNvbG9yMik7XG4gICAgICAgIHZhciBjID0gW1xuICAgICAgICAgICAgcSAqIGMxWzBdICsgcCAqIGMyWzBdLFxuICAgICAgICAgICAgcSAqIGMxWzFdICsgcCAqIGMyWzFdLFxuICAgICAgICAgICAgcSAqIGMxWzJdICsgcCAqIGMyWzJdXG4gICAgICAgIF07XG4gICAgICAgIHZhciBoZXgyID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIChuIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgTWF0aC5mbG9vcihuKS50b1N0cmluZygxNik7IH07XG4gICAgICAgIHJldHVybiBcIiNcIiArIGhleDIoY1swXSkgKyBoZXgyKGNbMV0pICsgaGV4MihjWzJdKTtcbiAgICB9O1xuICAgIC8qKiBEaXNhYmxlIGFsbCBzdHlsZSBydWxlcyBpbiBvbmUgZ28gd2l0aG91dCByZW1vdmluZyB0aGVtICh1c2UgYC5lbmFibGUoKWAgdG8gcmV2ZXJzZSB0aGUgZWZmZWN0KTsgcmV0dXJucyB0aGlzICovXG4gICAgU3R5bGVzaGVldC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQudmFsdWUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZS1lbmFibGUgYWxsIHN0eWxlIHJ1bGVzIChhZnRlciB1c2luZyBgLmRpc2FibGUoKWAgdG8gZGlzYWJsZSB0aGVtKTsgcmV0dXJucyB0aGlzICovXG4gICAgU3R5bGVzaGVldC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZC52YWx1ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgbGlzdCBvZiBzZWxlY3RvcnMgZGVmaW5lZCBpbiB0aGlzIHN0eWxlIHNoZWV0IChvYnNlcnZhYmxlKSAqL1xuICAgIFN0eWxlc2hlZXQucHJvdG90eXBlLmxpc3RTZWxlY3RvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzLnNsaWNlKDApO1xuICAgIH07XG4gICAgU3R5bGVzaGVldC5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzdHlsZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3NlbGVjdG9ycy5oYXNPYnNlcnZhYmxlUHJvcGVydHkoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHByb3BlcnR5IG9ic2VydmFibGUgYW5kIHNldCBzdHlsZVxuICAgICAgICAgICAgQXN5bmMubWFrZVByb3BlcnR5T2JzZXJ2YWJsZSh0aGlzLl9zZWxlY3RvcnMsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChzZWxlY3Rvcik7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RvcnNbc2VsZWN0b3JdID0gKHN0eWxlIGluc3RhbmNlb2YgU3R5bGUpID9cbiAgICAgICAgICAgICAgICBzdHlsZSA6IG5ldyBTdHlsZShzdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBTdHlsZSBpbnN0YW5jZSB0byBjb21iaW5lIG9sZCBhbmQgbmV3IHN0eWxlc1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0b3JzW3NlbGVjdG9yXSA9IG5ldyBTdHlsZSgpXG4gICAgICAgICAgICAgICAgLm92ZXJyaWRlKHRoaXMuX3NlbGVjdG9yc1tzZWxlY3Rvcl0pXG4gICAgICAgICAgICAgICAgLm92ZXJyaWRlKHN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBSZW1vdmUgZGVmaW5lZCBzdHlsZXMgZm9yIGdpdmVuIHNlbGVjdG9yIG9yIHBhdHRlcm47IHJldHVybnMgdGhpcyAqL1xuICAgIFN0eWxlc2hlZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgbWF0Y2hpbmcgc2VsZWN0b3JzXG4gICAgICAgICAgICB0aGlzLl9rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci50ZXN0KGtleSkpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZWxlY3RvcnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHNlbGVjdG9yIGRpcmVjdGx5XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RvcnNbU3RyaW5nKHNlbGVjdG9yKV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogSW52b2tlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIHNlbGVjdG9yIG9mIHRoaXMgc3R5bGUgc2hlZXQsIGluY2x1ZGluZyBpbnN0YW5jZSBpZGVudGlmaWVyIGNsYXNzIGFuZCBiYXNlIGNsYXNzIChleGNlcHQgZm9yIGtleWZyYW1lIHNlbGVjdG9ycyksIGlmIGFueSwgYW5kIHRoZSByZWZlcmVuY2VkIGBTdHlsZWAgaW5zdGFuY2UsIGlmIGFueTsgdG8gYmUgdXNlZCBpbiBhbiBvYnNlcnZhYmxlIGNvbnRleHQgdG8gd2F0Y2ggZm9yIGNoYW5nZXMqL1xuICAgIFN0eWxlc2hlZXQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVkLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgYmFzZSA9ICh0aGlzLmJhc2VDbGFzc05hbWUgfHwgXCJcIik7XG4gICAgICAgIGlmIChiYXNlKVxuICAgICAgICAgICAgYmFzZSA9IFwiLlwiICsgYmFzZS50cmltKCkucmVwbGFjZSgvXFxzKy8sIFwiLlwiKTtcbiAgICAgICAgdmFyIGJhc2VMYXN0ID0gYmFzZS5yZXBsYWNlKC8uKihcXC5bXlxcLl0rKSQvLCBcIiQxXCIpO1xuICAgICAgICB2YXIgdWlkU2VsID0gXCIjXCIgKyB1aWQgKyBcIiBcIjtcbiAgICAgICAgdmFyIGtmID0gL15Aa2V5ZnJhbWVzLztcbiAgICAgICAgdGhpcy5fa2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZWN0b3JzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgaWYgKCFrZi50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGJhc2UgY2xhc3Mgd2hlcmUgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0ga2V5LnNwbGl0KC9cXHMqLFxccyovZykubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgLn4gYW5kL29yIEAuLi57IGJsb2NrIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrLmluZGV4T2YoXCIuflwiKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrLnJlcGxhY2UoL1xcLlxcflxcfi9nLCBiYXNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuXFx+L2csIGJhc2VMYXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXigoPzpbXlxce10qXFx7XFxzKik/KS8sIFwiJDFcIiArIHVpZFNlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGsucmVwbGFjZSgvXigoPzpbXlxce10qXFx7XFxzKik/KS8sIFwiJDFcIiArIHVpZFNlbCArIChiYXNlICYmIGJhc2UgKyBcIiBcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGtleWZyYW1lIHBlcmNlbnRhZ2UvZnJvbS90byBhcyBpc1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGFzcyBjYWxsYmFjayB0aGUgYXVnbWVudGVkIHNlbGVjdG9yIGFuZCBTdHlsZVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNlbGVjdG9yLCBfdGhpcy5fc2VsZWN0b3JzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTdHlsZXNoZWV0O1xufSgpKTtcbmV4cG9ydCB7IFN0eWxlc2hlZXQgfTtcbi8qKiBEZWZpbmUgZ2xvYmFsIENTUyBzdHlsZXMgZnJvbSBnaXZlbiBzdHlsZSBzaGVldCwgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgcnVudGltZSBpbnN0YW5jZTsgaWYgdGhlIGBsaXZlVXBkYXRlYCBhcmd1bWVudCBpcyBzZXQgdG8gdHJ1ZSwgY2hhbmdlcyB0byB0aGUgc3R5bGUgc2hlZXQgYW5kIGFueSBvZiBpdHMgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzIGFyZSBvYnNlcnZlZCBhbmQgcmVmbGVjdGVkIGluIHRoZSBET00gYXN5bmNocm9ub3VzbHkgKGFuZCB0aGUgYC5kaXNhYmxlYCBtZXRob2QgY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBzdHlsZXNoZWV0IGZyb20gdGhlIERPTSB0ZW1wb3JhcmlseSBvciBwZXJtYW5lbnRseSkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlc2hlZXQoc2hlZXQsIGxpdmVVcGRhdGUpIHtcbiAgICB2YXIgc3R5bGVFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgaWYgKCEoc2hlZXQgaW5zdGFuY2VvZiBTdHlsZXNoZWV0KSlcbiAgICAgICAgc2hlZXQgPSBuZXcgU3R5bGVzaGVldCh1bmRlZmluZWQsIHNoZWV0KTtcbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gcmV0dXJuIGNvbWJpbmVkIENTUyB0ZXh0IGZvciBhbGwgc2VsZWN0b3JzXG4gICAgZnVuY3Rpb24gZ2V0Q1NTVGV4dCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHZhciBsYXN0QmxvY2tJRDtcbiAgICAgICAgc2hlZXQuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBzdHlsZSkge1xuICAgICAgICAgICAgdmFyIHRleHQ7XG4gICAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgQ1NTIHRleHQgZnJvbSBzdHlsZSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZXMgPSBzdHlsZS5nZXRPdmVycmlkZXMoKTtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgICAgICBzLmZvckVhY2hQcm9wZXJ0eShmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gXCIuXCIgJiYga2V5WzBdICE9PSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL14od2Via2l0fG98bXN8bW96KS0vLCBcIi0kMS1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFN0cmluZyh2YWx1ZSkuc3BsaXQoXCJ8fFwiKS5yZXZlcnNlKCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0ga2V5ICsgXCI6IFwiICsgc3RyICsgXCI7IFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCI6c2hhZG93XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYm94IHNoYWRvdyBmb3IgZ2l2ZW4gZGVwdGggZmFjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJveFNoYWRvdyA9IGdldEJveFNoYWRvd1RleHQoTnVtYmVyKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBcImJveC1zaGFkb3c6IFwiICsgYm94U2hhZG93ICsgXCI7IFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IFwiIHtcIiArIHRleHQuc2xpY2UoMCwgLTIpICsgXCJ9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1c2Uga2V5IGFzIGVudGlyZSBDU1MgdGV4dFxuICAgICAgICAgICAgICAgIHRleHQgPSBrZXksIGtleSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcHBlbmQgc2VsZWN0b3IgYW5kIENTUyB0ZXh0LCBpZiBhbnlcbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrTWF0Y2ggPSBrZXkubWF0Y2goL14oLiopXFx7XFxzKiguKilcXHMqXFx9XFxzKiQvKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tJRCA9IGJsb2NrTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEJsb2NrSUQgIT09IGJsb2NrSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0ZXh0IHdpdGhpbiBkZWZpbmVkIEAuLi57IGJsb2NrIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBibG9ja0lEICsgXCIgeyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tNYXRjaFsyXSArIHRleHQgKyBcIn1cXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCB0ZXh0IHRvIHNhbWUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCAtMikgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja01hdGNoWzJdICsgdGV4dCArIFwifVxcblwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RCbG9ja0lEID0gYmxvY2tJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCB0ZXh0IGFmdGVyIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBrZXkgKyB0ZXh0ICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEJsb2NrSUQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGxpdmVVcGRhdGUpIHtcbiAgICAgICAgLy8ga2VlcCB0aGUgPHN0eWxlPiBlbGVtZW50IHVwZGF0ZWRcbiAgICAgICAgQXN5bmMub2JzZXJ2ZShnZXRDU1NUZXh0KS5zdWJzY3JpYmUoZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHN0eWxlRWx0LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGluc2VydCB0aGUgPHN0eWxlPiBlbGVtZW50IG9ubHkgb25jZVxuICAgICAgICBzdHlsZUVsdC50ZXh0Q29udGVudCA9IGdldENTU1RleHQoKTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsdCk7XG4gICAgfVxufVxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBhcHBseSBTdHlsZSBwcm9wZXJ0aWVzIHRvIGdpdmVuIERPTSBlbGVtZW50OyByZXR1cm5zIHRoZSBTdHlsZSBvYmplY3QgKGRvZXMgbm90IG9ic2VydmUgc3R5bGVzIGRpcmVjdGx5LCBidXQgY2FuIGJlIHVzZWQgaW4gYW4gb2JzZXJ2YWJsZSBnZXR0ZXIsIGUuZy4gdXNpbmcgYENvbXBvbmVudFJlbmRlcmVyI3dhdGNoYCB0byByZWFwcGx5IHN0eWxlcyB3aGVuIHRoZXkgY2hhbmdlKSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3R5bGVUbyhzdHlsZSwgZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgLy8gZ2V0IGEgbGlzdCBvZiBhbGwgb3ZlcnJpZGVzIHJlY3Vyc2l2ZWx5XG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSBzdHlsZS5nZXRPdmVycmlkZXMoKTtcbiAgICAgICAgdmFyIG92ZXJyaWRlc1N0ciA9IGluc3RhbmNlcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudWlkOyB9KS5qb2luKFwifFwiKTtcbiAgICAgICAgLy8gY2xlYXIgc3R5bGUgaWYgYW55IGNoYW5nZXMgb2NjdXJyZWQgc2luY2Ugc3R5bGVzIHdlcmUgbGFzdCBhcHBsaWVkXG4gICAgICAgIHZhciBsYXN0T3ZlcnJpZGVzU3RyID0gKHN0eWxlRWxlbWVudE1hcCA/IHN0eWxlRWxlbWVudE1hcC5nZXQoZWxlbWVudCkgOlxuICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVpLXN0eWxlLW1hcFwiKSkgfHwgXCJcIjtcbiAgICAgICAgaWYgKGxhc3RPdmVycmlkZXNTdHIgIT09IG92ZXJyaWRlc1N0ciAmJiBlbGVtZW50LnN0eWxlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZWxlbWVudC5zdHlsZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKGVsZW1lbnQuc3R5bGUuaXRlbShpKSk7XG4gICAgICAgICAgICBmb3IgKGkgPSBwcm9wcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21iaW5lIHNvcnRlZCBvdmVycmlkZGVuIHN0eWxlc1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IHt9O1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBmYWxzZSwgaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICBpbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3R5bGUuZm9yRWFjaFByb3BlcnR5KGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBcIjpoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgaGlkZGVuIHN0YXR1cyBpZiB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNIaWRkZW4gPSAhIXZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSBcIjpzZWxlY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBzZWxlY3Rpb24gc3RhdHVzIGlmIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSAhIXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zZWxlY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWRkL3JlbW92ZSBzZWxlY3Rpb24gY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzW1wiLlwiICsgX3NlbGVjdGlvbkNsYXNzXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09IFwiOnNoYWRvd1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBib3ggc2hhZG93IGZvciBnaXZlbiBkZXB0aCBmYWN0b3JcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5ib3hTaGFkb3cgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Qm94U2hhZG93VGV4dChOdW1iZXIodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZVswXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGNsYXNzIG5hbWUgKHN0aWxsIHByZWZpeGVkIHdpdGggZG90KVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgc3R5bGUgcHJvcGVydHkgdXNpbmcgRE9NIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBTdHJpbmcodmFsdWUpLnNwbGl0KFwifHxcIikucmV2ZXJzZSgpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBzdHI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvbGxhdGUgYW5kIHNldCBjbGFzcyBuYW1lXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgaWYgKGtleVswXSA9PT0gXCIuXCIgJiYgY2xhc3NOYW1lc1trZXldKVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSArPSBcIiBcIiArIGtleS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUuc2xpY2UoMSkgK1xuICAgICAgICAgICAgKChpc1NlbGVjdGVkICYmIF9zZWxlY3Rpb25DbGFzcykgPyBcIiBcIiArIF9zZWxlY3Rpb25DbGFzcyA6IFwiXCIpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lIHx8IGVsZW1lbnQuY2xhc3NOYW1lKVxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIC8vIGhpZGUgb3Igc2hvdyB0aGUgZWxlbWVudFxuICAgICAgICBpZiAoaXNIaWRkZW4pXG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJoaWRkZW5cIik7XG4gICAgICAgIC8vIHNlbGVjdCBvciBkZXNlbGVjdCB0aGUgZWxlbWVudFxuICAgICAgICBpZiAoaXNTZWxlY3RlZClcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKTtcbiAgICB9XG59XG4vKiogR2V0IGJveFNoYWRvdyBwcm9wZXJ0eSBmb3IgZ2l2ZW4gc2hhZG93IGhlaWdodCAoMC0xKSAqL1xuZnVuY3Rpb24gZ2V0Qm94U2hhZG93VGV4dChkKSB7XG4gICAgZCA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGQpKTtcbiAgICByZXR1cm4gXCIwIDAgXCIgKyBkICogMiArIFwicmVtIFwiICsgZCAqIC0uMjUgKyBcInJlbSByZ2JhKDAsMCwwLFwiICsgKGQgKiBkICogLjEgKyBkICogLjA4KSArIFwiKSxcIiArXG4gICAgICAgIChcIjAgXCIgKyBkICogLjg1ICsgXCJyZW0gXCIgKyBkICogMSArIFwicmVtIFwiICsgZCAqIC0uMjUgKyBcInJlbSByZ2JhKDAsMCwwLFwiICsgKGQgKiAuMTUgKyAuMSkgKyBcIiksXCIpICtcbiAgICAgICAgKFwiMCBcIiArIChkICogZCAqIC41ICsgZCAqIC42KSArIFwicmVtIFwiICsgZCAqIDEgKyBcInJlbSBcIiArIGQgKiAtMSArIFwicmVtIHJnYmEoMCwwLDAsLjQpLFwiKSArXG4gICAgICAgIChcIjAgXCIgKyBkICogZCAqIDEuNSArIFwicmVtIFwiICsgZCAqIDMgKyBcInJlbSBcIiArIGQgKiAtMSArIFwicmVtIHJnYmEoMCwwLDAsLjMpLFwiKSArXG4gICAgICAgIChcIjAgXCIgKyBkICogZCAqIDMgKyBcInJlbSBcIiArIGQgKiAyLjUgKyBcInJlbSBcIiArIGQgKiAtMiArIFwicmVtIHJnYmEoMCwwLDAsLjMpXCIpO1xufVxuLyoqIFNldCB0aGUgZ2xvYmFsIHJvb3QtZW0gdW5pdCBzaXplIGluIHBpeGVscyBvciB1c2luZyBhIENTUyB2YWx1ZSBzdHJpbmc7IHRoZSBgcmVtYCB1bml0IHNpemUgaXMgZGVmaW5lZCBhdCB0aGUgSFRNTCBsZXZlbCBhbmQgc2hvdWxkIGJlIHNldCB0byBgMTZweGAgb24gYWxsIGJyb3dzZXJzLCBob3dldmVyIHNvbWUgQ1NTIGZyYW1ld29ya3MgKGUuZy4gQm9vdHN0cmFwIDMpIG1vZGlmeSB0aGlzIHVuaXQ7IHVzZSB0aGlzIG1ldGhvZCB0byBvdmVycmlkZSB0aGUgYHJlbWAgdW5pdCBzaXplIGFnYWluICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q1NTUmVtU2l6ZShweCkge1xuICAgIHZhciBzdHJQeCA9ICh0eXBlb2YgcHggPT09IFwic3RyaW5nXCIpID8gcHggOiAocHggKyBcInB4XCIpO1xuICAgIHZhciBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgZWx0LnRleHRDb250ZW50ID0gXCJodG1sIHsgZm9udC1zaXplOiBcIiArIHN0clB4ICsgXCIgfVwiO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWx0KTtcbn1cbi8qKiBTZXQgdGhlIGNsYXNzIG5hbWUgZ2xvYmFsbHkgYXBwbGllZCB0byBzZWxlY3RlZCBpdGVtcyAoaW4gYWRkaXRpb24gdG8gdGhlIGBzZWxlY3RlZGAgRE9NIGF0dHJpYnV0ZSksIGkuZS4gdGhvc2UgaXRlbXMgc2VsZWN0ZWQgdXNpbmcgYFN0eWxlLnNlbGVjdGAgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRTZWxlY3Rpb25DbGFzcyhjbGFzc05hbWUpIHtcbiAgICBfc2VsZWN0aW9uQ2xhc3MgPSBTdHJpbmcoY2xhc3NOYW1lIHx8IFwiXCIpO1xufVxuLyoqIEdldCB0aGUgY2xhc3MgbmFtZSBnbG9iYWxseSBhcHBsaWVkIHRvIHNlbGVjdGVkIGl0ZW1zIChpZiBhbnkpICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uQ2xhc3MoKSB7XG4gICAgcmV0dXJuIF9zZWxlY3Rpb25DbGFzcztcbn1cbi8qKiBMb2FkIGV4dGVybmFsIHN0eWxlc2hlZXQocykgYnkgVVJMOyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBzdHlsZSBzaGVldChzKSBoYXZlIGJlZW4gYXBwbGllZCBPUiBhZnRlciBhIDEgc2Vjb25kIHdhaXQgKGUuZy4gd2hlbiBvZmZsaW5lIG9yIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGlzIGZ1bmN0aW9uKSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRFeHRlcm5hbENTUygpIHtcbiAgICB2YXIgdXJscyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHVybHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jLlByb21pc2UucmFjZShbXG4gICAgICAgIEFzeW5jLlByb21pc2Uuc2xlZXAoMTAwMCksXG4gICAgICAgIEFzeW5jLlByb21pc2UuYWxsKHVybHMubWFwKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXN5bmMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gZHluYW1pY2FsbHkgY3JlYXRlIGxpbmsgZWxlbWVudFxuICAgICAgICAgICAgICAgIHZhciBsaW5rRWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgICAgICAgICAgbGlua0VsdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbiAoKSB7IHJlc29sdmUoKTsgfSk7XG4gICAgICAgICAgICAgICAgbGlua0VsdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24gKCkgeyByZWplY3QobmV3IEVycm9yKCkpOyB9KTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgYXR0cmlidXRlcyBhbmQgYXBwZW5kIHRvIGhlYWRcbiAgICAgICAgICAgICAgICBsaW5rRWx0LnNldEF0dHJpYnV0ZSgncmVsJywgJ3N0eWxlc2hlZXQnKTtcbiAgICAgICAgICAgICAgICBsaW5rRWx0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgICAgICAgICAgIGxpbmtFbHQuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpLml0ZW0oMClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZENoaWxkKGxpbmtFbHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKVxuICAgIF0pO1xufVxuLyoqIFdlYWsgbWFwIChpZiBhdmFpbGFibGUpIG9mIGVsZW1lbnRzIGFuZCB0aGUgU3R5bGUgVUlEcyB0aGF0IGhhdmUgYmVlbiBhcHBsaWVkIHRvIHRoZW0gKi9cbnZhciBzdHlsZUVsZW1lbnRNYXAgPSAodHlwZW9mIFdlYWtNYXAgIT09IFwidW5kZWZpbmVkXCIpID9cbiAgICBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvRE9NL1N0eWxlc2hlZXQuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBTdHlsZXNoZWV0IH0gZnJvbSBcIi4uL1N0eWxlc2hlZXRcIjtcbmltcG9ydCB7IFN0eWxlcyB9IGZyb20gXCIuLi9TdHlsZXNcIjtcbmV4cG9ydCBkZWZhdWx0IG5ldyBTdHlsZXNoZWV0KFwiXCIsIHtcbiAgICBcIi5fX3BhZ2Vfd3JhcHBlclwiOiB7XG4gICAgICAgIGZvbnRGYW1pbHk6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmZvbnQuZmFtaWx5OyB9KSxcbiAgICAgICAgZm9udFNpemU6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLnNpemUudGV4dDsgfSlcbiAgICB9LFxuICAgIFwiaDEsaDIsaDMsaDQsaDUsaDZcIjoge1xuICAgICAgICBmb250RmFtaWx5OiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udFdlaWdodDogXCI1MDBcIixcbiAgICAgICAgbGluZUhlaWdodDogXCIxLjFlbVwiXG4gICAgfSxcbiAgICBcImgxXCI6IHsgZm9udFNpemU6IFwiMi41cmVtXCIgfSxcbiAgICBcImgyXCI6IHsgZm9udFNpemU6IFwiMnJlbVwiIH0sXG4gICAgXCJoM1wiOiB7IGZvbnRTaXplOiBcIjEuNzVyZW1cIiB9LFxuICAgIFwiaDRcIjogeyBmb250U2l6ZTogXCIxLjVyZW1cIiB9LFxuICAgIFwiaDVcIjogeyBmb250U2l6ZTogXCIxLjI1cmVtXCIgfSxcbiAgICBcImg2XCI6IHsgZm9udFNpemU6IFwiMXJlbVwiIH0sXG4gICAgXCJidXR0b24saW5wdXQsc2VsZWN0LHRleHRhcmVhLGxhYmVsXCI6IHtcbiAgICAgICAgZm9udEZhbWlseTogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjFlbVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IFwibm9ybWFsXCIsXG4gICAgICAgIG1hcmdpbjogXCIwXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBvdXRsaW5lOiBcIjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBvdmVyZmxvdzogXCJhdXRvXCIsXG4gICAgICAgIHRvdWNoQWN0aW9uOiBcIm1hbmlwdWxhdGlvblwiXG4gICAgfSxcbiAgICBcImJ1dHRvblwiOiB7IG92ZXJmbG93OiBcInZpc2libGVcIiB9LFxuICAgIFwiaW5wdXRcIjogeyBvdmVyZmxvdzogXCJ2aXNpYmxlXCIgfSxcbiAgICBcInRleHRhcmVhXCI6IHsgcmVzaXplOiBcInZlcnRpY2FsXCIgfSxcbiAgICBcImFcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgdG91Y2hBY3Rpb246IFwibWFuaXB1bGF0aW9uXCIsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCJhOmhvdmVyXCI6IHtcbiAgICAgICAgb3V0bGluZVdpZHRoOiBcIjBcIixcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCJcbiAgICB9LFxuICAgIFwiYTphY3RpdmVcIjogeyBvdXRsaW5lV2lkdGg6IFwiMFwiIH0sXG4gICAgXCJpbWdcIjogeyBib3JkZXJTdHlsZTogXCJub25lXCIgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9ET00vc3R5bGVzL3JlYm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IFN0eWxlc2hlZXQgfSBmcm9tIFwiLi4vU3R5bGVzaGVldFwiO1xuaW1wb3J0IHsgU3R5bGVzIH0gZnJvbSBcIi4uL1N0eWxlc1wiO1xuZXhwb3J0IGRlZmF1bHQgbmV3IFN0eWxlc2hlZXQoXCJcIiwge1xuICAgIC8vIHBsYWluIGxpbmtzOlxuICAgIFwiYVwiOiB7IGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5saW5rVGV4dDsgfSkgfSxcbiAgICBcImE6YWN0aXZlXCI6IHsgY29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmxpbmtWaXNpdGVkVGV4dDsgfSkgfSxcbiAgICBcImE6dmlzaXRlZFwiOiB7IGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5saW5rVmlzaXRlZFRleHQ7IH0pIH0sXG4gICAgLy8gZm9ybSBsYWJlbHMgYW5kIGNoZWNrYm94ZXMvcmFkaW9zOlxuICAgIFwiLmZvcm0tY29udHJvbC1sYWJlbFwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogXCIuMjVyZW1cIlxuICAgIH0sXG4gICAgXCIuZm9ybS1jaGVjay1sYWJlbFwiOiB7XG4gICAgICAgIG1hcmdpblJpZ2h0OiBcIi0uNXJlbSAhaW1wb3J0YW50XCIsXG4gICAgfSxcbiAgICBcIi5mb3JtLWNoZWNrLWxhYmVsID4gKlwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IFwiMS40cmVtXCIsXG4gICAgICAgIG1hcmdpblJpZ2h0OiBcIi41cmVtXCJcbiAgICB9LFxuICAgIFwiLmZvcm0tY2hlY2staW5wdXRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB0b3A6IFwiLjFlbVwiXG4gICAgfSxcbiAgICAvLyB0ZXh0L3NlbGVjdCBpbnB1dDpcbiAgICBcIi5mb3JtLWNvbnRyb2xcIjoge1xuICAgICAgICBib3JkZXJXaWR0aDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuc2l6ZS5jb250cm9sQm9yZGVyV2lkdGg7IH0pLFxuICAgICAgICBib3JkZXJTdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICBib3JkZXJDb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IuY29udHJvbEJhc2U7IH0pLFxuICAgICAgICBiYWNrZ3JvdW5kOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5iYWNrZ3JvdW5kOyB9KSxcbiAgICAgICAgY29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLnRleHQ7IH0pLFxuICAgICAgICBwYWRkaW5nOiBcIjAgLjZyZW1cIixcbiAgICAgICAgaGVpZ2h0OiBcIjIuMjVyZW1cIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5zaXplLmlucHV0Qm9yZGVyUmFkaXVzOyB9KVxuICAgIH0sXG4gICAgXCIuZm9ybS1jb250cm9sOmZvY3VzXCI6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmNvbnRyb2xGb2N1czsgfSlcbiAgICB9LFxuICAgIFwidGV4dGFyZWEuZm9ybS1jb250cm9sXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIuNnJlbVwiLFxuICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiXG4gICAgfSxcbiAgICAvLyBidXR0b25zOlxuICAgIFwiLmJ0blwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiLjRyZW0gLjc1cmVtXCIsXG4gICAgICAgIG1hcmdpbjogXCItLjI1cmVtIDBcIixcbiAgICAgICAgbWluV2lkdGg6IFwiNnJlbVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLnNpemUuYnV0dG9uQm9yZGVyUmFkaXVzOyB9KSxcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuYnRuOmZvY3VzXCI6IHtcbiAgICAgICAgb3V0bGluZVdpZHRoOiBcIjBcIlxuICAgIH0sXG4gICAgXCIuYnRuW2Rpc2FibGVkXVwiOiB7XG4gICAgICAgIGN1cnNvcjogXCJkZWZhdWx0XCIsXG4gICAgICAgIG9wYWNpdHk6IFwiLjVcIlxuICAgIH0sXG4gICAgXCIuYnRuLWdyb3VwIC5idG5cIjoge1xuICAgICAgICBtaW5XaWR0aDogXCIycmVtXCJcbiAgICB9LFxuICAgIFwiLmJ0bi1ncm91cC12ZXJ0aWNhbCAuYnRuXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSxcbiAgICBcIi5idG4tZ3JvdXAgLmJ0bjpub3QoOmZpcnN0LWNoaWxkKVwiOiB7XG4gICAgICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IFwiMFwiLFxuICAgICAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBcIjBcIlxuICAgIH0sXG4gICAgXCIuYnRuLWdyb3VwIC5idG46bm90KDpsYXN0LWNoaWxkKVwiOiB7XG4gICAgICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBcIjBcIixcbiAgICAgICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IFwiMFwiXG4gICAgfSxcbiAgICBcIi5idG4tZ3JvdXAtdmVydGljYWwgLmJ0bjpub3QoOmZpcnN0LWNoaWxkKVwiOiB7XG4gICAgICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IFwiMFwiLFxuICAgICAgICBib3JkZXJUb3BSaWdodFJhZGl1czogXCIwXCIsXG4gICAgICAgIG1hcmdpblRvcDogXCIwXCJcbiAgICB9LFxuICAgIFwiLmJ0bi1ncm91cC12ZXJ0aWNhbCAuYnRuOm5vdCg6bGFzdC1jaGlsZClcIjoge1xuICAgICAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBcIjBcIixcbiAgICAgICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IFwiMFwiLFxuICAgICAgICBtYXJnaW5Cb3R0b206IFwiMFwiXG4gICAgfSxcbiAgICAvLyAtIHByaW1hcnkgYnV0dG9uOlxuICAgIFwiLmJ0bi1wcmltYXJ5XCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IucHJpbWFyeTsgfSksXG4gICAgICAgIGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5wcmltYXJ5VGV4dDsgfSksXG4gICAgICAgIGJvcmRlcldpZHRoOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5zaXplLmNvbnRyb2xCb3JkZXJXaWR0aDsgfSksXG4gICAgICAgIGJvcmRlclN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgIGJvcmRlckNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5wcmltYXJ5OyB9KVxuICAgIH0sXG4gICAgXCIuYnRuLXByaW1hcnk6aG92ZXJcIjogeyBib3JkZXJDb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IucHJpbWFyeURhcms7IH0pIH0sXG4gICAgXCIuYnRuLXByaW1hcnk6Zm9jdXNcIjogeyBib3JkZXJDb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IucHJpbWFyeURhcms7IH0pIH0sXG4gICAgXCIuYnRuLXByaW1hcnk6YWN0aXZlLC5idG4tcHJpbWFyeS5hY3RpdmVcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5iYWNrZ3JvdW5kOyB9KSxcbiAgICAgICAgYm9yZGVyQ29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLnByaW1hcnk7IH0pLFxuICAgICAgICBjb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IudGV4dDsgfSlcbiAgICB9LFxuICAgIC8vIC0gc2Vjb25kYXJ5IChkZWZhdWx0KSBidXR0b246XG4gICAgXCIuYnRuLXNlY29uZGFyeVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmNvbnRyb2xCYXNlOyB9KSxcbiAgICAgICAgY29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmNvbnRyb2xCYXNlVGV4dDsgfSksXG4gICAgICAgIGJvcmRlcldpZHRoOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5zaXplLmNvbnRyb2xCb3JkZXJXaWR0aDsgfSksXG4gICAgICAgIGJvcmRlclN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgIGJvcmRlckNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5jb250cm9sQmFzZTsgfSlcbiAgICB9LFxuICAgIFwiLmJ0bi1zZWNvbmRhcnk6aG92ZXJcIjogeyBib3JkZXJDb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IuY29udHJvbEZvY3VzOyB9KSB9LFxuICAgIFwiLmJ0bi1zZWNvbmRhcnk6Zm9jdXNcIjogeyBib3JkZXJDb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IuY29udHJvbEZvY3VzOyB9KSB9LFxuICAgIFwiLmJ0bi1zZWNvbmRhcnk6YWN0aXZlLC5idG4tc2Vjb25kYXJ5LmFjdGl2ZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmNvbnRyb2xGb2N1czsgfSksXG4gICAgICAgIGJvcmRlckNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5jb250cm9sRm9jdXM7IH0pLFxuICAgICAgICBjb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IuY29udHJvbEZvY3VzVGV4dDsgfSlcbiAgICB9LFxuICAgIC8vIC0gbGluayBidXR0b246XG4gICAgXCIuYnRuLWxpbmtcIjoge1xuICAgICAgICBjb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IubGlua1RleHQ7IH0pLFxuICAgICAgICBib3JkZXJXaWR0aDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuc2l6ZS5jb250cm9sQm9yZGVyV2lkdGg7IH0pLFxuICAgICAgICBib3JkZXJTdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICBib3JkZXJDb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfSxcbiAgICBcIi5idG4tbGluazpob3ZlclwiOiB7XG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXG4gICAgfSxcbiAgICBcIi5idG4tbGluazpmb2N1c1wiOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5jb250cm9sQmFzZTsgfSlcbiAgICB9LFxuICAgIFwiLmJ0bi1saW5rOmFjdGl2ZSwuYnRuLWxpbmsuYWN0aXZlXCI6IHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmNvbnRyb2xCYXNlOyB9KVxuICAgIH0sXG4gICAgLy8gdGFibGVzOlxuICAgIFwiLnRhYmxlXCI6IHtcbiAgICAgICAgYm9yZGVyQ29sbGFwc2U6IFwiY29sbGFwc2VcIixcbiAgICAgICAgYmFja2dyb3VuZDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IuYmFja2dyb3VuZDsgfSksXG4gICAgICAgIGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci50ZXh0OyB9KVxuICAgIH0sXG4gICAgXCIudGFibGUgdGhlYWQgdGhcIjoge1xuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICAgICAgYm9yZGVyQm90dG9tV2lkdGg6IFwiMnB4XCIsXG4gICAgICAgIGJvcmRlckJvdHRvbVN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5kaXZpZGVyOyB9KVxuICAgIH0sXG4gICAgXCIudGFibGUgdGhcIjoge1xuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICAgICAgYm9yZGVyVG9wV2lkdGg6IFwiMXB4XCIsXG4gICAgICAgIGJvcmRlclRvcFN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgIGJvcmRlclRvcENvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5kaXZpZGVyOyB9KVxuICAgIH0sXG4gICAgXCIudGFibGUgdGRcIjoge1xuICAgICAgICBib3JkZXJUb3BXaWR0aDogXCIxcHhcIixcbiAgICAgICAgYm9yZGVyVG9wU3R5bGU6IFwic29saWRcIixcbiAgICAgICAgYm9yZGVyVG9wQ29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmRpdmlkZXI7IH0pXG4gICAgfSxcbiAgICAvLyBiYWRnZXM6XG4gICAgXCIuYmFkZ2VcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yNWVtIC40ZW1cIixcbiAgICAgICAgZm9udFNpemU6IFwiLjhlbVwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiBcIjFcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJiYXNlbGluZVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLnNpemUuYmFkZ2VCb3JkZXJSYWRpdXM7IH0pLFxuICAgICAgICBiYWNrZ3JvdW5kOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci50ZXh0OyB9KSxcbiAgICAgICAgY29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmJhY2tncm91bmQ7IH0pXG4gICAgfSxcbiAgICBcIi5iYWRnZTplbXB0eVwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgfSxcbiAgICAvLyBjYXJkczpcbiAgICBcIi5jYXJkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IuYmFja2dyb3VuZDsgfSksXG4gICAgICAgIGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci50ZXh0OyB9KSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IFwiMXB4XCIsXG4gICAgICAgIGJvcmRlclN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgIGJvcmRlckNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5kaXZpZGVyOyB9KSxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5zaXplLmNhcmRCb3JkZXJSYWRpdXM7IH0pXG4gICAgfSxcbiAgICBcIi5jYXJkLWhlYWRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLnByaW1hcnk7IH0pLFxuICAgICAgICBjb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IucHJpbWFyeVRleHQ7IH0pXG4gICAgfSxcbiAgICBcIi5jYXJkLWZvb3RlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLnByaW1hcnk7IH0pLFxuICAgICAgICBjb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IucHJpbWFyeVRleHQ7IH0pXG4gICAgfSxcbiAgICAvLyBkcm9wZG93bnMgKG1lbnVzKTpcbiAgICBcIi5kcm9wZG93bi1tZW51XCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4ycmVtIDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IuYmFja2dyb3VuZDsgfSksXG4gICAgICAgIG1pbldpZHRoOiBcIjEycmVtXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJzdGFydCB8fCBsZWZ0XCJcbiAgICB9LFxuICAgIFwiLmRyb3Bkb3duLWRpdmlkZXJcIjoge1xuICAgICAgICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICAgICAgICBoZWlnaHQ6IFwiMXB4XCIsXG4gICAgICAgIG1hcmdpbjogXCIuNXJlbSAwXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5kaXZpZGVyOyB9KVxuICAgIH0sXG4gICAgXCIuZHJvcGRvd24taXRlbVwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgbGlzdFN0eWxlOiBcIm5vbmVcIixcbiAgICAgICAgbWFyZ2luOiBcIjBcIixcbiAgICAgICAgcGFkZGluZzogXCIwIDFyZW1cIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgICAgbGluZUhlaWdodDogXCIyLjVlbVwiLFxuICAgICAgICBjb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IudGV4dDsgfSlcbiAgICB9LFxuICAgIFwiLmRyb3Bkb3duLWl0ZW06aG92ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci50ZXh0OyB9KSxcbiAgICAgICAgY29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmJhY2tncm91bmQ7IH0pLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJub25lXCIsXG4gICAgfSxcbiAgICBcIi5kcm9wZG93bi1pdGVtOmFjdGl2ZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLnRleHQ7IH0pLFxuICAgICAgICBjb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IuYmFja2dyb3VuZDsgfSlcbiAgICB9LFxuICAgIFwiLmRyb3Bkb3duLWl0ZW06Zm9jdXNcIjoge1xuICAgICAgICBvdXRsaW5lV2lkdGg6IFwiMnB4XCIsXG4gICAgICAgIG91dGxpbmVTdHlsZTogXCJzb2xpZFwiLFxuICAgICAgICBvdXRsaW5lQ29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLnRleHQ7IH0pXG4gICAgfSxcbiAgICBcIi5kcm9wZG93bi1pdGVtW2Rpc2FibGVkXVwiOiB7XG4gICAgICAgIG9wYWNpdHk6IFwiLjVcIlxuICAgIH0sXG4gICAgLy8gbmF2OlxuICAgIFwiLm5hdlwiOiB7XG4gICAgICAgIGxpc3RTdHlsZTogXCJub25lXCIsXG4gICAgICAgIG1hcmdpbjogXCIwXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiXG4gICAgfSxcbiAgICBcIi5uYXYtaXRlbVwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIGxpc3RTdHlsZTogXCJub25lXCIsXG4gICAgICAgIG1hcmdpbjogXCIwXCIsXG4gICAgICAgIG1hcmdpblJpZ2h0OiBcIi4yNXJlbVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjBcIlxuICAgIH0sXG4gICAgLy8gLSBwaWxsczpcbiAgICBcIi5uYXYtcGlsbHMgLm5hdi1saW5rXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBwYWRkaW5nOiBcIi41cmVtIDFyZW1cIixcbiAgICAgICAgbWluV2lkdGg6IFwiNXJlbVwiLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5zaXplLmJ1dHRvbkJvcmRlclJhZGl1czsgfSlcbiAgICB9LFxuICAgIFwiLm5hdi1waWxscyAubmF2LWxpbms6aG92ZXJcIjoge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJub25lXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmNvbnRyb2xCYXNlOyB9KSxcbiAgICAgICAgY29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gU3R5bGVzLmNvbG9yLmNvbnRyb2xCYXNlVGV4dDsgfSlcbiAgICB9LFxuICAgIFwiLm5hdi1waWxscyAubmF2LWxpbmsuYWN0aXZlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IucHJpbWFyeTsgfSksXG4gICAgICAgIGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5wcmltYXJ5VGV4dDsgfSlcbiAgICB9LFxuICAgIFwiLm5hdi1waWxscy5uYXYtc3RhY2tlZCAubmF2LWl0ZW1cIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIG1hcmdpbjogXCIwXCJcbiAgICB9LFxuICAgIC8vIC0gdGFiczpcbiAgICBcIi5uYXYtdGFic1wiOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbVdpZHRoOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5zaXplLmNvbnRyb2xCb3JkZXJXaWR0aDsgfSksXG4gICAgICAgIGJvcmRlckJvdHRvbVN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0eWxlcy5jb2xvci5kaXZpZGVyOyB9KVxuICAgIH0sXG4gICAgXCIubmF2LXRhYnMgLm5hdi1saW5rXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgcGFkZGluZzogXCIuNXJlbVwiLFxuICAgICAgICBtaW5XaWR0aDogXCI1cmVtXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgYm9yZGVyVG9wTGVmdFJhZGl1czogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuc2l6ZS5idXR0b25Cb3JkZXJSYWRpdXM7IH0pLFxuICAgICAgICBib3JkZXJUb3BSaWdodFJhZGl1czogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuc2l6ZS5idXR0b25Cb3JkZXJSYWRpdXM7IH0pLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJub25lXCJcbiAgICB9LFxuICAgIFwiLm5hdi10YWJzIC5uYXYtbGluazpob3ZlclwiOiB7XG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcIm5vbmVcIixcbiAgICAgICAgYmFja2dyb3VuZDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IuY29udHJvbEJhc2U7IH0pLFxuICAgICAgICBjb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IuY29udHJvbEJhc2VUZXh0OyB9KVxuICAgIH0sXG4gICAgXCIubmF2LXRhYnMgLm5hdi1saW5rLmFjdGl2ZVwiOiB7XG4gICAgICAgIG1hcmdpbkJvdHRvbTogXCItNHB4XCIsXG4gICAgICAgIGJvcmRlckJvdHRvbVN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgIGJvcmRlckJvdHRvbVdpZHRoOiBcIjRweFwiLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBTdHlsZXMuY29sb3IucHJpbWFyeTsgfSlcbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL1VJL0RPTS9zdHlsZXMvY29udHJvbHMuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBTdHlsZXNoZWV0LCBhcHBseVN0eWxlc2hlZXQgfSBmcm9tIFwiLi9TdHlsZXNoZWV0XCI7XG5pbXBvcnQgcmVib290U3R5bGVzRGVmaW5pdGlvbiBmcm9tIFwiLi9zdHlsZXMvcmVib290XCI7XG5pbXBvcnQgY29udHJvbFN0eWxlc0RlZmluaXRpb24gZnJvbSBcIi4vc3R5bGVzL2NvbnRyb2xzXCI7XG4vKiogQSBzZXQgb2YgcHJlZGVmaW5lZCBzdHlsZXMgYW5kIHN0eWxlIHNoZWV0cyB0aGF0IGFyZSB1c2VkIGJ5IHNwZWNpZmljIGNvbXBvbmVudHM7IHRoZXNlIG1heSBiZSBtb2RpZmllZCB0byBhcHBseSBhIFwidGhlbWVcIiwgd2hpY2ggd2lsbCBnZW5lcmFsbHkgdXBkYXRlIGFsbCBzdHlsZXMgaW4gdGhlIERPTSBhc3luY2hyb25vdXNseTsgX2hvd2V2ZXJfLCBzdHlsZXMgZGVmaW5lZCBoZXJlIGFyZSBzdWJqZWN0IHRvIGNoYW5nZSBmb3Igbm93IGFuZCBpdCBpcyBub3QgZ3VhcmFudGVlZCB0aGF0IHNlbGVjdG9ycyBhbmQgY2xhc3MgbmFtZXMgd2lsbCBjb250aW51ZSB0byBleGlzdCBhY3Jvc3MgdmVyc2lvbnMgKi9cbmV4cG9ydCB2YXIgU3R5bGVzO1xuKGZ1bmN0aW9uIChTdHlsZXMpIHtcbiAgICAvKiogR3JvdXBzIGJhc2ljIGNvbXBvbmVudCBzdHlsZSBzaGVldCBkZWZpbml0aW9ucyB0b2dldGhlciwgaW5kZXhlZCBieSBjbGFzcyBuYW1lIChlLmcuIFwiVUktQ29udGFpbmVyXCIpICovXG4gICAgU3R5bGVzLmNvbXBvbmVudHMgPSB7fTtcbiAgICAvKiogQ29udGFpbnMgYmFzaWMgZm9udCBzZXR0aW5ncyB0aGF0IGFyZSBhcHBsaWVkIGdsb2JhbGx5IGZvciB0aGlzIGluc3RhbmNlOyB0byBkaXNhYmxlLCBlaXRoZXIgc2V0IHZhbHVlKHMpIHRvIGBpbmhlcml0YCwgb3IgZGlzYWJsZSBgY3NzUmVzZXRgIGFsdG9nZXRoZXIgKi9cbiAgICBTdHlsZXMuZm9udCA9IEFzeW5jLm9ic2VydmUoe1xuICAgICAgICAvKiogQmFzZSBmb250IGZhbWlseSAoZGVmYXVsdHMgdG8gc3lzdGVtIGZvbnQgc3RhY2spICovXG4gICAgICAgIGZhbWlseTogXCItYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgT3h5Z2VuLVNhbnMsIFVidW50dSwgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIHNhbnMtc2VyaWZcIlxuICAgIH0pO1xuICAgIC8qKiBDb250YWlucyBiYXNpYyBtZWFzdXJlbWVudHMgdGhhdCBkZXRlcm1pbmUgdGhlIHNpemluZyBvZiB0ZXh0IGFuZCBjZXJ0YWluIGNvbXBvbmVudHM7IGN1c3RvbSBvYnNlcnZhYmxlIHByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIGhlcmUgaWYgcmVxdWlyZWQgKi9cbiAgICBTdHlsZXMuc2l6ZSA9IEFzeW5jLm9ic2VydmUoe1xuICAgICAgICAvKiogQmFzZSBmb250IHNpemUgdXNlZCBmb3IgbWFpbiBhcHBsaWNhdGlvbiBsYXlvdXQgYW5kIGRpYWxvZ3MvZHJhd2VycyAoZGVmYXVsdHMgdG8gYDFyZW1gKSAqL1xuICAgICAgICB0ZXh0OiBcIjFyZW1cIixcbiAgICAgICAgLyoqIFBhcmFncmFwaCBsYWJlbCBsaW5lIGhlaWdodCAoZGVmYXVsdHMgdG8gYDEuNjVlbWApICovXG4gICAgICAgIHBhcmFncmFwaExpbmVIZWlnaHQ6IFwiMS42NWVtXCIsXG4gICAgICAgIC8qKiBEZWZhdWx0IHNwYWNlIGFyb3VuZCBjb250cm9sIGVsZW1lbnRzIChkZWZhdWx0cyB0byBgMXJlbWApICovXG4gICAgICAgIGNvbnRyb2xTcGFjaW5nOiBcIjFyZW1cIixcbiAgICAgICAgLyoqIE91dGxpbmUgd2lkdGggb2YgZm9jdXNlZCBzZWxlY3RlZCBsaXN0IGVsZW1lbnRzIChkZWZhdWx0cyB0byBgMGAsIGJlY2F1c2UgYmFja2dyb3VuZCBhbmQgdGV4dCBjb2xvcmluZyBpcyBhcHBsaWVkIGluc3RlYWQpICovXG4gICAgICAgIGxpc3RTZWxlY3Rpb25Gb2N1c091dGxpbmU6IFwiMFwiLFxuICAgICAgICAvKiogRGVmYXVsdCBib3JkZXIgcmFkaXVzIG9mIGFsbCBkaWFsb2dzIChkZWZhdWx0cyB0byBgLjI1cmVtYCkgKi9cbiAgICAgICAgZGlhbG9nQm9yZGVyUmFkaXVzOiBcIi4yNXJlbVwiLFxuICAgICAgICAvKiogRGVmYXVsdCBib3JkZXIgcmFkaXVzIG9mIGNhcmQgY29tcG9uZW50cyAoZGVmYXVsdHMgdG8gYC4yNXJlbWApICovXG4gICAgICAgIGNhcmRCb3JkZXJSYWRpdXM6IFwiLjI1cmVtXCIsXG4gICAgICAgIC8qKiBEZWZhdWx0IGJvcmRlciByYWRpdXMgb2YgYmFkZ2UgZWxlbWVudHMgKGRlZmF1bHRzIHRvIGAuMjVyZW1gKSAqL1xuICAgICAgICBiYWRnZUJvcmRlclJhZGl1czogXCIuMjVyZW1cIixcbiAgICAgICAgLyoqIERlZmF1bHQgYm9yZGVyIHJhZGl1cyBvZiBhbGwgYnV0dG9ucyAoZGVmYXVsdHMgdG8gYDBgKSAqL1xuICAgICAgICBidXR0b25Cb3JkZXJSYWRpdXM6IFwiMFwiLFxuICAgICAgICAvKiogRGVmYXVsdCBib3JkZXIgcmFkaXVzIG9mIHRleHQvc2VsZWN0IGlucHV0IGVsZW1lbnRzIChkZWZhdWx0cyB0byBgMGApICovXG4gICAgICAgIGlucHV0Qm9yZGVyUmFkaXVzOiBcIjBcIixcbiAgICAgICAgLyoqIERlZmF1bHQgYm9yZGVyIHdpZHRoIG9mIGFsbCBjb250cm9scyAoZS5nLiBidXR0b25zLCBpbnB1dCBlbGVtZW50cywgZGVmYXVsdHMgdG8gYDJweGApICovXG4gICAgICAgIGNvbnRyb2xCb3JkZXJXaWR0aDogXCIycHhcIlxuICAgIH0pO1xuICAgIC8qKiBDb250YWlucyBhbiBvYnNlcnZhYmxlIGNvbG9yIHNjaGVtZSBiYXNlZCBvbiB0aGUgY29sb3Igd2hlZWwsIHdpdGggYSBzZWxlY3Rpb24gb2YgcHJpbWFyeSBhbmQgYWNjZW50IGNvbG9yczsgY3VzdG9tIG9ic2VydmFibGUgcHJvcGVydGllcyBjYW4gYmUgYWRkZWQgaGVyZSBpZiByZXF1aXJlZCAqL1xuICAgIFN0eWxlcy5jb2xvciA9IEFzeW5jLm9ic2VydmUoe1xuICAgICAgICAvKiogRGFya2VzdCBibGFjayB0aGF0IG1hdGNoZXMgdGhlIGNvbG9yIHNjaGVtZSAqL1xuICAgICAgICBibGFjazogXCIjMDAwMDAwXCIsXG4gICAgICAgIC8qKiBMaWdodGVzdCB3aGl0ZSB0aGF0IG1hdGNoZXMgdGhlIGNvbG9yIHNjaGVtZSAqL1xuICAgICAgICB3aGl0ZTogXCIjZmZmZmZmXCIsXG4gICAgICAgIC8qKiBEYXJrZXIgZ3JheSBjb2xvciB0aGF0IG1hdGNoZXMgdGhlIGNvbG9yIHNjaGVtZSAqL1xuICAgICAgICBkYXJrZXJHcmF5OiBcIiMzMzMzMzNcIixcbiAgICAgICAgLyoqIERhcmsgdG8gbWlkLWdyYXkgY29sb3IgdGhhdCBtYXRjaGVzIHRoZSBjb2xvciBzY2hlbWUgKi9cbiAgICAgICAgZGFya0dyYXk6IFwiIzc3Nzc3N1wiLFxuICAgICAgICAvKiogTGlnaHQgZ3JheSBjb2xvciB0aGF0IG1hdGNoZXMgdGhlIGNvbG9yIHNjaGVtZSAqL1xuICAgICAgICBsaWdodEdyYXk6IFwiI2RkZGRkZFwiLFxuICAgICAgICAvKiogQmx1ZWlzaCAoc2lsdmVyKSBkYXJrIHRvIG1pZC1ncmF5IGNvbG9yIHRoYXQgbWF0Y2hlcyB0aGUgY29sb3Igc2NoZW1lICovXG4gICAgICAgIHNsYXRlOiBcIiM2Njc3ODhcIixcbiAgICAgICAgLyoqIEJsdWVpc2ggKHNpbHZlcikgbGlnaHQgZ3JheSBjb2xvciB0aGF0IG1hdGNoZXMgdGhlIGNvbG9yIHNjaGVtZSAqL1xuICAgICAgICBsaWdodFNsYXRlOiBcIiNjMGM4ZDBcIixcbiAgICAgICAgLyoqIEJyaWdodCByZWQgY29sb3IgdGhhdCBtYXRjaGVzIHRoZSBjb2xvciBzY2hlbWUgKi9cbiAgICAgICAgcmVkOiBcIiNlZTMzMzNcIixcbiAgICAgICAgLyoqIEJyaWdodCBvcmFuZ2UgY29sb3IgdGhhdCBtYXRjaGVzIHRoZSBjb2xvciBzY2hlbWUgKi9cbiAgICAgICAgb3JhbmdlOiBcIiNlZTk5MjJcIixcbiAgICAgICAgLyoqIEJyaWdodCB5ZWxsb3cgY29sb3IgdGhhdCBtYXRjaGVzIHRoZSBjb2xvciBzY2hlbWUgKi9cbiAgICAgICAgeWVsbG93OiBcIiNkZGNjMzNcIixcbiAgICAgICAgLyoqIEJyaWdodCBsaW1lIGdyZWVuIGNvbG9yIHRoYXQgbWF0Y2hlcyB0aGUgY29sb3Igc2NoZW1lICovXG4gICAgICAgIGxpbWU6IFwiIzk5YmIzM1wiLFxuICAgICAgICAvKiogQnJpZ2h0IGdyZWVuIGNvbG9yIHRoYXQgbWF0Y2hlcyB0aGUgY29sb3Igc2NoZW1lICovXG4gICAgICAgIGdyZWVuOiBcIiM0NGFhNDRcIixcbiAgICAgICAgLyoqIEJyaWdodCB0dXJxdW9pc2UgY29sb3IgdGhhdCBtYXRjaGVzIHRoZSBjb2xvciBzY2hlbWUgKi9cbiAgICAgICAgdHVycXVvaXNlOiBcIiMzM2FhYWFcIixcbiAgICAgICAgLyoqIEJyaWdodCBjeWFuIGNvbG9yIHRoYXQgbWF0Y2hlcyB0aGUgY29sb3Igc2NoZW1lICovXG4gICAgICAgIGN5YW46IFwiIzMzYmJiYlwiLFxuICAgICAgICAvKiogQnJpZ2h0IGJsdWUgY29sb3IgdGhhdCBtYXRjaGVzIHRoZSBjb2xvciBzY2hlbWUgKi9cbiAgICAgICAgYmx1ZTogXCIjMzM1NWFhXCIsXG4gICAgICAgIC8qKiBCcmlnaHQgdmlvbGV0IGNvbG9yIHRoYXQgbWF0Y2hlcyB0aGUgY29sb3Igc2NoZW1lICovXG4gICAgICAgIHZpb2xldDogXCIjNTUzM2FhXCIsXG4gICAgICAgIC8qKiBCcmlnaHQgcHVycGxlIGNvbG9yIHRoYXQgbWF0Y2hlcyB0aGUgY29sb3Igc2NoZW1lICovXG4gICAgICAgIHB1cnBsZTogXCIjODgzM2FhXCIsXG4gICAgICAgIC8qKiBCcmlnaHQgbWFnZW50YSBjb2xvciB0aGF0IG1hdGNoZXMgdGhlIGNvbG9yIHNjaGVtZSAqL1xuICAgICAgICBtYWdlbnRhOiBcIiNkZDQ0ODhcIixcbiAgICAgICAgLyoqIEJhY2tncm91bmQgY29sb3IgZm9yIG1haW4gYXBwbGljYXRpb24gbGF5b3V0IGFuZCBkaWFsb2dzL2RyYXdlcnMsIGRlZmF1bHRzIHRvIHB1cmUgd2hpdGUgKi9cbiAgICAgICAgYmFja2dyb3VuZDogXCIjZmZmZmZmXCIsXG4gICAgICAgIC8qKiBUZXh0IGNvbG9yIGZvciBtYWluIGFwcGxpY2F0aW9uIGxheW91dCBhbmQgZGlhbG9ncy9kcmF3ZXJzIChkZWZhdWx0cyB0byA4MCUgb3BhcXVlIGJsYWNrKSAqL1xuICAgICAgICB0ZXh0OiBcInJnYmEoMCwwLDAsLjgpXCIsXG4gICAgICAgIC8qKiBGYWRlZCB0ZXh0IGNvbG9yIHVzZWQgZm9yIHNtYWxsZXIgdGV4dCBiZWZvcmUvYWZ0ZXIgbGFiZWwgdGV4dCAoZGVmYXVsdHMgdG8gNDUlIG9wYXF1ZSBibGFjaykgKi9cbiAgICAgICAgdGV4dEZhZGVkOiBcInJnYmEoMCwwLDAsLjQ1KVwiLFxuICAgICAgICAvKiogRGVmYXVsdCBkaXZpZGVyIGNvbG9yIChkZWZhdWx0cyB0byAyMCUgb3BhcXVlIGJsYWNrKSAqL1xuICAgICAgICBkaXZpZGVyOiBcInJnYmEoMCwwLDAsLjIpXCIsXG4gICAgICAgIC8qKiBQcmltYXJ5IGhpZ2hsaWdodCBjb2xvciAoZGVmYXVsdHMgdG8gYC5ibHVlYCksIHVzdWFsbHkgYSBicmlnaHQgY29sb3IgZm9yIGUuZy4gaGVhZGluZyByb3cgYmFja2dyb3VuZHM7IHNldCB0aGlzIHByb3BlcnR5IHRvIGNoYW5nZSBhbGwgcHJpbWFyeSogcHJvcGVydGllcywgX29yXyBzZXQgdGhvc2UgZGlyZWN0bHkgYXMgd2VsbCAqL1xuICAgICAgICBnZXQgcHJpbWFyeSgpIHsgcmV0dXJuIHRoaXMucHJpbWFyeSB8fCB0aGlzLmJsdWU7IH0sXG4gICAgICAgIHNldCBwcmltYXJ5KHYpIHsgdGhpcy5wcmltYXJ5ID0gdjsgfSxcbiAgICAgICAgLyoqIFRleHQgY29sb3IgdG8gYmUgdXNlZCBvbiB0b3Agb2YgcHJpbWFyeS1jb2xvcmVkIGJhY2tncm91bmRzICovXG4gICAgICAgIGdldCBwcmltYXJ5VGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW1hcnlUZXh0IHx8XG4gICAgICAgICAgICAgICAgKFN0eWxlc2hlZXQuaXNCcmlnaHRDb2xvcih0aGlzLnByaW1hcnkpID9cbiAgICAgICAgICAgICAgICAgICAgU3R5bGVzaGVldC5taXhDb2xvcnModGhpcy5wcmltYXJ5LCBcIiMwMDAwMDBcIiwgLjgpIDpcbiAgICAgICAgICAgICAgICAgICAgXCIjZmZmZmZmXCIpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgcHJpbWFyeVRleHQodikgeyB0aGlzLnByaW1hcnlUZXh0ID0gdjsgfSxcbiAgICAgICAgLyoqIERhcmtlciBzaGFkZSBvZiB0aGUgcHJpbWFyeSBjb2xvciAqL1xuICAgICAgICBnZXQgcHJpbWFyeURhcmsoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5RGFyayB8fFxuICAgICAgICAgICAgICAgIFN0eWxlc2hlZXQubWl4Q29sb3JzKHRoaXMucHJpbWFyeSwgXCIjMDAwMDAwXCIsIC4yKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHByaW1hcnlEYXJrKHYpIHsgdGhpcy5wcmltYXJ5RGFyayA9IHY7IH0sXG4gICAgICAgIC8qKiBMaWdodGVyIHNoYWRlIG9mIHRoZSBwcmltYXJ5IGNvbG9yICovXG4gICAgICAgIGdldCBwcmltYXJ5TGlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmltYXJ5TGlnaHQgfHxcbiAgICAgICAgICAgICAgICBTdHlsZXNoZWV0Lm1peENvbG9ycyh0aGlzLnByaW1hcnksIFwiI2ZmZmZmZlwiLCAuMik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBwcmltYXJ5TGlnaHQodikgeyB0aGlzLnByaW1hcnlMaWdodCA9IHY7IH0sXG4gICAgICAgIC8qKiBBY2NlbnQgY29sb3IgKGRlZmF1bHRzIHRvIGAudmlvbGV0YCksIGRlbm90ZXMgaW50ZXJhY3RpdmUgZWxlbWVudHMsIHVzdWFsbHkgYSBicmlnaHQgY29sb3IgZm9yIGUuZy4gYmFja2dyb3VuZHMgb2YgYnV0dG9ucyB0aGF0IHNob3VsZCBzdGFuZCBvdXQ7IHNldCB0aGlzIHByb3BlcnR5IHRvIGNoYW5nZSBgLmFjY2VudFRleHRgIGFzIHdlbGwsIF9vcl8gc2V0IHRoYXQgZGlyZWN0bHkgdG8gb3ZlcnJpZGUgdGhlIGFjY2VudCB0ZXh0IGNvbG9yICovXG4gICAgICAgIGdldCBhY2NlbnQoKSB7IHJldHVybiB0aGlzLmFjY2VudCB8fCB0aGlzLnZpb2xldDsgfSxcbiAgICAgICAgc2V0IGFjY2VudCh2KSB7IHRoaXMuYWNjZW50ID0gdjsgfSxcbiAgICAgICAgLyoqIFRleHQgY29sb3IgdG8gYmUgdXNlZCBvbiB0b3Agb2YgYWNjZW50LWNvbG9yZWQgYmFja2dyb3VuZHMgKi9cbiAgICAgICAgZ2V0IGFjY2VudFRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnRUZXh0IHx8XG4gICAgICAgICAgICAgICAgKFN0eWxlc2hlZXQuaXNCcmlnaHRDb2xvcih0aGlzLmFjY2VudCkgP1xuICAgICAgICAgICAgICAgICAgICBTdHlsZXNoZWV0Lm1peENvbG9ycyh0aGlzLmFjY2VudCwgXCIjMDAwMDAwXCIsIC44KSA6XG4gICAgICAgICAgICAgICAgICAgIFwiI2ZmZmZmZlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGFjY2VudFRleHQodikgeyB0aGlzLmFjY2VudFRleHQgPSB2OyB9LFxuICAgICAgICAvKiogRGFya2VyIHNoYWRlIG9mIHRoZSBhY2NlbnQgY29sb3IgKi9cbiAgICAgICAgZ2V0IGFjY2VudERhcmsoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnREYXJrIHx8XG4gICAgICAgICAgICAgICAgU3R5bGVzaGVldC5taXhDb2xvcnModGhpcy5hY2NlbnQsIFwiIzAwMDAwMFwiLCAuMik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBhY2NlbnREYXJrKHYpIHsgdGhpcy5hY2NlbnREYXJrID0gdjsgfSxcbiAgICAgICAgLyoqIExpZ2h0ZXIgc2hhZGUgb2YgdGhlIGFjY2VudCBjb2xvciAqL1xuICAgICAgICBnZXQgYWNjZW50TGlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnRMaWdodCB8fFxuICAgICAgICAgICAgICAgIFN0eWxlc2hlZXQubWl4Q29sb3JzKHRoaXMuYWNjZW50LCBcIiNmZmZmZmZcIiwgLjIpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgYWNjZW50TGlnaHQodikgeyB0aGlzLmFjY2VudExpZ2h0ID0gdjsgfSxcbiAgICAgICAgLyoqIExpbmsgdGV4dCBjb2xvciAoZGVmYXVsdHMgdG8gYC5ibHVlYCk7IHNldCB0aGlzIHByb3BlcnR5IHRvIGNoYW5nZSBgLmxpbmtWaXNpdGVkVGV4dGAgYXMgd2VsbCwgX29yXyBzZXQgdGhhdCBkaXJlY3RseSB0byBvdmVycmlkZSB0aGUgdmlzaXRlZCBsaW5rIHRleHQgY29sb3IgKi9cbiAgICAgICAgZ2V0IGxpbmtUZXh0KCkgeyByZXR1cm4gdGhpcy5saW5rVGV4dCB8fCB0aGlzLmJsdWU7IH0sXG4gICAgICAgIHNldCBsaW5rVGV4dCh2KSB7IHRoaXMubGlua1RleHQgPSB2OyB9LFxuICAgICAgICAvKiogVmlzaXRlZCBsaW5rIHRleHQgY29sb3IgKGRlZmF1bHRzIHRvIGEgZGFya2VyIHZlcnNpb24gb2YgbGluayB0ZXh0KSAqL1xuICAgICAgICBnZXQgbGlua1Zpc2l0ZWRUZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlua1Zpc2l0ZWRUZXh0IHx8XG4gICAgICAgICAgICAgICAgU3R5bGVzaGVldC5taXhDb2xvcnModGhpcy5saW5rVGV4dCwgXCIjMDAwMDAwXCIsIC4zNSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBsaW5rVmlzaXRlZFRleHQodikgeyB0aGlzLmxpbmtWaXNpdGVkVGV4dCA9IHY7IH0sXG4gICAgICAgIC8qKiBUaXRsZSBiYXIgYmxvY2sgY29sb3IgKGRlZmF1bHRzIHRvIGAuZGFya2VyR3JheWApOyBzZXQgdGhpcyBwcm9wZXJ0eSB0byBjaGFuZ2UgYC50aXRsZUJhclRleHRgIGFzIHdlbGwsIF9vcl8gc2V0IHRoYXQgZGlyZWN0bHkgdG8gb3ZlcnJpZGUgdGhlIHRpdGxlIGJhciB0ZXh0IGNvbG9yICovXG4gICAgICAgIGdldCB0aXRsZUJhckJhY2tncm91bmQoKSB7IHJldHVybiB0aGlzLnRpdGxlQmFyQmFja2dyb3VuZCB8fCB0aGlzLmRhcmtlckdyYXk7IH0sXG4gICAgICAgIHNldCB0aXRsZUJhckJhY2tncm91bmQodikgeyB0aGlzLnRpdGxlQmFyQmFja2dyb3VuZCA9IHY7IH0sXG4gICAgICAgIC8qKiBUZXh0IGNvbG9yIHRvIGJlIHVzZWQgb24gdG9wIG9mIHRpdGxlIGJhciBibG9ja3MgKi9cbiAgICAgICAgZ2V0IHRpdGxlQmFyVGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpdGxlQmFyVGV4dCB8fFxuICAgICAgICAgICAgICAgIChTdHlsZXNoZWV0LmlzQnJpZ2h0Q29sb3IodGhpcy50aXRsZUJhckJhY2tncm91bmQpID9cbiAgICAgICAgICAgICAgICAgICAgU3R5bGVzaGVldC5taXhDb2xvcnModGhpcy50aXRsZUJhckJhY2tncm91bmQsIFwiIzAwMDAwMFwiLCAuOCkgOlxuICAgICAgICAgICAgICAgICAgICBcIiNmZmZmZmZcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB0aXRsZUJhclRleHQodikgeyB0aGlzLnRpdGxlQmFyVGV4dCA9IHY7IH0sXG4gICAgICAgIC8qKiBTZWxlY3RlZCBidXQgbm9uLWZvY3VzZWQgbGlzdCBpdGVtIGJsb2NrIGNvbG9yIChkZWZhdWx0cyB0byBgLmRhcmtHcmF5YCk7IHNldCB0aGlzIHByb3BlcnR5IHRvIGNoYW5nZSBgLmxpc3RTZWxlY3Rpb25UZXh0YCBhcyB3ZWxsLCBfb3JfIHNldCB0aGF0IGRpcmVjdGx5IHRvIG92ZXJyaWRlIHRoZSBzZWxlY3RlZCBsaXN0IGl0ZW0gdGV4dCBjb2xvciAqL1xuICAgICAgICBnZXQgbGlzdFNlbGVjdGlvbkJhY2tncm91bmQoKSB7IHJldHVybiB0aGlzLmxpc3RTZWxlY3Rpb25CYWNrZ3JvdW5kIHx8IHRoaXMuZGFya0dyYXk7IH0sXG4gICAgICAgIHNldCBsaXN0U2VsZWN0aW9uQmFja2dyb3VuZCh2KSB7IHRoaXMubGlzdFNlbGVjdGlvbkJhY2tncm91bmQgPSB2OyB9LFxuICAgICAgICAvKiogVGV4dCBjb2xvciB0byBiZSB1c2VkIG9uIHRvcCBvZiBzZWxlY3RlZCBidXQgbm9uLWZvY3VzZWQgbGlzdCBpdGVtcyAqL1xuICAgICAgICBnZXQgbGlzdFNlbGVjdGlvblRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0U2VsZWN0aW9uVGV4dCB8fFxuICAgICAgICAgICAgICAgIChTdHlsZXNoZWV0LmlzQnJpZ2h0Q29sb3IodGhpcy5saXN0U2VsZWN0aW9uQmFja2dyb3VuZCkgP1xuICAgICAgICAgICAgICAgICAgICBTdHlsZXNoZWV0Lm1peENvbG9ycyh0aGlzLmxpc3RTZWxlY3Rpb25CYWNrZ3JvdW5kLCBcIiMwMDAwMDBcIiwgLjgpIDpcbiAgICAgICAgICAgICAgICAgICAgXCIjZmZmZmZmXCIpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgbGlzdFNlbGVjdGlvblRleHQodikgeyB0aGlzLmxpc3RTZWxlY3Rpb25UZXh0ID0gdjsgfSxcbiAgICAgICAgLyoqIFNlbGVjdGVkIGZvY3VzZWQgbGlzdCBpdGVtIGJsb2NrIGNvbG9yIChkZWZhdWx0cyB0byBkYXJrZXIgdmVyc2lvbiBvZiBgLmxpc3RTZWxlY3Rpb25CYWNrZ3JvdW5kYCk7IHNldCB0aGlzIHByb3BlcnR5IHRvIGNoYW5nZSBgLmxpc3RTZWxlY3Rpb25Gb2N1c1RleHRgIGFzIHdlbGwsIF9vcl8gc2V0IHRoYXQgZGlyZWN0bHkgdG8gb3ZlcnJpZGUgdGhlIHNlbGVjdGVkIGxpc3QgaXRlbSB0ZXh0IGNvbG9yICovXG4gICAgICAgIGdldCBsaXN0U2VsZWN0aW9uRm9jdXNCYWNrZ3JvdW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdFNlbGVjdGlvbkZvY3VzQmFja2dyb3VuZCB8fFxuICAgICAgICAgICAgICAgIFN0eWxlc2hlZXQubWl4Q29sb3JzKHRoaXMubGlzdFNlbGVjdGlvbkJhY2tncm91bmQsIFwiIzAwMDAwMFwiLCAuMzUpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgbGlzdFNlbGVjdGlvbkZvY3VzQmFja2dyb3VuZCh2KSB7IHRoaXMubGlzdFNlbGVjdGlvbkZvY3VzQmFja2dyb3VuZCA9IHY7IH0sXG4gICAgICAgIC8qKiBUZXh0IGNvbG9yIHRvIGJlIHVzZWQgb24gdG9wIG9mIHNlbGVjdGVkIGZvY3VzZWQgbGlzdCBpdGVtcyAqL1xuICAgICAgICBnZXQgbGlzdFNlbGVjdGlvbkZvY3VzVGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RTZWxlY3Rpb25Gb2N1c1RleHQgfHxcbiAgICAgICAgICAgICAgICAoU3R5bGVzaGVldC5pc0JyaWdodENvbG9yKHRoaXMubGlzdFNlbGVjdGlvbkZvY3VzQmFja2dyb3VuZCkgP1xuICAgICAgICAgICAgICAgICAgICBTdHlsZXNoZWV0Lm1peENvbG9ycyh0aGlzLmxpc3RTZWxlY3Rpb25Gb2N1c0JhY2tncm91bmQsIFwiIzAwMDAwMFwiLCAuOCkgOlxuICAgICAgICAgICAgICAgICAgICBcIiNmZmZmZmZcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBsaXN0U2VsZWN0aW9uRm9jdXNUZXh0KHYpIHsgdGhpcy5saXN0U2VsZWN0aW9uRm9jdXNUZXh0ID0gdjsgfSxcbiAgICAgICAgLyoqIENvbnRyb2wgYmFzZSBjb2xvciAoZGVmYXVsdHMgdG8gYC5saWdodEdyYXlgKTsgc2V0IHRoaXMgcHJvcGVydHkgdG8gY2hhbmdlIGAuY29udHJvbEJhc2VUZXh0YCBhcyB3ZWxsLCBfb3JfIHNldCB0aGF0IGRpcmVjdGx5IHRvIG92ZXJyaWRlIHRoZSBjb250cm9sIGJhc2UgdGV4dCBjb2xvciAqL1xuICAgICAgICBnZXQgY29udHJvbEJhc2UoKSB7IHJldHVybiB0aGlzLmNvbnRyb2xCYXNlIHx8IHRoaXMubGlnaHRHcmF5OyB9LFxuICAgICAgICBzZXQgY29udHJvbEJhc2UodikgeyB0aGlzLmNvbnRyb2xCYXNlID0gdjsgfSxcbiAgICAgICAgLyoqIFRleHQgY29sb3IgdG8gYmUgdXNlZCBmb3IgY29udHJvbHMgaW4gYmFzZSBjb2xvciAqL1xuICAgICAgICBnZXQgY29udHJvbEJhc2VUZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbEJhc2VUZXh0IHx8XG4gICAgICAgICAgICAgICAgKFN0eWxlc2hlZXQuaXNCcmlnaHRDb2xvcih0aGlzLmNvbnRyb2xCYXNlKSA/XG4gICAgICAgICAgICAgICAgICAgIFN0eWxlc2hlZXQubWl4Q29sb3JzKHRoaXMuY29udHJvbEJhc2UsIFwiIzAwMDAwMFwiLCAuOCkgOlxuICAgICAgICAgICAgICAgICAgICBcIiNmZmZmZmZcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCBjb250cm9sQmFzZVRleHQodikgeyB0aGlzLmNvbnRyb2xCYXNlVGV4dCA9IHY7IH0sXG4gICAgICAgIC8qKiBDb250cm9sIGZvY3VzIGNvbG9yIChkZWZhdWx0cyB0byBhIGRhcmtlciBvciBsaWdodGVyIHZlcnNpb24gb2YgYC5jb250cm9sQmFzZWAgZGVwZW5kaW5nIG9uIGl0cyBsaWdodG5lc3MpOyBzZXQgdGhpcyBwcm9wZXJ0eSB0byBjaGFuZ2UgYC5jb250cm9sRm9jdXNUZXh0YCBhcyB3ZWxsLCBfb3JfIHNldCB0aGF0IGRpcmVjdGx5IHRvIG92ZXJyaWRlIHRoZSB0ZXh0IGNvbG9yIGZvciBjb250cm9scyBpbiBmb2N1cyBjb2xvciAqL1xuICAgICAgICBnZXQgY29udHJvbEZvY3VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbEZvY3VzIHx8XG4gICAgICAgICAgICAgICAgKFN0eWxlc2hlZXQuaXNCcmlnaHRDb2xvcih0aGlzLmNvbnRyb2xCYXNlKSA/XG4gICAgICAgICAgICAgICAgICAgIFN0eWxlc2hlZXQubWl4Q29sb3JzKHRoaXMuY29udHJvbEJhc2UsIFwiIzAwMDAwMFwiLCAuNSkgOlxuICAgICAgICAgICAgICAgICAgICBTdHlsZXNoZWV0Lm1peENvbG9ycyh0aGlzLmNvbnRyb2xCYXNlLCBcIiNmZmZmZmZcIiwgLjUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGNvbnRyb2xGb2N1cyh2KSB7IHRoaXMuY29udHJvbEZvY3VzID0gdjsgfSxcbiAgICAgICAgLyoqIFRleHQgY29sb3IgdG8gYmUgdXNlZCBmb3IgY29udHJvbHMgaW4gZm9jdXMgY29sb3IgKi9cbiAgICAgICAgZ2V0IGNvbnRyb2xGb2N1c1RleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sRm9jdXNUZXh0IHx8XG4gICAgICAgICAgICAgICAgKFN0eWxlc2hlZXQuaXNCcmlnaHRDb2xvcih0aGlzLmNvbnRyb2xGb2N1cykgP1xuICAgICAgICAgICAgICAgICAgICBTdHlsZXNoZWV0Lm1peENvbG9ycyh0aGlzLmNvbnRyb2xGb2N1cywgXCIjMDAwMDAwXCIsIC44KSA6XG4gICAgICAgICAgICAgICAgICAgIFwiI2ZmZmZmZlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IGNvbnRyb2xGb2N1c1RleHQodikgeyB0aGlzLmNvbnRyb2xGb2N1c1RleHQgPSB2OyB9XG4gICAgfSk7XG4gICAgLyoqIENTUyByZWJvb3Qgc3R5bGVzaGVldCB0aGF0IGRlZmluZXMgYmFzaWMgc3R5bGVzIGZvciBjb21tb24gSFRNTCBlbGVtZW50cyAoZXhjZXB0IHRob3NlIGFscmVhZHkgb3ZlcnJpZGRlbiBieSBgQ29tcG9uZW50YCByZW5kZXJlcnMpLCBfZW5hYmxlZCBieSBkZWZhdWx0XzogYXBwbGllZCBhcyBhIGxpdmUgc3R5bGVzaGVldCBhdCB0aGUgcGFnZSBsZXZlbCBmb3IgdGhpcyBpbnN0YW5jZTsgY2FuIGJlIG1vZGlmaWVkIHRvIGFkanVzdCBvciBhZGQgQ1NTIHJlc2V0IHN0eWxlcywgb3IgZGlzYWJsZWQgdXNpbmcgdGhlIGAuZGlzYWJsZSgpYCBtZXRob2QgaWYgYW4gZXh0ZXJuYWwgQ1NTIHJlc2V0IHN0eWxlc2hlZXQgaXMgYWxyZWFkeSBsb2FkZWQgKi9cbiAgICBTdHlsZXMucmVib290U3R5bGVzID0gcmVib290U3R5bGVzRGVmaW5pdGlvbjtcbiAgICAvKiogQmFzaWMgY29udHJvbCB0aGVtZSBzdHlsZXNoZWV0IHRoYXQgdXNlcyBjb2xvcnMgZnJvbSB0aGUgYC5jb2xvcmAgb2JqZWN0LCBfZW5hYmxlZCBieSBkZWZhdWx0XzogYXBwbGllZCBhcyBhIGxpdmUgc3R5bGVzaGVldCBhdCB0aGUgcGFnZSBsZXZlbCBmb3IgdGhpcyBpbnN0YW5jZTsgY2FuIGJlIG1vZGlmaWVkIHRvIGFkanVzdCBvciBhZGQgQ1NTIHJlc2V0IHN0eWxlcywgb3IgZGlzYWJsZWQgdXNpbmcgdGhlIGAuZGlzYWJsZSgpYCBtZXRob2QgaWYgZXh0ZXJuYWwgQ1NTIHN0eWxlcyBhcmUgYWxyZWFkeSBsb2FkZWQgKi9cbiAgICBTdHlsZXMuY29udHJvbFN0eWxlcyA9IGNvbnRyb2xTdHlsZXNEZWZpbml0aW9uO1xuICAgIC8qKiBAaW50ZXJuYWwgQWRkIGEgY29tcG9uZW50IHN0eWxlIHNoZWV0IHRvIGAuY29tcG9uZW50c2AgYW5kIGFwcGx5IGl0IHRvIHRoZSBET00gKHVzaW5nIGBuZXcgU3R5bGVzaGVldCguLi4pYCBhbmQgYC5hcHBseVN0eWxlc2hlZXQoLi4uKWApICovXG4gICAgZnVuY3Rpb24gZGVmaW5lKGNsYXNzTmFtZSwgc3ViU3R5bGVzKSB7XG4gICAgICAgIHZhciBzaGVldCA9IG5ldyBTdHlsZXNoZWV0KGNsYXNzTmFtZSwgc3ViU3R5bGVzKTtcbiAgICAgICAgU3R5bGVzLmNvbXBvbmVudHNbY2xhc3NOYW1lLnJlcGxhY2UoLy4qXFxzLywgXCJcIildID0gc2hlZXQ7XG4gICAgICAgIGFwcGx5U3R5bGVzaGVldChzaGVldCwgdHJ1ZSk7XG4gICAgfVxuICAgIFN0eWxlcy5kZWZpbmUgPSBkZWZpbmU7XG59KShTdHlsZXMgfHwgKFN0eWxlcyA9IHt9KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9ET00vU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiLyoqIE9wdGlvbnMgdGhhdCBjb250cm9sIHBhZ2UgcmVuZGVyaW5nICovXG5leHBvcnQgdmFyIFBBR0VfT1BUSU9OUyA9IHtcbiAgICBiYXNlWkluZGV4OiAxMDAwLFxuICAgIHNoYWRlVHJhbnNpdGlvbjogMjAwLFxuICAgIHNoYWRlT3BhY2l0eTogLjIsXG4gICAgc2hhZGVDb2xvcjogXCIjMDAwXCJcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9ET00vRE9NUGFnZU9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBBbmltYXRpb24sIENvbXBvbmVudCB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCAqIGFzIERPTSBmcm9tIFwiLi9ET01cIjtcbi8qKiBUaW1lIChtcykgdG8gd2FpdCBiZWZvcmUgYW5pbWF0aW5nIGFwcGVhcmFuY2Ugb2Ygc3ViLXN1YmNvbXBvbmVudHMgKi9cbnZhciBTVUJDT01QT05FTlRfQU5JTV9DVVRPRkZfTVMgPSAyMDAwO1xuLyoqIE1heCBudW1iZXIgb2YgY2hpbGQgY29tcG9uZW50cyB0byBhbmltYXRlICovXG52YXIgTUFYX05fQ09NUE9ORU5UX0FOSU0gPSAxMDA7XG4vKiogQGludGVybmFsIFJlcHJlc2VudHMgdGhlIERPTSB1cGRhdGVyIGNvbnRleHQ7IHN0b3JlZCBpbiB0aGUgY29tcG9uZW50IHJlbmRlciBvdXRwdXQgb2JqZWN0LCBvciBpbiB0aGUgcmVuZGVyaW5nIGNvbnRleHQgb3duaW5nIHNjb3BlIChlLmcuIHBhZ2UgcmVuZGVyZXIpICovXG52YXIgVXBkYXRlQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIENyZWF0ZSBhIG5ldyB1cGRhdGVyIGNvbnRleHQgZm9yIGdpdmVuIEhUTUwgcGFyZW50IGVsZW1lbnQgKi9cbiAgICBmdW5jdGlvbiBVcGRhdGVDb250ZXh0KHJvb3QpIHtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCBVcGRhdGUgc2VxdWVuY2UgbnVtYmVyICovXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICAgICAgaWYgKCFyb290KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgfVxuICAgIC8qKiBVcGRhdGUgdGhlIHJvb3QgZWxlbWVudCB3aXRoIGdpdmVuIGNvbnRlbnQgKERPTSBub2RlcywgcmVuZGVyIG91dHB1dCwgb3IgY29tcG9uZW50cywgd2hpY2ggYXJlIHJlbmRlcmVkIGFzeW5jaHJvbm91c2x5KTsgaWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIGl0IGlzIHVzZWQgdG8gc2VsZWN0IGEgZGlmZmVyZW50IERPTSBub2RlIGZyb20gdGhlIGBlbGVtZW50c2Agb2JqZWN0IG9mIGFsbCByZW5kZXIgb3V0cHV0IGluc3RhbmNlcyAoZS5nLiB3cmFwcGVyIGVsZW1lbnRzKTsgcmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSBET00gZWxlbWVudHMgaGF2ZSBhY3R1YWxseSBiZWVuIHVwZGF0ZWQgKGFsdGhvdWdoIHN1YiBjb21wb25lbnRzIG1heSBzdGlsbCBub3QgaGF2ZSBiZWVuIGZ1bGx5IHJlbmRlcmVkKSAqL1xuICAgIFVwZGF0ZUNvbnRleHQucHJvdG90eXBlLnVwZGF0ZUFzeW5jID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVzZVdyYXBwZXIsIGFuaW1hdGVQb3NpdGlvbk1TKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIGlkID0gKyt0aGlzLl91cGRhdGVJRDtcbiAgICAgICAgdGhpcy5fbkFuaW0gPSAwO1xuICAgICAgICAvLyBmaW5kIE5vZGVzIGZvciBhbGwgZ2l2ZW4gZWxlbWVudHNcbiAgICAgICAgdmFyIGRlZmVyUmVuZGVyO1xuICAgICAgICB2YXIgc2VlbiA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gY29udGVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBjb250ZW50W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1lbWJlciB0aGlzIGNvbXBvbmVudCwgYW5kIHByZXBhcmUgYXN5bmMgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuW2l0ZW0udWlkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzW2ldID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgc2VlbltpdGVtLnVpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmZXIgPSB0aGlzLl9yZW5kZXJDb21wb25lbnQoaXRlbSwgbm9kZXMsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVmZXJSZW5kZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJSZW5kZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyUmVuZGVyLnB1c2goZGVmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uaXNDb21wb25lbnRPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgb3duaW5nIGNvbXBvbmVudCwgYW5kIHN0b3JlIG91dHB1dCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBpdGVtLmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5bY29tcG9uZW50LnVpZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgc2Vlbltjb21wb25lbnQudWlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaV0gPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gdXNlV3JhcHBlciAmJiBpdGVtLndyYXBwZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgZ2l2ZW4gRE9NIG5vZGUgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzY2hlZHVsZSBkZWZlcnJlZCByZW5kZXJpbmcgZm9yIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHJlbmRlcmVkIHlldFxuICAgICAgICBpZiAoZGVmZXJSZW5kZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGRlZmVySWR4ID0gZGVmZXJSZW5kZXIubGVuZ3RoIC0gMTsgZGVmZXJJZHggPj0gMDsgZGVmZXJJZHgtLSkge1xuICAgICAgICAgICAgICAgIEFzeW5jLmRlZmVyKGRlZmVyUmVuZGVyW2RlZmVySWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gY2hpbGQgbm9kZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcbiAgICAgICAgcmV0dXJuIG5ldyBBc3luYy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBBc3luYy5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBydW4gdXBkYXRlIChpLmUuIGFkZC9jaGFuZ2UvcmVtb3ZlIGNoaWxkIG5vZGVzKSwgaWYgbm8gb3RoZXJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgd2FzIHNjaGVkdWxlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3VwZGF0ZUlEID09PSBpZClcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZUNoaWxkTm9kZXMoYW5pbWF0ZVBvc2l0aW9uTVMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCBBY3F1aXJlIHRoZSByZW5kZXJlZCBET00gbm9kZSBmb3IgZ2l2ZW4gY29udGVudCwgYW5kIHBsYWNlIGl0IGluIGdpdmVuIGFycmF5IGF0IGdpdmVuIGluZGV4OyByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgZGVmZXJyZWQgaWYgZ2l2ZW4gY29tcG9uZW50IGlzIG5vdCByZW5kZXJlZCB5ZXQgKi9cbiAgICBVcGRhdGVDb250ZXh0LnByb3RvdHlwZS5fcmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgbm9kZXMsIGkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbXBvbmVudC5nZXRMYXN0UmVuZGVyZWRPdXRwdXQoKSB8fFxuICAgICAgICAgICAgY29tcG9uZW50LnJlbmRlck9wdGlvbnMgJiZcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucmVuZGVyT3B0aW9ucy5zeW5jaHJvbm91cykge1xuICAgICAgICAgICAgLy8gc3RvcmUgZXhpc3Rpbmcgb3V0cHV0IGVsZW1lbnQgcmlnaHQgYXdheSwgb3IgZm9yY2Ugc3luYyByZW5kZXJcbiAgICAgICAgICAgIHZhciBvdXQgPSBjb21wb25lbnQub3V0O1xuICAgICAgICAgICAgbm9kZXNbaV0gPSBvdXQgJiYgb3V0LmVsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc3RvcmUgcGxhY2Vob2xkZXIgZmlyc3QsIHRoZW4gcmVzb2x2ZSBhc3luY2hyb25vdXNseVxuICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcInBsYWNlaG9sZGVyXCIpO1xuICAgICAgICAgICAgbm9kZXNbaV0gPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIC8vIGRlcGVuZCBvbiBhIGR1bW15IG9ic2VydmFibGUsIHRvIG1ha2Ugc3VyZSB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIC5vdXQgZGVwZW5kcyBvbiB0aGUgbmVzdGVkIGNvbXBvbmVudCdzIC5vdXQgZXZlbnR1YWxseTtcbiAgICAgICAgICAgIC8vIGJ1dCBkbyBub3QgcmUtcmVuZGVyIChiZWNhdXNlIHRoZSB2YWx1ZSByZW1haW5zIHVuZGVmaW5lZClcbiAgICAgICAgICAgIHZhciBvID0gQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQXN5bmMuT2JzZXJ2YWJsZVZhbHVlKCk7IH0pO1xuICAgICAgICAgICAgby52YWx1ZTtcbiAgICAgICAgICAgIC8vIHJldHVybiBhIGNhbGxiYWNrIHRvIHJlbmRlciBhc3luY2hyb25vdXNseVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgZ2V0dGVyIHRvIGFkZCBkZXBlbmRlbmNpZXMgdG8gZXhpc3Rpbmcgb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICAgIG8uZ2V0dGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IGNvbXBvbmVudC5vdXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbHQgPSBvdXQgJiYgb3V0LmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlciBpcyBhbHJlYWR5IGluIHBsYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlci5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbHQsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkgeyBfdGhpcy5fYW5pbWF0ZUFwcGVhcihjb21wb25lbnQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlcmVkIGJlZm9yZSBwbGFjZWhvbGRlciB3YXMgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gZWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkudXBkYXRlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsIFVwZGF0ZSBjaGlsZCBub2RlcyAqL1xuICAgIFVwZGF0ZUNvbnRleHQucHJvdG90eXBlLl91cGRhdGVDaGlsZE5vZGVzID0gZnVuY3Rpb24gKGFuaW1hdGVQb3NpdGlvbk1TKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGVDaGlsZENvbXBvbmVudHMoYW5pbWF0ZVBvc2l0aW9uTVMpO1xuICAgICAgICAvLyByZXBsYWNlIGV4aXN0aW5nIGVsZW1lbnRzIGZpcnN0XG4gICAgICAgIHZhciBuTm9kZXMgPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3QsIGN1cnJlbnQgPSByb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbk5vZGVzICYmIGN1cnJlbnQ7IGkrKykge1xuICAgICAgICAgICAgLy8gc2tpcCBvdmVyIHVubWFuYWdlZCBub2Rlc1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuaGFzQXR0cmlidXRlICYmXG4gICAgICAgICAgICAgICAgY3VycmVudC5oYXNBdHRyaWJ1dGUoVXBkYXRlQ29udGV4dC5VTk1BTkFHRURfRkxBRykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXBsYWNlIHdpdGggdGFyZ2V0IG5vZGVcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcInBsYWNlaG9sZGVyXCIpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUgJiZcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShVcGRhdGVDb250ZXh0LlVOTUFOQUdFRF9GTEFHKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBub2RlKVxuICAgICAgICAgICAgICAgIHJvb3QucmVwbGFjZUNoaWxkKG5vZGUsIGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IG5vZGUpXG4gICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWxldGUgdHJhaWxpbmcgZXhpc3RpbmcgZWxlbWVudHNcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmICghY3VycmVudC5oYXNBdHRyaWJ1dGUgfHxcbiAgICAgICAgICAgICAgICAhY3VycmVudC5oYXNBdHRyaWJ1dGUoVXBkYXRlQ29udGV4dC5VTk1BTkFHRURfRkxBRykpXG4gICAgICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChjdXJyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBuZXcgZWxlbWVudHMgaWYgbmVlZGVkXG4gICAgICAgIGZvciAoOyBpIDwgbk5vZGVzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcInBsYWNlaG9sZGVyXCIpO1xuICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0ZVBvc2l0aW9uTVMgPiAwKVxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUNoaWxkUG9zaXRpb25zKGFuaW1hdGVQb3NpdGlvbk1TKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgQW5pbWF0ZSBkaWZmZXJlbmNlcyB3aXRoIGxhc3QgdXBkYXRlIChhcHBlYXIvZGlzYXBwZWFyKSAqL1xuICAgIFVwZGF0ZUNvbnRleHQucHJvdG90eXBlLl9hbmltYXRlQ2hpbGRDb21wb25lbnRzID0gZnVuY3Rpb24gKGFuaW1hdGVQb3NpdGlvbk1TKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGZpbmQgYXBwZWFyaW5nIGFuZCBkaXNhcHBlYXJpbmcgY29tcG9uZW50cyB1c2luZyBvbGQgYXJyYXlzXG4gICAgICAgIHZhciBvbGRDb21wb25lbnRzID0gdGhpcy5fb2xkQ29tcG9uZW50cztcbiAgICAgICAgdmFyIG9sZE5vZGVzID0gdGhpcy5fb2xkTm9kZXM7XG4gICAgICAgIHRoaXMuX29sZENvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG4gICAgICAgIHRoaXMuX29sZE5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgICAgdGhpcy5fdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gaWYgYW5pbWF0aW5nIHBvc2l0aW9ucywgZ2V0IGN1cnJlbnQgY29vcmRpbmF0ZXMgZmlyc3RcbiAgICAgICAgaWYgKGFuaW1hdGVQb3NpdGlvbk1TID4gMClcbiAgICAgICAgICAgIHRoaXMuX3NhdmVDaGlsZFBvc2l0aW9ucygpO1xuICAgICAgICAvLyBhbmltYXRlIGFwcGVhcmFuY2VzIGFuZCBkaXNhcHBlYXJhbmNlc1xuICAgICAgICBpZiAoQW5pbWF0aW9uLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIGN1dG9mZlRpbWUgPSBEYXRlLm5vdygpIC0gU1VCQ09NUE9ORU5UX0FOSU1fQ1VUT0ZGX01TO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY29tcG9uZW50czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAvLyBhbmltYXRlIGFsbCBpdGVtcyB0aGF0IHdlcmUgbm90IHRoZXJlIGJlZm9yZVxuICAgICAgICAgICAgICAgIGlmIChjICYmICghb2xkQ29tcG9uZW50cyB8fFxuICAgICAgICAgICAgICAgICAgICAhb2xkQ29tcG9uZW50cy5zb21lKGZ1bmN0aW9uIChvbGRjKSB7IHJldHVybiBvbGRjID09PSBjOyB9KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUFwcGVhcihjKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5pbWF0ZSBleGlzdGluZyBzdWIgY29tcG9uZW50cywgaWYgYWRkZWQgPjJzIGFnb1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkT3V0ID0gYy5nZXRMYXN0UmVuZGVyZWRPdXRwdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZE91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZE91dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuZXN0ZWRPdXRbXCJAY29udGV4dFwiXSBpbnN0YW5jZW9mIFVwZGF0ZUNvbnRleHQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkT3V0W1wiQGNvbnRleHRcIl0uX3RpbWVzdGFtcCA8IGN1dG9mZlRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRPdXRbXCJAY29udGV4dFwiXS5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkT3V0W1wiQGNvbnRleHRcIl0uY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChuQykgeyBfdGhpcy5fYW5pbWF0ZUFwcGVhcihuQyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uQW5pbSA+IE1BWF9OX0NPTVBPTkVOVF9BTklNKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbGRDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGUgYW5kIGZsYWcgYWxsIGl0ZW1zIHRoYXQgYXJlIG5vdCB0aGVyZSBhbnltb3JlXG4gICAgICAgICAgICAgICAgICAgIGMgPSBvbGRDb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyAmJiBjLmFuaW1hdGlvbnMgJiYgYy5hbmltYXRpb25zLmRpc2FwcGVhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCA9IG9sZE5vZGVzICYmIG9sZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZUVsZW1lbnQgJiYgcmVtb3ZlRWxlbWVudC5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzXzEuY29tcG9uZW50cy5zb21lKGZ1bmN0aW9uIChuZXdjKSB7IHJldHVybiBuZXdjID09PSBjOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbHRfMSA9IHJlbW92ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWx0XzEuc2V0QXR0cmlidXRlKFVwZGF0ZUNvbnRleHQuVU5NQU5BR0VEX0ZMQUcsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuX25BbmltKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxheWluZyA9IGMuYW5pbWF0aW9ucy5kaXNhcHBlYXIucGxheU9uY2UoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgY29tcG9uZW50IHN0eWxlIG1hbnVhbGx5IGhlcmUsIHNpbmNlIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIG5vIGxvbmdlciB3YXRjaGVkIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RPdXQgPSBjLmdldExhc3RSZW5kZXJlZE91dHB1dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNFbHQgPSBsYXN0T3V0ICYmIGxhc3RPdXQuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjRWx0ICYmIERPTS5hcHBseVN0eWxlVG8oYy5zdHlsZSwgY0VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBkb25lLCBjaGVjayBpZiBub3QgcmUtYXBwZWFyZWQsIGFuZCByZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGF5aW5nLmRvbmUudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbHRfMS5wYXJlbnROb2RlID09PSBfdGhpcy5yb290ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHRfMS5oYXNBdHRyaWJ1dGUoVXBkYXRlQ29udGV4dC5VTk1BTkFHRURfRkxBRykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRlUG9zaXRpb25NUyA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NhdmVDaGlsZFBvc2l0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucm9vdC5yZW1vdmVDaGlsZChlbHRfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0ZVBvc2l0aW9uTVMgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRlQ2hpbGRQb3NpdGlvbnMoYW5pbWF0ZVBvc2l0aW9uTVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNfMS5fbkFuaW0gPiBNQVhfTl9DT01QT05FTlRfQU5JTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc18xID0gdGhpcywgYywgcmVtb3ZlRWxlbWVudCwgcGxheWluZywgbGFzdE91dCwgY0VsdDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2xkQ29tcG9uZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCBIZWxwZXIgZnVuY3Rpb24gdGhhdCBwbGF5cyB0aGUgXCJhcHBlYXJcIiBhbmltYXRpb24gZm9yIGdpdmVuIGNvbXBvbmVudCwgaWYgYW55ICovXG4gICAgVXBkYXRlQ29udGV4dC5wcm90b3R5cGUuX2FuaW1hdGVBcHBlYXIgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuX25BbmltKys7XG4gICAgICAgIGlmIChBbmltYXRpb24uaXNFbmFibGVkICYmXG4gICAgICAgICAgICBjb21wb25lbnQgJiYgY29tcG9uZW50LmFuaW1hdGlvbnMgJiZcbiAgICAgICAgICAgIGNvbXBvbmVudC5hbmltYXRpb25zLmFwcGVhcilcbiAgICAgICAgICAgIGNvbXBvbmVudC5hbmltYXRpb25zLmFwcGVhci5wbGF5T25jZShjb21wb25lbnQpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCBIZWxwZXIgZnVuY3Rpb24gdG8gc2F2ZSBjdXJyZW50IGNoaWxkIHBvc2l0aW9ucywgdG8gYmUgdXNlZCBieSBgX2FuaW1hdGVDaGlsZFBvc2l0aW9uc2AgKi9cbiAgICBVcGRhdGVDb250ZXh0LnByb3RvdHlwZS5fc2F2ZUNoaWxkUG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb2xkWFBvcyA9IHRoaXMuX29sZFhQb3MgPSB7fTtcbiAgICAgICAgdmFyIG9sZFlQb3MgPSB0aGlzLl9vbGRZUG9zID0ge307XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICB2YXIgZWx0ID0gX3RoaXMubm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoYyAmJiBlbHQgJiYgZWx0Lm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGVsdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY3QgfHwgIXJlY3Qud2lkdGggfHwgIXJlY3QuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgb2xkWFBvc1tjLnVpZF0gPSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgb2xkWVBvc1tjLnVpZF0gPSByZWN0LnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsIEFuaW1hdGUgcG9zaXRpb24gZGlmZmVyZW5jZXMgd2l0aCBsYXN0IHVwZGF0ZSAodHJhbnNsYXRlKSAqL1xuICAgIFVwZGF0ZUNvbnRleHQucHJvdG90eXBlLl9hbmltYXRlQ2hpbGRQb3NpdGlvbnMgPSBmdW5jdGlvbiAoYW5pbWF0ZVBvc2l0aW9uc01TKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fb2xkWFBvcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgdmFyIGVsdCA9IF90aGlzLm5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGMgJiYgZWx0ICYmIGVsdC5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICAgICAgX3RoaXMuX29sZFhQb3NbYy51aWRdID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgZGlmZmVyZW5jZSB3aXRoIG9sZCBwb3NpdGlvbiBiZWZvcmUgdXBkYXRlXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmZYID0gX3RoaXMuX29sZFhQb3NbYy51aWRdIC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBkaWZmWSA9IF90aGlzLl9vbGRZUG9zW2MudWlkXSAtIHJlY3QudG9wO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmWCB8fCBkaWZmWSkge1xuICAgICAgICAgICAgICAgICAgICBlbHQuc3R5bGUudHJhbnNpdGlvbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGVsdC5zdHlsZS50cmFuc2Zvcm0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc2xhdGVYKFwiICsgZGlmZlggKyBcInB4KSB0cmFuc2xhdGVZKFwiICsgZGlmZlkgKyBcInB4KVwiO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHQuc3R5bGUudHJhbnNpdGlvbiA9IFwidHJhbnNmb3JtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlUG9zaXRpb25zTVMgKyBcIm1zIGVhc2VcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsdC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZVgoMCkgdHJhbnNsYXRlWSgwKVwiO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhbmltYXRlIHRyYW5zaXRpb24gbm93XG4gICAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoKVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoZikgeyByZXR1cm4gZigpOyB9KTsgfSwgMCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vbGRYUG9zO1xuICAgICAgICBkZWxldGUgdGhpcy5fb2xkWVBvcztcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgRE9NIGF0dHJpYnV0ZSB1c2VkIHRvIHNpZ25hbCB0aGF0IGFuIGVsZW1lbnQgaXMgbWFuYWdlZCBvdXRzaWRlIHRoZSB1cGRhdGUgY29udGV4dCwgYW5kIHNob3VsZCBiZSBsZWZ0IGFsb25lIHdoaWxlIHVwZGF0aW5nIHRoZSBwYXJlbnQgZWxlbWVudCAoZS5nLiBlbGVtZW50cyBiZWluZyByZW1vdmVkLCBvciB0aGUgbW9kYWwgc2hhZGUgZWxlbWVudCkgKi9cbiAgICBVcGRhdGVDb250ZXh0LlVOTUFOQUdFRF9GTEFHID0gXCJyZW5kZXItdW5tYW5hZ2VkXCI7XG4gICAgcmV0dXJuIFVwZGF0ZUNvbnRleHQ7XG59KCkpO1xuZXhwb3J0IHsgVXBkYXRlQ29udGV4dCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvVXBkYXRlQ29udGV4dC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0ICogYXMgQXN5bmMgZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9Bc3luY1wiO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBTdHlsZSwgQmxvY2ssIENvbXBvbmVudFJlbmRlcmVyLCBtYXBDb21wb25lbnRSZW5kZXJlciB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCAqIGFzIERPTSBmcm9tIFwiLi4vLi4vRE9NXCI7XG5pbXBvcnQgeyBVcGRhdGVDb250ZXh0IH0gZnJvbSBcIi4uLy4uL1VwZGF0ZUNvbnRleHRcIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1CbG9ja1wiO1xuLyoqIEBpbnRlcm5hbCBET00tc3BlY2lmaWMgY29tcG9uZW50IHJlbmRlcmVyICovXG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHJlbmRlcmVyIGZvciBnaXZlbiBjb21wb25lbnQgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlcihjb21wb25lbnQsIHRhZ05hbWUpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09IHZvaWQgMCkgeyB0YWdOYW1lID0gXCJkaXZcIjsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XG4gICAgICAgIC8vIGluaXRpYWxpemUgbWFpbiBET00gZWxlbWVudChzKVxuICAgICAgICBfdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBlbGVtZW50IHVwZGF0ZSBjb250ZXh0XG4gICAgICAgIF90aGlzLmNvbnRleHQgPSBuZXcgVXBkYXRlQ29udGV4dChfdGhpcy5lbGVtZW50KTtcbiAgICAgICAgLy8gYWRkIHdhdGNoZXJzIGZvciBjb21wb25lbnQgcHJvcGVydGllc1xuICAgICAgICB2YXIgcG9zaXRpb25TdHlsZTtcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gRE9NLmFwcGx5U3R5bGVUbyhjb21wb25lbnQuc3R5bGUsIF90aGlzLmVsZW1lbnQpOyB9KTtcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50LmZvY3VzTW9kZTsgfSwgZnVuY3Rpb24gKGZvY3VzTW9kZSkge1xuICAgICAgICAgICAgaWYgKGZvY3VzTW9kZSA9PT0gQ29tcG9uZW50LkZvY3VzTW9kZS5BdXRvKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBlbGVtZW50IGZvY3VzYWJsZSB0aHJvdWdoIHRoZSBET01cbiAgICAgICAgICAgICAgICBfdGhpcy5lbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZvY3VzTW9kZSA9PT0gQ29tcG9uZW50LkZvY3VzTW9kZS5DbGljaykge1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgZWxlbWVudCBmb2N1c2FibGUgbWFudWFsbHlcbiAgICAgICAgICAgICAgICBfdGhpcy5lbGVtZW50LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIGVsZW1lbnQgbm8gbG9uZ2VyIGZvY3VzYWJsZSBpbiB0aGUgRE9NIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgX3RoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGdldCBvdmVybGF5IHBvc2l0aW9uIGFuZCB0cmFuc2xhdGUgbHRyL3J0bCBtb2RlIHZhbHVlc1xuICAgICAgICAgICAgdmFyIHBvcyA9IGNvbXBvbmVudC5vdmVybGF5UG9zaXRpb247XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmZsb3dEaXJlY3Rpb24gPT09IFwicnRsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID09PSBCbG9jay5PdmVybGF5UG9zaXRpb24uVG9wU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCbG9jay5PdmVybGF5UG9zaXRpb24uVG9wUmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gQmxvY2suT3ZlcmxheVBvc2l0aW9uLlRvcEVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJsb2NrLk92ZXJsYXlQb3NpdGlvbi5Ub3BMZWZ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IEJsb2NrLk92ZXJsYXlQb3NpdGlvbi5Cb3R0b21TdGFydClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJsb2NrLk92ZXJsYXlQb3NpdGlvbi5Cb3R0b21SaWdodDtcbiAgICAgICAgICAgICAgICBpZiAocG9zID09PSBCbG9jay5PdmVybGF5UG9zaXRpb24uQm90dG9tRW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmxvY2suT3ZlcmxheVBvc2l0aW9uLkJvdHRvbUxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID09PSBCbG9jay5PdmVybGF5UG9zaXRpb24uVG9wU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCbG9jay5PdmVybGF5UG9zaXRpb24uVG9wTGVmdDtcbiAgICAgICAgICAgICAgICBpZiAocG9zID09PSBCbG9jay5PdmVybGF5UG9zaXRpb24uVG9wRW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmxvY2suT3ZlcmxheVBvc2l0aW9uLlRvcFJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IEJsb2NrLk92ZXJsYXlQb3NpdGlvbi5Cb3R0b21TdGFydClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJsb2NrLk92ZXJsYXlQb3NpdGlvbi5Cb3R0b21MZWZ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IEJsb2NrLk92ZXJsYXlQb3NpdGlvbi5Cb3R0b21FbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCbG9jay5PdmVybGF5UG9zaXRpb24uQm90dG9tUmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9LCBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBwb3NpdGlvbmluZyBzdHlsZXMgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgcG9zaXRpb25TdHlsZSAmJiBwb3NpdGlvblN0eWxlLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcIlwiLCB0b3A6IFwiXCIsIGxlZnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogXCJcIiwgcmlnaHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogXCJcIiwgbWFyZ2luQm90dG9tOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiBcIlwiLCBtYXJnaW5SaWdodDogXCJcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcG9zaXRpb25TdHlsZSkge1xuICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlIHN0eWxlcyB3aXRoIHBvc2l0aW9uaW5nIHN0eWxlc1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZS5vdmVycmlkZShwb3NpdGlvblN0eWxlID0gbmV3IFN0eWxlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwbHkgcG9zaXRpb25pbmcgc3R5bGVzIChhYnNvbHV0ZSBwb3NpdGlvbilcbiAgICAgICAgICAgIHZhciB0b3AgPSBcImF1dG9cIiwgYm90dG9tID0gXCJhdXRvXCIsIGxlZnQgPSBcImF1dG9cIiwgcmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIHZhciBtYXJnaW5MZWZ0ID0gXCJcIiwgbWFyZ2luUmlnaHQgPSBcIlwiO1xuICAgICAgICAgICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEJsb2NrLk92ZXJsYXlQb3NpdGlvbi5Ub3BMZWZ0OlxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSBsZWZ0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxvY2suT3ZlcmxheVBvc2l0aW9uLlRvcFJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHJpZ2h0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxvY2suT3ZlcmxheVBvc2l0aW9uLlRvcDpcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdCA9IG1hcmdpblJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGxlZnQgPSByaWdodCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJsb2NrLk92ZXJsYXlQb3NpdGlvbi5Cb3R0b21MZWZ0OlxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBsZWZ0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxvY2suT3ZlcmxheVBvc2l0aW9uLkJvdHRvbVJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHJpZ2h0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQmxvY2suT3ZlcmxheVBvc2l0aW9uLkJvdHRvbTpcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdCA9IG1hcmdpblJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IGxlZnQgPSByaWdodCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUuc2V0KHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIHRvcDogdG9wLCBsZWZ0OiBsZWZ0LCBib3R0b206IGJvdHRvbSwgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IG1hcmdpbkxlZnQsIG1hcmdpblJpZ2h0OiBtYXJnaW5SaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpIHx8IG5ldyBDb21wb25lbnRSZW5kZXJlci5PdXRwdXQodGhpcy5jb21wb25lbnQsIHRoaXMuZWxlbWVudCwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgLy8gc2V0IG9yIHVwZGF0ZSBmbG93IGRpcmVjdGlvbiBtb2RlIG9uIGNvbnRleHQgYW5kIGVsZW1lbnRcbiAgICAgICAgdGhpcy5jb250ZXh0LmZsb3dEaXJlY3Rpb24gPSB0aGlzLmNvbXBvbmVudC5mbG93RGlyZWN0aW9uO1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQuZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmRpciA9IHRoaXMuY29tcG9uZW50LmZsb3dEaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKEJsb2NrKVxuICAgIF0sIFJlbmRlcmVyKTtcbiAgICByZXR1cm4gUmVuZGVyZXI7XG59KENvbXBvbmVudFJlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gQWRkIGxvZ2ljIGZvciBmb2N1c2luZyBhbmQgYmx1cnJpbmcgYmxvY2sgY29tcG9uZW50c1xuQXN5bmMuaW5qZWN0KEJsb2NrLCB7XG4gICAgXCJAZm9jdXNMaXZlQ29tcG9uZW50XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgRE9NLmZvY3VzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJAYmx1ckxpdmVDb21wb25lbnRcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBET00uYmx1cih0aGlzKTtcbiAgICB9XG59KTtcbi8vIEFkZCBzdHlsZSBvdmVycmlkZSBhbmQgYXBwbHkgc3R5bGUgc2hlZXRcbkJsb2NrLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUykpO1xuRE9NLlN0eWxlcy5kZWZpbmUoQ1NTX0NMQVNTLCB7XG4gICAgXCIufn5cIjoge1xuICAgICAgICBjdXJzb3I6IFwiZGVmYXVsdFwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiBcIm5vcm1hbFwiLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJzdGFydCB8fCBsZWZ0XCIsXG4gICAgICAgIG1hcmdpbjogXCJhdXRvXCIsXG4gICAgICAgIHRyYW5zaXRpb246IFwiYm94LXNoYWRvdyAxMDBtcyBlYXNlXCJcbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9CbG9ja3MvQmxvY2suanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IEJsb2NrLCBtYXBDb21wb25lbnRSZW5kZXJlciwgU3R5bGUgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBCbG9ja1JlbmRlcmVyIH0gZnJvbSBcIi4uL1JlbmRlcmVycy9CbG9ja3MvQmxvY2tcIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1ET01CbG9ja1wiO1xuLyoqIFBsYXRmb3JtIHNwZWNpZmljIEJsb2NrIGJhc2UgY2xhc3M6IGZ1bGwtd2lkdGggaG9yaXpvbnRhbCBibG9jayBjb250YWluaW5nIERPTSBlbGVtZW50KHMpICovXG52YXIgRE9NQmxvY2sgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhET01CbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBET01CbG9jaygpIHtcbiAgICAgICAgdmFyIGVsdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGVsdHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBsaWZ0IGFsbCBjaGlsZCBub2RlcyBmcm9tIGEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAgaWYgKGVsdHMgJiYgZWx0c1swXSAmJiBlbHRzWzBdLm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBlbHRzWzBdLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBqdXN0IGNvcHkgYXJyYXkgb2Ygbm9kZXNcbiAgICAgICAgICAgIF90aGlzLm5vZGVzID0gZWx0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX25vdF9udWxsXG4gICAgXSwgRE9NQmxvY2sucHJvdG90eXBlLCBcIm5vZGVzXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIERPTUJsb2NrO1xufShCbG9jaykpO1xuZXhwb3J0IHsgRE9NQmxvY2sgfTtcbi8qKiBAaW50ZXJuYWwgRE9NLXNwZWNpZmljIGNvbXBvbmVudCByZW5kZXJlciAqL1xudmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqIEdlbmVyYXRlIHJlbmRlcmVkIGNvbXBvbmVudCBvdXRwdXQgKi9cbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IG91dHB1dCBvYmplY3RcbiAgICAgICAgdmFyIG91dCA9IF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIGFkZCBhbGwgRE9NIG5vZGVzXG4gICAgICAgIG91dC51cGRhdGVkID0gdGhpcy5jb250ZXh0LnVwZGF0ZUFzeW5jKHRoaXMuY29tcG9uZW50Lm5vZGVzKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKERPTUJsb2NrKVxuICAgIF0sIFJlbmRlcmVyKTtcbiAgICByZXR1cm4gUmVuZGVyZXI7XG59KEJsb2NrUmVuZGVyZXIpKTtcbmV4cG9ydCB7IFJlbmRlcmVyIH07XG5ET01CbG9jay5hZGRTdHlsZU92ZXJyaWRlKFN0eWxlLndpdGhDbGFzcyhDU1NfQ0xBU1MpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL1VJL0RPTS9ET01CbG9jay5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0ICogYXMgQXN5bmMgZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9Bc3luY1wiO1xuaW1wb3J0IHsgQW5pbWF0aW9uLCBTdHlsZSB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCAqIGFzIERPTSBmcm9tIFwiLi9cIjtcbi8qKiBSZXByZXNlbnRzIGEgQ1NTIGtleWZyYW1lIGFuaW1hdGlvbiAqL1xudmFyIERPTUFuaW1hdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERPTUFuaW1hdGlvbiwgX3N1cGVyKTtcbiAgICAvKiogR2V0IGFuIGFuaW1hdGlvbiB3aXRoIGdpdmVuIGtleWZyYW1lcyBhbmQgZ2l2ZW4gcGxheWJhY2sgb3B0aW9ucyByZWFkeSBmb3IgdXNlICovXG4gICAgZnVuY3Rpb24gRE9NQW5pbWF0aW9uKG5hbWUsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoa2V5ZnJhbWVzID09PSB2b2lkIDApIHsga2V5ZnJhbWVzID0gW107IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBkZWNsYXJlIGFsbCBrZXlmcmFtZXMgaW4gdGhlIGFuaW1hdGlvblxuICAgICAgICBfdGhpcy5fa2V5ZnJhbWVzSUQgPSBvcHRpb25zLl9rZXlmcmFtZXMgfHwgX3RoaXMuaWQ7XG4gICAgICAgIGlmICghb3B0aW9ucy5fa2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICAvLyBnZXQgc3R5bGUgc2hlZXQgd2l0aCBhbGwga2V5ZnJhbWVzXG4gICAgICAgICAgICB2YXIgc2hlZXQgPSBuZXcgRE9NLlN0eWxlc2hlZXQoKTtcbiAgICAgICAgICAgIGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFtZSwgaSkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZnJhbWUudDtcbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB0ID0gaSAvIChrZXlmcmFtZXMubGVuZ3RoIC0gMSB8fCAxKTtcbiAgICAgICAgICAgICAgICB2YXIgcGVyYyA9IChNYXRoLnJvdW5kKHQgKiAxMDAwKSAvIDEwKSArIFwiJVwiO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IChmcmFtZS5zdHlsZSBpbnN0YW5jZW9mIFN0eWxlKSA/XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnN0eWxlIDogbmV3IFN0eWxlKGZyYW1lLnN0eWxlKTtcbiAgICAgICAgICAgICAgICBzaGVldC5kZWZpbmUoXCJAa2V5ZnJhbWVzIFwiICsgX3RoaXMuaWQgKyBcIntcIiArIHBlcmMgKyBcIn1cIiwgc3R5bGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBET00uYXBwbHlTdHlsZXNoZWV0KHNoZWV0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWNsYXJlIHRoZSBhbmltYXRpb24gaXRzZWxmXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IDM1MCwgZGVsYXkgPSAwLCBjb3VudCA9IFwiMVwiO1xuICAgICAgICBpZiAob3B0aW9ucy5kdXJhdGlvbiA+PSAwKVxuICAgICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICAgICAgICBpZiAob3B0aW9ucy5kZWxheSA+PSAwKVxuICAgICAgICAgICAgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuICAgICAgICBpZiAob3B0aW9ucy5jb3VudCA9PT0gSW5maW5pdHkpXG4gICAgICAgICAgICBjb3VudCA9IFwiaW5maW5pdGVcIjtcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jb3VudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY291bnQgPSBTdHJpbmcob3B0aW9ucy5jb3VudCk7XG4gICAgICAgIHZhciBjc3NUZXh0ID0gX3RoaXMuX2tleWZyYW1lc0lEICsgXCIgXCIgK1xuICAgICAgICAgICAgKG9wdGlvbnMuc3BlY0R1cmF0aW9uID49IDAgPyBvcHRpb25zLnNwZWNEdXJhdGlvbiA6IGR1cmF0aW9uKSArIFwibXMgXCIgK1xuICAgICAgICAgICAgZGVsYXkgKyBcIm1zIFwiICtcbiAgICAgICAgICAgIGNvdW50ICsgXCIgXCIgK1xuICAgICAgICAgICAgKG9wdGlvbnMuZGlyZWN0aW9uIHx8IFwibm9ybWFsXCIpICtcbiAgICAgICAgICAgIChvcHRpb25zLmVhc2UgPyBcIiBlYXNlXCIgOiBcIlwiKSArIFwiIGZvcndhcmRzXCI7XG4gICAgICAgIERPTS5hcHBseVN0eWxlc2hlZXQobmV3IERPTS5TdHlsZXNoZWV0KF90aGlzLmlkLCB7XG4gICAgICAgICAgICBcIi5+X3BsYXlpbmdcIjoge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogY3NzVGV4dCxcbiAgICAgICAgICAgICAgICB3ZWJraXRBbmltYXRpb246IGNzc1RleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBfdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uICsgZGVsYXk7XG4gICAgICAgIF90aGlzLl9wbGF5aW5nQ1NTVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBhIGNvbWJpbmVkIGFuaW1hdGlvbiBvdXQgb2YgZ2l2ZW4ga2V5IGZyYW1lIGFuaW1hdGlvbnMgKi9cbiAgICBET01BbmltYXRpb24udG9nZXRoZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmltYXRpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhbmltYXRpb25zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCBtYXhpbXVtIGR1cmF0aW9uIGZyb20gZ2l2ZW4gYW5pbWF0aW9ucywgY29tYmluZSBDU1NcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gMCwgY3NzVGV4dHMgPSBbXTtcbiAgICAgICAgYW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKGEuX3BsYXlpbmdDU1NUZXh0KTtcbiAgICAgICAgICAgIGlmIChhLmR1cmF0aW9uID4gZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBhLmR1cmF0aW9uO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbWJpbmVkQ1NTVGV4dCA9IGNzc1RleHRzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgLy8gY3JlYXRlIGEgY29tYmluZWQgQW5pbWF0aW9uIGNsYXNzXG4gICAgICAgIHZhciBDb21iaW5lZEFuaW1hdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgX3RoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgQ1NTIGNsYXNzIHdpdGggY29tYmluZWQgQ1NTXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBuZXcgRE9NLlN0eWxlc2hlZXQoX3RoaXMuaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgXCIufl9wbGF5aW5nXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogY29tYmluZWRDU1NUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2Via2l0QW5pbWF0aW9uOiBjb21iaW5lZENTU1RleHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIERPTS5hcHBseVN0eWxlc2hlZXQocyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV1c2Uga2V5ZnJhbWUgYW5pbWF0aW9uIHBsYXkgbWV0aG9kXG4gICAgICAgICAgICAgICAgcmV0dXJuIERPTUFuaW1hdGlvbi5wcm90b3R5cGUucGxheS5jYWxsKHRoaXMsIGMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgICAgICB9KEFuaW1hdGlvbikpO1xuICAgICAgICAvLyByZXR1cm4gYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAgICAgICAgcmV0dXJuIG5ldyBDb21iaW5lZEFuaW1hdGlvbihhbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKGEgJiYgYS5uYW1lKTsgfSkuam9pbihcIl9hbmRfXCIpKTtcbiAgICB9O1xuICAgIC8qKiBDbG9uZSB0aGUgYW5pbWF0aW9uIHdpdGggdGhlIHNhbWUga2V5ZnJhbWVzIGJ1dCB3aXRoIGV4dHJhIG9wdGlvbnMgKi9cbiAgICBET01BbmltYXRpb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNsb25lZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbiA+PSAwID9cbiAgICAgICAgICAgICAgICBvcHRpb25zLmR1cmF0aW9uIDogdGhpcy5fb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgICAgIGRlbGF5OiBvcHRpb25zLmRlbGF5ID49IDAgP1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVsYXkgOiB0aGlzLl9vcHRpb25zLmRlbGF5LFxuICAgICAgICAgICAgY291bnQ6IG9wdGlvbnMuY291bnQgPj0gMCA/XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb3VudCA6IHRoaXMuX29wdGlvbnMuY291bnQsXG4gICAgICAgICAgICBkaXJlY3Rpb246IG9wdGlvbnMuZGlyZWN0aW9uID9cbiAgICAgICAgICAgICAgICBvcHRpb25zLmRpcmVjdGlvbiA6IHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uLFxuICAgICAgICAgICAgZWFzZTogb3B0aW9ucy5lYXNlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZWFzZSA6IHRoaXMuX29wdGlvbnMuZWFzZSxcbiAgICAgICAgICAgIF9rZXlmcmFtZXM6IHRoaXMuX2tleWZyYW1lc0lEXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgRE9NQW5pbWF0aW9uKHRoaXMubmFtZSwgdW5kZWZpbmVkLCBjbG9uZWRPcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKiBDb21iaW5lIHRoaXMgYW5pbWF0aW9uIHdpdGggZ2l2ZW4ga2V5IGZyYW1lIGFuaW1hdGlvbnM7IHRoaXMgZG9lcyAqbm90KiB3b3JrIGZvciBhbmltYXRpb25zIHRoYXQgdXNlIHRoZSBzYW1lIENTUyBwcm9wZXJ0eSwgc3VjaCBhcyBgdHJhbnNmb3JtYCAocm90YXRlLCBzY2FsZSwgdHJhbnNsYXRlLi4uKSAqL1xuICAgIERPTUFuaW1hdGlvbi5wcm90b3R5cGUudG9nZXRoZXJXaXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYW5pbWF0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBET01BbmltYXRpb24udG9nZXRoZXIuYXBwbHkoRE9NQW5pbWF0aW9uLCBbdGhpc10uY29uY2F0KGFuaW1hdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKiBDbG9uZSB0aGlzIGFuaW1hdGlvbiBhbmQgb3ZlcnJpZGUgdGltaW5ncyAqL1xuICAgIERPTUFuaW1hdGlvbi5wcm90b3R5cGUud2l0aFRpbWluZyA9IGZ1bmN0aW9uIChtc0R1cmF0aW9uLCBtc0RlbGF5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKHsgZHVyYXRpb246IG1zRHVyYXRpb24sIGRlbGF5OiBtc0RlbGF5IH0pO1xuICAgIH07XG4gICAgLyoqIENsb25lIHRoaXMgYW5pbWF0aW9uIGFuZCBzcGVjaWZ5IHRvIGJlIHBsYXllZCBpbiByZXZlcnNlICovXG4gICAgRE9NQW5pbWF0aW9uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSh7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICh0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uID09PSBcInJldmVyc2VcIikgP1xuICAgICAgICAgICAgICAgIFwibm9ybWFsXCIgOiBcInJldmVyc2VcIlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBQbGF5IHRoZSBhbmltYXRpb24gb25jZSBvbiBnaXZlbiBjb21wb25lbnQgKi9cbiAgICBET01BbmltYXRpb24ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb250cm9sID0geyBhbmltYXRpb246IHRoaXMgfTtcbiAgICAgICAgaWYgKCFBbmltYXRpb24uaXNFbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBkbyBub3Qgc3RhcnQsIHJldHVybiBib2d1cyBvYmplY3RcbiAgICAgICAgICAgIGNvbnRyb2wuZG9uZSA9IEFzeW5jLlByb21pc2UucmVzb2x2ZShjb250cm9sKTtcbiAgICAgICAgICAgIGNvbnRyb2wuc3RvcCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZS5hZGRDbGFzcyh0aGlzLmlkICsgXCJfcGxheWluZ1wiKTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgbm90IGNvcnJlY3QgYnV0IGdvb2QgZW5vdWdoIGluIG1vc3QgY2FzZXNcbiAgICAgICAgICAgIC8vIHdoZXJlIHRoZSBhbmltYXRpb24gaXMgdHJpZ2dlcmVkIG9uIGFuIGV4aXN0aW5nIGVsZW1lbnQsIGFuZFxuICAgICAgICAgICAgLy8gYXZvaWRzIGNvbXBsaWNhdGVkIGV2ZW50IHNldHVwOlxuICAgICAgICAgICAgY29udHJvbC5kb25lID0gQXN5bmMuc2xlZXAodGhpcy5kdXJhdGlvbiwgY29udHJvbCk7XG4gICAgICAgICAgICBjb250cm9sLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlLnJlbW92ZUNsYXNzKF90aGlzLmlkICsgXCJfcGxheWluZ1wiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2w7XG4gICAgfTtcbiAgICByZXR1cm4gRE9NQW5pbWF0aW9uO1xufShBbmltYXRpb24pKTtcbmV4cG9ydCB7IERPTUFuaW1hdGlvbiB9O1xuKGZ1bmN0aW9uIChET01BbmltYXRpb24pIHtcbiAgICB2YXIgZmFkZUluID0gbmV3IERPTUFuaW1hdGlvbihcImZhZGVJblwiLCBbXG4gICAgICAgIHsgc3R5bGU6IHsgb3BhY2l0eTogXCIwXCIgfSB9LFxuICAgICAgICB7IHN0eWxlOiB7IG9wYWNpdHk6IFwiMVwiIH0gfVxuICAgIF0pO1xuICAgIHZhciBmYWRlT3V0ID0gZmFkZUluLnJldmVyc2UoKTtcbiAgICB2YXIgc2xpZGVJblVwID0gbmV3IERPTUFuaW1hdGlvbihcInNsaWRlSW5VcFwiLCBbXG4gICAgICAgIHsgc3R5bGU6IHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMTAwJSlcIiB9IH0sXG4gICAgICAgIHsgc3R5bGU6IHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIiB9IH1cbiAgICBdKTtcbiAgICB2YXIgZmFkZUluVXAgPSBuZXcgRE9NQW5pbWF0aW9uKFwiZmFkZUluVXBcIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IG9wYWNpdHk6IFwiMFwiLCB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSg1MCUpXCIgfSB9LFxuICAgICAgICB7IHN0eWxlOiB7IG9wYWNpdHk6IFwiMVwiLCB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgwKVwiIH0gfVxuICAgIF0pO1xuICAgIHZhciBzbGlkZU91dERvd24gPSBzbGlkZUluVXAucmV2ZXJzZSgpO1xuICAgIHZhciBmYWRlT3V0RG93biA9IGZhZGVJblVwLnJldmVyc2UoKTtcbiAgICB2YXIgc2xpZGVJbkRvd24gPSBuZXcgRE9NQW5pbWF0aW9uKFwic2xpZGVJbkRvd25cIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC0xMDAlKVwiIH0gfSxcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgwKVwiIH0gfVxuICAgIF0pO1xuICAgIHZhciBmYWRlSW5Eb3duID0gbmV3IERPTUFuaW1hdGlvbihcImZhZGVJbkRvd25cIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IG9wYWNpdHk6IFwiMFwiLCB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtNTAlKVwiIH0gfSxcbiAgICAgICAgeyBzdHlsZTogeyBvcGFjaXR5OiBcIjFcIiwgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIiB9IH1cbiAgICBdKTtcbiAgICB2YXIgc2xpZGVPdXRVcCA9IHNsaWRlSW5Eb3duLnJldmVyc2UoKTtcbiAgICB2YXIgZmFkZU91dFVwID0gZmFkZUluRG93bi5yZXZlcnNlKCk7XG4gICAgdmFyIHNsaWRlSW5MZWZ0ID0gbmV3IERPTUFuaW1hdGlvbihcInNsaWRlSW5MZWZ0XCIsIFtcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCgxMDAlKVwiIH0gfSxcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCgwKVwiIH0gfVxuICAgIF0pO1xuICAgIHZhciBmYWRlSW5MZWZ0ID0gbmV3IERPTUFuaW1hdGlvbihcImZhZGVJbkxlZnRcIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IG9wYWNpdHk6IFwiMFwiLCB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCg1MCUpXCIgfSB9LFxuICAgICAgICB7IHN0eWxlOiB7IG9wYWNpdHk6IFwiMVwiLCB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCgwKVwiIH0gfVxuICAgIF0pO1xuICAgIHZhciBzbGlkZU91dFJpZ2h0ID0gc2xpZGVJbkxlZnQucmV2ZXJzZSgpO1xuICAgIHZhciBmYWRlT3V0UmlnaHQgPSBmYWRlSW5MZWZ0LnJldmVyc2UoKTtcbiAgICB2YXIgc2xpZGVJblJpZ2h0ID0gbmV3IERPTUFuaW1hdGlvbihcInNsaWRlSW5SaWdodFwiLCBbXG4gICAgICAgIHsgc3R5bGU6IHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoLTEwMCUpXCIgfSB9LFxuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKDApXCIgfSB9XG4gICAgXSk7XG4gICAgdmFyIGZhZGVJblJpZ2h0ID0gbmV3IERPTUFuaW1hdGlvbihcImZhZGVJblJpZ2h0XCIsIFtcbiAgICAgICAgeyBzdHlsZTogeyBvcGFjaXR5OiBcIjBcIiwgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoLTUwJSlcIiB9IH0sXG4gICAgICAgIHsgc3R5bGU6IHsgb3BhY2l0eTogXCIxXCIsIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVYKDApXCIgfSB9XG4gICAgXSk7XG4gICAgdmFyIHNsaWRlT3V0TGVmdCA9IHNsaWRlSW5SaWdodC5yZXZlcnNlKCk7XG4gICAgdmFyIGZhZGVPdXRMZWZ0ID0gZmFkZUluUmlnaHQucmV2ZXJzZSgpO1xuICAgIHZhciBzY2FsZUluID0gbmV3IERPTUFuaW1hdGlvbihcInNjYWxlSW5cIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJzY2FsZSgwKVwiIH0gfSxcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIiB9IH1cbiAgICBdKTtcbiAgICB2YXIgc2NhbGVPdXQgPSBzY2FsZUluLnJldmVyc2UoKTtcbiAgICB2YXIgc2NhbGVJbk92ZXIgPSBuZXcgRE9NQW5pbWF0aW9uKFwic2NhbGVJbk92ZXJcIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJzY2FsZSgwKVwiIH0gfSxcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwic2NhbGUoMS4xNSlcIiB9LCB0OiAuNSB9LFxuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJzY2FsZSguOTUpXCIgfSwgdDogLjggfSxcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIiB9IH1cbiAgICBdKTtcbiAgICB2YXIgc2NhbGVPdXRPdmVyID0gc2NhbGVJbk92ZXIucmV2ZXJzZSgpO1xuICAgIHZhciB0dXJuSW5YID0gbmV3IERPTUFuaW1hdGlvbihcInR1cm5JblhcIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJwZXJzcGVjdGl2ZSgxMDAwcHgpIHJvdGF0ZVgoOTBkZWcpXCIgfSB9LFxuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJwZXJzcGVjdGl2ZSgxMDAwcHgpXCIgfSB9XG4gICAgXSk7XG4gICAgdmFyIHR1cm5PdXRYID0gbmV3IERPTUFuaW1hdGlvbihcInR1cm5PdXRYXCIsIFtcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwicGVyc3BlY3RpdmUoMTAwMHB4KVwiIH0gfSxcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwicGVyc3BlY3RpdmUoMTAwMHB4KSByb3RhdGVYKDkwZGVnKVwiIH0gfVxuICAgIF0pO1xuICAgIHZhciB0dXJuSW5ZID0gbmV3IERPTUFuaW1hdGlvbihcInR1cm5JbllcIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJwZXJzcGVjdGl2ZSgxMDAwcHgpIHJvdGF0ZVkoOTBkZWcpXCIgfSB9LFxuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJwZXJzcGVjdGl2ZSgxMDAwcHgpXCIgfSB9XG4gICAgXSk7XG4gICAgdmFyIHR1cm5PdXRZID0gbmV3IERPTUFuaW1hdGlvbihcInR1cm5PdXRZXCIsIFtcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwicGVyc3BlY3RpdmUoMTAwMHB4KVwiIH0gfSxcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwicGVyc3BlY3RpdmUoMTAwMHB4KSByb3RhdGVZKDkwZGVnKVwiIH0gfVxuICAgIF0pO1xuICAgIHZhciBncm93TWF4SGVpZ2h0ID0gbmV3IERPTUFuaW1hdGlvbihcImdyb3dNYXhIZWlnaHRcIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IG1heEhlaWdodDogXCIwXCIsIGFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uOiBcImN1YmljLWJlemllcigwLjUsIDAsIDEsIDAuNSlcIiB9IH0sXG4gICAgICAgIHsgc3R5bGU6IHsgbWF4SGVpZ2h0OiBcIjUwMDBweFwiLCBhbmltYXRpb25UaW1pbmdGdW5jdGlvbjogXCJjdWJpYy1iZXppZXIoMC41LCAwLCAxLCAwLjUpXCIgfSB9XG4gICAgXSwgeyBkdXJhdGlvbjogODAwIH0pO1xuICAgIHZhciBzaHJpbmtNYXhIZWlnaHQgPSBuZXcgRE9NQW5pbWF0aW9uKFwic2hyaW5rTWF4SGVpZ2h0XCIsIFtcbiAgICAgICAgeyBzdHlsZTogeyBtYXhIZWlnaHQ6IFwiNTAwMHB4XCIsIGFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uOiBcImN1YmljLWJlemllcigwLCAwLjUsIDAuNSwgMSlcIiB9IH0sXG4gICAgICAgIHsgc3R5bGU6IHsgbWF4SGVpZ2h0OiBcIjBcIiwgYW5pbWF0aW9uVGltaW5nRnVuY3Rpb246IFwiY3ViaWMtYmV6aWVyKDAsIDAuNSwgMC41LCAxKVwiIH0gfSxcbiAgICBdLCB7IGR1cmF0aW9uOiA4MDAgfSk7XG4gICAgdmFyIGdyb3dNYXhXaWR0aCA9IG5ldyBET01BbmltYXRpb24oXCJncm93TWF4V2lkdGhcIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IG1heFdpZHRoOiBcIjBcIiwgYW5pbWF0aW9uVGltaW5nRnVuY3Rpb246IFwiY3ViaWMtYmV6aWVyKDAuNSwgMCwgMSwgMC41KVwiIH0gfSxcbiAgICAgICAgeyBzdHlsZTogeyBtYXhXaWR0aDogXCI1MDAwcHhcIiwgYW5pbWF0aW9uVGltaW5nRnVuY3Rpb246IFwiY3ViaWMtYmV6aWVyKDAuNSwgMCwgMSwgMC41KVwiIH0gfVxuICAgIF0sIHsgZHVyYXRpb246IDgwMCB9KTtcbiAgICB2YXIgc2hyaW5rTWF4V2lkdGggPSBuZXcgRE9NQW5pbWF0aW9uKFwic2hyaW5rTWF4V2lkdGhcIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IG1heFdpZHRoOiBcIjUwMDBweFwiLCBhbmltYXRpb25UaW1pbmdGdW5jdGlvbjogXCJjdWJpYy1iZXppZXIoMCwgMC41LCAwLjUsIDEpXCIgfSB9LFxuICAgICAgICB7IHN0eWxlOiB7IG1heFdpZHRoOiBcIjBcIiwgYW5pbWF0aW9uVGltaW5nRnVuY3Rpb246IFwiY3ViaWMtYmV6aWVyKDAsIDAuNSwgMC41LCAxKVwiIH0gfSxcbiAgICBdLCB7IGR1cmF0aW9uOiA4MDAgfSk7XG4gICAgdmFyIGhpZ2hsaWdodFllbGxvdyA9IG5ldyBET01BbmltYXRpb24oXCJoaWdobGlnaHRZZWxsb3dcIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IGJhY2tncm91bmQ6IFwiI2ZmY1wiIH0gfSxcbiAgICAgICAgeyBzdHlsZTogeyBiYWNrZ3JvdW5kOiBcIiNmZmFcIiB9IH0sXG4gICAgICAgIHsgc3R5bGU6IHsgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiIH0gfVxuICAgIF0pO1xuICAgIHZhciBqdW1wT3V0ID0gbmV3IERPTUFuaW1hdGlvbihcImp1bXBPdXRcIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJzY2FsZSguOSlcIiB9IH0sXG4gICAgICAgIHsgc3R5bGU6IHsgdHJhbnNmb3JtOiBcInNjYWxlKDEuMilcIiB9IH0sXG4gICAgICAgIHsgc3R5bGU6IHsgdHJhbnNmb3JtOiBcInNjYWxlKC45KVwiIH0sIHQ6IC45IH0sXG4gICAgICAgIHsgc3R5bGU6IHsgdHJhbnNmb3JtOiBcInNjYWxlKDEpXCIgfSB9XG4gICAgXSk7XG4gICAgdmFyIGp1bXBJbiA9IG5ldyBET01BbmltYXRpb24oXCJqdW1wSW5cIiwgW1xuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJzY2FsZSgxLjA1KVwiIH0gfSxcbiAgICAgICAgeyBzdHlsZTogeyB0cmFuc2Zvcm06IFwic2NhbGUoLjkpXCIgfSB9LFxuICAgICAgICB7IHN0eWxlOiB7IHRyYW5zZm9ybTogXCJzY2FsZSgxLjA1KVwiIH0sIHQ6IC45IH0sXG4gICAgICAgIHsgc3R5bGU6IHsgdHJhbnNmb3JtOiBcInNjYWxlKDEpXCIgfSB9XG4gICAgXSk7XG4gICAgLyoqIExpc3Qgb2YgYmFzaWMgYW5pbWF0aW9ucyBbaW1wbGVtZW50YXRpb25dICovXG4gICAgRE9NQW5pbWF0aW9uLmJhc2ljID0ge1xuICAgICAgICBpbjoge1xuICAgICAgICAgICAgZmFkZTogZmFkZUluLFxuICAgICAgICAgICAgZmFkZVVwOiBmYWRlSW5VcCxcbiAgICAgICAgICAgIGZhZGVEb3duOiBmYWRlSW5Eb3duLFxuICAgICAgICAgICAgZmFkZUxlZnQ6IGZhZGVJbkxlZnQsXG4gICAgICAgICAgICBmYWRlUmlnaHQ6IGZhZGVJblJpZ2h0LFxuICAgICAgICAgICAgc2xpZGVVcDogc2xpZGVJblVwLFxuICAgICAgICAgICAgc2xpZGVEb3duOiBzbGlkZUluRG93bixcbiAgICAgICAgICAgIHNsaWRlTGVmdDogc2xpZGVJbkxlZnQsXG4gICAgICAgICAgICBzbGlkZVJpZ2h0OiBzbGlkZUluUmlnaHQsXG4gICAgICAgICAgICBzY2FsZTogc2NhbGVJbixcbiAgICAgICAgICAgIHNjYWxlT3Zlcjogc2NhbGVJbk92ZXIsXG4gICAgICAgICAgICB0dXJuWDogdHVybkluWCxcbiAgICAgICAgICAgIHR1cm5ZOiB0dXJuSW5ZLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiBncm93TWF4SGVpZ2h0LFxuICAgICAgICAgICAgbWF4V2lkdGg6IGdyb3dNYXhXaWR0aFxuICAgICAgICB9LFxuICAgICAgICBvdXQ6IHtcbiAgICAgICAgICAgIGZhZGU6IGZhZGVPdXQsXG4gICAgICAgICAgICBmYWRlVXA6IGZhZGVPdXRVcCxcbiAgICAgICAgICAgIGZhZGVEb3duOiBmYWRlT3V0RG93bixcbiAgICAgICAgICAgIGZhZGVMZWZ0OiBmYWRlT3V0TGVmdCxcbiAgICAgICAgICAgIGZhZGVSaWdodDogZmFkZU91dFJpZ2h0LFxuICAgICAgICAgICAgc2xpZGVVcDogc2xpZGVPdXRVcCxcbiAgICAgICAgICAgIHNsaWRlRG93bjogc2xpZGVPdXREb3duLFxuICAgICAgICAgICAgc2xpZGVMZWZ0OiBzbGlkZU91dExlZnQsXG4gICAgICAgICAgICBzbGlkZVJpZ2h0OiBzbGlkZU91dFJpZ2h0LFxuICAgICAgICAgICAgc2NhbGU6IHNjYWxlT3V0LFxuICAgICAgICAgICAgc2NhbGVPdmVyOiBzY2FsZU91dE92ZXIsXG4gICAgICAgICAgICB0dXJuWDogdHVybk91dFgsXG4gICAgICAgICAgICB0dXJuWTogdHVybk91dFksXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IHNocmlua01heEhlaWdodCxcbiAgICAgICAgICAgIG1heFdpZHRoOiBzaHJpbmtNYXhXaWR0aCxcbiAgICAgICAgfSxcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICB5ZWxsb3c6IGhpZ2hsaWdodFllbGxvdyxcbiAgICAgICAgICAgIGp1bXBPdXQ6IGp1bXBPdXQsIGp1bXBJbjoganVtcEluXG4gICAgICAgIH1cbiAgICB9O1xufSkoRE9NQW5pbWF0aW9uIHx8IChET01BbmltYXRpb24gPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvRE9NL0RPTUFuaW1hdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgU2NyZWVuIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0IHsgYXBwbHlTdHlsZXNoZWV0IH0gZnJvbSBcIi4vU3R5bGVzaGVldFwiO1xuaW1wb3J0IHsgU3R5bGVzIH0gZnJvbSBcIi4vU3R5bGVzXCI7XG4vKiogQGludGVybmFsIENyZWF0ZSBhIDxkaXY+IGVsZW1lbnQgd2l0aCBnaXZlbiBjbGFzcyBuYW1lIGFuZCBub2RlICovXG5leHBvcnQgZnVuY3Rpb24gZGl2KGNsYXNzTmFtZSwgbm9kZSkge1xuICAgIHZhciByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGlmIChjbGFzc05hbWUpXG4gICAgICAgIHJlc3VsdC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgaWYgKG5vZGUpXG4gICAgICAgIHJlc3VsdC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBjb21wb25lbnQgY29udGFpbnMgZ2l2ZW4gRE9NIG5vZGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWlucyhjb21wb25lbnQsIG5vZGUpIHtcbiAgICAvLyBvbmx5IHJldHVybiB0cnVlIGlmIGNvbXBvbmVudCBvdXRwdXQgRE9NIGVsZW1lbnQgaXMgZXF1YWwgdG8gdGhlXG4gICAgLy8gZ2l2ZW4gRE9NIGVsZW1lbnQsIG9yIGxvZ2ljYWxseSBjb250YWlucyBpdFxuICAgIHZhciBvdXQgPSBjb21wb25lbnQuZ2V0TGFzdFJlbmRlcmVkT3V0cHV0KCk7XG4gICAgcmV0dXJuICEhKG91dCAmJiBvdXQuZWxlbWVudCAmJiAobm9kZSA9PT0gb3V0LmVsZW1lbnQgfHxcbiAgICAgICAgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihvdXQuZWxlbWVudCkgJiA4KSk7XG59XG4vLyB3YWl0IGZvciBsb2FkIGV2ZW50LCBvciAxcyBhZnRlciBET01Db250ZW50TG9hZGVkICh3YWl0IGZvciBDU1MgdG8gbG9hZFxuLy8gdG8gYXZvaWQgZmxhc2ggb2YgdW5zdHlsZWQgY29udGVudC0tIGJ1dCBub3QgdG9vIGxvbmcpLCBvciByZXNvbHZlIHJpZ2h0XG4vLyBhd2F5IGlmIGV2ZXJ5dGhpbmcgaXMgYWxyZWFkeSBsb2FkZWQ6XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkgeyBTY3JlZW4ucmVzb2x2ZVJlYWR5KHRydWUpOyB9KTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIEFzeW5jLnNsZWVwKDEwMDApLnRoZW4oZnVuY3Rpb24gKCkgeyBTY3JlZW4ucmVzb2x2ZVJlYWR5KHRydWUpOyB9KTtcbn0pO1xuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIilcbiAgICBTY3JlZW4ucmVzb2x2ZVJlYWR5KHRydWUpO1xuLy8gYXBwbHkgQ1NTIHJlc2V0XG5TY3JlZW4ucmVhZHkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgYXBwbHlTdHlsZXNoZWV0KHtcbiAgICAgICAgXCJbaGlkZGVuXVwiOiB7IGRpc3BsYXk6IFwibm9uZSAhaW1wb3J0YW50XCIgfSxcbiAgICAgICAgXCIqXCI6IHsgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIiB9XG4gICAgfSk7XG4gICAgYXBwbHlTdHlsZXNoZWV0KFN0eWxlcy5yZWJvb3RTdHlsZXMsIHRydWUpO1xuICAgIGFwcGx5U3R5bGVzaGVldChTdHlsZXMuY29udHJvbFN0eWxlcywgdHJ1ZSk7XG59KTtcbi8vIGxpc3RlbiBmb3IgY2hhbmdlcyBpbiB3aW5kb3cgc2l6ZTpcbnZhciBkZWZlcnJlZERpbWVuc2lvbnNVcGRhdGU7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkZWZlcnJlZERpbWVuc2lvbnNVcGRhdGUpIHtcbiAgICAgICAgZGVmZXJyZWREaW1lbnNpb25zVXBkYXRlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWZlcnJlZERpbWVuc2lvbnNVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB1cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIHVwZGF0ZURpbWVuc2lvbnMoKSB7XG4gICAgLy8gd3JpdGUgdG8gYC5kaW1lbnNpb25zYCBwcm9wZXJ0aWVzLCBpZ25vcmUgcmVhZG9ubHkgbW9kaWZpZXJcbiAgICB2YXIgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgICAgU2NyZWVuLmRpbWVuc2lvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgU2NyZWVuLmRpbWVuc2lvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdGFydFVwZGF0ZURpbWVuc2lvbnMoKSB7XG4gICAgaWYgKCF1cGRhdGVEaW1lbnNpb25zKCkpXG4gICAgICAgIHNldFRpbWVvdXQoc3RhcnRVcGRhdGVEaW1lbnNpb25zLCAyMDApO1xufVxuc3RhcnRVcGRhdGVEaW1lbnNpb25zKCk7XG4vLyBJbmplY3QgZWxlbWVudCBtZWFzdXJlbWVudCBmdW5jdGlvbiBpbnRvIENvbXBvbmVudCBjbGFzc1xuQXN5bmMuaW5qZWN0KENvbXBvbmVudCwge1xuICAgIGdldEFjdHVhbERpbWVuc2lvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMuZ2V0TGFzdFJlbmRlcmVkT3V0cHV0KCk7XG4gICAgICAgIHZhciBlbHQgPSBvdXQgJiYgb3V0LmVsZW1lbnQ7XG4gICAgICAgIGlmIChlbHQpIHtcbiAgICAgICAgICAgIC8vIHRha2UgY3VycmVudCBoZWlnaHQgJiB3aWR0aCBmcm9tIGFjdHVhbCBjb21wb25lbnRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBlbHQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBlbHQub2Zmc2V0V2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gMHgwIHNpbmNlIG5vdGhpbmcgaXMgdmlzaWJsZVxuICAgICAgICAgICAgcmV0dXJuIHsgaGVpZ2h0OiAwLCB3aWR0aDogMCB9O1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vLyBDdXN0b21FdmVudCBwb2x5ZmlsbCAoc291cmNlOiBNRE4pXG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBDdXN0b21FdmVudChcInRlc3RcIik7XG4gICAgfVxuICAgIGNhdGNoIChhbGwpIHtcbiAgICAgICAgdmFyIEMgPSBmdW5jdGlvbiAoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgISFwYXJhbXMuYnViYmxlcywgISFwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICAgICAgICByZXR1cm4gZXZ0O1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3dbXCJDdXN0b21FdmVudFwiXSA9IEM7XG4gICAgICAgIEMucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgICB9XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvRE9NL21haW4uanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgeyBjb250YWlucyB9IGZyb20gXCIuL21haW5cIjtcbi8vIEluamVjdCBmb2N1cyBzdGF0ZSBsb2dpY1xuQXN5bmMuaW5qZWN0KENvbXBvbmVudCwge1xuICAgIFwiQGdldExpdmVDb21wb25lbnRGb2N1c1N0YXRlXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gISEoZm9jdXNlZCAmJiBjb250YWlucyh0aGlzLCBmb2N1c2VkKSk7XG4gICAgfVxufSk7XG4vKiogRWxlbWVudCB0byBmb2N1cyBhcyBzb29uIGFzIGl0IGJlY29tZXMgYXZhaWxhYmxlIChzZWUgYGZvY3VzKC4uLilgKSAqL1xudmFyIHRvRm9jdXNBU0FQO1xuLyoqIFRyeSB0byBmb2N1cyBnaXZlbiBjb21wb25lbnQsIGl0cyBsaXZlIGVsZW1lbnQgKGZyb20gcmVuZGVyZWQgb3V0cHV0KSwgb3IgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IHdpdGhpbiBnaXZlbiBjb21wb25lbnQsIGFzIHNvb24gYXMgaXQgYmVjb21lcyBhdmFpbGFibGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBmb2N1cyhjb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQuZ2V0UmVuZGVyZWRPdXRwdXRBc3luYygpLnRoZW4oZnVuY3Rpb24gKG91dCkge1xuICAgICAgICBpZiAoIW91dC5lbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBjaGVjayB3aGljaCBlbGVtZW50IHRvIHNldCBmb2N1cyB0b1xuICAgICAgICB2YXIgZm9jdXNhYmxlO1xuICAgICAgICBpZiAob3V0LmVsZW1lbnQuaGFzQXR0cmlidXRlICYmXG4gICAgICAgICAgICBvdXQuZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSkge1xuICAgICAgICAgICAgLy8gdXNlIGVsZW1lbnQgaXRzZWxmXG4gICAgICAgICAgICBmb2N1c2FibGUgPSBvdXQuZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdXQubGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIHVzZSBsaXZlIGVsZW1lbnQgZnJvbSBvdXRwdXRcbiAgICAgICAgICAgIGZvY3VzYWJsZSA9IG91dC5saXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZpbmQgZm9jdXNhYmxlIGVsZW1lbnRzIChub3QgaGlkZGVuIGFuZCBwYXJlbnQocykgbm90IGhpZGRlbilcbiAgICAgICAgICAgIHZhciBlbHRzID0gb3V0LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIlt0YWJpbmRleF0sYVtocmVmXSxpbnB1dDpub3QoW2Rpc2FibGVkXSksXCIgK1xuICAgICAgICAgICAgICAgIFwiYnV0dG9uOm5vdChbZGlzYWJsZWRdKSx0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksXCIgK1xuICAgICAgICAgICAgICAgIFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgZWx0c18xID0gZWx0czsgX2kgPCBlbHRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBlbHRzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIGhpZGRlbiA9IGZhbHNlLCBjdXIgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXIgJiYgIWhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLmhhc0F0dHJpYnV0ZSAmJiBjdXIuaGFzQXR0cmlidXRlKFwiaGlkZGVuXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzYWJsZSA9IGN1cjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZvY3VzIHRoZSAoZmlyc3QgZm9jdXNhYmxlKSBlbGVtZW50IGZvdW5kXG4gICAgICAgIGlmIChmb2N1c2FibGUpIHtcbiAgICAgICAgICAgIHRvRm9jdXNBU0FQID0gZm9jdXNhYmxlO1xuICAgICAgICAgICAgdmFyIHRyaWVzID0gMDtcbiAgICAgICAgICAgIHZhciBkb0ZvY3VzXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvRm9jdXNBU0FQICE9PSBmb2N1c2FibGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodG9Gb2N1c0FTQVAgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdG9Gb2N1c0FTQVApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGZvY3VzIHRoZSBlbGVtZW50IGFuZCBrZWVwIGNoZWNraW5nIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgdG9Gb2N1c0FTQVAuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWVzKysgPCAxMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGRvRm9jdXNfMSwgdHJpZXMgKiAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hbmFnZWQgdG8gZm9jdXMgdGhlIGVsZW1lbnQsIGZvcmdldCBhYm91dCBpdDpcbiAgICAgICAgICAgICAgICAgICAgdG9Gb2N1c0FTQVAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvRm9jdXNfMSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKiogUmVtb3ZlIGZvY3VzIGZyb20gZ2l2ZW4gY29tcG9uZW50LCBvciB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsdXIoY29tcG9uZW50KSB7XG4gICAgdmFyIGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgIC8vIGRvIG5vdCBibHVyIGlmIG5vdCBjb250YWluZWQgYnkgZ2l2ZW4gY29tcG9uZW50XG4gICAgICAgIGlmIChjb21wb25lbnQgJiYgIWNvbnRhaW5zKGNvbXBvbmVudCwgZm9jdXNlZCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGJsdXIgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgZm9jdXNlZCAmJiBmb2N1c2VkLmJsdXIgJiYgZm9jdXNlZC5ibHVyKCk7XG4gICAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvRE9NL0ZvY3VzLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZXhwb3J0ICogZnJvbSBcIi4vU3R5bGVzaGVldFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vU3R5bGVzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ET01QYWdlT3B0aW9uc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vRE9NQmxvY2tcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0RPTUFuaW1hdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vRm9jdXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21haW5cIjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL1VJL0RPTS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0ICogYXMgQXN5bmMgZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9Bc3luY1wiO1xuaW1wb3J0IHsgRHJhZywgU3R5bGUgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4vRE9NXCI7XG4vKiogVGhlIGRpc3RhbmNlIHRvIG1vdmUgYmVmb3JlIHRoZSBgLm1vdmVkYCBwcm9taXNlIGdldHMgcmVzb2x2ZWQgKi9cbnZhciBQWF9NT1ZFX1RIUkVTSE9MRCA9IDQ7XG4vKiogVGhlIHBhY2UgKG1zKSBhdCB3aGljaCBtb3VzZSBtb3ZlIGV2ZW50cyB0YWtlIGVmZmVjdCAqL1xudmFyIE1PVVNFX01PVkVfUEFDRSA9IDIwO1xuLyoqIFJlcHJlc2VudHMgYSBkcmFnIG9wZXJhdGlvbiBpbiB0aGUgRE9NIGNvbnRleHQgKi9cbnZhciBET01EcmFnID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRE9NRHJhZywgX3N1cGVyKTtcbiAgICAvKiogSW5pdGlhbGl6ZSB0aGUgb3BlcmF0aW9uIGFuZCBzdGFydCB0cmFja2luZyBtb3VzZSBtb3ZlbWVudCwgc2VuZHMgZHJhZyBzdGFydCBldmVudCB0byBnaXZlbiB0YXJnZXQgRE9NIGVsZW1lbnQ7IHN0YXJ0cyBzZW5kaW5nIGRyYWcgZW50ZXIgYW5kIGRyYWcgbGVhdmUgZXZlbnRzIGFzIHdlbGwgKi9cbiAgICBmdW5jdGlvbiBET01EcmFnKGV2ZW50IC8qIFRPRE86IHwgVG91Y2hFdmVudCAqLykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBzaGFkb3cgcHJvcGVydGllcyBmb3IgeCBhbmQgeVxuICAgICAgICBfdGhpcy5fY3VyWCA9IG5ldyBBc3luYy5PYnNlcnZhYmxlVmFsdWUoKTtcbiAgICAgICAgX3RoaXMuX2N1clkgPSBuZXcgQXN5bmMuT2JzZXJ2YWJsZVZhbHVlKCk7XG4gICAgICAgIF90aGlzLl9jdXJYLnZhbHVlID0gX3RoaXMuX29yaWdYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgX3RoaXMuX2N1clkudmFsdWUgPSBfdGhpcy5fb3JpZ1kgPSBldmVudC5jbGllbnRZO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIHRhcmdldC5zZXRDYXB0dXJlICYmIHRhcmdldC5zZXRDYXB0dXJlKCk7XG4gICAgICAgIF90aGlzLl9vcmlnVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBfdGhpcy5tb3ZlZCA9IG5ldyBBc3luYy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBfdGhpcy5fbW92ZWRfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGlzIG92ZXJyaWRkZW4gd2hlbiBjb25zdHJhaW5pbmcgbW92ZW1lbnRcbiAgICAgICAgX3RoaXMuX3NldENvb3JkcyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBfdGhpcy5fY3VyWC52YWx1ZSA9IHg7XG4gICAgICAgICAgICBfdGhpcy5fY3VyWS52YWx1ZSA9IHk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gaXMgb3ZlcnJpZGRlbiB3aGVuIHBpY2tpbmcgdXAgYW4gZWxlbWVudFxuICAgICAgICBfdGhpcy5fZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7IH07XG4gICAgICAgIC8vIHNlbmQgZXZlbnQgdG8gdG9wIGxldmVsIGVsZW1lbnQgdG8gd2FrZSB1cCBsaXN0ZW5lcnNcbiAgICAgICAgdmFyIHVpRHJhZ1N0YXJ0ID0gbmV3IEN1c3RvbUV2ZW50KFwidWlkcmFnc3RhcnRcIiwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlLCBkZXRhaWw6IF90aGlzLmRldGFpbCB9KTtcbiAgICAgICAgaWYgKHRhcmdldC5kaXNwYXRjaEV2ZW50KHVpRHJhZ1N0YXJ0KSlcbiAgICAgICAgICAgIGFkZExpc3RlbmVycygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRE9NRHJhZy5wcm90b3R5cGUsIFwieFwiLCB7XG4gICAgICAgIC8qKiBDdXJyZW50IHZpZXdwb3J0IFggY29vcmRpbmF0ZSAocmVhZC1vbmx5IG9ic2VydmFibGUsIGNvbnN0cmFpbmVkKSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1clgudmFsdWU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01EcmFnLnByb3RvdHlwZSwgXCJ5XCIsIHtcbiAgICAgICAgLyoqIEN1cnJlbnQgdmlld3BvcnQgWSBjb29yZGluYXRlIChyZWFkLW9ubHkgb2JzZXJ2YWJsZSwgY29uc3RyYWluZWQpICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY3VyWS52YWx1ZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIENvbnN0cmFpbiBlZmZlY3RpdmUgZHJhZyBjb29yZGluYXRlcyBvbiAob3JpZ2luYWwpIFggYW5kL29yIFkgYXhpcyBvZiB0aGUgdmlld3BvcnQsIGFuZC9vciBjb250cmFpbiB0byBzdGF5IHdpdGhpbiBnaXZlbiBlbGVtZW50IG9uIHNjcmVlbiAoY2FsbGluZyB0aGlzIG1ldGhvZCB0d2ljZSBkb2VzIG5vdCBjb25zdHJhaW4gZnVydGhlciwgYnV0IHRoZSBjb25zdHJhaW50cyBhcmUgcmVwbGFjZWQpICovXG4gICAgRE9NRHJhZy5wcm90b3R5cGUuY29uc3RyYWluID0gZnVuY3Rpb24gKGNvbnN0cmFpblgsIGNvbnN0cmFpblksIGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBmaW5kIHRoZSBlbGVtZW50IHRvIGNvbnN0cmFpbiB0b1xuICAgICAgICB2YXIgYmFzZUVsdCA9IHRoaXMuX2N1cnJlbnRUYXJnZXQgfHwgdGhpcy5fb3JpZ1RhcmdldDtcbiAgICAgICAgdmFyIGNvbnN0cmFpbkVsdDtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IGNvbXBvbmVudC5nZXRMYXN0UmVuZGVyZWRPdXRwdXQoKTtcbiAgICAgICAgICAgIGlmIChvdXQgJiYgb3V0LmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW5FbHQgPSBiYXNlRWx0ID0gb3V0LmVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdSZWN0ID0gYmFzZUVsdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgP1xuICAgICAgICAgICAgYmFzZUVsdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIHZhciBiYXNlWCA9ICh0aGlzLl9jdXJYLnZhbHVlIC0gb3JpZ1JlY3QubGVmdCkgKyAoYmFzZUVsdC5zY3JvbGxMZWZ0IHx8IDApO1xuICAgICAgICB2YXIgYmFzZVkgPSAodGhpcy5fY3VyWS52YWx1ZSAtIG9yaWdSZWN0LnRvcCkgKyAoYmFzZUVsdC5zY3JvbGxUb3AgfHwgMCk7XG4gICAgICAgIHRoaXMuX3NldENvb3JkcyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJlY3QgPSBiYXNlRWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgLy8gY29uc3RyYWluIG9uIFggYW5kL29yIFkgYXhpc1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpblgpXG4gICAgICAgICAgICAgICAgeCA9IChiYXNlWCAtIGJhc2VFbHQuc2Nyb2xsTGVmdCkgKyBjdXJyZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpblkpXG4gICAgICAgICAgICAgICAgeSA9IChiYXNlWSAtIGJhc2VFbHQuc2Nyb2xsVG9wKSArIGN1cnJlbnRSZWN0LnRvcDtcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbiB0byBlbGVtZW50IG9uIHNjcmVlblxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbkVsdCkge1xuICAgICAgICAgICAgICAgIGlmICh4IDwgY3VycmVudFJlY3QubGVmdClcbiAgICAgICAgICAgICAgICAgICAgeCA9IGN1cnJlbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKHggPiBjdXJyZW50UmVjdC5yaWdodClcbiAgICAgICAgICAgICAgICAgICAgeCA9IGN1cnJlbnRSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh5IDwgY3VycmVudFJlY3QudG9wKVxuICAgICAgICAgICAgICAgICAgICB5ID0gY3VycmVudFJlY3QudG9wO1xuICAgICAgICAgICAgICAgIGlmICh5ID4gY3VycmVudFJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICB5ID0gY3VycmVudFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2N1clgudmFsdWUgPSB4IDwgMCA/IDAgOiB4O1xuICAgICAgICAgICAgX3RoaXMuX2N1clkudmFsdWUgPSB5IDwgMCA/IDAgOiB5O1xuICAgICAgICB9O1xuICAgICAgICAvLyBjb25zdHJhaW4gY29vcmRpbmF0ZXMgbm93XG4gICAgICAgIHRoaXMuX3NldENvb3Jkcyh0aGlzLl9jdXJYLnZhbHVlLCB0aGlzLl9jdXJZLnZhbHVlKTtcbiAgICB9O1xuICAgIC8qKiBNYWtlIGdpdmVuIGNvbXBvbmVudCBmb2xsb3cgdGhlIG1vdXNlIGN1cnNvciB3aGlsZSBkcmFnZ2luZzsgaWYgdGhlIGNvbXBvbmVudCBkb2VzIG5vdCBjb250YWluIGEgZml4ZWQtcG9zaXRpb24gZWxlbWVudCwgdGhlIGVsZW1lbnQgc3R5bGUgd2lsbCBiZSBjaGFuZ2VkIHRvIHVzZSBmaXhlZCBhYnNvbHV0ZSBwb3NpdGlvbmluZywgYW5kIGEgcGxhY2hvbGRlciB3aWxsIGJlIGluc2VydGVkIGluc3RlYWQgKi9cbiAgICBET01EcmFnLnByb3RvdHlwZS5waWNrVXAgPSBmdW5jdGlvbiAoY29tcG9uZW50LCByZW1vdmVXaGVuRG9uZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZWxlbWVudDtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IGNvbXBvbmVudC5nZXRMYXN0UmVuZGVyZWRPdXRwdXQoKTtcbiAgICAgICAgICAgIGlmIChvdXQpXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IG91dC5lbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWxlbWVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIG92ZXJyaWRlIGNvbXBvbmVudCBzdHlsZSB0byBtb3ZlIGl0IGFyb3VuZFxuICAgICAgICB2YXIgb3ZlcnJpZGUgPSBjb21wb25lbnRbXCJAX0RPTURyYWdfT3ZlcnJpZGVcIl07XG4gICAgICAgIGlmICghb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlID0gY29tcG9uZW50W1wiQF9ET01EcmFnX092ZXJyaWRlXCJdID0gbmV3IFN0eWxlKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogXCJhdXRvXCIsIHJpZ2h0OiBcImF1dG9cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb21wb25lbnQuc3R5bGUub3ZlcnJpZGUob3ZlcnJpZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgKGFuZCBmaXgpIHRoZSBlbGVtZW50J3MgcG9zaXRpb25cbiAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgb1ggPSB0aGlzLl9jdXJYLnZhbHVlIC0gcmVjdC5sZWZ0O1xuICAgICAgICB2YXIgb1kgPSB0aGlzLl9jdXJZLnZhbHVlIC0gcmVjdC50b3A7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiX19kcmFnX3BsYWNlaG9sZGVyX1wiICsgY29tcG9uZW50LnVpZCk7XG4gICAgICAgIGlmICghcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gRE9NLmRpdihcIl9fZHJhZ19wbGFjZWhvbGRlclwiKTtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLmlkID0gXCJfX2RyYWdfcGxhY2Vob2xkZXJfXCIgKyBjb21wb25lbnQudWlkO1xuICAgICAgICAgICAgcGxhY2Vob2xkZXIuc3R5bGUuZm9udFNpemUgPSBcIjBcIjtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLnN0eWxlLmxpbmVIZWlnaHQgPSBcIjBcIjtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLnN0eWxlLmhlaWdodCA9IHJlY3QuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgcGxhY2Vob2xkZXIuc3R5bGUud2lkdGggPSByZWN0LndpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgcGxhY2Vob2xkZXIuc3R5bGUubWFyZ2luID0gZWxlbWVudC5zdHlsZS5tYXJnaW47XG4gICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBsYWNlaG9sZGVyLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBvdmVycmlkZS5zZXQoeyBsZWZ0OiBvWCArIFwicHhcIiwgdG9wOiBvWSArIFwicHhcIiB9KTtcbiAgICAgICAgLy8gbW92ZSBlbGVtZW50IHdoaWxlIGRyYWdnaW5nXG4gICAgICAgIEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIGxlZnQ6IChfdGhpcy5fY3VyWC52YWx1ZSAtIG9YKSArIFwicHhcIixcbiAgICAgICAgICAgIHRvcDogKF90aGlzLl9jdXJZLnZhbHVlIC0gb1kpICsgXCJweFwiXG4gICAgICAgIH0pOyB9KS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICBvdmVycmlkZS5zZXQoc3R5bGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbG9vayBcInRocm91Z2hcIiBlbGVtZW50IHdoZW4gY2hlY2tpbmcgb24gdGFyZ2V0XG4gICAgICAgIHRoaXMuX2dldFRhcmdldCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJoaWRkZW5cIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICAvLyByZW1vdmUgZWxlbWVudCB3aGVuIGRvbmVcbiAgICAgICAgaWYgKHJlbW92ZVdoZW5Eb25lKSB7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlRWx0cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSAmJlxuICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KSAmJlxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocGxhY2Vob2xkZXIpOyB9O1xuICAgICAgICAgICAgdGhpcy5Ecm9wcGVkLmNvbm5lY3QocmVtb3ZlRWx0cyk7XG4gICAgICAgICAgICB0aGlzLkNhbmNlbGVkLmNvbm5lY3QocmVtb3ZlRWx0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBTdG9wIHRoZSBjdXJyZW50IGRyYWcgb3BlcmF0aW9uICovXG4gICAgRE9NRHJhZy5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vcmlnVGFyZ2V0LnJlbGVhc2VDYXB0dXJlICYmXG4gICAgICAgICAgICB0aGlzLl9vcmlnVGFyZ2V0LnJlbGVhc2VDYXB0dXJlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuY2FuY2VsLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIGFsc28gc2VuZCAoYnViYmxpbmchKSB1aWRyYWdsZWF2ZSBmb3Igc3ltbWV0cnlcbiAgICAgICAgdmFyIHVpRHJhZ0xlYXZlID0gbmV3IEN1c3RvbUV2ZW50KFwidWlkcmFnbGVhdmVcIiwgeyBidWJibGVzOiB0cnVlLCBkZXRhaWw6IHRoaXMuZGV0YWlsIH0pO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ICYmIHRoaXMuX2N1cnJlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudCh1aURyYWdMZWF2ZSk7XG4gICAgICAgIC8vIHJlbW92ZSBtb3VzZSBsaXN0ZW5lcnMgaWYgbm90IGRyYWdnaW5nIGFueW1vcmVcbiAgICAgICAgaWYgKCFEcmFnLmdldEN1cnJlbnRJbnN0YW5jZXMoKS5sZW5ndGgpXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIC8qKiBBY2NlcHQgdGhlIGN1cnJlbnQgZHJvcCB0YXJnZXQgKGkuZS4gcGVyZm9ybSB0aGUgZHJvcCwgcHJpbWFyaWx5IGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IG1vdXNldXAgaGFuZGxlciBidXQgY2FuIGJlIGNhbGxlZCBtYW51YWxseSk7IHNlbmRzIGRyb3AgZXZlbnQgdG8gZHJvcCB0YXJnZXQgZWxlbWVudCAqL1xuICAgIERPTURyYWcucHJvdG90eXBlLmRyb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29yaWdUYXJnZXQucmVsZWFzZUNhcHR1cmUgJiZcbiAgICAgICAgICAgIHRoaXMuX29yaWdUYXJnZXQucmVsZWFzZUNhcHR1cmUoKTtcbiAgICAgICAgLy8gc2VuZCBldmVudCB0byBkcm9wIHRhcmdldCB0byBjb25maXJtXG4gICAgICAgIHZhciB1aURyYWdEcm9wID0gbmV3IEN1c3RvbUV2ZW50KFwidWlkcmFnZHJvcFwiLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUsIGRldGFpbDogdGhpcy5kZXRhaWwgfSk7XG4gICAgICAgIHZhciBjYW5jZWxlZCA9ICEodGhpcy5fY3VycmVudFRhcmdldCAmJlxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KHVpRHJhZ0Ryb3ApKTtcbiAgICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZHJvcC5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBhbHNvIHNlbmQgKGJ1YmJsaW5nISkgdWlkcmFnbGVhdmUgZm9yIHN5bW1ldHJ5XG4gICAgICAgIHZhciB1aURyYWdMZWF2ZSA9IG5ldyBDdXN0b21FdmVudChcInVpZHJhZ2xlYXZlXCIsIHsgYnViYmxlczogdHJ1ZSwgZGV0YWlsOiB0aGlzLmRldGFpbCB9KTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCAmJiB0aGlzLl9jdXJyZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQodWlEcmFnTGVhdmUpO1xuICAgICAgICAvLyByZW1vdmUgbW91c2UgbGlzdGVuZXJzIGlmIG5vdCBkcmFnZ2luZyBhbnltb3JlXG4gICAgICAgIGlmICghRHJhZy5nZXRDdXJyZW50SW5zdGFuY2VzKCkubGVuZ3RoKVxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICAvKiogVXBkYXRlIG1vdXNlIGN1cnNvciBzY3JlZW4gY29vcmRpbmF0ZXMgKHByaW1hcmlseSBjYWxsZWQgYnkgbW91c2Vtb3ZlIGhhbmRsZXIpOyByZXR1cm5zIHRydWUgaWYgYW4gZWxlbWVudCB3YXMgc2Nyb2xsZWQgLSBtZWFuaW5nIHVwZGF0ZSBzaG91bGQgYmUgY2FsbGVkIGFnYWluIGFmdGVyIGEgc2hvcnQgdGltZSAqL1xuICAgIERPTURyYWcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvbGRYID0gdGhpcy5fY3VyWC52YWx1ZTtcbiAgICAgICAgdmFyIG9sZFkgPSB0aGlzLl9jdXJZLnZhbHVlO1xuICAgICAgICB0aGlzLl9zZXRDb29yZHMoeCwgeSk7XG4gICAgICAgIHZhciBuZXdYID0gdGhpcy5fY3VyWC52YWx1ZSwgbmV3WSA9IHRoaXMuX2N1clkudmFsdWU7XG4gICAgICAgIC8vIGdldCB0YXJnZXQgZWxlbWVudCBhbmQgc2Nyb2xsIGlmIG5lZWRlZFxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0VGFyZ2V0KG5ld1gsIG5ld1kpO1xuICAgICAgICB2YXIgY3VyID0gdGFyZ2V0O1xuICAgICAgICB2YXIgc2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGN1ciAmJiAhc2Nyb2xsZWQpIHtcbiAgICAgICAgICAgIHZhciBjdXJTdHlsZTtcbiAgICAgICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgICAgIChjdXJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGN1cikpICYmXG4gICAgICAgICAgICAgICAgY3VyU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93XCIpICE9PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjdXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ggPCByZWN0LmxlZnQgKyAzMiAmJiBjdXIuc2Nyb2xsTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBjdXIuc2Nyb2xsTGVmdCAtIDgpO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdZIDwgcmVjdC50b3AgKyAzMiAmJiBjdXIuc2Nyb2xsVG9wID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgY3VyLnNjcm9sbFRvcCAtIDgpO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdYID4gcmVjdC5yaWdodCAtIDMyICYmXG4gICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxMZWZ0IDwgY3VyLnNjcm9sbFdpZHRoIC0gY3VyLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxMZWZ0ID0gY3VyLnNjcm9sbExlZnQgKyA4O1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdZID4gcmVjdC5ib3R0b20gLSAzMiAmJlxuICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsVG9wIDwgY3VyLnNjcm9sbEhlaWdodCAtIGN1ci5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbFRvcCA9IGN1ci5zY3JvbGxUb3AgKyA4O1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbGVkKSB7XG4gICAgICAgICAgICAvLyBtaWdodCBoYXZlIHNjcm9sbGVkIHRvIGEgbmV3IChjaGlsZCkgdGFyZ2V0XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9nZXRUYXJnZXQobmV3WCwgbmV3WSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZFggIT09IG5ld1ggfHwgb2xkWSAhPT0gbmV3WSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgb25seSBub3cgbW92aW5nIGZhciBlbm91Z2hcbiAgICAgICAgICAgIGlmICghdGhpcy5fbW92ZWQgJiZcbiAgICAgICAgICAgICAgICAoTWF0aC5hYnMobmV3WCAtIHRoaXMuX29yaWdYKSA+IFBYX01PVkVfVEhSRVNIT0xEIHx8XG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuX29yaWdZIC0gbmV3WSkgPiBQWF9NT1ZFX1RIUkVTSE9MRCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZWRfcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluZm9ybSBvbGQgYW5kIG5ldyBwb3RlbnRpYWwgZHJvcCB0YXJnZXQocylcbiAgICAgICAgICAgIHZhciBvbGRUYXJnZXQgPSB0aGlzLl9jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGFyZ2V0ICYmIHRoaXMuX2N1cnJlbnRUYXJnZXQgIT09IG9sZFRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgb2xkIGRyb3AgdGFyZ2V0cyB0aGF0IGRvIG5vdCBjb250YWluIG5ldyBkcm9wIHRhcmdldFxuICAgICAgICAgICAgICAgIHZhciBsZWZ0VGFyZ2V0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChvbGRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBpZiB0aGUgb2xkIHRhcmdldCBjb250YWlucyB0aGUgbmV3IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG9sZFRhcmdldCkgJiA4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzZW5kIGEgbm9uLWJ1YmJsaW5nIFwibGVhdmVcIiBldmVudCAoaW4gcmV2ZXJzZSlcbiAgICAgICAgICAgICAgICAgICAgbGVmdFRhcmdldHMudW5zaGlmdChvbGRUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBnbyB1cCB0byBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRUYXJnZXQgPSBvbGRUYXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAob2xkVGFyZ2V0ICYmICFvbGRUYXJnZXQuZGlzcGF0Y2hFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlZnRUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKGVsdCkge1xuICAgICAgICAgICAgICAgICAgICBlbHQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJ1aWRyYWdsZWF2ZVwiLCB7IGRldGFpbDogX3RoaXMuZGV0YWlsIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBvbGRUYXJnZXQgaXMgbm93IHRoZSBjbG9zZXN0IG9sZCBwYXJlbnQsIG9yIG51bGw7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBuZXcgZHJvcCB0YXJnZXRzIChjaGlsZCBlbGVtZW50cywgdXAgdG8gc2hhcmVkIHBhcmVudClcbiAgICAgICAgICAgICAgICB2YXIgZW50ZXJlZFRhcmdldHMgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gb2xkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgYSBub24tYnViYmxpbmcgXCJlbnRlclwiIGV2ZW50IChpbiByZXZlcnNlKVxuICAgICAgICAgICAgICAgICAgICBlbnRlcmVkVGFyZ2V0cy51bnNoaWZ0KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdvIHVwIHRvIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICh0YXJnZXQgJiYgIXRhcmdldC5kaXNwYXRjaEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50ZXJlZFRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAoZWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsdC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInVpZHJhZ2VudGVyXCIsIHsgZGV0YWlsOiBfdGhpcy5kZXRhaWwgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY3JvbGxlZDtcbiAgICB9O1xuICAgIHJldHVybiBET01EcmFnO1xufShEcmFnKSk7XG4vLyB1c2UgdGhpcyBjbGFzcyBhcyB0aGUgcHJpbWFyeSBEcmFnIGNsYXNzOlxuRHJhZy5CYXNlQ2xhc3MgPSBET01EcmFnO1xuLy8gbW91c2Vtb3ZlIHBhY2VyIHRpbWVyIChmaXJlcyBvbmx5IGFmdGVyIGRlbGF5IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UpXG52YXIgbW91c2VNb3ZlUGFjZXI7XG52YXIgbGFzdE1vdXNlTW92ZTtcbi8vIG1vdXNlbW92ZSBldmVudCBoYW5kbGVyLCB1cGRhdGVzIGN1cnJlbnQgZHJhZyBjb29yZGluYXRlc1xuZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICBmdW5jdGlvbiBkb1VwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGxhc3RNb3VzZU1vdmUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gbGFzdE1vdXNlTW92ZS5jbGllbnRYO1xuICAgICAgICAgICAgdmFyIHkgPSBsYXN0TW91c2VNb3ZlLmNsaWVudFk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIERyYWcuZ2V0Q3VycmVudEluc3RhbmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGRyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZy51cGRhdGUoeCwgeSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBBc3luYy5ydW5ZaWVsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHBhY2UgdXBkYXRlcywgZXhjZXB0IGZvciBmaXJzdCBvbmUgdG8gYXZvaWQgZGVsYXlcbiAgICB2YXIgZmlyc3RVcGRhdGUgPSAhbGFzdE1vdXNlTW92ZTtcbiAgICBsYXN0TW91c2VNb3ZlID0gZXZlbnQ7XG4gICAgaWYgKGZpcnN0VXBkYXRlKSB7XG4gICAgICAgIGRvVXBkYXRlKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFtb3VzZU1vdmVQYWNlcikge1xuICAgICAgICBtb3VzZU1vdmVQYWNlciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxlZCA9IGRvVXBkYXRlKCk7XG4gICAgICAgICAgICBtb3VzZU1vdmVQYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlZClcbiAgICAgICAgICAgICAgICBvbk1vdXNlTW92ZShsYXN0TW91c2VNb3ZlKTtcbiAgICAgICAgfSwgTU9VU0VfTU9WRV9QQUNFKTtcbiAgICB9XG59XG4vLyBtb3VzZXVwIGhhbmRsZXIgdG8gY2FwdHVyZSBkcm9wIGV2ZW50c1xuZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgIERyYWcuZ2V0Q3VycmVudEluc3RhbmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZHJvcCgpOyB9KTtcbiAgICBBc3luYy5ydW5ZaWVsZCgpO1xufVxuLy8gaWYgbW91c2UgbW92ZXMgb3V0IG9mIHRoZSB3aW5kb3cgd2hpbGUgZHJhZ2dpbmcsIGNhbmNlbCBkcmFnXG5mdW5jdGlvbiBvbk1vdXNlT3V0KGV2ZW50KSB7XG4gICAgdmFyIG1vdmVkVG8gPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICghbW92ZWRUbyB8fCBtb3ZlZFRvLm5vZGVOYW1lID09IFwiSFRNTFwiKVxuICAgICAgICBEcmFnLmdldEN1cnJlbnRJbnN0YW5jZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmNhbmNlbCgpOyB9KTtcbn1cbi8vIGNhbmNlbCBkcmFnIHdoZW4gZXNjIGtleSBpcyBwcmVzc2VkXG5mdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykge1xuICAgICAgICBEcmFnLmdldEN1cnJlbnRJbnN0YW5jZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmNhbmNlbCgpOyB9KTtcbiAgICB9XG59XG4vLyBjYW5jZWwgdGV4dCBzZWxlY3Rpb25cbnZhciBvbGRfb25TZWxlY3RTdGFydDtcbi8vIGhlbHBlciB1c2VkIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYW5kIHBhY2VyIHRpbWVyXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgb25Nb3VzZU91dCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0ID0gb2xkX29uU2VsZWN0U3RhcnQ7XG4gICAgbW91c2VNb3ZlUGFjZXIgJiYgd2luZG93LmNsZWFyVGltZW91dChtb3VzZU1vdmVQYWNlcik7XG4gICAgbW91c2VNb3ZlUGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgbGFzdE1vdXNlTW92ZSA9IHVuZGVmaW5lZDtcbn1cbi8vIGhlbHBlciB1c2VkIHRvIGFkZCBldmVudCBsaXN0ZW5lcnMgd2hlbiBhY3R1YWxseSBkcmFnZ2luZ1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIG9uTW91c2VPdXQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgb2xkX29uU2VsZWN0U3RhcnQgPSBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0O1xuICAgIGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL1VJL0RyYWcuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IENvbnRhaW5lciwgUGFnZSwgUGFnZVJlbmRlcmVyLCBTY3JlZW4gfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4vRE9NXCI7XG5pbXBvcnQgeyBVcGRhdGVDb250ZXh0IH0gZnJvbSBcIi4vVXBkYXRlQ29udGV4dFwiO1xuLyoqIENvbnRhaW5zIGZ1bmN0aW9uYWxpdHkgZm9yIHJlbmRlcmluZyBhIHBhZ2UgdG8gdGhlIERPTTsgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBhZ2VSZW5kZXJlciBjbGFzcywgdXNlZCBieSBQYWdlIHRvIHBlcmZvcm0gcGxhdGZvcm0gZGVwZW5kZW50IHRhc2tzICovXG52YXIgRE9NUGFnZVJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRE9NUGFnZVJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERPTVBhZ2VSZW5kZXJlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgQm91bmQga2V5ZG93biBldmVudCBoYW5kbGVyIChvbiB0aGUgd2luZG93KSAqL1xuICAgICAgICBfdGhpcy5fb25LZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX29uRXZlbnQoZXZlbnQpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLktleURvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGludm9rZSB0b3AgY29tcG9uZW50J3Mgb25Fc2MgaGFuZGxlciB3aGVuIGVzY2FwZSBpcyBwcmVzc2VkXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYWdlLmhhbmRsZUVzYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsIEJvdW5kIGV2ZW50IGhhbmRsZXIgKG9uIHRoZSB3aW5kb3cpICovXG4gICAgICAgIF90aGlzLl9vbkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2lzQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01QYWdlUmVuZGVyZXIucHJvdG90eXBlLCBcImRvbVVwZGF0ZXJcIiwge1xuICAgICAgICAvKiogRE9NIHVwZGF0ZSBjb250ZXh0IGZvciB0aGUgcmVuZGVyZWQgcGFnZSAobWVtb2l6ZWQpICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBwYWdlIHJvb3QgZWxlbWVudFxuICAgICAgICAgICAgdmFyIHJvb3QgPSBET00uZGl2KFwiX19wYWdlXCIpO1xuICAgICAgICAgICAgcm9vdC5pZCA9IERPTS51aWQ7XG4gICAgICAgICAgICByb290LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgcm9vdC5zdHlsZS56SW5kZXggPSBTdHJpbmcoRE9NLlBBR0VfT1BUSU9OUy5iYXNlWkluZGV4KTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdXBkYXRlIGNvbnRleHQgZm9yIHRoZSBwYWdlIHJvb3QgZWxlbWVudFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGRhdGVDb250ZXh0KHJvb3QpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogUmVuZGVyIGFuZCBzaG93IHRoZSBwYWdlICh3aXRoaW4gYW4gb2JzZXJ2YWJsZSBnZXR0ZXIpOyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gYWxsIGNvbnRlbnQgaGFzIGJlZW4gcmVuZGVyZWQgKi9cbiAgICBET01QYWdlUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUFzeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBhdHRhY2gga2V5ZG93biBoYW5kbGVyIHRvIHRoZSB3aW5kb3dcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5ZG93bik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleWRvd24pO1xuICAgICAgICAvLyByZXNldCByZWZlcmVuY2UgdG8gY3VycmVudGx5IHNoYWRlZCB3cmFwcGVyXG4gICAgICAgIHRoaXMuX3NoYWRlZFdyYXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHRha2UgZmxvdyBkaXJlY3Rpb24gZnJvbSBzY3JlZW4gaWYgbm90IGRlZmluZWQgb24gcGFnZVxuICAgICAgICBpZiAoIXRoaXMucGFnZS5mbG93RGlyZWN0aW9uICYmIFNjcmVlbi5kZWZhdWx0Rmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGFnZS5mbG93RGlyZWN0aW9uID0gU2NyZWVuLmRlZmF1bHRGbG93RGlyZWN0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVuZGVyIGFsbCBjb250ZW50IGludG8gRE9NIG5vZGVzXG4gICAgICAgIHZhciBjb250ZW50ID0gW107XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5wYWdlLmNvbnRlbnQuc2xpY2UoKTtcbiAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAvLyBjb3B5IGx0ci9ydGwgZmxvdyBkaXJlY3Rpb24gaWYgc2V0IGF0IHBhZ2UgbGV2ZWxcbiAgICAgICAgICAgIGlmIChjICYmIF90aGlzLnBhZ2UuZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjLmZsb3dEaXJlY3Rpb24gPSBfdGhpcy5wYWdlLmZsb3dEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW5kZXIgY29tcG9uZW50IHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIHZhciBvdXQgPSBjICYmIGMub3V0O1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBvdXQgJiYgb3V0LmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIHdyYXBwZXIgZWxlbWVudCwgb3IgY3JlYXRlIG9uZVxuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gb3V0LndyYXBwZXI7XG4gICAgICAgICAgICAgICAgaWYgKCF3cmFwcGVyIHx8IHdyYXBwZXIuY2xhc3NOYW1lICE9PSBcIl9fcGFnZV93cmFwcGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBvdXQud3JhcHBlciA9IF90aGlzLl9jcmVhdGVXcmFwcGVyKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZVdyYXBwZXIoZWxlbWVudCwgd3JhcHBlciwgY1tcImRpc3BsYXlPcHRpb25zXCJdLCBjLnN0eWxlLCBjIGluc3RhbmNlb2YgQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHJlbmRlcmVkIG91dHB1dCBpbnN0YW5jZSB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIGEgcGxhY2Vob2xkZXIgdG8gc3RvcCBlbGVtZW50cyBmcm9tIHNoaWZ0aW5nIGFyb3VuZFxuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChkb2N1bWVudC5jcmVhdGVDb21tZW50KFwicGxhY2Vob2xkZXJcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgcGFnZSBlbGVtZW50IHRvIHRoZSBkb2N1bWVudCBib2R5LCBpZiBuZWVkZWRcbiAgICAgICAgdmFyIHVwZGF0ZXIgPSB0aGlzLmRvbVVwZGF0ZXI7XG4gICAgICAgIGlmICghdXBkYXRlci5yb290LnBhcmVudE5vZGUpXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZG9tVXBkYXRlci5yb290KTtcbiAgICAgICAgLy8gYWRkIGFsbCBjb250ZW50IHRvIHRoZSBwYWdlIGVsZW1lbnQgKHVzaW5nIGdlbmVyYXRlZCB3cmFwcGVycylcbiAgICAgICAgcmV0dXJuIHVwZGF0ZXIudXBkYXRlQXN5bmMoY29udGVudCwgdHJ1ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wYWdlLlJlbmRlcmVkKCk7XG4gICAgICAgICAgICBfdGhpcy5fbW92ZVNoYWRlRWxlbWVudCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBSZW1vdmUgdGhlIHJlbmRlcmVkIHBhZ2UgZnJvbSB0aGUgc2NyZWVuICovXG4gICAgRE9NUGFnZVJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgcGFnZSBlbGVtZW50IGl0c2VsZlxuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuZG9tVXBkYXRlci5yb290O1xuICAgICAgICBpZiAocm9vdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgcm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJvb3QpO1xuICAgICAgICAvLyByZW1vdmUga2V5ZG93biB3aW5kb3cgZXZlbnQgaGFuZGxlclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fb25LZXlkb3duLCB0cnVlKTtcbiAgICAgICAgLy8gY2xlYW4gdXAgcmVmZXJlbmNlc1xuICAgICAgICBkZWxldGUgdGhpcy5fdG9wT3B0aW9ucztcbiAgICAgICAgZGVsZXRlIHRoaXMuX3NoYWRlZFdyYXBwZXI7XG4gICAgfTtcbiAgICAvKiogQmxvY2sgYWxsIGlucHV0ICovXG4gICAgRE9NUGFnZVJlbmRlcmVyLnByb3RvdHlwZS5kaXNhYmxlSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHVuZm9jdXMgYW5kIHNldCBmbGFnXG4gICAgICAgIERPTS5ibHVyKCk7XG4gICAgICAgIHRoaXMuX2lzQmxvY2tlZCA9IHRydWU7XG4gICAgICAgIC8vIGFkZCBibG9ja2luZyBldmVudCBoYW5kbGVycyBvbiB0aGUgd2luZG93IChvbiBjYXB0dXJlKVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9vbkV2ZW50LCB0cnVlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9vbkV2ZW50LCB0cnVlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLl9vbkV2ZW50LCB0cnVlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3RzdGFydFwiLCB0aGlzLl9vbkV2ZW50LCB0cnVlKTtcbiAgICAgICAgLy8gYWRkIG92ZXJsYXkgZWxlbWVudCB0byB3cmFwIG92ZXIgZXhpc3RpbmcgY29udGVudFxuICAgICAgICBpZiAoIXRoaXMuX2Jsb2NrRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGJsb2NrZXIgPSB0aGlzLl9ibG9ja0VsZW1lbnQgPSBET00uZGl2KFwiX19wYWdlX2Jsb2NrXCIpO1xuICAgICAgICAgICAgYmxvY2tlci5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAgICAgICAgIGJsb2NrZXIuc3R5bGUudG9wID0gXCIwXCI7XG4gICAgICAgICAgICBibG9ja2VyLnN0eWxlLmJvdHRvbSA9IFwiMFwiO1xuICAgICAgICAgICAgYmxvY2tlci5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgICAgICAgICBibG9ja2VyLnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG4gICAgICAgICAgICBibG9ja2VyLnN0eWxlLmN1cnNvciA9IFwid2FpdFwiO1xuICAgICAgICAgICAgYmxvY2tlci5zdHlsZS56SW5kZXggPSBcIjEwMDAwMDAwMDBcIjtcbiAgICAgICAgICAgIGJsb2NrZXIuc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiYSgwLDAsMCwwKVwiOyAvLyBmb3IgSUVcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2Jsb2NrRWxlbWVudCk7XG4gICAgfTtcbiAgICAvKiogVW5ibG9jayBhbGwgaW5wdXQgKi9cbiAgICBET01QYWdlUmVuZGVyZXIucHJvdG90eXBlLmVuYWJsZUlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVtb3ZlIG92ZXJsYXkgZWxlbWVudFxuICAgICAgICBpZiAodGhpcy5fYmxvY2tFbGVtZW50ICYmIHRoaXMuX2Jsb2NrRWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGhpcy5fYmxvY2tFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fYmxvY2tFbGVtZW50KTtcbiAgICAgICAgLy8gcmVtb3ZlIGJsb2NraW5nIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSB3aW5kb3dcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fb25FdmVudCwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fb25FdmVudCwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5fb25FdmVudCwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgdGhpcy5fb25FdmVudCwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKiogU2Nyb2xsIHRvIGdpdmVuIGNvbXBvbmVudCAqL1xuICAgIERPTVBhZ2VSZW5kZXJlci5wcm90b3R5cGUuc2Nyb2xsVG8gPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIGNvbXBvbmVudC5nZXRSZW5kZXJlZE91dHB1dEFzeW5jKCkudGhlbihmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgICAgICB2YXIgZWx0ID0gb3V0ICYmIG91dC5lbGVtZW50O1xuICAgICAgICAgICAgaWYgKCFlbHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gZ28gdGhyb3VnaCBhbGwgcGFyZW50IGVsZW1lbnRzIHRvIHNjcm9sbCB0aGVtXG4gICAgICAgICAgICB2YXIgdG9wT2Zmc2V0ID0gZWx0Lm9mZnNldFRvcDtcbiAgICAgICAgICAgIHZhciBpdGVtSGVpZ2h0ID0gZWx0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHdoaWxlIChlbHQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsdCA9IGVsdC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEVsdC5zY3JvbGxUb3AgKyBwYXJlbnRFbHQub2Zmc2V0SGVpZ2h0IDxcbiAgICAgICAgICAgICAgICAgICAgdG9wT2Zmc2V0ICsgaXRlbUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGwgZG93biB0byBib3R0b20gb2Ygc2VsZWN0ZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbHQuc2Nyb2xsVG9wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcE9mZnNldCArIGl0ZW1IZWlnaHQgLSBwYXJlbnRFbHQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50RWx0LnNjcm9sbFRvcCA+IHRvcE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGwgdXAgdG8gdG9wIG9mIHNlbGVjdGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RWx0LnNjcm9sbFRvcCA9IHRvcE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9wT2Zmc2V0ICs9IHBhcmVudEVsdC5vZmZzZXRUb3AgLSBwYXJlbnRFbHQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIGVsdCA9IHBhcmVudEVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsIENyZWF0ZSBhbiBlbXB0eSBzaGFkZWQgYmFja2Ryb3AgZWxlbWVudCAqL1xuICAgIERPTVBhZ2VSZW5kZXJlci5wcm90b3R5cGUuX2NyZWF0ZVNoYWRlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMuX3NoYWRlRWxlbWVudCA9IERPTS5kaXYoXCJfX3BhZ2VfYmFja2Ryb3BzaGFkZXJcIik7XG4gICAgICAgIHNoYWRlci5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAgICAgc2hhZGVyLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgICAgc2hhZGVyLnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG4gICAgICAgIHNoYWRlci5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgICAgc2hhZGVyLnN0eWxlLmJvdHRvbSA9IFwiMFwiO1xuICAgICAgICBzaGFkZXIuc3R5bGUub3V0bGluZSA9IFwiMFwiO1xuICAgICAgICBzaGFkZXIuc3R5bGUuekluZGV4ID0gU3RyaW5nKERPTS5QQUdFX09QVElPTlMuYmFzZVpJbmRleCk7XG4gICAgICAgIHNoYWRlci5zdHlsZS5iYWNrZ3JvdW5kID0gRE9NLlBBR0VfT1BUSU9OUy5zaGFkZUNvbG9yO1xuICAgICAgICBzaGFkZXIuc3R5bGUudHJhbnNpdGlvbiA9IFwib3BhY2l0eSBcIiArXG4gICAgICAgICAgICBET00uUEFHRV9PUFRJT05TLnNoYWRlVHJhbnNpdGlvbiArIFwibXMgZWFzZVwiO1xuICAgICAgICBzaGFkZXIuc3R5bGUub3BhY2l0eSA9IFwiMFwiOyAvLyBpbml0aWFsXG4gICAgICAgIHNoYWRlci5zZXRBdHRyaWJ1dGUoVXBkYXRlQ29udGV4dC5VTk1BTkFHRURfRkxBRywgXCJ0cnVlXCIpO1xuICAgICAgICBzaGFkZXIudGFiSW5kZXggPSAtMTtcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgTW92ZSwgcmVtb3ZlLCBvciBpbnNlcnQgdGhlIG1vZGFsIGJhY2tkcm9wIHNoYWRlICovXG4gICAgRE9NUGFnZVJlbmRlcmVyLnByb3RvdHlwZS5fbW92ZVNoYWRlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmRvbVVwZGF0ZXIucm9vdDtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRlZFdyYXBwZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2hhZGVFbGVtZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNoYWRlRWxlbWVudCgpO1xuICAgICAgICAgICAgdmFyIHNoYWRlRWxlbWVudCA9IHRoaXMuX3NoYWRlRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBzaGFkZWRXcmFwcGVyID0gdGhpcy5fc2hhZGVkV3JhcHBlcjtcbiAgICAgICAgICAgIHJvb3QuaW5zZXJ0QmVmb3JlKHNoYWRlRWxlbWVudCwgdGhpcy5fc2hhZGVkV3JhcHBlcik7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3NoYWRlRWxlbWVudCA9PT0gc2hhZGVFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zaGFkZWRXcmFwcGVyID09PSBzaGFkZWRXcmFwcGVyKVxuICAgICAgICAgICAgICAgICAgICBzaGFkZUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcoRE9NLlBBR0VfT1BUSU9OUy5zaGFkZU9wYWNpdHkpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2hhZGVFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyB0cmFuc2l0aW9uIGFuZCByZW1vdmUgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgc2hhZGUgZWxlbWVudFxuICAgICAgICAgICAgdmFyIHNoYWRlcl8xID0gdGhpcy5fc2hhZGVFbGVtZW50O1xuICAgICAgICAgICAgc2hhZGVyXzEuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNoYWRlcl8xLnBhcmVudE5vZGUgJiYgIV90aGlzLl9zaGFkZWRXcmFwcGVyKVxuICAgICAgICAgICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKHNoYWRlcl8xKTtcbiAgICAgICAgICAgIH0sIERPTS5QQUdFX09QVElPTlMuc2hhZGVUcmFuc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCBDcmVhdGUgYW4gZW1wdHkgd3JhcHBlciBlbGVtZW50IGZvciBhIGNvbXBvbmVudCAqL1xuICAgIERPTVBhZ2VSZW5kZXJlci5wcm90b3R5cGUuX2NyZWF0ZVdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB3cmFwcGVyID0gRE9NLmRpdihcIl9fcGFnZV93cmFwcGVyXCIpO1xuICAgICAgICB3cmFwcGVyLnN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCI7XG4gICAgICAgIHdyYXBwZXIuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICAgIC8vIGRpc2FsbG93IGZvY3VzIGlmIGJlaGluZCBtb2RhbCBzaGFkZXJcbiAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3NoYWRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXIgPSB3cmFwcGVyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXIgJiYgY3VyLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciA9PT0gX3RoaXMuX3NoYWRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zaGFkZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIElFIGFsc28gbGlzdGVucyB0byBjbGlja3MgaW4gdGhlIHRyYW5zcGFyZW50IGFyZWE6XG4gICAgICAgIHdyYXBwZXIuc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiYSgwLDAsMCwwKVwiO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgUG9zaXRpb24gZ2l2ZW4gRE9NIGVsZW1lbnQgaW5zaWRlIG9mIGl0cyBwYWdlIHdyYXBwZXIgKi9cbiAgICBET01QYWdlUmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGVXcmFwcGVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIHdyYXBwZXIsIG9wdGlvbnMsIHN0eWxlLCB6ZXJvRm9udFNpemUpIHtcbiAgICAgICAgdGhpcy5fdG9wT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIGZpeCBmb250IHNpemUgZm9yIGNvbnRhaW5lciB3cmFwcGVyc1xuICAgICAgICBpZiAoemVyb0ZvbnRTaXplKSB7XG4gICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmxpbmVIZWlnaHQgPSBcIjBcIjtcbiAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUuZm9udFNpemUgPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUubGluZUhlaWdodCA9IFwiXCI7XG4gICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmZvbnRTaXplID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgei1pbmRleCB0byBmb2xsb3cgY29udGVudCBvcmRlciBvciBzdGF5IG9uIHRvcFxuICAgICAgICB3cmFwcGVyLnN0eWxlLnpJbmRleCA9IFN0cmluZyhET00uUEFHRV9PUFRJT05TLmJhc2VaSW5kZXggK1xuICAgICAgICAgICAgKChvcHRpb25zICYmIG9wdGlvbnMuc3RheU9uVG9wKSA/IDEwMDAgOiAwKSk7XG4gICAgICAgIC8vIHJlbWVtYmVyIHRvIGluc2VydCB0aGUgYmFja2Ryb3Agc2hhZGUgaGVyZSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFkZSlcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlZFdyYXBwZXIgPSB3cmFwcGVyO1xuICAgICAgICAvLyB1c2UgXCJkaXJcIiBhdHRyaWJ1dGUgaWYgZmxvdyBkaXJlY3Rpb24gc2V0XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmxvd0RpcmVjdGlvbilcbiAgICAgICAgICAgIHdyYXBwZXIuZGlyID0gb3B0aW9ucy5mbG93RGlyZWN0aW9uO1xuICAgICAgICAvLyB1c2UgLmRpc3BsYXlPcHRpb25zIHRvIGZpZ3VyZSBvdXQgcG9zaXRpb25pbmdcbiAgICAgICAgdmFyIGNlbGw7XG4gICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLm1vZGFsKSkge1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gdGhlIGVsZW1lbnQgaW5zaWRlIGEgZnVsbC1zY3JlZW4gdGFibGUgY2VsbFxuICAgICAgICAgICAgd3JhcHBlci5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUuYm90dG9tID0gXCIwXCI7XG4gICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgICAgICAgICAgIGlmICghd3JhcHBlci5maXJzdENoaWxkIHx8IHdyYXBwZXIuZmlyc3RDaGlsZCA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgbGF5b3V0IHdyYXBwZXIgY2VsbCBmaXJzdFxuICAgICAgICAgICAgICAgIGNlbGwgPSBET00uZGl2KFwiX19wYWdlX2xheW91dGNlbGxcIik7XG4gICAgICAgICAgICAgICAgY2VsbC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgICAgICAgICAgICAgY2VsbC5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcbiAgICAgICAgICAgICAgICBjZWxsLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgICAgIGNlbGwuc3R5bGUuaGVpZ2h0ID0gXCIxMDB2aFwiO1xuICAgICAgICAgICAgICAgIGNlbGwuc3R5bGUud2lkdGggPSBcIjEwMHZ3XCI7XG4gICAgICAgICAgICAgICAgY2VsbC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgY2VsbC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGNlbGwpO1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2VsbC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQoY2VsbC5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lIHRoYXQgdGhlIGZpcnN0IGNoaWxkIGlzIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAgY2VsbCA9IHdyYXBwZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBjZWxsLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgb3RoZXIgZWxlbWVudHNcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgIGNlbGwucmVtb3ZlQ2hpbGQoZWxlbWVudC5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWxpZ24gaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5XG4gICAgICAgICAgICBjZWxsLnN0eWxlLnRleHRBbGlnbiA9IG9wdGlvbnMubW9kYWxIb3J6QWxpZ24gfHwgXCJjZW50ZXJcIjtcbiAgICAgICAgICAgIGNlbGwuc3R5bGUudmVydGljYWxBbGlnbiA9IG9wdGlvbnMubW9kYWxWZXJ0QWxpZ24gfHwgXCJtaWRkbGVcIjtcbiAgICAgICAgICAgIGNlbGwuc3R5bGUucGFkZGluZ1RvcCA9IG9wdGlvbnMubW9kYWxWZXJ0QWxpZ24gPT09IFwidG9wXCIgP1xuICAgICAgICAgICAgICAgIChvcHRpb25zLmFsaWduTWFyZ2luIHx8IFwiMFwiKSA6XG4gICAgICAgICAgICAgICAgKG9wdGlvbnMubW9kYWxWZXJ0QWxpZ24gJiYgb3B0aW9ucy5vdXRlck1hcmdpbiB8fCBcIjBcIik7XG4gICAgICAgICAgICBjZWxsLnN0eWxlLnBhZGRpbmdCb3R0b20gPSBvcHRpb25zLm1vZGFsVmVydEFsaWduID09PSBcImJvdHRvbVwiID9cbiAgICAgICAgICAgICAgICAob3B0aW9ucy5hbGlnbk1hcmdpbiB8fCBcIjBcIikgOlxuICAgICAgICAgICAgICAgIChvcHRpb25zLm1vZGFsVmVydEFsaWduICYmIG9wdGlvbnMub3V0ZXJNYXJnaW4gfHwgXCIwXCIpO1xuICAgICAgICAgICAgdmFyIGlzTGVmdEFsaWduZWQgPSBvcHRpb25zLm1vZGFsSG9yekFsaWduID09PSBcImxlZnRcIiB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubW9kYWxIb3J6QWxpZ24gPT09IFwic3RhcnRcIjtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nTGVmdCA9IGlzTGVmdEFsaWduZWQgP1xuICAgICAgICAgICAgICAgIChvcHRpb25zLmFsaWduTWFyZ2luIHx8IFwiMFwiKSA6XG4gICAgICAgICAgICAgICAgKG9wdGlvbnMubW9kYWxIb3J6QWxpZ24gJiYgb3B0aW9ucy5vdXRlck1hcmdpbiB8fCBcIjBcIik7XG4gICAgICAgICAgICB2YXIgaXNSaWdodEFsaWduZWQgPSBvcHRpb25zLm1vZGFsSG9yekFsaWduID09PSBcInJpZ2h0XCIgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1vZGFsSG9yekFsaWduID09PSBcImVuZFwiO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdSaWdodCA9IGlzUmlnaHRBbGlnbmVkID9cbiAgICAgICAgICAgICAgICAob3B0aW9ucy5hbGlnbk1hcmdpbiB8fCBcIjBcIikgOlxuICAgICAgICAgICAgICAgIChvcHRpb25zLm1vZGFsSG9yekFsaWduICYmIG9wdGlvbnMub3V0ZXJNYXJnaW4gfHwgXCIwXCIpO1xuICAgICAgICAgICAgLy8gZmxpcCBsZWZ0L3JpZ2h0IHBhZGRpbmcgZm9yIHJpZ2h0LXRvLWxlZnQgZmxvd1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmxvd0RpcmVjdGlvbiA9PT0gXCJydGxcIiAmJlxuICAgICAgICAgICAgICAgIChvcHRpb25zLm1vZGFsSG9yekFsaWduID09PSBcInN0YXJ0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tb2RhbEhvcnpBbGlnbiA9PT0gXCJlbmRcIikpIHtcbiAgICAgICAgICAgICAgICBjZWxsLnN0eWxlLnBhZGRpbmdMZWZ0ID0gcGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgICAgIGNlbGwuc3R5bGUucGFkZGluZ1JpZ2h0ID0gcGFkZGluZ0xlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxsLnN0eWxlLnBhZGRpbmdMZWZ0ID0gcGFkZGluZ0xlZnQ7XG4gICAgICAgICAgICAgICAgY2VsbC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbnNlcnQgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSB3cmFwcGVyLCBjbGVhciBvdGhlciBub2Rlc1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIuZmlyc3RDaGlsZCAhPT0gZWxlbWVudCB8fCB3cmFwcGVyLmxhc3RDaGlsZCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQucHJldmlvdXNTaWJsaW5nKVxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKGVsZW1lbnQucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpeCBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZWxlbWVudHMgd2l0aCBhIFwiYm90dG9tXCIgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiBPTkxZLCBvdGhlcndpc2UgdG8gdGhlIHRvcCBPTkxZXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24sIGJvdHRvbTtcbiAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gc3R5bGUuZ2V0KFwicG9zaXRpb25cIik7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gc3R5bGUuZ2V0KFwiYm90dG9tXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBlbGVtZW50LnN0eWxlLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IGVsZW1lbnQuc3R5bGUucG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZS5vdmVyZmxvdyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmdpbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hbGlnbk1hcmdpbiB8fCBcIjBcIjtcbiAgICAgICAgICAgICAgICBpZiAoYm90dG9tICYmIGJvdHRvbSAhPT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZS50b3AgPSBcImF1dG9cIjtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZS5ib3R0b20gPSBtYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUubGVmdCA9IG1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZS5yaWdodCA9IG1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUuYm90dG9tID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUudG9wID0gbWFyZ2luO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmxlZnQgPSBtYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUucmlnaHQgPSBtYXJnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgcG9zaXRpb25lZCByZWxhdGl2ZS9zdGF0aWMsIHVzZSBmdWxsLXNjcmVlbiB3cmFwcGVyXG4gICAgICAgICAgICAgICAgdmFyIG1hcmdpbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vdXRlck1hcmdpbiB8fCBcIjBcIjtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLnRvcCA9IG1hcmdpbjtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmJvdHRvbSA9IG1hcmdpbjtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmxlZnQgPSBtYXJnaW47XG4gICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZS5yaWdodCA9IG1hcmdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmVzcyBvdXRzaWRlIHRoZSBlbGVtZW50IGludm9rZXMgb25Fc2MgaGFuZGxlclxuICAgICAgICB3cmFwcGVyLm9ubW91c2Vkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgJiYgKHR5cGVvZiBvcHRpb25zLm9uRXNjID09PSBcImZ1bmN0aW9uXCIpKSAmJlxuICAgICAgICAgICAgICAgIChldmVudC50YXJnZXQgPT09IHdyYXBwZXIgfHwgZXZlbnQudGFyZ2V0ID09PSBjZWxsKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25Fc2MuY2FsbCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLnVub2JzZXJ2YWJsZV9tZW1vaXplX2dldFxuICAgIF0sIERPTVBhZ2VSZW5kZXJlci5wcm90b3R5cGUsIFwiZG9tVXBkYXRlclwiLCBudWxsKTtcbiAgICByZXR1cm4gRE9NUGFnZVJlbmRlcmVyO1xufShQYWdlUmVuZGVyZXIpKTtcbi8vIGluamVjdCB0aGlzIHJlbmRlcmVyIGludG8gUGFnZSBpdHNlbGZcbkFzeW5jLmluamVjdChQYWdlLCB7IFJlbmRlcmVyOiBET01QYWdlUmVuZGVyZXIgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9QYWdlUmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IFN0eWxlLCBDb250YWluZXIsIEZsb3dDb250YWluZXIsIENvbXBvbmVudFJlbmRlcmVyLCBtYXBDb21wb25lbnRSZW5kZXJlciB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCAqIGFzIERPTSBmcm9tIFwiLi4vLi4vRE9NXCI7XG5pbXBvcnQgeyBVcGRhdGVDb250ZXh0IH0gZnJvbSBcIi4uLy4uL1VwZGF0ZUNvbnRleHRcIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1Db250YWluZXJcIjtcbi8qKiBAaW50ZXJuYWwgRE9NLXNwZWNpZmljIGNvbXBvbmVudCByZW5kZXJlciAqL1xudmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgLyoqIEluc3RhbnRpYXRlIHRoZSByZW5kZXJlciBmb3IgZ2l2ZW4gY29tcG9uZW50ICovXG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoY29tcG9uZW50LCBub1Njcm9sbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XG4gICAgICAgIC8vIGluaXRpYWxpemUgbWFpbiBET00gZWxlbWVudChzKVxuICAgICAgICBfdGhpcy5jZWxsV3JhcHBlciA9IERPTS5kaXYoQ1NTX0NMQVNTICsgXCJfbGF5b3V0Y2VsbFwiKTtcbiAgICAgICAgX3RoaXMubWFpbldyYXBwZXIgPSBET00uZGl2KENTU19DTEFTUyArIFwiX21haW5cIiwgX3RoaXMuY2VsbFdyYXBwZXIpO1xuICAgICAgICBfdGhpcy5lbGVtZW50ID0gRE9NLmRpdih1bmRlZmluZWQsIF90aGlzLm1haW5XcmFwcGVyKTtcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBlbGVtZW50IHVwZGF0ZSBjb250ZXh0XG4gICAgICAgIF90aGlzLmNvbnRleHQgPSBuZXcgVXBkYXRlQ29udGV4dChfdGhpcy5jZWxsV3JhcHBlcik7XG4gICAgICAgIC8vIGFkZCB3YXRjaGVycyBmb3IgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gRE9NLmFwcGx5U3R5bGVUbyhjb21wb25lbnQuc3R5bGUsIF90aGlzLmVsZW1lbnQpOyB9KTtcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gc2V0IG1heCBjb250ZW50IHdpZHRoXG4gICAgICAgICAgICBfdGhpcy5tYWluV3JhcHBlci5zdHlsZS5tYXhXaWR0aCA9IGNvbXBvbmVudC5tYXhDb250ZW50V2lkdGg7XG4gICAgICAgICAgICAvLyBzZXQgdmVydGljYWwgYWxpZ25tZW50XG4gICAgICAgICAgICBfdGhpcy5jZWxsV3JhcHBlci5zdHlsZS52ZXJ0aWNhbEFsaWduID0gY29tcG9uZW50LnZlcnRBbGlnbiB8fCBcInRvcFwiO1xuICAgICAgICAgICAgLy8gc2V0IGhvcml6b250YWwgYWxpZ25tZW50XG4gICAgICAgICAgICB2YXIgaG9yekFsaWduID0gY29tcG9uZW50LmhvcnpBbGlnbjtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuZmxvd0RpcmVjdGlvbiA9PT0gXCJydGxcIikge1xuICAgICAgICAgICAgICAgIGlmIChob3J6QWxpZ24gPT09IFwic3RhcnRcIilcbiAgICAgICAgICAgICAgICAgICAgaG9yekFsaWduID0gXCJyaWdodFwiO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhvcnpBbGlnbiA9PT0gXCJlbmRcIilcbiAgICAgICAgICAgICAgICAgICAgaG9yekFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChob3J6QWxpZ24gPT09IFwic3RhcnRcIilcbiAgICAgICAgICAgICAgICBob3J6QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGhvcnpBbGlnbiA9PT0gXCJlbmRcIilcbiAgICAgICAgICAgICAgICBob3J6QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgICAgICBpZiAoaG9yekFsaWduID09PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICAgIF90aGlzLm1haW5XcmFwcGVyLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYWluV3JhcHBlci5zdHlsZS5tYXJnaW5SaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaG9yekFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYWluV3JhcHBlci5zdHlsZS5tYXJnaW5MZWZ0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgX3RoaXMubWFpbldyYXBwZXIuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLm1haW5XcmFwcGVyLnN0eWxlLm1hcmdpbkxlZnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIF90aGlzLm1haW5XcmFwcGVyLnN0eWxlLm1hcmdpblJpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvIG5vdCBmaXggdGFibGUgd2lkdGggaWYgb3V0ZXIgd2lkdGggaXMgXCJhdXRvXCJcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuc3R5bGUuZ2V0KFwid2lkdGhcIikgPT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWFpbldyYXBwZXIuc3R5bGUudGFibGVMYXlvdXQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYWluV3JhcHBlci5zdHlsZS53aWR0aCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWFpbldyYXBwZXIuc3R5bGUudGFibGVMYXlvdXQgPSBcImZpeGVkXCI7XG4gICAgICAgICAgICAgICAgX3RoaXMubWFpbldyYXBwZXIuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGFkZCB3YXRjaGVyIGZvciBzY3JvbGxhYmxlICh1bmRlc2lyZWQgZm9yIGUuZy4gTGF5b3V0Q29udGFpbmVyKVxuICAgICAgICBpZiAoIW5vU2Nyb2xsKSB7XG4gICAgICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnQuc2Nyb2xsYWJsZTsgfSwgZnVuY3Rpb24gKHNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgb3ZlcmZsb3cgdG8gc2Nyb2xsIG9yIGhpZGUgb3ZlcmZsb3dpbmcgY29udGVudFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZS5zZXQoe1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogc2Nyb2xsYWJsZSA/IFwiYXV0b1wiIDogXCJoaWRkZW5cIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGUgcmVuZGVyZWQgY29tcG9uZW50IG91dHB1dCAqL1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobm9VcGRhdGUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IG91dHB1dCBvYmplY3RcbiAgICAgICAgdmFyIG91dCA9IF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcykgfHwgbmV3IENvbXBvbmVudFJlbmRlcmVyLk91dHB1dChjb21wb25lbnQsIHRoaXMuZWxlbWVudCwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgLy8gc2V0IG9yIHVwZGF0ZSBmbG93IGRpcmVjdGlvbiBtb2RlIG9uIGNvbnRleHQgYW5kIGVsZW1lbnRcbiAgICAgICAgdGhpcy5jb250ZXh0LmZsb3dEaXJlY3Rpb24gPSB0aGlzLmNvbXBvbmVudC5mbG93RGlyZWN0aW9uO1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQuZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmRpciA9IHRoaXMuY29tcG9uZW50LmZsb3dEaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGFsbCBjb21wb25lbnRzXG4gICAgICAgIGlmICghbm9VcGRhdGUpXG4gICAgICAgICAgICBvdXQudXBkYXRlZCA9IHRoaXMuY29udGV4dC51cGRhdGVBc3luYyhjb21wb25lbnQuY29udGVudCk7XG4gICAgICAgIC8vIGZvY3VzIGZpcnN0IGVsZW1lbnQgaWYgaW5pdGlhbGl6ZXIgaGFkIFwiZm9jdXNGaXJzdFwiIHNldFxuICAgICAgICBpZiAoY29tcG9uZW50LmZvY3VzRmlyc3QpIHtcbiAgICAgICAgICAgIERPTS5mb2N1cyhjb21wb25lbnQpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbXBvbmVudC5mb2N1c0ZpcnN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihDb250YWluZXIpXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQ29tcG9uZW50UmVuZGVyZXIpKTtcbmV4cG9ydCB7IFJlbmRlcmVyIH07XG4vLyBpbmplY3Qgc2Nyb2xsIG1vbml0b3IgbWV0aG9kXG5Bc3luYy5pbmplY3QoQ29udGFpbmVyLCB7XG4gICAgXCJAbW9uaXRvclBsYXRmb3JtU2Nyb2xsXCI6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmdldFJlbmRlcmVkT3V0cHV0QXN5bmMoKS50aGVuKGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgICAgIHZhciBlbHQgPSBvdXQuZWxlbWVudDtcbiAgICAgICAgICAgIGlmIChlbHQgJiYgZWx0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIF9zY3JvbGwgZWxlbWVudCBmb3IgbGF5b3V0IGNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsRWx0ID0gZWx0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJVSS1MYXlvdXRDb250YWluZXJfc2Nyb2xsXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxFbHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBlbHQgPSBzY3JvbGxFbHRbMF07XG4gICAgICAgICAgICAgICAgLy8gcnVuIHRoZSBjYWxsYmFjayBvbiBzY3JvbGwsIHJlc2l6ZSwgYW5kIGZpcnN0IHVwZGF0ZVxuICAgICAgICAgICAgICAgIHZhciBkb0NhbGxiYWNrXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZWx0LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBlbHQuc2Nyb2xsSGVpZ2h0IC0gKHQgKyBlbHQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBlbHQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBlbHQuc2Nyb2xsV2lkdGggLSAobCArIGVsdC5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHQsIGIsIGwsIHIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZWx0Lm9uc2Nyb2xsID0gZG9DYWxsYmFja18xO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGRvQ2FsbGJhY2tfMSk7XG4gICAgICAgICAgICAgICAgb3V0LnVwZGF0ZWQgJiYgb3V0LnVwZGF0ZWQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBc3luYy5zbGVlcCgxMCkudGhlbihkb0NhbGxiYWNrXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRvQ2FsbGJhY2tfMSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8vIEFkZCBzdHlsZSBvdmVycmlkZSBhbmQgYXBwbHkgc3R5bGUgc2hlZXRcbkNvbnRhaW5lci5hZGRTdHlsZU92ZXJyaWRlKFN0eWxlLndpdGhDbGFzcyhDU1NfQ0xBU1MpKTtcbkZsb3dDb250YWluZXIuYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTICsgXCIgXCIgKyBDU1NfQ0xBU1MgKyBcIi1GbG93XCIpKTtcbkRPTS5TdHlsZXMuZGVmaW5lKENTU19DTEFTUywge1xuICAgIFwiLn5+XCI6IHtcbiAgICAgICAgY3Vyc29yOiBcImRlZmF1bHRcIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgdG9wOiBcIjBcIiwgYm90dG9tOiBcIjBcIixcbiAgICAgICAgbGVmdDogXCIwXCIsIHJpZ2h0OiBcIjBcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIG1hcmdpbjogXCIwIGF1dG9cIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIHRyYW5zaXRpb246IFwiYm94LXNoYWRvdyAxMDBtcyBlYXNlXCIsXG4gICAgICAgIGZvbnRTaXplOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuc2l6ZS50ZXh0OyB9KVxuICAgIH0sXG4gICAgXCIufl9tYWluXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgZGlzcGxheTogXCJ0YWJsZVwiLFxuICAgICAgICBib3JkZXJTcGFjaW5nOiBcIjBcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgbWFyZ2luOiBcIjAgYXV0b1wiXG4gICAgfSxcbiAgICBcIi5+X2xheW91dGNlbGxcIjoge1xuICAgICAgICBkaXNwbGF5OiBcInRhYmxlLWNlbGxcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIlxuICAgIH0sXG4gICAgXCIufi1GbG93ID4gLn5fbWFpbiA+IC5+X2xheW91dGNlbGwgPiAuVUktQmxvY2tcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRvcFwiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udGFpbmVycy9Db250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IFN0eWxlLCBSb3csIG1hcENvbXBvbmVudFJlbmRlcmVyLCBEaWFsb2dDb250YWluZXIgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4uLy4uL0RPTVwiO1xuaW1wb3J0IHsgRE9NQW5pbWF0aW9uIH0gZnJvbSBcIi4uLy4uL0RPTS9ET01BbmltYXRpb25cIjtcbmltcG9ydCB7IFJlbmRlcmVyIGFzIENvbnRhaW5lclJlbmRlcmVyIH0gZnJvbSBcIi4vQ29udGFpbmVyXCI7XG4vKiogQmFzZSBjbGFzcyBuYW1lIHVzZWQgZm9yIENTUyBzdHlsZSBzaGVldCAqL1xudmFyIENTU19DTEFTUyA9IFwiVUktRGlhbG9nQ29udGFpbmVyXCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgcmVuZGVyZXIgZm9yIGdpdmVuIGNvbXBvbmVudCAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XG4gICAgICAgIC8vIGFkZCB3YXRjaGVyIGZvciB3aWR0aCB0byBzZXQgbWF4IHdpZHRoIGluc3RlYWRcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50LndpZHRoOyB9LCBmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlLnNldCh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHcgPT09IFwiYXV0b1wiID8gXCJhdXRvXCIgOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogdyA9PT0gXCJhdXRvXCIgPyBcIm5vbmVcIiA6IHdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGUgcmVuZGVyZWQgY29tcG9uZW50IG91dHB1dCAqL1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGdldCBvciBjcmVhdGUgdGhlIGN1cnJlbnQgb3V0cHV0IG9iamVjdFxuICAgICAgICB2YXIgb3V0ID0gX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzLCB0cnVlKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAvLyByZW5kZXIgaGVhZGVyIGJsb2NrIGFuZCBjcmVhdGUgd3JhcHBlciBpZiBuZWVkZWRcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5oZWFkZXIpIHtcbiAgICAgICAgICAgIC8vIGZpeCB2ZXJ0aWNhbCBzcGFjaW5nIGZvciBhIG1vcmUgXCJuYXRpdmVcIiBsb29rIGlmIG5vbmUgc2V0XG4gICAgICAgICAgICB2YXIgaGVhZGVyUm93ID0gY29tcG9uZW50LmhlYWRlcjtcbiAgICAgICAgICAgIGlmIChoZWFkZXJSb3cgaW5zdGFuY2VvZiBSb3cgJiYgIWhlYWRlclJvdy52ZXJ0aWNhbFNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgICBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyUm93LnZlcnRpY2FsU3BhY2luZyA9IFwiLjY1cmVtXCI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3B5IGx0ci9ydGwgZmxvdyBkaXJlY3Rpb24gaWYgc2V0IGF0IGNvbXBvbmVudCBsZXZlbFxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5mbG93RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlclJvdy5mbG93RGlyZWN0aW9uID0gY29tcG9uZW50LmZsb3dEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW5kZXIgaGVhZGVyIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIHZhciBvdXRfMSA9IGhlYWRlclJvdy5vdXQ7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gQ1NTX0NMQVNTICsgXCJfaGVhZGVyXCI7XG4gICAgICAgICAgICBpZiAob3V0XzEgJiYgKCFvdXRfMS53cmFwcGVyIHx8IG91dF8xLndyYXBwZXIuZmlyc3RDaGlsZCAhPT0gb3V0XzEuZWxlbWVudCB8fFxuICAgICAgICAgICAgICAgIG91dF8xLndyYXBwZXIuY2xhc3NOYW1lICE9PSBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBvdXRfMS53cmFwcGVyID0gRE9NLmRpdihjbGFzc05hbWUsIG91dF8xLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHcub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7IH07XG4gICAgICAgICAgICAgICAgdy5vbm1vdXNlZG93biA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBjb21wb25lbnQuaGVhZGVyICYmIGNvbXBvbmVudC5oZWFkZXIuUHJlc3NlZChlKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChvdXRfMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVuZGVyIGNvbnRlbnQgYmxvY2tzIGFuZCByZW1vdmUgd3JhcHBlcnMgaWYgbmVlZGVkXG4gICAgICAgIGNvbXBvbmVudC5jb250ZW50LmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIC8vIGNvcHkgbHRyL3J0bCBmbG93IGRpcmVjdGlvbiBpZiBzZXQgYXQgY29tcG9uZW50IGxldmVsXG4gICAgICAgICAgICBpZiAoYyAmJiBjb21wb25lbnQuZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjLmZsb3dEaXJlY3Rpb24gPSBjb21wb25lbnQuZmxvd0RpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbmRlciBjb250ZW50IHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIHZhciBvdXQgPSBjICYmIGMub3V0O1xuICAgICAgICAgICAgaWYgKG91dClcbiAgICAgICAgICAgICAgICBkZWxldGUgb3V0LndyYXBwZXI7XG4gICAgICAgICAgICBjb250ZW50LnB1c2gob3V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlbmRlciBmb290ZXIgYmxvY2sgYW5kIGNyZWF0ZSB3cmFwcGVyIGlmIG5lZWRlZFxuICAgICAgICBpZiAoY29tcG9uZW50LmZvb3Rlcikge1xuICAgICAgICAgICAgLy8gY29weSBsdHIvcnRsIGZsb3cgZGlyZWN0aW9uIGlmIHNldCBhdCBjb21wb25lbnQgbGV2ZWxcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZm9vdGVyLmZsb3dEaXJlY3Rpb24gPSBjb21wb25lbnQuZmxvd0RpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbmRlciBmb290ZXIgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgdmFyIG91dF8yID0gY29tcG9uZW50LmZvb3Rlci5vdXQ7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gQ1NTX0NMQVNTICsgXCJfZm9vdGVyXCI7XG4gICAgICAgICAgICBpZiAob3V0XzIgJiYgKCFvdXRfMi53cmFwcGVyIHx8IG91dF8yLndyYXBwZXIuZmlyc3RDaGlsZCAhPT0gb3V0XzIuZWxlbWVudCB8fFxuICAgICAgICAgICAgICAgIG91dF8yLndyYXBwZXIuY2xhc3NOYW1lICE9PSBjbGFzc05hbWUpKVxuICAgICAgICAgICAgICAgIG91dF8yLndyYXBwZXIgPSBET00uZGl2KGNsYXNzTmFtZSwgb3V0XzIuZWxlbWVudCk7XG4gICAgICAgICAgICBjb250ZW50LnB1c2gob3V0XzIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBhbGwgc3ViIGJsb2NrcyBvdXRwdXRcbiAgICAgICAgb3V0LnVwZGF0ZWQgPSB0aGlzLmNvbnRleHQudXBkYXRlQXN5bmMoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihEaWFsb2dDb250YWluZXIpXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQ29udGFpbmVyUmVuZGVyZXIpKTtcbmV4cG9ydCB7IFJlbmRlcmVyIH07XG4vLyBTZXQgZGVmYXVsdCBhbmltYXRpb25zXG5EaWFsb2dDb250YWluZXIuQVBQRUFSX0FOSU1BVElPTiA9IERPTUFuaW1hdGlvbi5iYXNpYy5pbi5mYWRlVXAud2l0aFRpbWluZygyMDApO1xuRGlhbG9nQ29udGFpbmVyLkRJU0FQUEVBUl9BTklNQVRJT04gPSBET01BbmltYXRpb24uYmFzaWMub3V0LmZhZGUud2l0aFRpbWluZygyMDApO1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlIGZvciBEaWFsb2dDb250YWluZXIgYW5kIFRvcENsb3NlQnV0dG9uXG5EaWFsb2dDb250YWluZXIuYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTKSk7XG5EaWFsb2dDb250YWluZXIuVG9wQ2xvc2VCdXR0b24uYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTICsgXCJfdG9wY2xvc2VidXR0b25cIikpO1xuLy8gQXBwbHkgc3R5bGUgc2hlZXRcbkRPTS5TdHlsZXMuZGVmaW5lKFwiVUktQ29udGFpbmVyIFwiICsgQ1NTX0NMQVNTLCB7XG4gICAgXCIufn5cIjogbmV3IFN0eWxlKClcbiAgICAgICAgLmFkZFNoYWRvd0VmZmVjdCguNzUpXG4gICAgICAgIC5zZXQoe1xuICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuY29sb3IuYmFja2dyb3VuZDsgfSksXG4gICAgICAgIGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuY29sb3IudGV4dDsgfSksXG4gICAgICAgIGJvcmRlclJhZGl1czogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBET00uU3R5bGVzLnNpemUuZGlhbG9nQm9yZGVyUmFkaXVzOyB9KVxuICAgIH0pLFxuICAgIFwiLn5faGVhZGVyXCI6IHtcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICB9LFxuICAgIFwiLn5fZm9vdGVyXCI6IHtcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICB9LFxuICAgIFwiLn5fdG9wY2xvc2VidXR0b25cIjoge1xuICAgICAgICBsaW5lSGVpZ2h0OiBcIjBcIlxuICAgIH0sXG4gICAgXCIufl90b3BjbG9zZWJ1dHRvbi5VSS1UZXh0QnV0dG9uLlVJLUJ1dHRvbiA+IGJ1dHRvblt0eXBlXVwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjEuNWVtXCIsXG4gICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IFwiMS4xcmVtXCIsXG4gICAgICAgIGZvbnRGYW1pbHk6IFwiaW5pdGlhbFwiLFxuICAgICAgICB0b3A6IFwiLS4xZW1cIlxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0NvbnRhaW5lcnMvRGlhbG9nQ29udGFpbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IHsgRHJhd2VyQ29udGFpbmVyLCBPcHBvc2l0ZURyYXdlckNvbnRhaW5lciwgU3R5bGUgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4uLy4uL0RPTVwiO1xuaW1wb3J0IHsgRE9NQW5pbWF0aW9uIH0gZnJvbSBcIi4uLy4uL0RPTS9ET01BbmltYXRpb25cIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1EcmF3ZXJDb250YWluZXJcIjtcbi8vIHNldCBkZWZhdWx0IGFuaW1hdGlvbnNcbkRyYXdlckNvbnRhaW5lci5BUFBFQVJfQU5JTUFUSU9OID1cbiAgICBET01BbmltYXRpb24uYmFzaWMuaW4uZmFkZVJpZ2h0LndpdGhUaW1pbmcoMzAwKTtcbkRyYXdlckNvbnRhaW5lci5ESVNBUFBFQVJfQU5JTUFUSU9OID1cbiAgICBET01BbmltYXRpb24uYmFzaWMub3V0LmZhZGVMZWZ0LndpdGhUaW1pbmcoMzAwKTtcbk9wcG9zaXRlRHJhd2VyQ29udGFpbmVyLkFQUEVBUl9BTklNQVRJT04gPVxuICAgIERPTUFuaW1hdGlvbi5iYXNpYy5pbi5mYWRlTGVmdC53aXRoVGltaW5nKDMwMCk7XG5PcHBvc2l0ZURyYXdlckNvbnRhaW5lci5ESVNBUFBFQVJfQU5JTUFUSU9OID1cbiAgICBET01BbmltYXRpb24uYmFzaWMub3V0LmZhZGVSaWdodC53aXRoVGltaW5nKDMwMCk7XG4vLyBBZGQgc3R5bGUgb3ZlcnJpZGUgYW5kIGFwcGx5IHN0eWxlIHNoZWV0XG5EcmF3ZXJDb250YWluZXIuYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTKSk7XG5ET00uU3R5bGVzLmRlZmluZShcIlVJLUNvbnRhaW5lciBcIiArIENTU19DTEFTUywge1xuICAgIFwiLn5+XCI6IG5ldyBTdHlsZSgpXG4gICAgICAgIC5hZGRTaGFkb3dFZmZlY3QoMSlcbiAgICAgICAgLnNldCh7IGhlaWdodDogXCIxMDB2aFwiIH0pXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250YWluZXJzL0RyYXdlckNvbnRhaW5lci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0ICogYXMgQXN5bmMgZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9Bc3luY1wiO1xuaW1wb3J0IHsgTGF5b3V0Q29udGFpbmVyLCBTdHlsZSwgbWFwQ29tcG9uZW50UmVuZGVyZXIgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4uLy4uL0RPTVwiO1xuaW1wb3J0IHsgVXBkYXRlQ29udGV4dCB9IGZyb20gXCIuLi8uLi9VcGRhdGVDb250ZXh0XCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBDb250YWluZXJSZW5kZXJlciB9IGZyb20gXCIuL0NvbnRhaW5lclwiO1xuLyoqIEJhc2UgY2xhc3MgbmFtZSB1c2VkIGZvciBDU1Mgc3R5bGUgc2hlZXQgKi9cbnZhciBDU1NfQ0xBU1MgPSBcIlVJLUxheW91dENvbnRhaW5lclwiO1xuLyoqIEBpbnRlcm5hbCBET00tc3BlY2lmaWMgY29tcG9uZW50IHJlbmRlcmVyICovXG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHJlbmRlcmVyIGZvciBnaXZlbiBjb21wb25lbnQgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gXG4gICAgICAgIC8vIGluc3RhbnRpYXRlIGNvbnRhaW5lciByZW5kZXJlciwgZm9yZ2V0IGFib3V0IHNjcm9sbGluZ1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQsIHRydWUpIHx8IHRoaXM7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgb3V0ZXIgZWxlbWVudCB1cGRhdGUgY29udGV4dCwgdG8gYmUgdXBkYXRlZCB3aXRoIGFsbFxuICAgICAgICAvLyBjb250YWluZXJzLCBhbmQgdGhlIGNlbnRlciB3cmFwcGVyIGVsZW1lbnRcbiAgICAgICAgX3RoaXMuZWxlbWVudC5yZW1vdmVDaGlsZChfdGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICBfdGhpcy5zY3JvbGxXcmFwcGVyID0gRE9NLmRpdihDU1NfQ0xBU1MgKyBcIl9zY3JvbGxcIiwgX3RoaXMubWFpbldyYXBwZXIpO1xuICAgICAgICBfdGhpcy5vdXRlckNvbnRleHQgPSBuZXcgVXBkYXRlQ29udGV4dChfdGhpcy5lbGVtZW50KTtcbiAgICAgICAgLy8gYWRkIHdhdGNoZXIgZm9yIHNjcm9sbGFibGUgKG92ZXJyaWRkZW4pXG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhY29tcG9uZW50LnNjcm9sbGFibGU7IH0sIGZ1bmN0aW9uIChzY3JvbGxhYmxlKSB7XG4gICAgICAgICAgICAvLyBzZXQgb3ZlcmZsb3cgdG8gc2Nyb2xsIG9yIGhpZGUgb3ZlcmZsb3dpbmcgY2VudGVyIGNvbnRlbnRcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbFdyYXBwZXIuc3R5bGUub3ZlcmZsb3cgPSBzY3JvbGxhYmxlID8gXCJhdXRvXCIgOiBcImhpZGRlblwiO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGUgcmVuZGVyZWQgY29tcG9uZW50IG91dHB1dCAqL1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGdldCBvciBjcmVhdGUgdGhlIGN1cnJlbnQgb3V0cHV0IG9iamVjdCwgcmVuZGVyIG1haW4gY29udGV4dFxuICAgICAgICB2YXIgb3V0ID0gX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBbdGhpcy5zY3JvbGxXcmFwcGVyXTtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICB2YXIgZmxvd0RpcmVjdGlvbiA9IGNvbXBvbmVudC5mbG93RGlyZWN0aW9uO1xuICAgICAgICB2YXIgaXNSVEwgPSBmbG93RGlyZWN0aW9uID09PSBcInJ0bFwiO1xuICAgICAgICAvLyBoZWxwZXIgdG8gcmVuZGVyIGFuZCB3cmFwIHNpZGUgY29udGFpbmVyXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlclNpZGVDb250YWluZXIoYywgY2xhc3NOYW1lLCBiZWZvcmUsIGFib3ZlKSB7XG4gICAgICAgICAgICAvLyBjb3B5IGx0ci9ydGwgZmxvdyBkaXJlY3Rpb24gaWYgc2V0IGF0IGNvbXBvbmVudCBsZXZlbFxuICAgICAgICAgICAgaWYgKGMgJiYgZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjLmZsb3dEaXJlY3Rpb24gPSBjb21wb25lbnQuZmxvd0RpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbmRlciBjb250YWluZXIgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgdmFyIG91dCA9IGMgJiYgYy5vdXQ7XG4gICAgICAgICAgICBpZiAob3V0ICYmICEoYy5oaWRkZW4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvdXQud3JhcHBlciB8fCBvdXQud3JhcHBlci5maXJzdENoaWxkICE9PSBvdXQuZWxlbWVudCB8fFxuICAgICAgICAgICAgICAgICAgICBvdXQud3JhcHBlci5jbGFzc05hbWUgIT09IGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQud3JhcHBlciA9IERPTS5kaXYoY2xhc3NOYW1lLCBvdXQuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIG91dC53cmFwcGVyLnN0eWxlLnpJbmRleCA9IERPTS5QQUdFX09QVElPTlMuYmFzZVpJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoYWJvdmUgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJlZm9yZSA/IGNvbnRlbnQudW5zaGlmdChvdXQpIDogY29udGVudC5wdXNoKG91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC53cmFwcGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlbmRlciBsZWZ0IGd1dHRlciBjb250YWluZXIgYW5kIGZpbmQgaXRzIHdpZHRoXG4gICAgICAgIHZhciBsZWZ0Q29tcG9uZW50ID0gaXNSVEwgP1xuICAgICAgICAgICAgY29tcG9uZW50Lm91dHNpZGVHdXR0ZXIgOiBjb21wb25lbnQuaW5zaWRlR3V0dGVyO1xuICAgICAgICB2YXIgbGVmdFdyYXBwZXIgPSByZW5kZXJTaWRlQ29udGFpbmVyKGxlZnRDb21wb25lbnQsIENTU19DTEFTUyArIFwiX2xlZnRcIiwgIWlzUlRMKTtcbiAgICAgICAgdmFyIGxlZnRXaWR0aCA9IGxlZnRXcmFwcGVyICYmIGxlZnRDb21wb25lbnQud2lkdGg7XG4gICAgICAgIGxlZnRXaWR0aCA9IGxlZnRXaWR0aCA9PT0gXCJhdXRvXCIgP1xuICAgICAgICAgICAgKGlzUlRMID8gTGF5b3V0Q29udGFpbmVyLk9VVFNJREVfR1VUVEVSX1dJRFRIIDpcbiAgICAgICAgICAgICAgICBMYXlvdXRDb250YWluZXIuSU5TSURFX0dVVFRFUl9XSURUSCkgOlxuICAgICAgICAgICAgKGxlZnRXaWR0aCB8fCBcIlwiKTtcbiAgICAgICAgLy8gcmVuZGVyIHJpZ2h0IGd1dHRlciBjb250YWluZXIgYW5kIGZpbmQgaXRzIHdpZHRoXG4gICAgICAgIHZhciByaWdodENvbXBvbmVudCA9IGlzUlRMID9cbiAgICAgICAgICAgIGNvbXBvbmVudC5pbnNpZGVHdXR0ZXIgOiBjb21wb25lbnQub3V0c2lkZUd1dHRlcjtcbiAgICAgICAgdmFyIHJpZ2h0V3JhcHBlciA9IHJlbmRlclNpZGVDb250YWluZXIocmlnaHRDb21wb25lbnQsIENTU19DTEFTUyArIFwiX3JpZ2h0XCIsIGlzUlRMKTtcbiAgICAgICAgdmFyIHJpZ2h0V2lkdGggPSByaWdodFdyYXBwZXIgJiYgcmlnaHRDb21wb25lbnQud2lkdGg7XG4gICAgICAgIHJpZ2h0V2lkdGggPSByaWdodFdpZHRoID09PSBcImF1dG9cIiA/XG4gICAgICAgICAgICAoaXNSVEwgPyBMYXlvdXRDb250YWluZXIuSU5TSURFX0dVVFRFUl9XSURUSCA6XG4gICAgICAgICAgICAgICAgTGF5b3V0Q29udGFpbmVyLk9VVFNJREVfR1VUVEVSX1dJRFRIKSA6XG4gICAgICAgICAgICAocmlnaHRXaWR0aCB8fCBcIlwiKTtcbiAgICAgICAgLy8gcmVuZGVyIGhlYWRlciBjb250YWluZXIgYW5kIGZpbmQgaXRzIGhlaWdodFxuICAgICAgICB2YXIgaGVhZGVyV3JhcHBlciA9IHJlbmRlclNpZGVDb250YWluZXIoY29tcG9uZW50LmhlYWRlciwgQ1NTX0NMQVNTICsgXCJfaGVhZGVyXCIsIHRydWUsIHRydWUpO1xuICAgICAgICB2YXIgaGVhZGVySGVpZ2h0ID0gaGVhZGVyV3JhcHBlciAmJiBjb21wb25lbnQuaGVhZGVyLmhlaWdodDtcbiAgICAgICAgaGVhZGVySGVpZ2h0ID0gaGVhZGVySGVpZ2h0ID09PSBcImF1dG9cIiA/XG4gICAgICAgICAgICBMYXlvdXRDb250YWluZXIuSEVBREVSX0hFSUdIVCA6IChoZWFkZXJIZWlnaHQgfHwgXCJcIik7XG4gICAgICAgIC8vIHJlbmRlciBmb290ZXIgY29udGFpbmVyIGFuZCBmaW5kIGl0cyBoZWlnaHRcbiAgICAgICAgdmFyIGZvb3RlcldyYXBwZXIgPSByZW5kZXJTaWRlQ29udGFpbmVyKGNvbXBvbmVudC5mb290ZXIsIENTU19DTEFTUyArIFwiX2Zvb3RlclwiLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBmb290ZXJIZWlnaHQgPSBmb290ZXJXcmFwcGVyICYmIGNvbXBvbmVudC5mb290ZXIuaGVpZ2h0O1xuICAgICAgICBmb290ZXJIZWlnaHQgPSBmb290ZXJIZWlnaHQgPT09IFwiYXV0b1wiID9cbiAgICAgICAgICAgIExheW91dENvbnRhaW5lci5GT09URVJfSEVJR0hUIDogKGZvb3RlckhlaWdodCB8fCBcIlwiKTtcbiAgICAgICAgLy8gYWRqdXN0IHBvc2l0aW9ucyBvZiBhbGwgd3JhcHBlcnNcbiAgICAgICAgdGhpcy5zY3JvbGxXcmFwcGVyLnN0eWxlLnRvcCA9IGhlYWRlckhlaWdodDtcbiAgICAgICAgdGhpcy5zY3JvbGxXcmFwcGVyLnN0eWxlLmJvdHRvbSA9IGZvb3RlckhlaWdodDtcbiAgICAgICAgdGhpcy5zY3JvbGxXcmFwcGVyLnN0eWxlLmxlZnQgPSBsZWZ0V2lkdGg7XG4gICAgICAgIHRoaXMuc2Nyb2xsV3JhcHBlci5zdHlsZS5yaWdodCA9IHJpZ2h0V2lkdGg7XG4gICAgICAgIGlmIChsZWZ0V3JhcHBlcikge1xuICAgICAgICAgICAgbGVmdFdyYXBwZXIuc3R5bGUudG9wID0gaGVhZGVySGVpZ2h0O1xuICAgICAgICAgICAgbGVmdFdyYXBwZXIuc3R5bGUuYm90dG9tID0gZm9vdGVySGVpZ2h0O1xuICAgICAgICAgICAgbGVmdFdyYXBwZXIuc3R5bGUud2lkdGggPSBsZWZ0V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0V3JhcHBlcikge1xuICAgICAgICAgICAgcmlnaHRXcmFwcGVyLnN0eWxlLnRvcCA9IGhlYWRlckhlaWdodDtcbiAgICAgICAgICAgIHJpZ2h0V3JhcHBlci5zdHlsZS5ib3R0b20gPSBmb290ZXJIZWlnaHQ7XG4gICAgICAgICAgICByaWdodFdyYXBwZXIuc3R5bGUud2lkdGggPSByaWdodFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJXcmFwcGVyKSB7XG4gICAgICAgICAgICBoZWFkZXJXcmFwcGVyLnN0eWxlLmhlaWdodCA9IGhlYWRlckhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9vdGVyV3JhcHBlcikge1xuICAgICAgICAgICAgZm9vdGVyV3JhcHBlci5zdHlsZS5oZWlnaHQgPSBmb290ZXJIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGFsbCBzdWIgYmxvY2tzIG9mIG91dHB1dFxuICAgICAgICB0aGlzLm91dGVyQ29udGV4dC51cGRhdGVBc3luYyhjb250ZW50LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKExheW91dENvbnRhaW5lcilcbiAgICBdLCBSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufShDb250YWluZXJSZW5kZXJlcikpO1xuZXhwb3J0IHsgUmVuZGVyZXIgfTtcbi8vIEFkZCBzdHlsZSBvdmVycmlkZSBhbmQgYXBwbHkgc3R5bGUgc2hlZXRcbkxheW91dENvbnRhaW5lci5hZGRTdHlsZU92ZXJyaWRlKFN0eWxlLndpdGhDbGFzcyhDU1NfQ0xBU1MpKTtcbkRPTS5TdHlsZXMuZGVmaW5lKFwiVUktQ29udGFpbmVyIFwiICsgQ1NTX0NMQVNTLCB7XG4gICAgXCIufn5cIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICB9LFxuICAgIFwiLn5fc2Nyb2xsXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiBcIjBcIiwgbGVmdDogXCIwXCIsXG4gICAgICAgIGJvdHRvbTogXCIwXCIsIHJpZ2h0OiBcIjBcIlxuICAgIH0sXG4gICAgXCIufl9oZWFkZXJcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB0b3A6IFwiMFwiLCBsZWZ0OiBcIjBcIiwgcmlnaHQ6IFwiMFwiXG4gICAgfSxcbiAgICBcIi5+X2Zvb3RlclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGJvdHRvbTogXCIwXCIsIGxlZnQ6IFwiMFwiLCByaWdodDogXCIwXCJcbiAgICB9LFxuICAgIFwiLn5fbGVmdFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHRvcDogXCIwXCIsIGJvdHRvbTogXCIwXCIsIGxlZnQ6IFwiMFwiXG4gICAgfSxcbiAgICBcIi5+X3JpZ2h0XCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiBcIjBcIiwgYm90dG9tOiBcIjBcIiwgcmlnaHQ6IFwiMFwiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udGFpbmVycy9MYXlvdXRDb250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IFN0eWxlLCBDYXJkLCBtYXBDb21wb25lbnRSZW5kZXJlciB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCAqIGFzIERPTSBmcm9tIFwiLi4vLi4vRE9NXCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBCbG9ja1JlbmRlcmVyIH0gZnJvbSBcIi4vQmxvY2tcIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1DYXJkXCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIC8vIHJlbmRlciBoZWFkZXIgYmxvY2sgYW5kIGNyZWF0ZSB3cmFwcGVyIGlmIG5lZWRlZFxuICAgICAgICB2YXIgY29udGVudCA9IFtdO1xuICAgICAgICBpZiAoY29tcG9uZW50LmhlYWRlcikge1xuICAgICAgICAgICAgLy8gY29weSBsdHIvcnRsIGZsb3cgZGlyZWN0aW9uIGlmIHNldCBhdCBjb21wb25lbnQgbGV2ZWxcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaGVhZGVyLmZsb3dEaXJlY3Rpb24gPSBjb21wb25lbnQuZmxvd0RpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbmRlciBoZWFkZXIgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgdmFyIG91dF8xID0gY29tcG9uZW50LmhlYWRlci5vdXQ7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gQ1NTX0NMQVNTICsgXCJfaGVhZGVyIHBhbmVsLWhlYWRpbmcgY2FyZC1oZWFkZXJcIjtcbiAgICAgICAgICAgIGlmIChvdXRfMSAmJiAoIW91dF8xLndyYXBwZXIgfHwgb3V0XzEud3JhcHBlci5maXJzdENoaWxkICE9PSBvdXRfMS5lbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgb3V0XzEud3JhcHBlci5jbGFzc05hbWUgIT09IGNsYXNzTmFtZSkpXG4gICAgICAgICAgICAgICAgb3V0XzEud3JhcHBlciA9IERPTS5kaXYoY2xhc3NOYW1lLCBvdXRfMS5lbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChvdXRfMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVuZGVyIGNvbnRlbnQgYmxvY2tzIGFuZCByZW1vdmUgd3JhcHBlcnMgaWYgbmVlZGVkXG4gICAgICAgIGNvbXBvbmVudC5jb250ZW50LmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIC8vIGNvcHkgbHRyL3J0bCBmbG93IGRpcmVjdGlvbiBpZiBzZXQgYXQgY29tcG9uZW50IGxldmVsXG4gICAgICAgICAgICBpZiAoYyAmJiBjb21wb25lbnQuZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjLmZsb3dEaXJlY3Rpb24gPSBjb21wb25lbnQuZmxvd0RpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbmRlciBjb250ZW50IHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIHZhciBvdXQgPSBjICYmIGMub3V0O1xuICAgICAgICAgICAgaWYgKG91dClcbiAgICAgICAgICAgICAgICBkZWxldGUgb3V0LndyYXBwZXI7XG4gICAgICAgICAgICBjb250ZW50LnB1c2gob3V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlbmRlciBmb290ZXIgYmxvY2sgYW5kIGNyZWF0ZSB3cmFwcGVyIGlmIG5lZWRlZFxuICAgICAgICBpZiAoY29tcG9uZW50LmZvb3Rlcikge1xuICAgICAgICAgICAgLy8gY29weSBsdHIvcnRsIGZsb3cgZGlyZWN0aW9uIGlmIHNldCBhdCBjb21wb25lbnQgbGV2ZWxcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZm9vdGVyLmZsb3dEaXJlY3Rpb24gPSBjb21wb25lbnQuZmxvd0RpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbmRlciBmb290ZXIgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgdmFyIG91dF8yID0gY29tcG9uZW50LmZvb3Rlci5vdXQ7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gQ1NTX0NMQVNTICsgXCJfZm9vdGVyIHBhbmVsLWZvb3RlciBjYXJkLWZvb3RlclwiO1xuICAgICAgICAgICAgaWYgKG91dF8yICYmICghb3V0XzIud3JhcHBlciB8fCBvdXRfMi53cmFwcGVyLmZpcnN0Q2hpbGQgIT09IG91dF8yLmVsZW1lbnQgfHxcbiAgICAgICAgICAgICAgICBvdXRfMi53cmFwcGVyLmNsYXNzTmFtZSAhPT0gY2xhc3NOYW1lKSlcbiAgICAgICAgICAgICAgICBvdXRfMi53cmFwcGVyID0gRE9NLmRpdihjbGFzc05hbWUsIG91dF8yLmVsZW1lbnQpO1xuICAgICAgICAgICAgY29udGVudC5wdXNoKG91dF8yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgYWxsIHN1YiBibG9ja3Mgb3V0cHV0XG4gICAgICAgIG91dC51cGRhdGVkID0gdGhpcy5jb250ZXh0LnVwZGF0ZUFzeW5jKGNvbnRlbnQsIHRydWUpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgbWFwQ29tcG9uZW50UmVuZGVyZXIoQ2FyZClcbiAgICBdLCBSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufShCbG9ja1JlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlIGFuZCBhcHBseSBzdHlsZSBzaGVldFxuQ2FyZC5hZGRTdHlsZU92ZXJyaWRlKFN0eWxlLndpdGhDbGFzcyhDU1NfQ0xBU1MgKyBcIiBwYW5lbCBwYW5lbC1kZWZhdWx0IGNhcmRcIikpO1xuRE9NLlN0eWxlcy5kZWZpbmUoXCJVSS1CbG9jayBcIiArIENTU19DTEFTUywge1xuICAgIFwiLn5+XCI6IHtcbiAgICAgICAgbWFyZ2luOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuc2l6ZS5jb250cm9sU3BhY2luZzsgfSksXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiLFxuICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgfSxcbiAgICBcIi5+X2hlYWRlclwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMFwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgIH0sXG4gICAgXCIufl9mb290ZXJcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjBcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICB9LFxuICAgIC8vIGRvIG5vdCBhZGQgbWFyZ2luIHRvIGNhcmRzIHVzZWQgd2l0aGluIHJvd3NcbiAgICBcIi5VSS1Db250cm9sID4gLn5+XCI6IHtcbiAgICAgICAgbWFyZ2luOiBcIjBcIlxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0Jsb2Nrcy9DYXJkLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4uLy4uL0RPTVwiO1xuaW1wb3J0IHsgU3R5bGUsIENvbnRhaW5lckJsb2NrLCBtYXBDb21wb25lbnRSZW5kZXJlciB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCB7IFJlbmRlcmVyIGFzIEJsb2NrUmVuZGVyZXIgfSBmcm9tIFwiLi9CbG9ja1wiO1xuLyoqIEJhc2UgY2xhc3MgbmFtZSB1c2VkIGZvciBDU1Mgc3R5bGUgc2hlZXQgKi9cbnZhciBDU1NfQ0xBU1MgPSBcIlVJLUNvbnRhaW5lckJsb2NrXCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBhZGQgY29udGFpbmVyIHRvIG91dHB1dFxuICAgICAgICBvdXQudXBkYXRlZCA9IHRoaXMuY29udGV4dC51cGRhdGVBc3luYyhbdGhpcy5jb21wb25lbnQuY29udGFpbmVyXSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihDb250YWluZXJCbG9jaylcbiAgICBdLCBSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufShCbG9ja1JlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlIGFuZCBhcHBseSBzdHlsZSBzaGVldFxuQ29udGFpbmVyQmxvY2suYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTKSk7XG5ET00uU3R5bGVzLmRlZmluZShcIlVJLUJsb2NrIFwiICsgQ1NTX0NMQVNTLCB7XG4gICAgXCIufn5cIjoge1xuICAgICAgICBmb250U2l6ZTogXCIwXCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IFwiMFwiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQmxvY2tzL0NvbnRhaW5lckJsb2NrLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4uLy4uL0RPTVwiO1xuaW1wb3J0IHsgU3R5bGUsIERpdmlkZXIsIG1hcENvbXBvbmVudFJlbmRlcmVyIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0IHsgUmVuZGVyZXIgYXMgQmxvY2tSZW5kZXJlciB9IGZyb20gXCIuL0Jsb2NrXCI7XG4vKiogQmFzZSBjbGFzcyBuYW1lIHVzZWQgZm9yIENTUyBzdHlsZSBzaGVldCAqL1xudmFyIENTU19DTEFTUyA9IFwiVUktRGl2aWRlclwiO1xuLyoqIEBpbnRlcm5hbCBET00tc3BlY2lmaWMgY29tcG9uZW50IHJlbmRlcmVyICovXG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHJlbmRlcmVyIGZvciBnaXZlbiBjb21wb25lbnQgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50LCBcImhyXCIpIHx8IHRoaXM7XG4gICAgICAgIC8vIGFkZCB3YXRjaGVyIGZvciBjb21wb25lbnQgc3R5bGUgcHJvcGVydGllc1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IFwiMCAwIFwiICsgKGNvbXBvbmVudC50aGlja25lc3MgfHwgXCIxcHhcIiksXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogY29tcG9uZW50LmNvbG9yLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiBjb21wb25lbnQubWFyZ2luIHx8IFwiLjVyZW1cIixcbiAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogY29tcG9uZW50Lm1hcmdpbiB8fCBcIi41cmVtXCIsXG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiBjb21wb25lbnQuZmxvd0RpcmVjdGlvbiA9PT0gXCJydGxcIiA/XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lmluc2V0RW5kIDogY29tcG9uZW50Lmluc2V0U3RhcnQsXG4gICAgICAgICAgICBtYXJnaW5SaWdodDogY29tcG9uZW50LmZsb3dEaXJlY3Rpb24gPT09IFwicnRsXCIgP1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pbnNldFN0YXJ0IDogY29tcG9uZW50Lmluc2V0RW5kXG4gICAgICAgIH0pOyB9LCBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgICAgICAgICBjb21wb25lbnQuc3R5bGUuc2V0KHN0eWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKERpdmlkZXIpXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQmxvY2tSZW5kZXJlcikpO1xuZXhwb3J0IHsgUmVuZGVyZXIgfTtcbi8vIEFkZCBzdHlsZSBvdmVycmlkZSBhbmQgYXBwbHkgc3R5bGUgc2hlZXRcbkRpdmlkZXIuYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTKSk7XG5ET00uU3R5bGVzLmRlZmluZShcIlVJLUJsb2NrIFwiICsgQ1NTX0NMQVNTLCB7XG4gICAgXCIufn5cIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiY29udGVudC1ib3hcIixcbiAgICAgICAgaGVpZ2h0OiBcIjBcIixcbiAgICAgICAgbGluZUhlaWdodDogXCIwXCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjBcIixcbiAgICAgICAgcGFkZGluZzogXCIwXCIsIG1hcmdpbjogXCIwXCIsXG4gICAgICAgIGJvcmRlclN0eWxlOiBcInNvbGlkXCIsXG4gICAgICAgIGJvcmRlckNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuY29sb3IuZGl2aWRlcjsgfSksXG4gICAgICAgIGJvcmRlcldpZHRoOiBcIjBcIiAvLyBzZXQgYnkgcmVuZGVyIG1ldGhvZFxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0Jsb2Nrcy9EaXZpZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBTdHlsZSwgTGlzdCwgVHJlZUxpc3QsIG1hcENvbXBvbmVudFJlbmRlcmVyIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0ICogYXMgRE9NIGZyb20gXCIuLi8uLi9ET01cIjtcbmltcG9ydCB7IFJlbmRlcmVyIGFzIEJsb2NrUmVuZGVyZXIgfSBmcm9tIFwiLi9CbG9ja1wiO1xuLyoqIEJhc2UgY2xhc3MgbmFtZXMgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1MaXN0XCI7XG52YXIgQ1NTX0NMQVNTX1RSRUVMSVNUID0gXCJVSS1UcmVlTGlzdFwiO1xuLyoqIEBpbnRlcm5hbCBET00tc3BlY2lmaWMgY29tcG9uZW50IHJlbmRlcmVyICovXG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGUgcmVuZGVyZWQgY29tcG9uZW50IG91dHB1dCAqL1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGdldCBvciBjcmVhdGUgdGhlIGN1cnJlbnQgb3V0cHV0IG9iamVjdFxuICAgICAgICB2YXIgb3V0ID0gX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gYWRkIGFsbCBpdGVtcyBhbmQgZGl2aWRlcnMsIGlmIGFueVxuICAgICAgICBvdXQudXBkYXRlZCA9IHRoaXMuY29udGV4dC51cGRhdGVBc3luYyh0aGlzLmNvbXBvbmVudC5nZXRDaGlsZHJlbigpLCBmYWxzZSwgdGhpcy5jb21wb25lbnQucmVuZGVyT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVuZGVyT3B0aW9ucy5hbmltYXRlTGlzdEl0ZW1zKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKExpc3QpLFxuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihUcmVlTGlzdClcbiAgICBdLCBSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufShCbG9ja1JlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlXG5MaXN0LmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUykpO1xuVHJlZUxpc3QuYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTICsgXCIgXCIgKyBDU1NfQ0xBU1NfVFJFRUxJU1QpKTtcbkRPTS5TdHlsZXMuZGVmaW5lKENTU19DTEFTUywge1xuICAgIFwiLn5+ID4gW3NlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gRE9NLlN0eWxlcy5jb2xvci5saXN0U2VsZWN0aW9uQmFja2dyb3VuZDsgfSksXG4gICAgICAgIGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuY29sb3IubGlzdFNlbGVjdGlvblRleHQ7IH0pXG4gICAgfSxcbiAgICBcIi5+fiA+IFtzZWxlY3RlZF06Zm9jdXNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuY29sb3IubGlzdFNlbGVjdGlvbkZvY3VzQmFja2dyb3VuZDsgfSksXG4gICAgICAgIGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuY29sb3IubGlzdFNlbGVjdGlvbkZvY3VzVGV4dDsgfSksXG4gICAgICAgIG91dGxpbmVXaWR0aDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBET00uU3R5bGVzLnNpemUubGlzdFNlbGVjdGlvbkZvY3VzT3V0bGluZTsgfSlcbiAgICB9LFxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQmxvY2tzL0xpc3QuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IFN0eWxlLCBDb250cm9sRWxlbWVudCwgQ29tcG9uZW50UmVuZGVyZXIsIG1hcENvbXBvbmVudFJlbmRlcmVyIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0ICogYXMgRE9NIGZyb20gXCIuLi8uLi9ET01cIjtcbmltcG9ydCB7IFVwZGF0ZUNvbnRleHQgfSBmcm9tIFwiLi4vLi4vVXBkYXRlQ29udGV4dFwiO1xuLyoqIEJhc2UgY2xhc3MgbmFtZSB1c2VkIGZvciBDU1Mgc3R5bGUgc2hlZXQgKi9cbnZhciBDU1NfQ0xBU1MgPSBcIlVJLUNvbnRyb2xcIjtcbi8qKiBAaW50ZXJuYWwgRE9NLXNwZWNpZmljIGNvbXBvbmVudCByZW5kZXJlciAqL1xudmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgLyoqIEluc3RhbnRpYXRlIHRoZSByZW5kZXJlciBmb3IgZ2l2ZW4gY29tcG9uZW50ICovXG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoY29tcG9uZW50LCB0YWdOYW1lKSB7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSB2b2lkIDApIHsgdGFnTmFtZSA9IFwic3BhblwiOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBtYWluIERPTSBlbGVtZW50KHMpXG4gICAgICAgIF90aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgICBfdGhpcy5lbGVtZW50LmlkID0gY29tcG9uZW50LnVpZDtcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBlbGVtZW50IHVwZGF0ZSBjb250ZXh0XG4gICAgICAgIF90aGlzLmNvbnRleHQgPSBuZXcgVXBkYXRlQ29udGV4dChfdGhpcy5lbGVtZW50KTtcbiAgICAgICAgLy8gYWRkIHdhdGNoZXJzIGZvciBjb21wb25lbnQgcHJvcGVydGllc1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBET00uYXBwbHlTdHlsZVRvKGNvbXBvbmVudC5zdHlsZSwgX3RoaXMuZWxlbWVudCk7IH0pO1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB3aWR0aCBBTkQgc2hyaW5rd3JhcCBwcm9wZXJ0aWVzIHRvIHNldCBDU1Mgd2lkdGhcbiAgICAgICAgICAgIHZhciB3ID0gY29tcG9uZW50LndpZHRoO1xuICAgICAgICAgICAgaWYgKHcgPT09IFwiYXV0b1wiKVxuICAgICAgICAgICAgICAgIHcgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGlzUGVyY2VudGFnZSA9ICh3LnNsaWNlKC0xKSA9PT0gXCIlXCIpO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5zaHJpbmt3cmFwKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHNocmlua3dyYXAgY2xhc3MgYW5kIHNldCB3aWR0aFxuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuc3R5bGUuYWRkQ2xhc3MoXCJzaHJpbmt3cmFwXCIpLnNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaXNQZXJjZW50YWdlICYmIHcgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IHdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgc2hyaW5rd3JhcCBjbGFzcyBhbmQgc2V0IHdpZHRoXG4gICAgICAgICAgICAgICAgQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZS5yZW1vdmVDbGFzcyhcInNocmlua3dyYXBcIikuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpc1BlcmNlbnRhZ2UgJiYgdyB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnQud3JhcFRleHQ7IH0sIGZ1bmN0aW9uICh3cmFwVGV4dCkge1xuICAgICAgICAgICAgLy8gc2V0IHdoaXRlLXNwYWNlIHByb3BlcnR5IChwcmUtd3JhcCBvciBwcmUgW2RlZmF1bHRdKVxuICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlLnNldCh7XG4gICAgICAgICAgICAgICAgd2hpdGVTcGFjZTogd3JhcFRleHQgPyBcInByZS13cmFwXCIgOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEdlbmVyYXRlIHJlbmRlcmVkIGNvbXBvbmVudCBvdXRwdXQgKi9cbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IG91dHB1dCBvYmplY3RcbiAgICAgICAgdmFyIG91dCA9IF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcykgfHwgbmV3IENvbXBvbmVudFJlbmRlcmVyLk91dHB1dCh0aGlzLmNvbXBvbmVudCwgdGhpcy5lbGVtZW50LCB0aGlzLmNvbnRleHQpO1xuICAgICAgICAvLyBzZXQgb3IgdXBkYXRlIGZsb3cgZGlyZWN0aW9uIG1vZGUgb24gY29udGV4dCBhbmQgZWxlbWVudFxuICAgICAgICB0aGlzLmNvbnRleHQuZmxvd0RpcmVjdGlvbiA9IHRoaXMuY29tcG9uZW50LmZsb3dEaXJlY3Rpb247XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5mbG93RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZGlyID0gdGhpcy5jb21wb25lbnQuZmxvd0RpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgbWFwQ29tcG9uZW50UmVuZGVyZXIoQ29udHJvbEVsZW1lbnQpXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQ29tcG9uZW50UmVuZGVyZXIpKTtcbmV4cG9ydCB7IFJlbmRlcmVyIH07XG4vLyBBZGQgbG9naWMgZm9yIGZvY3VzaW5nIGFuZCBibHVycmluZyBjb250cm9sIGVsZW1lbnRzXG5Bc3luYy5pbmplY3QoQ29udHJvbEVsZW1lbnQsIHtcbiAgICBcIkBmb2N1c0xpdmVDb21wb25lbnRcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBET00uZm9jdXModGhpcyk7XG4gICAgfSxcbiAgICBcIkBibHVyTGl2ZUNvbXBvbmVudFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIERPTS5ibHVyKHRoaXMpO1xuICAgIH1cbn0pO1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlIGFuZCBhcHBseSBzdHlsZSBzaGVldFxuQ29udHJvbEVsZW1lbnQuYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTKSk7XG5ET00uU3R5bGVzLmRlZmluZShcIlVJLUNvbnRyb2wgXCIgKyBDU1NfQ0xBU1MsIHtcbiAgICBcIi5+flwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIGRpc3BsYXk6IFwidGFibGUtY2VsbFwiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBib3JkZXJTcGFjaW5nOiBcImluaXRpYWxcIixcbiAgICAgICAgbWFyZ2luOiBcIjBcIixcbiAgICAgICAgcGFkZGluZzogXCIwXCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IFwibm9ybWFsXCIsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCJcbiAgICB9LFxuICAgIFwiLn5+LnNocmlua3dyYXBcIjoge1xuICAgICAgICB3aWR0aDogXCIxcHhcIixcbiAgICAgICAgbWF4V2lkdGg6IFwibm9uZVwiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvQ29udHJvbEVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IExhYmVsLCBXaWRlTGFiZWwsIFBhcmFncmFwaCwgSGVhZGluZzEsIEhlYWRpbmcyLCBIZWFkaW5nMywgSGVhZGluZzQsIEhlYWRpbmc1LCBIZWFkaW5nNiwgU3R5bGUsIG1hcENvbXBvbmVudFJlbmRlcmVyIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0ICogYXMgRE9NIGZyb20gXCIuLi8uLi9ET01cIjtcbmltcG9ydCB7IFJlbmRlcmVyIGFzIENvbnRyb2xSZW5kZXJlciB9IGZyb20gXCIuL0NvbnRyb2xFbGVtZW50XCI7XG4vKiogQmFzZSBjbGFzcyBuYW1lIHVzZWQgZm9yIENTUyBzdHlsZSBzaGVldCAqL1xudmFyIENTU19DTEFTUyA9IFwiVUktTGFiZWxcIjtcbi8qKiBAaW50ZXJuYWwgRE9NLXNwZWNpZmljIGNvbXBvbmVudCByZW5kZXJlciAqL1xudmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgUmVuZGVyZXJfMSA9IFJlbmRlcmVyO1xuICAgIC8qKiBIZWxwZXIgbWV0aG9kIHRvIHJlcGxhY2UgY29udGVudHMgb2YgZ2l2ZW4gbm9kZSB3aXRoIGljb24sIGxhYmVsLCBhbmQgYmFkZ2UsIGlmIGFueTsgcmV0dXJucyBub2RlIGl0c2VsZiAqL1xuICAgIFJlbmRlcmVyLnJlbmRlckludG8gPSBmdW5jdGlvbiAobm9kZSwgaWNvbiwgcmVtR3V0dGVyLCBsYWJlbCwgYmFkZ2UsIGFwcGVuZCwgaWNvblJpZ2h0LCBzbWFsbEJlZm9yZSwgc21hbGxBZnRlcikge1xuICAgICAgICBpZiAoIWFwcGVuZClcbiAgICAgICAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB2YXIgYmVmb3JlTGFiZWxUZXh0ID0gc21hbGxCZWZvcmUgIT09IHVuZGVmaW5lZCAmJiBTdHJpbmcoc21hbGxCZWZvcmUpO1xuICAgICAgICBpZiAoYmVmb3JlTGFiZWxUZXh0KSB7XG4gICAgICAgICAgICB2YXIgYmVmb3JlTGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNtYWxsXCIpO1xuICAgICAgICAgICAgYmVmb3JlTGFiZWxFbGVtZW50LnRleHRDb250ZW50ID0gYmVmb3JlTGFiZWxUZXh0O1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChiZWZvcmVMYWJlbEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpY29uIHx8IHJlbUd1dHRlciA+IDApIHtcbiAgICAgICAgICAgIHZhciBpY29uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpY29uXCIpO1xuICAgICAgICAgICAgaWYgKHJlbUd1dHRlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWNvbkVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgICAgICAgICAgaWNvbkVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgICAgICBpY29uRWxlbWVudC5zdHlsZS5taW5XaWR0aCA9IHJlbUd1dHRlciArIFwicmVtXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWNvbikge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpY29uID0gaWNvbi5yZXBsYWNlKC9cXHMrKFtcXHctXSspXFxzKj1cXHMqKFxcXCJbXlxcXCJdKlxcXCJ8W15cXHNdKykvZywgZnVuY3Rpb24gKHMsIHByb3AsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wID0gcHJvcC5yZXBsYWNlKC8tXFx3L2csIGZ1bmN0aW9uIChzKSB7IHJldHVybiBzWzFdLnRvVXBwZXJDYXNlKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpY29uRWxlbWVudC5zdHlsZVtwcm9wXSA9ICh2YWxbMF0gPT09ICdcIicpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UodmFsKSA6IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcOig/OlxcXCJbXlxcXCJdKlxcXCJ8W15cXHNdKykvLCBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgICAgICBzID0gcy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IChzWzBdID09PSAnXCInKSA/IEpTT04ucGFyc2UocykgOiBzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gaWNvbi5zcGxpdChcIi1cIiwgMSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gaWNvbilcbiAgICAgICAgICAgICAgICAgICAgaWNvbiA9IHByZWZpeCArIFwiIFwiICsgaWNvbjtcbiAgICAgICAgICAgICAgICBpY29uRWxlbWVudC5jbGFzc05hbWUgPSBpY29uO1xuICAgICAgICAgICAgICAgIGljb25FbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoaWNvbkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYWJlbFRleHQgPSBsYWJlbCAhPT0gdW5kZWZpbmVkICYmIFN0cmluZyhsYWJlbCk7XG4gICAgICAgIGlmIChsYWJlbFRleHQpIHtcbiAgICAgICAgICAgIGlmIChpY29uICYmICEocmVtR3V0dGVyID4gMCkpXG4gICAgICAgICAgICAgICAgbGFiZWxUZXh0ID0gXCIgXCIgKyBsYWJlbFRleHQ7XG4gICAgICAgICAgICB2YXIgbGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBsYWJlbEVsZW1lbnQudGV4dENvbnRlbnQgPSBsYWJlbFRleHQ7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGxhYmVsRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhZGdlVGV4dCA9IGJhZGdlICE9PSB1bmRlZmluZWQgJiYgU3RyaW5nKGJhZGdlKTtcbiAgICAgICAgaWYgKGJhZGdlVGV4dCkge1xuICAgICAgICAgICAgdmFyIGJhZGdlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiYWRnZVwiKTtcbiAgICAgICAgICAgIGJhZGdlRWxlbWVudC5jbGFzc05hbWUgPSBcImJhZGdlIGJhZGdlLWRlZmF1bHQgdGFnIHRhZy1kZWZhdWx0XCI7XG4gICAgICAgICAgICBiYWRnZUVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCA9IFwiLjVyZW1cIjtcbiAgICAgICAgICAgIGJhZGdlRWxlbWVudC50ZXh0Q29udGVudCA9IGJhZGdlVGV4dDtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoYmFkZ2VFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXJMYWJlbFRleHQgPSBzbWFsbEFmdGVyICE9PSB1bmRlZmluZWQgJiYgU3RyaW5nKHNtYWxsQWZ0ZXIpO1xuICAgICAgICBpZiAoYWZ0ZXJMYWJlbFRleHQpIHtcbiAgICAgICAgICAgIHZhciBhZnRlckxhYmVsRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiKTtcbiAgICAgICAgICAgIGFmdGVyTGFiZWxFbGVtZW50LnRleHRDb250ZW50ID0gYWZ0ZXJMYWJlbFRleHQ7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGFmdGVyTGFiZWxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIC8vIHJlbmRlciB0ZXh0IGludG8gRE9NIGVsZW1lbnRcbiAgICAgICAgUmVuZGVyZXJfMS5yZW5kZXJJbnRvKHRoaXMuZWxlbWVudCwgY29tcG9uZW50Lmljb24sIGNvbXBvbmVudC5yZW1HdXR0ZXIsIGNvbXBvbmVudC50ZXh0LCBjb21wb25lbnQuYmFkZ2UsIGZhbHNlLCBmYWxzZSwgY29tcG9uZW50LnRleHRCZWZvcmUsIGNvbXBvbmVudC50ZXh0QWZ0ZXIpO1xuICAgICAgICAvLyBzZXQgdG9vbHRpcCB0ZXh0XG4gICAgICAgIGlmIChjb21wb25lbnQudG9vbHRpcFRleHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50aXRsZSA9IGNvbXBvbmVudC50b29sdGlwVGV4dDtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gUmVuZGVyZXJfMSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihMYWJlbClcbiAgICBdLCBSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xuICAgIHZhciBSZW5kZXJlcl8xO1xufShDb250cm9sUmVuZGVyZXIpKTtcbmV4cG9ydCB7IFJlbmRlcmVyIH07XG4vKiogQGludGVybmFsICovXG52YXIgUGFyYWdyYXBoUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXJhZ3JhcGhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJhZ3JhcGhSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCwgXCJwXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIFBhcmFncmFwaFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKFBhcmFncmFwaClcbiAgICBdLCBQYXJhZ3JhcGhSZW5kZXJlcik7XG4gICAgcmV0dXJuIFBhcmFncmFwaFJlbmRlcmVyO1xufShSZW5kZXJlcikpO1xuZXhwb3J0IHsgUGFyYWdyYXBoUmVuZGVyZXIgfTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBIMVJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSDFSZW5kZXJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIMVJlbmRlcmVyKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50LCBcImgxXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIEgxUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgbWFwQ29tcG9uZW50UmVuZGVyZXIoSGVhZGluZzEpXG4gICAgXSwgSDFSZW5kZXJlcik7XG4gICAgcmV0dXJuIEgxUmVuZGVyZXI7XG59KFJlbmRlcmVyKSk7XG5leHBvcnQgeyBIMVJlbmRlcmVyIH07XG4vKiogQGludGVybmFsICovXG52YXIgSDJSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEgyUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSDJSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCwgXCJoMlwiKSB8fCB0aGlzO1xuICAgIH1cbiAgICBIMlJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKEhlYWRpbmcyKVxuICAgIF0sIEgyUmVuZGVyZXIpO1xuICAgIHJldHVybiBIMlJlbmRlcmVyO1xufShSZW5kZXJlcikpO1xuZXhwb3J0IHsgSDJSZW5kZXJlciB9O1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIEgzUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIM1JlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEgzUmVuZGVyZXIoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQsIFwiaDNcIikgfHwgdGhpcztcbiAgICB9XG4gICAgSDNSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihIZWFkaW5nMylcbiAgICBdLCBIM1JlbmRlcmVyKTtcbiAgICByZXR1cm4gSDNSZW5kZXJlcjtcbn0oUmVuZGVyZXIpKTtcbmV4cG9ydCB7IEgzUmVuZGVyZXIgfTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBINFJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSDRSZW5kZXJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBINFJlbmRlcmVyKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50LCBcImg0XCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIEg0UmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgbWFwQ29tcG9uZW50UmVuZGVyZXIoSGVhZGluZzQpXG4gICAgXSwgSDRSZW5kZXJlcik7XG4gICAgcmV0dXJuIEg0UmVuZGVyZXI7XG59KFJlbmRlcmVyKSk7XG5leHBvcnQgeyBINFJlbmRlcmVyIH07XG4vKiogQGludGVybmFsICovXG52YXIgSDVSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEg1UmVuZGVyZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSDVSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCwgXCJoNVwiKSB8fCB0aGlzO1xuICAgIH1cbiAgICBINVJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKEhlYWRpbmc1KVxuICAgIF0sIEg1UmVuZGVyZXIpO1xuICAgIHJldHVybiBINVJlbmRlcmVyO1xufShSZW5kZXJlcikpO1xuZXhwb3J0IHsgSDVSZW5kZXJlciB9O1xuLyoqIEBpbnRlcm5hbCAqL1xudmFyIEg2UmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhINlJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEg2UmVuZGVyZXIoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQsIFwiaDZcIikgfHwgdGhpcztcbiAgICB9XG4gICAgSDZSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihIZWFkaW5nNilcbiAgICBdLCBINlJlbmRlcmVyKTtcbiAgICByZXR1cm4gSDZSZW5kZXJlcjtcbn0oUmVuZGVyZXIpKTtcbmV4cG9ydCB7IEg2UmVuZGVyZXIgfTtcbi8vIEFkZCBzdHlsZSBvdmVycmlkZSBhbmQgYXBwbHkgc3R5bGUgc2hlZXRcbkxhYmVsLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUykpO1xuV2lkZUxhYmVsLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUyArIFwiIHdpZGVcIilcbiAgICAuc2V0KFwibWF4V2lkdGhcIiwgXCIxcHhcIikpO1xuRE9NLlN0eWxlcy5kZWZpbmUoXCJVSS1Db250cm9sIFwiICsgQ1NTX0NMQVNTLCB7XG4gICAgXCIufn5cIjoge1xuICAgICAgICBjdXJzb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgIH0sXG4gICAgXCIufn4ud2lkZVwiOiB7XG4gICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiXG4gICAgfSxcbiAgICBcIi5+fiBzbWFsbFwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgY29sb3I6IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gRE9NLlN0eWxlcy5jb2xvci50ZXh0RmFkZWQ7IH0pXG4gICAgfSxcbiAgICBcInAufn5cIjoge1xuICAgICAgICBsaW5lSGVpZ2h0OiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuc2l6ZS5wYXJhZ3JhcGhMaW5lSGVpZ2h0OyB9KVxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0NvbnRyb2xzL0xhYmVsLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBTdHlsZSwgTmF2TGlzdCwgbWFwQ29tcG9uZW50UmVuZGVyZXIgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBMYWJlbFJlbmRlcmVyIH0gZnJvbSBcIi4uL0NvbnRyb2xzL0xhYmVsXCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBCbG9ja1JlbmRlcmVyIH0gZnJvbSBcIi4vQmxvY2tcIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1OYXZMaXN0XCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgcmVuZGVyZXIgZm9yIGdpdmVuIGNvbXBvbmVudCAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQsIFwibmF2XCIpIHx8IHRoaXM7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgVUwgd3JhcHBlclxuICAgICAgICBfdGhpcy5fdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEdlbmVyYXRlIHJlbmRlcmVkIGNvbXBvbmVudCBvdXRwdXQgKi9cbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IG91dHB1dCBvYmplY3RcbiAgICAgICAgdmFyIG91dCA9IF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgLy8gc2V0IFVMIGNsYXNzIG5hbWUgZGVwZW5kaW5nIG9uIG5hdiB0eXBlXG4gICAgICAgIHZhciB1bCA9IHRoaXMuX3VsO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJuYXYgXCI7XG4gICAgICAgIGlmIChjb21wb25lbnQuanVzdGlmaWVkKVxuICAgICAgICAgICAgY2xhc3NOYW1lICs9IFwibmF2LWp1c3RpZmllZCBcIjtcbiAgICAgICAgc3dpdGNoIChjb21wb25lbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBOYXZMaXN0LlR5cGUuVGFiczpcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gXCJuYXYtdGFic1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBOYXZMaXN0LlR5cGUuUGlsbHM6XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lICs9IFwibmF2LXBpbGxzXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE5hdkxpc3QuVHlwZS5TdGFja2VkUGlsbHM6XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lICs9IFwibmF2LXBpbGxzIG5hdi1zdGFja2VkXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICAvLyBjcmVhdGUgb3IgcmV1c2UgTEkgbm9kZXNcbiAgICAgICAgdmFyIGN1ciA9IHVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gY29tcG9uZW50LnNlbGVjdGVkSW5kZXg7XG4gICAgICAgIGNvbXBvbmVudC5uYXZJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFpdGVtKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgICAgICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICAgICAgYS5ocmVmID0gXCIjXCI7XG4gICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICAgICAgICAgICAgbGkub25jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuYWN0aXZhdGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB1bC5hcHBlbmRDaGlsZChjdXIgPSBsaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMYWJlbFJlbmRlcmVyLnJlbmRlckludG8oY3VyLmZpcnN0Q2hpbGQsIGl0ZW0uaWNvbiwgY29tcG9uZW50LnJlbUd1dHRlciwgaXRlbS5sYWJlbCwgaXRlbS5iYWRnZSk7XG4gICAgICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IChpbmRleCA9PT0gc2VsZWN0ZWRJbmRleCk7XG4gICAgICAgICAgICBjdXIuY2xhc3NOYW1lID0gaXNTZWxlY3RlZCA/XG4gICAgICAgICAgICAgICAgXCJuYXYtaXRlbSBhY3RpdmVcIiA6IFwibmF2LWl0ZW1cIjtcbiAgICAgICAgICAgIGN1ci5maXJzdENoaWxkLmNsYXNzTmFtZSA9IGlzU2VsZWN0ZWQgP1xuICAgICAgICAgICAgICAgIFwibmF2LWxpbmsgYWN0aXZlXCIgOiBcIm5hdi1saW5rXCI7XG4gICAgICAgICAgICBjdXIgPSBjdXIubmV4dFNpYmxpbmc7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZW1vdmUgYWRkaXRpb25hbCBleGlzdGluZyBub2Rlc1xuICAgICAgICB3aGlsZSAoY3VyKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGN1ci5uZXh0U2libGluZztcbiAgICAgICAgICAgIHVsLnJlbW92ZUNoaWxkKGN1cik7XG4gICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSB3aXRoIFVMLCBhbmQgY29udGFpbmVyIGJsb2NrIGlmIG5lZWRlZFxuICAgICAgICBvdXQudXBkYXRlZCA9IHRoaXMuY29udGV4dC51cGRhdGVBc3luYyhbdWxdLmNvbmNhdChjb21wb25lbnQuZ2V0Q2hpbGRyZW4oKSkpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgbWFwQ29tcG9uZW50UmVuZGVyZXIoTmF2TGlzdClcbiAgICBdLCBSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufShCbG9ja1JlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gaW5qZWN0IHNpbXBsZSBVUkwtYmFzZWQgYWN0aXZhdGlvbiBmdW5jdGlvbnNcbkFzeW5jLmluamVjdChOYXZMaXN0LkFjdGl2YXRpb24sIHtcbiAgICBhY3RpdmF0ZTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAvLyBzZXQgbG9jYXRpb24gdG8gZ2l2ZW4gdGFyZ2V0IGRpcmVjdGx5IChVUkwsIHBhdGggb3IgaGFzaClcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHRhcmdldDtcbiAgICB9LFxuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgICAgICAgICAgaWYgKHRhcmdldFswXSAhPT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21wYXJlIHRhcmdldCB0byBwYXJ0aWFsIHBhdGggbmFtZSAod2l0aG91dCBob3N0IGFuZCBoYXNoKVxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gU3RyaW5nKGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvIy4qLywgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IHRhcmdldCB8fFxuICAgICAgICAgICAgICAgICAgICBwYXRoLnNsaWNlKDAsIHRhcmdldC5sZW5ndGggKyAxKSA9PT0gdGFyZ2V0ICsgXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcGFyZSB0YXJnZXQgdG8gcGFydGlhbCBoYXNoXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNoID0gU3RyaW5nKGRvY3VtZW50LmxvY2F0aW9uLmhhc2ggfHwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL14jLywgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGhhc2ggPT09IHRhcmdldCB8fFxuICAgICAgICAgICAgICAgICAgICBoYXNoLnNsaWNlKDAsIHRhcmdldC5sZW5ndGggKyAxKSA9PT0gdGFyZ2V0ICsgXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KTtcbi8vIEFkZCBzdHlsZSBvdmVycmlkZVxuTmF2TGlzdC5hZGRTdHlsZU92ZXJyaWRlKFN0eWxlLndpdGhDbGFzcyhDU1NfQ0xBU1MpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9CbG9ja3MvTmF2TGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgU3R5bGUsIFJvdywgbWFwQ29tcG9uZW50UmVuZGVyZXIgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4uLy4uL0RPTVwiO1xuaW1wb3J0IHsgUmVuZGVyZXIgYXMgQmxvY2tSZW5kZXJlciB9IGZyb20gXCIuL0Jsb2NrXCI7XG4vKiogQmFzZSBjbGFzcyBuYW1lIHVzZWQgZm9yIENTUyBzdHlsZSBzaGVldCAqL1xudmFyIENTU19DTEFTUyA9IFwiVUktUm93XCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgcmVuZGVyZXIgZm9yIGdpdmVuIGNvbXBvbmVudCAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XG4gICAgICAgIC8vIGluaXRpYWxpemUgbWFpbiBET00gZWxlbWVudFxuICAgICAgICB2YXIgd3JhcHBlciA9IF90aGlzLndyYXBwZXIgPSBET00uZGl2KENTU19DTEFTUyArIFwiX3dyYXBwZXJcIik7XG4gICAgICAgIF90aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgIF90aGlzLmNvbnRleHQucm9vdCA9IHdyYXBwZXI7XG4gICAgICAgIC8vIGFkZCB3YXRjaGVyIHRvIGRldGVjdCBpZiBhbGwgY2hpbGQgY29tcG9uZW50cyBhcmUgc2hyaW5rd3JhcHBlZFxuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50LmNvbnRlbnQuZXZlcnkoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICFjIHx8IGMuaGlkZGVuIHx8XG4gICAgICAgICAgICAgICAgKGMuc2hyaW5rd3JhcCAmJiAhKGMud2lkdGggJiYgYy53aWR0aC5zbGljZSgtMSkgPT09IFwiJVwiKSk7IH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoYWxsU2hydW5rKSB7XG4gICAgICAgICAgICAvLyBhZGp1c3Qgd2lkdGggdG8gY29tcHJlc3MgYXJvdW5kIHNocmlua3dyYXBwZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgd3JhcHBlci5zdHlsZS53aWR0aCA9IGFsbFNocnVuayA/IFwiYXV0b1wiIDogXCIxMDAlXCI7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhZGQgd2F0Y2hlciBmb3IgaG9yaXpvbnRhbCBhbGlnbm1lbnRcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhvcnpBbGlnbiA9IGNvbXBvbmVudC5ob3J6QWxpZ247XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmZsb3dEaXJlY3Rpb24gPT09IFwicnRsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9yekFsaWduID09PSBcInN0YXJ0XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJpZ2h0XCI7XG4gICAgICAgICAgICAgICAgaWYgKGhvcnpBbGlnbiA9PT0gXCJlbmRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGVmdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaG9yekFsaWduID09PSBcInN0YXJ0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICBlbHNlIGlmIChob3J6QWxpZ24gPT09IFwiZW5kXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicmlnaHRcIjtcbiAgICAgICAgICAgIHJldHVybiBob3J6QWxpZ247XG4gICAgICAgIH0sIGZ1bmN0aW9uIChob3J6QWxpZ24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaG9yekFsaWduKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy53cmFwcGVyLnN0eWxlLm1hcmdpbkxlZnQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud3JhcHBlci5zdHlsZS5tYXJnaW5SaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud3JhcHBlci5zdHlsZS5tYXJnaW5MZWZ0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLndyYXBwZXIuc3R5bGUubWFyZ2luUmlnaHQgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud3JhcHBlci5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLndyYXBwZXIuc3R5bGUubWFyZ2luUmlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud3JhcHBlci5zdHlsZS5tYXJnaW5MZWZ0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud3JhcHBlci5zdHlsZS5tYXJnaW5SaWdodCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIHdhdGNoZXJzIGZvciBoZWlnaHQgYW5kIHNwYWNpbmdcbiAgICAgICAgdmFyIGhlaWdodElzU2V0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzcGFjaW5nID0gY29tcG9uZW50LnNwYWNpbmcgfHwgRE9NLlN0eWxlcy5zaXplLmNvbnRyb2xTcGFjaW5nO1xuICAgICAgICAgICAgX3RoaXMud3JhcHBlci5zdHlsZS5ib3JkZXJTcGFjaW5nID0gc3BhY2luZyArIFwiIDBcIjtcbiAgICAgICAgICAgIHZhciBoID0gY29tcG9uZW50LmhlaWdodDtcbiAgICAgICAgICAgIGlmICghaCB8fCBoID09PSBcImF1dG9cIikge1xuICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IChjb21wb25lbnQudmVydGljYWxTcGFjaW5nIHx8IHNwYWNpbmcpO1xuICAgICAgICAgICAgICAgIF90aGlzLndyYXBwZXIuc3R5bGUubWFyZ2luVG9wID0gc3BhY2U7XG4gICAgICAgICAgICAgICAgX3RoaXMud3JhcHBlci5zdHlsZS5tYXJnaW5Cb3R0b20gPSBzcGFjZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud3JhcHBlci5zdHlsZS5tYXJnaW5Ub3AgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICBfdGhpcy53cmFwcGVyLnN0eWxlLm1hcmdpbkJvdHRvbSA9IFwiMFwiO1xuICAgICAgICAgICAgICAgIF90aGlzLndyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0SXNTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZS5zZXQoe1xuICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZWlnaHRJc1NldCkge1xuICAgICAgICAgICAgICAgIGhlaWdodElzU2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIG1heEhlaWdodDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IFwiXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEdlbmVyYXRlIHJlbmRlcmVkIGNvbXBvbmVudCBvdXRwdXQgKi9cbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IG91dHB1dCBvYmplY3RcbiAgICAgICAgdmFyIG91dCA9IF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIGFkZCBhbGwgY29tcG9uZW50c1xuICAgICAgICBvdXQudXBkYXRlZCA9IHRoaXMuY29udGV4dC51cGRhdGVBc3luYyh0aGlzLmNvbXBvbmVudC5jb250ZW50KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKFJvdylcbiAgICBdLCBSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufShCbG9ja1JlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlKHMpIGFuZCBhcHBseSBzdHlsZSBzaGVldFxuUm93LmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUykpO1xuRE9NLlN0eWxlcy5kZWZpbmUoXCJVSS1CbG9jayBcIiArIENTU19DTEFTUywge1xuICAgIFwiLn5+XCI6IHtcbiAgICAgICAgbGluZUhlaWdodDogXCIwXCIsXG4gICAgICAgIG1heEhlaWdodDogXCJub25lXCIsXG4gICAgICAgIG92ZXJmbG93OiBcInZpc2libGVcIlxuICAgIH0sXG4gICAgXCIufl93cmFwcGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJ0YWJsZVwiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQmxvY2tzL1Jvdy5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0ICogYXMgQXN5bmMgZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9Bc3luY1wiO1xuaW1wb3J0IHsgU3R5bGUsIFRhYmxlLCBtYXBDb21wb25lbnRSZW5kZXJlciB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCAqIGFzIERPTSBmcm9tIFwiLi4vLi4vRE9NXCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBCbG9ja1JlbmRlcmVyIH0gZnJvbSBcIi4vQmxvY2tcIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1UYWJsZVwiO1xuLyoqIEBpbnRlcm5hbCBET00tc3BlY2lmaWMgY29tcG9uZW50IHJlbmRlcmVyICovXG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHJlbmRlcmVyIGZvciBnaXZlbiBjb21wb25lbnQgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50LCBcInRhYmxlXCIpIHx8IHRoaXM7XG4gICAgICAgIC8vIGNyZWF0ZSBtYWluIERPTSBlbGVtZW50c1xuICAgICAgICBfdGhpcy50aGVhZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aGVhZFwiKTtcbiAgICAgICAgX3RoaXMudGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIik7XG4gICAgICAgIF90aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMudGJvZHkpO1xuICAgICAgICBfdGhpcy5jb250ZXh0LnJvb3QgPSBfdGhpcy50Ym9keTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGUgcmVuZGVyZWQgY29tcG9uZW50IG91dHB1dCAqL1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGdldCBvciBjcmVhdGUgdGhlIGN1cnJlbnQgb3V0cHV0IG9iamVjdFxuICAgICAgICB2YXIgb3V0ID0gX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAvLyByZW1vdmUgKG9sZCkgaGVhZGVyIGVsZW1lbnQgZmlyc3RcbiAgICAgICAgd2hpbGUgKHRoaXMuZWxlbWVudC5maXJzdENoaWxkICE9PSB0aGlzLnRib2R5KVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgLy8gYWRkIGhlYWRlciBpZiBuZWVkZWQgKGp1c3QgcmVuZGVyIHN5bmNocm9ub3VzbHkpXG4gICAgICAgIGlmIChjb21wb25lbnQuaGVhZGVyICYmIGNvbXBvbmVudC5oZWFkZXIuY29sdW1ucy5sZW5ndGggJiZcbiAgICAgICAgICAgIGNvbXBvbmVudC5yb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gY29weSBsdHIvcnRsIGZsb3cgZGlyZWN0aW9uIGlmIHNldCBhdCBjb21wb25lbnQgbGV2ZWxcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuaGVhZGVyICYmIGNvbXBvbmVudC5mbG93RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgQXN5bmMudW5vYnNlcnZlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5oZWFkZXIuZmxvd0RpcmVjdGlvbiA9IGNvbXBvbmVudC5mbG93RGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhlYWRlck91dCA9IGNvbXBvbmVudC5oZWFkZXIgJiYgY29tcG9uZW50LmhlYWRlci5vdXQ7XG4gICAgICAgICAgICBpZiAoaGVhZGVyT3V0ICYmIGhlYWRlck91dC5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoZWFkVFIgPSBoZWFkZXJPdXQuZWxlbWVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnRoZWFkLmFwcGVuZENoaWxkKHRoZWFkVFIpO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGVhZFRSLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aGVhZC5yZW1vdmVDaGlsZCh0aGVhZFRSLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLnRoZWFkLCB0aGlzLnRib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgcm93IGluZGV4IG9uIHJlbmRlcmVkIHJvd3NcbiAgICAgICAgdmFyIHJvd3MgPSBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQucm93cy5tYXAoZnVuY3Rpb24gKHIsIGkpIHsgcmV0dXJuIHIgJiYgKHIucm93SW5kZXggPSBpLCByKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhZGQgYWxsIHRhYmxlIHJvd3MsIGlmIGFueVxuICAgICAgICBvdXQudXBkYXRlZCA9IHRoaXMuY29udGV4dC51cGRhdGVBc3luYyhyb3dzLCBmYWxzZSwgdGhpcy5jb21wb25lbnQucmVuZGVyT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVuZGVyT3B0aW9ucy5hbmltYXRlTGlzdEl0ZW1zKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKFRhYmxlKVxuICAgIF0sIFJlbmRlcmVyKTtcbiAgICByZXR1cm4gUmVuZGVyZXI7XG59KEJsb2NrUmVuZGVyZXIpKTtcbmV4cG9ydCB7IFJlbmRlcmVyIH07XG4vLyBBZGQgc3R5bGUgb3ZlcnJpZGUgYW5kIGFwcGx5IHN0eWxlIHNoZWV0XG5UYWJsZS5hZGRTdHlsZU92ZXJyaWRlKFN0eWxlLndpdGhDbGFzcyhDU1NfQ0xBU1MgKyBcIiB0YWJsZVwiKSk7XG5ET00uU3R5bGVzLmRlZmluZShcIlVJLUJsb2NrIFwiICsgQ1NTX0NMQVNTLCB7XG4gICAgXCIufn5cIjoge1xuICAgICAgICBkaXNwbGF5OiBcInRhYmxlXCIsXG4gICAgICAgIG1hcmdpbjogXCIwXCIsXG4gICAgICAgIGJvcmRlclNwYWNpbmc6IFwiaW5pdGlhbFwiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQmxvY2tzL1RhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIFN0eWxlLCBUYWJsZVJvdywgVGFibGVIZWFkZXIsIG1hcENvbXBvbmVudFJlbmRlcmVyIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0ICogYXMgRE9NIGZyb20gXCIuLi8uLi9ET01cIjtcbmltcG9ydCB7IFJlbmRlcmVyIGFzIEJsb2NrUmVuZGVyZXIgfSBmcm9tIFwiLi9CbG9ja1wiO1xuLyoqIEJhc2UgY2xhc3MgbmFtZSB1c2VkIGZvciBDU1Mgc3R5bGUgc2hlZXQgKi9cbnZhciBDU1NfQ0xBU1MgPSBcIlVJLVRhYmxlUm93XCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgcmVuZGVyZXIgZm9yIGdpdmVuIGNvbXBvbmVudCAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50LCBcInRyXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIC8vIGFkZCBhbGwgY29sdW1ucyAodXNpbmcgcmVuZGVyZXIgd3JhcHBlcnMpLCBpZiBhbnlcbiAgICAgICAgdmFyIGNvbHVtbnMgPSBbXTtcbiAgICAgICAgdmFyIGlzSGVhZGVyID0gKGNvbXBvbmVudCBpbnN0YW5jZW9mIFRhYmxlSGVhZGVyKTtcbiAgICAgICAgY29tcG9uZW50LmNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sLCBpKSB7XG4gICAgICAgICAgICB2YXIgY2VsbDtcbiAgICAgICAgICAgIC8vIGNoZWNrIGNvbHVtbiBjb250ZW50IHR5cGU6IGNvbXBvbmVudCBvciBzY2FsYXJcbiAgICAgICAgICAgIGlmIChjb2wgaW5zdGFuY2VvZiBDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBjb3B5IGx0ci9ydGwgZmxvdyBkaXJlY3Rpb24gaWYgc2V0IGF0IGNvbXBvbmVudCBsZXZlbFxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5mbG93RGlyZWN0aW9uID0gY29tcG9uZW50LmZsb3dEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgY29tcG9uZW50IHN5bmNocm9ub3VzbHksIGNoZWNrIHdyYXBwZXJcbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0gY29sLm91dDtcbiAgICAgICAgICAgICAgICBpZiAoIW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsID0gb3V0LndyYXBwZXI7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gU3RyaW5nKGNlbGwgJiYgY2VsbC5ub2RlTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkZXIgPyAobm9kZU5hbWUgIT09IFwidGRcIikgOiAobm9kZU5hbWUgIT09IFwidGhcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIChkb3VibGUpIHdyYXBwZXIgYXJvdW5kIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICBjZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpc0hlYWRlciA/IFwidGhcIiA6IFwidGRcIik7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuc3R5bGUudmVydGljYWxBbGlnbiA9IFwiYmFzZWxpbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5zdHlsZS5saW5lSGVpZ2h0ID0gXCJub3JtYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChvdXQuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0LndyYXBwZXIgPSBjZWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZGQgY29sdW1uIG91dHB1dCAod2l0aCB3cmFwcGVyKSB0byBjb250ZW50IGxpc3RcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2gob3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBjZWxsIHdpdGggdGV4dCBjb250ZW50XG4gICAgICAgICAgICAgICAgY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXNIZWFkZXIgPyBcInRoXCIgOiBcInRkXCIpO1xuICAgICAgICAgICAgICAgIGNlbGwudGV4dENvbnRlbnQgPSAoY29sIHx8IGNvbCA9PT0gMCkgPyBTdHJpbmcoY29sKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgY2VsbC5zdHlsZS53aGl0ZVNwYWNlID0gXCJwcmUtd3JhcFwiO1xuICAgICAgICAgICAgICAgIC8vIGFkZCBjZWxsIGVsZW1lbnQgaXRzZWxmIHRvIGNvbnRlbnQgbGlzdFxuICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaChjZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGx5IGFkZGl0aW9uYWwgc3R5bGVzXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LnN0eWxlc1tpXSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGNvbXBvbmVudC5zdHlsZXNbaV07XG4gICAgICAgICAgICAgICAgRE9NLmFwcGx5U3R5bGVUbygoc3R5bGUgaW5zdGFuY2VvZiBTdHlsZSkgP1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSA6IG5ldyBTdHlsZShzdHlsZSksIGNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC53aWR0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICBjZWxsLnN0eWxlLndpZHRoID0gY29tcG9uZW50LndpZHRoc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHVwZGF0ZSBUUiBjb250ZW50XG4gICAgICAgIG91dC51cGRhdGVkID0gdGhpcy5jb250ZXh0LnVwZGF0ZUFzeW5jKGNvbHVtbnMsIHRydWUpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgbWFwQ29tcG9uZW50UmVuZGVyZXIoVGFibGVSb3cpXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQmxvY2tSZW5kZXJlcikpO1xuZXhwb3J0IHsgUmVuZGVyZXIgfTtcbi8vIEFkZCBzdHlsZSBvdmVycmlkZSBhbmQgYXBwbHkgc3R5bGUgc2hlZXRcblRhYmxlUm93LmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUykpO1xuRE9NLlN0eWxlcy5kZWZpbmUoXCJVSS1CbG9jayBcIiArIENTU19DTEFTUywge1xuICAgIFwiLn5+XCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJ0YWJsZS1yb3dcIixcbiAgICAgICAgY3Vyc29yOiBcImluaGVyaXRcIlxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0Jsb2Nrcy9UYWJsZVJvdy5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgQmxvY2tDb250cm9sLCBtYXBDb21wb25lbnRSZW5kZXJlciB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCB7IFJlbmRlcmVyIGFzIENvbnRyb2xSZW5kZXJlciB9IGZyb20gXCIuL0NvbnRyb2xFbGVtZW50XCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICAvLyB1cGRhdGUgd2l0aCBjdXJyZW50IGJsb2NrIGNvbXBvbmVudFxuICAgICAgICBvdXQudXBkYXRlZCA9IHRoaXMuY29udGV4dC51cGRhdGVBc3luYyhbdGhpcy5jb21wb25lbnQuYmxvY2tdKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKEJsb2NrQ29udHJvbClcbiAgICBdLCBSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufShDb250cm9sUmVuZGVyZXIpKTtcbmV4cG9ydCB7IFJlbmRlcmVyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvQmxvY2tDb250cm9sLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBCdXR0b24sIFByaW1hcnlCdXR0b24sIFRvZ2dsZUJ1dHRvbiwgTGlua0J1dHRvbiwgVGV4dEJ1dHRvbiwgUm91bmRCdXR0b24sIFN0eWxlLCBtYXBDb21wb25lbnRSZW5kZXJlciB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCAqIGFzIERPTSBmcm9tIFwiLi4vLi4vRE9NXCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBDb250cm9sUmVuZGVyZXIgfSBmcm9tIFwiLi9Db250cm9sRWxlbWVudFwiO1xuaW1wb3J0IHsgUmVuZGVyZXIgYXMgTGFiZWxSZW5kZXJlciB9IGZyb20gXCIuL0xhYmVsXCI7XG4vKiogQmFzZSBjbGFzcyBuYW1lIHVzZWQgZm9yIENTUyBzdHlsZSBzaGVldCAqL1xudmFyIENTU19DTEFTUyA9IFwiVUktQnV0dG9uXCI7XG4vKiogT3ZlcnJpZGVzIGZvciBwcmVkZWZpbmVkIGJ1dHRvbiBzdHlsZXMgKi9cbnZhciBsaW5rQnRuT3ZlcnJpZGUgPSBTdHlsZS53aXRoQ2xhc3MoXCJidG4tbGlua1wiKVxuICAgIC5yZW1vdmVDbGFzcyhcImJ0bi1zZWNvbmRhcnlcIiwgXCJidG4tZGVmYXVsdFwiKTtcbnZhciB0ZXh0QnRuT3ZlcnJpZGUgPSBTdHlsZS53aXRoQ2xhc3MoXCJidG4tdGV4dC1vbmx5XCIpXG4gICAgLnJlbW92ZUNsYXNzKFwiYnRuLXNlY29uZGFyeVwiLCBcImJ0bi1kZWZhdWx0XCIpO1xuLyoqIEBpbnRlcm5hbCBET00tc3BlY2lmaWMgY29tcG9uZW50IHJlbmRlcmVyICovXG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHJlbmRlcmVyIGZvciBnaXZlbiBjb21wb25lbnQgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xuICAgICAgICBpZiAoY29tcG9uZW50IGluc3RhbmNlb2YgTGlua0J1dHRvbikge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGxpbmsgZWxlbWVudFxuICAgICAgICAgICAgdmFyIGEgPSBfdGhpcy5idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICAgIGEuaHJlZiA9IFwiI1wiO1xuICAgICAgICAgICAgYS5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTsgfTtcbiAgICAgICAgICAgIF90aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoYSk7XG4gICAgICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnQudGFyZ2V0OyB9LCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgYS5ocmVmID0gKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpID8gdGFyZ2V0IDogXCIjXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBidXR0b24gZWxlbWVudFxuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IF90aGlzLmJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgICAgICBidXR0b24udHlwZSA9IFwiYnV0dG9uXCI7XG4gICAgICAgICAgICBfdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnQuZGlzYWJsZWQ7IH0sIGZ1bmN0aW9uIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3ZlcnJpZGUgYnRuIHN0eWxlc1xuICAgICAgICBjb21wb25lbnQuc3R5bGVfYnV0dG9uLmFkZENsYXNzKFwiYnRuXCIpO1xuICAgICAgICBpZiAoY29tcG9uZW50IGluc3RhbmNlb2YgTGlua0J1dHRvbilcbiAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZV9idXR0b24ub3ZlcnJpZGUobGlua0J0bk92ZXJyaWRlKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudCBpbnN0YW5jZW9mIFRleHRCdXR0b24pXG4gICAgICAgICAgICBjb21wb25lbnQuc3R5bGVfYnV0dG9uLm92ZXJyaWRlKHRleHRCdG5PdmVycmlkZSk7XG4gICAgICAgIC8vIGFkZCB3YXRjaGVycyBmb3IgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gRE9NLmFwcGx5U3R5bGVUbyhjb21wb25lbnQuc3R5bGVfYnV0dG9uLCBfdGhpcy5idXR0b24pOyB9KTtcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50LnByaW1hcnk7IH0sIGZ1bmN0aW9uIChwcmltYXJ5KSB7XG4gICAgICAgICAgICBpZiAocHJpbWFyeSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZV9idXR0b24uYWRkQ2xhc3MoXCJidG4tcHJpbWFyeVwiKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc3R5bGVfYnV0dG9uLnJlbW92ZUNsYXNzKFwiYnRuLXNlY29uZGFyeVwiLCBcImJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlX2J1dHRvbi5yZW1vdmVDbGFzcyhcImJ0bi1wcmltYXJ5XCIpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZV9idXR0b24uYWRkQ2xhc3MoXCJidG4tc2Vjb25kYXJ5XCIsIFwiYnRuLWRlZmF1bHRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnQuc2VsZWN0ZWQ7IH0sIGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZV9idXR0b24uYWRkQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlX2J1dHRvbi5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEdlbmVyYXRlIHJlbmRlcmVkIGNvbXBvbmVudCBvdXRwdXQgKi9cbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IG91dHB1dCBvYmplY3RcbiAgICAgICAgdmFyIG91dCA9IF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIG91dC5saXZlRWxlbWVudCA9IHRoaXMuYnV0dG9uO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIC8vIHJlbmRlciB0ZXh0IGludG8gRE9NIGVsZW1lbnRcbiAgICAgICAgTGFiZWxSZW5kZXJlci5yZW5kZXJJbnRvKHRoaXMuYnV0dG9uLCBjb21wb25lbnQuaWNvbiwgY29tcG9uZW50Lmljb24gPyBjb21wb25lbnQucmVtR3V0dGVyIDogMCwgY29tcG9uZW50LmxhYmVsLCBjb21wb25lbnQuYmFkZ2UpO1xuICAgICAgICBpZiAoY29tcG9uZW50Lmljb25BZnRlcikge1xuICAgICAgICAgICAgLy8gYWxzbyBhcHBlbmQgaWNvbkFmdGVyXG4gICAgICAgICAgICBMYWJlbFJlbmRlcmVyLnJlbmRlckludG8odGhpcy5idXR0b24sIGNvbXBvbmVudC5pY29uQWZ0ZXIsIGNvbXBvbmVudC5yZW1HdXR0ZXIsIFwiXCIsIFwiXCIsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB0b29sdGlwIHRleHRcbiAgICAgICAgaWYgKGNvbXBvbmVudC50b29sdGlwVGV4dCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy5idXR0b24udGl0bGUgPSBjb21wb25lbnQudG9vbHRpcFRleHQ7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihCdXR0b24pXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQ29udHJvbFJlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gaW5qZWN0IHNpbXBsZSBVUkwtYmFzZWQgYWN0aXZhdGlvbiBmdW5jdGlvblxuQXN5bmMuaW5qZWN0KEJ1dHRvbi5BY3RpdmF0aW9uLCB7XG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgLy8gc2V0IGxvY2F0aW9uIHRvIGdpdmVuIHRhcmdldCBkaXJlY3RseSAoVVJMLCBwYXRoIG9yIGhhc2gpXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB0YXJnZXQ7XG4gICAgfVxufSk7XG4vLyBBZGQgc3R5bGUgb3ZlcnJpZGUgYW5kIGFwcGx5IHN0eWxlIHNoZWV0XG5CdXR0b24uYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTKSk7XG5QcmltYXJ5QnV0dG9uLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUyArIFwiIFVJLVByaW1hcnlCdXR0b25cIikpO1xuVG9nZ2xlQnV0dG9uLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUyArIFwiIFVJLVRvZ2dsZUJ1dHRvblwiKSk7XG5MaW5rQnV0dG9uLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUyArIFwiIFVJLUxpbmtCdXR0b25cIikpO1xuVGV4dEJ1dHRvbi5hZGRTdHlsZU92ZXJyaWRlKFN0eWxlLndpdGhDbGFzcyhDU1NfQ0xBU1MgKyBcIiBVSS1UZXh0QnV0dG9uXCIpKTtcblJvdW5kQnV0dG9uLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUyArIFwiIFVJLVJvdW5kQnV0dG9uXCIpKTtcbkRPTS5TdHlsZXMuZGVmaW5lKFwiVUktQ29udHJvbCBcIiArIENTU19DTEFTUywge1xuICAgIFwiLn5+XCI6IHtcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiXG4gICAgfSxcbiAgICBcIi5+fiA+IGJ1dHRvblwiOiB7XG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmVcIlxuICAgIH0sXG4gICAgXCIufn4uVUktVGV4dEJ1dHRvbiA+IGJ1dHRvblwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIwXCIsXG4gICAgICAgIGJveFNoYWRvdzogXCJub25lXCIsXG4gICAgICAgIG91dGxpbmU6IFwiMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiLFxuICAgICAgICBtYXJnaW46IFwiMFwiLFxuICAgICAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgICAgIG1pbldpZHRoOiBcIjBcIixcbiAgICAgICAgZm9udFNpemU6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcImluaGVyaXRcIixcbiAgICAgICAgZm9udEZhbWlseTogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTdHlsZTogXCJpbmhlcml0XCIsXG4gICAgICAgIGhlaWdodDogXCJhdXRvXCIsXG4gICAgICAgIGxpbmVIZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwiYmFzZWxpbmVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfSxcbiAgICBcIi5+fi5VSS1Sb3VuZEJ1dHRvbiA+IGJ1dHRvblwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMFwiLFxuICAgICAgICBib3JkZXI6IFwiMFwiLFxuICAgICAgICBvdXRsaW5lOiBcIjBcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjUwJVwiLFxuICAgICAgICBib3hTaGFkb3c6IFwibm9uZVwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgbWluV2lkdGg6IFwiMi4yZW1cIixcbiAgICAgICAgbWF4V2lkdGg6IFwiMi4yZW1cIixcbiAgICAgICAgaGVpZ2h0OiBcIjIuMmVtXCJcbiAgICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250cm9scy9CdXR0b24uanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCB7IEJ1dHRvbkdyb3VwLCBTdHlsZSwgbWFwQ29tcG9uZW50UmVuZGVyZXIgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4uLy4uL0RPTVwiO1xuaW1wb3J0IHsgUmVuZGVyZXIgYXMgQ29udHJvbFJlbmRlcmVyIH0gZnJvbSBcIi4vQ29udHJvbEVsZW1lbnRcIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1CdXR0b25Hcm91cFwiO1xuLyoqIEBpbnRlcm5hbCBET00tc3BlY2lmaWMgY29tcG9uZW50IHJlbmRlcmVyICovXG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHJlbmRlcmVyIGZvciBnaXZlbiBjb21wb25lbnQgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnQudmVydGljYWw7IH0sIGZ1bmN0aW9uICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgLy8gc2V0IGFwcHJvcHJpYXRlIGNsYXNzIG5hbWVcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbClcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc3R5bGUucmVtb3ZlQ2xhc3MoXCJidG4tZ3JvdXBcIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiYnRuLWdyb3VwLXZlcnRpY2FsXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZS5yZW1vdmVDbGFzcyhcImJ0bi1ncm91cC12ZXJ0aWNhbFwiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidG4tZ3JvdXBcIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIC8vIGFkZCBhbGwgYnV0dG9uIGVsZW1lbnRzXG4gICAgICAgIHZhciBlbGVtZW50cyA9IGNvbXBvbmVudC5idXR0b25zLm1hcChmdW5jdGlvbiAoYnV0dG9uKSB7XG4gICAgICAgICAgICB2YXIgYnV0dG9uT3V0ID0gYnV0dG9uICYmIGJ1dHRvbi5vdXQ7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uT3V0ICYmIGJ1dHRvbk91dC5saXZlRWxlbWVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dC51cGRhdGVkID0gdGhpcy5jb250ZXh0LnVwZGF0ZUFzeW5jKGVsZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKEJ1dHRvbkdyb3VwKVxuICAgIF0sIFJlbmRlcmVyKTtcbiAgICByZXR1cm4gUmVuZGVyZXI7XG59KENvbnRyb2xSZW5kZXJlcikpO1xuZXhwb3J0IHsgUmVuZGVyZXIgfTtcbi8vIEFkZCBzdHlsZSBvdmVycmlkZSBhbmQgYXBwbHkgc3R5bGUgc2hlZXRcbkJ1dHRvbkdyb3VwLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUykpO1xuRE9NLlN0eWxlcy5kZWZpbmUoXCJVSS1Db250cm9sIFwiICsgQ1NTX0NMQVNTLCB7XG4gICAgXCIufn4gYnV0dG9uXCI6IHtcbiAgICAgICAgZmxvYXQ6IFwibm9uZVwiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvQnV0dG9uR3JvdXAuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCB7IENvbnRhaW5lckNvbnRyb2wsIG1hcENvbXBvbmVudFJlbmRlcmVyIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0IHsgUmVuZGVyZXIgYXMgQ29udHJvbFJlbmRlcmVyIH0gZnJvbSBcIi4vQ29udHJvbEVsZW1lbnRcIjtcbi8qKiBAaW50ZXJuYWwgRE9NLXNwZWNpZmljIGNvbXBvbmVudCByZW5kZXJlciAqL1xudmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgLyoqIEluc3RhbnRpYXRlIHRoZSByZW5kZXJlciBmb3IgZ2l2ZW4gY29tcG9uZW50ICovXG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcbiAgICAgICAgLy8gb3ZlcnJpZGUgbGluZS1oZWlnaHQgZm9yIHRoaXMgZWxlbWVudFxuICAgICAgICBjb21wb25lbnQuc3R5bGUuc2V0KHsgbGluZUhlaWdodDogXCIwXCIgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEdlbmVyYXRlIHJlbmRlcmVkIGNvbXBvbmVudCBvdXRwdXQgKi9cbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IG91dHB1dCBvYmplY3RcbiAgICAgICAgdmFyIG91dCA9IF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIHVwZGF0ZSB3aXRoIGN1cnJlbnQgY29udGFpbmVyIGNvbXBvbmVudFxuICAgICAgICBvdXQudXBkYXRlZCA9IHRoaXMuY29udGV4dC51cGRhdGVBc3luYyhbdGhpcy5jb21wb25lbnQuY29udGFpbmVyXSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihDb250YWluZXJDb250cm9sKVxuICAgIF0sIFJlbmRlcmVyKTtcbiAgICByZXR1cm4gUmVuZGVyZXI7XG59KENvbnRyb2xSZW5kZXJlcikpO1xuZXhwb3J0IHsgUmVuZGVyZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL1VJL1JlbmRlcmVycy9Db250cm9scy9Db250YWluZXJDb250cm9sLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBTdHlsZSwgQ29udHJvbFN0YWNrLCBtYXBDb21wb25lbnRSZW5kZXJlciB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCAqIGFzIERPTSBmcm9tIFwiLi4vLi4vRE9NXCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBDb250cm9sUmVuZGVyZXIgfSBmcm9tIFwiLi9Db250cm9sRWxlbWVudFwiO1xuLyoqIEJhc2UgY2xhc3MgbmFtZSB1c2VkIGZvciBDU1Mgc3R5bGUgc2hlZXQgKi9cbnZhciBDU1NfQ0xBU1MgPSBcIlVJLUNvbnRyb2xTdGFja1wiO1xuLyoqIEBpbnRlcm5hbCBET00tc3BlY2lmaWMgY29tcG9uZW50IHJlbmRlcmVyICovXG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHJlbmRlcmVyIGZvciBnaXZlbiBjb21wb25lbnQgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xuICAgICAgICAvLyBhZGQgYSB3YXRjaGVyIGZvciBjb250ZW50IGFsaWdubWVudFxuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnQuaG9yekFsaWduOyB9LCBmdW5jdGlvbiAoYWxpZ24pIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZS5zZXQoXCJ0ZXh0QWxpZ25cIiwgYWxpZ24gfHwgXCJcIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIC8vIGFkZCBhbGwgY29udHJvbHMgKHVzaW5nIHJlbmRlcmVyIHdyYXBwZXJzKSwgaWYgYW55XG4gICAgICAgIHZhciBjb250ZW50ID0gW107XG4gICAgICAgIGNvbXBvbmVudC5jb250ZW50LmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIC8vIGFkZCBzcGFjZXJzIGluIGJldHdlZW4gd3JhcHBlciB0YWJsZXMgdG8gc3RhY2sgdGhlbSB1cFxuICAgICAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNlciA9IERPTS5kaXYoQ1NTX0NMQVNTICsgXCJfc3BhY2VyXCIpO1xuICAgICAgICAgICAgICAgIHNwYWNlci5zdHlsZS5oZWlnaHQgPVxuICAgICAgICAgICAgICAgICAgICAoY29tcG9uZW50LnNwYWNpbmcgfHwgRE9NLlN0eWxlcy5zaXplLmNvbnRyb2xTcGFjaW5nKTtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goc3BhY2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgbHRyL3J0bCBmbG93IGRpcmVjdGlvbiBpZiBzZXQgYXQgY29tcG9uZW50IGxldmVsXG4gICAgICAgICAgICBpZiAoYyAmJiBjb21wb25lbnQuZmxvd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjLmZsb3dEaXJlY3Rpb24gPSBjb21wb25lbnQuZmxvd0RpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFkZCB3cmFwcGVyIHRhYmxlcyAoaW5saW5lKSBmb3IgYWxsIGNvbnRyb2xzXG4gICAgICAgICAgICB2YXIgb3V0ID0gYyAmJiBjLm91dDtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChvdXQpO1xuICAgICAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gb3V0LndyYXBwZXI7XG4gICAgICAgICAgICAgICAgaWYgKCF3cmFwcGVyIHx8IHdyYXBwZXIuY2xhc3NOYW1lICE9PSBDU1NfQ0xBU1MgKyBcIl93cmFwcGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlciA9IERPTS5kaXYoQ1NTX0NMQVNTICsgXCJfd3JhcHBlclwiLCBvdXQuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIG91dC53cmFwcGVyID0gd3JhcHBlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2hyaW5rIHRhYmxlIGl0c2VsZiBpZiBjb21wb25lbnQgaXMgc2hyaW5rd3JhcHBlZFxuICAgICAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUud2lkdGggPSBjLnNocmlua3dyYXAgPyBcImF1dG9cIiA6IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB1cGRhdGUgc3RhY2sgY29udHJvbCBlbGVtZW50IGNvbnRlbnRcbiAgICAgICAgb3V0LnVwZGF0ZWQgPSB0aGlzLmNvbnRleHQudXBkYXRlQXN5bmMoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihDb250cm9sU3RhY2spXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQ29udHJvbFJlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlIGFuZCBhcHBseSBzdHlsZSBzaGVldFxuQ29udHJvbFN0YWNrLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUykpO1xuRE9NLlN0eWxlcy5kZWZpbmUoXCJVSS1Db250cm9sIFwiICsgQ1NTX0NMQVNTLCB7XG4gICAgXCIufn5cIjoge1xuICAgICAgICBsaW5lSGVpZ2h0OiBcIjBcIlxuICAgIH0sXG4gICAgXCIufl93cmFwcGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtdGFibGVcIixcbiAgICAgICAgdGFibGVMYXlvdXQ6IFwiZml4ZWRcIixcbiAgICAgICAgYm9yZGVyU3BhY2luZzogXCIwXCIsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIlxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0NvbnRyb2xzL0NvbnRyb2xTdGFjay5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgSWNvbiwgU3R5bGUsIG1hcENvbXBvbmVudFJlbmRlcmVyIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0ICogYXMgRE9NIGZyb20gXCIuLi8uLi9ET01cIjtcbmltcG9ydCB7IFJlbmRlcmVyIGFzIENvbnRyb2xSZW5kZXJlciB9IGZyb20gXCIuL0NvbnRyb2xFbGVtZW50XCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBMYWJlbFJlbmRlcmVyIH0gZnJvbSBcIi4vTGFiZWxcIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1JY29uXCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIC8vIHJlbmRlciB0ZXh0IGludG8gRE9NIGVsZW1lbnRcbiAgICAgICAgTGFiZWxSZW5kZXJlci5yZW5kZXJJbnRvKHRoaXMuZWxlbWVudCwgY29tcG9uZW50Lmljb24pO1xuICAgICAgICAvLyBzZXQgdG9vbHRpcCB0ZXh0XG4gICAgICAgIGlmIChjb21wb25lbnQudG9vbHRpcFRleHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50aXRsZSA9IGNvbXBvbmVudC50b29sdGlwVGV4dDtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKEljb24pXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQ29udHJvbFJlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlIGFuZCBhcHBseSBzdHlsZSBzaGVldFxuSWNvbi5hZGRTdHlsZU92ZXJyaWRlKFN0eWxlLndpdGhDbGFzcyhDU1NfQ0xBU1MpKTtcbkRPTS5TdHlsZXMuZGVmaW5lKFwiVUktQ29udHJvbCBcIiArIENTU19DTEFTUywge1xuICAgIFwiLn5+XCI6IHtcbiAgICAgICAgY3Vyc29yOiBcImluaGVyaXRcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiBcIjFlbVwiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvSWNvbi5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0ICogYXMgQXN5bmMgZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9Bc3luY1wiO1xuaW1wb3J0IHsgU3R5bGUsIEltYWdlLCBtYXBDb21wb25lbnRSZW5kZXJlciB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCAqIGFzIERPTSBmcm9tIFwiLi4vLi4vRE9NXCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBDb250cm9sUmVuZGVyZXIgfSBmcm9tIFwiLi9Db250cm9sRWxlbWVudFwiO1xuLyoqIEJhc2UgY2xhc3MgbmFtZSB1c2VkIGZvciBDU1Mgc3R5bGUgc2hlZXQgKi9cbnZhciBDU1NfQ0xBU1MgPSBcIlVJLUltYWdlXCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgcmVuZGVyZXIgZm9yIGdpdmVuIGNvbXBvbmVudCAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XG4gICAgICAgIC8vIGNyZWF0ZSBpbWFnZSBlbGVtZW50XG4gICAgICAgIHZhciBpbWcgPSBfdGhpcy5pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBfdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIC8vIGFkZCBzdHlsZSB3YXRjaGVyXG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5hcHBseVN0eWxlVG8oY29tcG9uZW50LnN0eWxlX2ltZywgaW1nKTsgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEdlbmVyYXRlIHJlbmRlcmVkIGNvbXBvbmVudCBvdXRwdXQgKi9cbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IG91dHB1dCBvYmplY3RcbiAgICAgICAgdmFyIG91dCA9IF9zdXBlci5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgICAgIG91dC5saXZlRWxlbWVudCA9IHRoaXMuaW1nO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBwcm9taXNlIGlmIG5lZWRlZFxuICAgICAgICBpZiAoIWNvbXBvbmVudC5yZXNvbHZlUmVhZHkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5yZWFkeSA9IG5ldyBBc3luYy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnJlc29sdmVSZWFkeSA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgaW1hZ2UgZXZlbnQgaGFuZGxlcnMgYW5kIHRoZW4gc2V0IChuZXcpIFVSTFxuICAgICAgICB0aGlzLmltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb21wb25lbnQuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5yZXNvbHZlUmVhZHkgJiYgY29tcG9uZW50LnJlc29sdmVSZWFkeSgpO1xuICAgICAgICAgICAgY29tcG9uZW50LnJlc29sdmVSZWFkeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBjb21wb25lbnQucmVzb2x2ZVJlYWR5ICYmIGNvbXBvbmVudC5yZXNvbHZlUmVhZHkoKTtcbiAgICAgICAgICAgIGNvbXBvbmVudC5yZXNvbHZlUmVhZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW1nLnNyYyA9IGNvbXBvbmVudC5pbWFnZVVybDtcbiAgICAgICAgLy8gc2V0IHRvb2x0aXAgdGV4dFxuICAgICAgICBpZiAoY29tcG9uZW50LnRvb2x0aXBUZXh0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmltZy50aXRsZSA9IGNvbXBvbmVudC50b29sdGlwVGV4dDtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKEltYWdlKVxuICAgIF0sIFJlbmRlcmVyKTtcbiAgICByZXR1cm4gUmVuZGVyZXI7XG59KENvbnRyb2xSZW5kZXJlcikpO1xuZXhwb3J0IHsgUmVuZGVyZXIgfTtcbi8vIEFkZCBzdHlsZSBvdmVycmlkZSBhbmQgYXBwbHkgc3R5bGUgc2hlZXRcbkltYWdlLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUykpO1xuRE9NLlN0eWxlcy5kZWZpbmUoXCJVSS1Db250cm9sIFwiICsgQ1NTX0NMQVNTLCB7XG4gICAgXCIufn4gPiBpbWdcIjoge1xuICAgICAgICBtYXJnaW46IFwiMFwiLFxuICAgICAgICBvdXRsaW5lOiBcIjBcIixcbiAgICAgICAgbWF4V2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvSW1hZ2UuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IFByb2dyZXNzQmFyLCBTdHlsZSwgbWFwQ29tcG9uZW50UmVuZGVyZXIgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4uLy4uL0RPTVwiO1xuaW1wb3J0IHsgUmVuZGVyZXIgYXMgQ29udHJvbFJlbmRlcmVyIH0gZnJvbSBcIi4vQ29udHJvbEVsZW1lbnRcIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1Qcm9ncmVzc0JhclwiO1xuLyoqIEBpbnRlcm5hbCBET00tc3BlY2lmaWMgY29tcG9uZW50IHJlbmRlcmVyICovXG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHJlbmRlcmVyIGZvciBnaXZlbiBjb21wb25lbnQgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xuICAgICAgICAvLyBjcmVhdGUgaW5uZXIgZWxlbWVudFxuICAgICAgICB2YXIgYmFyID0gX3RoaXMuYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGNvbXBvbmVudC5zdHlsZV9iYXIuYWRkQ2xhc3MoQ1NTX0NMQVNTICsgXCJfYmFyXCIpO1xuICAgICAgICBfdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGJhcik7XG4gICAgICAgIC8vIGFkZCB3YXRjaGVycyBmb3IgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKGNvbXBvbmVudC5mbG93RGlyZWN0aW9uID09PSBcInJ0bFwiKTsgfSwgZnVuY3Rpb24gKHJ0bCkge1xuICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlX2Jhci5zZXQoXCJmbG9hdFwiLCBydGwgPyBcInJpZ2h0XCIgOiBcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5hcHBseVN0eWxlVG8oY29tcG9uZW50LnN0eWxlX2JhciwgYmFyKTsgfSk7XG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvbmVudC5wcm9ncmVzczsgfSwgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICBjb21wb25lbnQuc3R5bGVfYmFyLnNldChcIndpZHRoXCIsIChNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIHByb2dyZXNzICogMTAwKSkgfHwgMCkgKyBcIiVcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnQudG9vbHRpcFRleHQ7IH0sIGZ1bmN0aW9uICh0b29sdGlwKSB7XG4gICAgICAgICAgICBpZiAodG9vbHRpcCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQudGl0bGUgPSB0b29sdGlwO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihQcm9ncmVzc0JhcilcbiAgICBdLCBSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufShDb250cm9sUmVuZGVyZXIpKTtcbmV4cG9ydCB7IFJlbmRlcmVyIH07XG4vLyBBZGQgc3R5bGUgb3ZlcnJpZGUgYW5kIGFwcGx5IHN0eWxlIHNoZWV0XG5Qcm9ncmVzc0Jhci5hZGRTdHlsZU92ZXJyaWRlKFN0eWxlLndpdGhDbGFzcyhDU1NfQ0xBU1MpKTtcbkRPTS5TdHlsZXMuZGVmaW5lKFwiVUktQ29udHJvbCBcIiArIENTU19DTEFTUywge1xuICAgIFwiLn5+XCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZjJmMmYyXCIsXG4gICAgICAgIGhlaWdodDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBET00uU3R5bGVzLnNpemUudGV4dDsgfSksXG4gICAgICAgIGJveFNoYWRvdzogXCJpbnNldCAwIDFweCAzcHggcmdiYSgwLDAsMCwuMilcIlxuICAgIH0sXG4gICAgXCIufl9iYXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIGZsb2F0OiBcImxlZnRcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJyZ2JhKDAsMCwwLC41KVwiLFxuICAgICAgICBtYXJnaW46IFwiMFwiLFxuICAgICAgICB0cmFuc2l0aW9uOiBcIndpZHRoIDI1MG1zIGVhc2VcIlxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0NvbnRyb2xzL1Byb2dyZXNzQmFyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgeyBTcGFjZXIsIG1hcENvbXBvbmVudFJlbmRlcmVyIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0IHsgUmVuZGVyZXIgYXMgQ29udHJvbFJlbmRlcmVyIH0gZnJvbSBcIi4vQ29udHJvbEVsZW1lbnRcIjtcbi8qKiBAaW50ZXJuYWwgRE9NLXNwZWNpZmljIGNvbXBvbmVudCByZW5kZXJlciAqL1xudmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgLyoqIEluc3RhbnRpYXRlIHRoZSByZW5kZXJlciBmb3IgZ2l2ZW4gY29tcG9uZW50ICovXG4gICAgZnVuY3Rpb24gUmVuZGVyZXIoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcbiAgICAgICAgLy8gc2V0IGVsZW1lbnQgY29udGVudCB0byBhIHNpbmdsZSB6ZXJvLXdpZHRoIHNwYWNlIGNoYXJhY3RlclxuICAgICAgICBfdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IFwiJiM4MjAzO1wiO1xuICAgICAgICAvLyB3YXRjaCBoZWlnaHQgYW5kIGFkanVzdCBsaW5lLWhlaWdodCBhbG9uZyB3aXRoIGl0XG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvbmVudC5oZWlnaHQ7IH0sIGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZS5zZXQoeyBsaW5lSGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlbmRlcmVyID0gX19kZWNvcmF0ZShbXG4gICAgICAgIG1hcENvbXBvbmVudFJlbmRlcmVyKFNwYWNlcilcbiAgICBdLCBSZW5kZXJlcik7XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufShDb250cm9sUmVuZGVyZXIpKTtcbmV4cG9ydCB7IFJlbmRlcmVyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvU3BhY2VyLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgeyBDaGVja2JveCwgU3R5bGUsIG1hcENvbXBvbmVudFJlbmRlcmVyIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0ICogYXMgRE9NIGZyb20gXCIuLi8uLi8uLi9ET01cIjtcbmltcG9ydCB7IFJlbmRlcmVyIGFzIENvbnRyb2xSZW5kZXJlciB9IGZyb20gXCIuLi9Db250cm9sRWxlbWVudFwiO1xuLyoqIEJhc2UgY2xhc3MgbmFtZSB1c2VkIGZvciBDU1Mgc3R5bGUgc2hlZXQgKi9cbnZhciBDU1NfQ0xBU1MgPSBcIlVJLUNoZWNrQm94XCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgcmVuZGVyZXIgZm9yIGdpdmVuIGNvbXBvbmVudCAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XG4gICAgICAgIC8vIGFkZCBsYWJlbCBhbmQgaW5wdXQgY2xhc3Nlc1xuICAgICAgICBjb21wb25lbnQuc3R5bGVfbGFiZWwuYWRkQ2xhc3MoXCJmb3JtLWNoZWNrLWxhYmVsXCIpO1xuICAgICAgICBjb21wb25lbnQuc3R5bGVfaW5wdXQuYWRkQ2xhc3MoXCJmb3JtLWNoZWNrLWlucHV0XCIpO1xuICAgICAgICAvLyBjcmVhdGUgbGFiZWwsIGlucHV0LCBhbmQgdGV4dCBlbGVtZW50c1xuICAgICAgICB2YXIgbGFiZWwgPSBfdGhpcy5sYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgICAgdmFyIGlucHV0ID0gX3RoaXMuaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIHZhciBzcGFuID0gX3RoaXMuc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICBfdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgbGFiZWwub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHNlbmQgZXZlbnQgdG8gdW5jaGVja2VkIHJhZGlvcyBhcyB3ZWxsXG4gICAgICAgICAgICB2YXIgcmFkaW9zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlucHV0W3R5cGU9XFxcInJhZGlvXFxcIl1bbmFtZT1cXFwiXCIgKyBjb21wb25lbnQubmFtZSArIFwiXFxcIl1cIik7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudHNcIik7XG4gICAgICAgICAgICBldnQuaW5pdEV2ZW50KFwiY2hhbmdlXCIsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSByYWRpb3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGlvID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW5wdXQub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IGNvbXBvbmVudC5jaGVja2VkID0gaW5wdXQuY2hlY2tlZDsgfTtcbiAgICAgICAgaW5wdXQub25ibHVyID0gZnVuY3Rpb24gKCkgeyBjb21wb25lbnQuY2hlY2tlZCA9IGlucHV0LmNoZWNrZWQ7IH07XG4gICAgICAgIC8vIGFkZCB3YXRjaGVycyBmb3IgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gRE9NLmFwcGx5U3R5bGVUbyhjb21wb25lbnQuc3R5bGVfbGFiZWwsIGxhYmVsKTsgfSk7XG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5hcHBseVN0eWxlVG8oY29tcG9uZW50LnN0eWxlX2lucHV0LCBpbnB1dCk7IH0pO1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBET00uYXBwbHlTdHlsZVRvKGNvbXBvbmVudC5zdHlsZV90ZXh0LCBzcGFuKTsgfSk7XG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvbmVudC5kaXNhYmxlZDsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW5wdXQuZGlzYWJsZWQgPSBjb21wb25lbnQuZGlzYWJsZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnQudHlwZTsgfSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLmlucHV0LnR5cGUgPSB0eXBlID8gXCJyYWRpb1wiIDogXCJjaGVja2JveFwiO1xuICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlLnJlbW92ZUNsYXNzKFwiY2hlY2tib3hcIikuYWRkQ2xhc3MoXCJyYWRpb1wiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc3R5bGUucmVtb3ZlQ2xhc3MoXCJyYWRpb1wiKS5hZGRDbGFzcyhcImNoZWNrYm94XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50LmNoZWNrZWQ7IH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmlucHV0LmNoZWNrZWQgPSAhIWNvbXBvbmVudC5jaGVja2VkO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGUgcmVuZGVyZWQgY29tcG9uZW50IG91dHB1dCAqL1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGdldCBvciBjcmVhdGUgdGhlIGN1cnJlbnQgb3V0cHV0IG9iamVjdFxuICAgICAgICB2YXIgb3V0ID0gX3N1cGVyLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgb3V0LmxpdmVFbGVtZW50ID0gdGhpcy5pbnB1dDtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAvLyBzZXQgcHJvcGVydGllc1xuICAgICAgICB0aGlzLmxhYmVsLmFwcGVuZENoaWxkKHRoaXMuaW5wdXQpO1xuICAgICAgICB0aGlzLmlucHV0LnZhbHVlID0gY29tcG9uZW50LnZhbHVlO1xuICAgICAgICB0aGlzLmlucHV0Lm5hbWUgPSBjb21wb25lbnQubmFtZTtcbiAgICAgICAgLy8gcmVuZGVyIHRleHQgaW50byBET00gZWxlbWVudFxuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuc3Bhbi50ZXh0Q29udGVudCA9IGNvbXBvbmVudC5sYWJlbDtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICAvLyBtb3ZlIGlucHV0IGluc2lkZSBvZiBzcGFuLCBhbG9uZyB3aXRoIHplcm8td2lkdGggc3BhY2VcbiAgICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSB0aGUgbGFiZWwgaGFzIHRoZSBoZWlnaHQgb2YgMSBsaW5lIGF0IG1pbmltdW1cbiAgICAgICAgICAgIHRoaXMuc3Bhbi5pbm5lckhUTUwgPSBcIiYjODIwMztcIjtcbiAgICAgICAgICAgIHRoaXMuc3Bhbi5pbnNlcnRCZWZvcmUodGhpcy5pbnB1dCwgdGhpcy5zcGFuLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFiZWwuYXBwZW5kQ2hpbGQodGhpcy5zcGFuKTtcbiAgICAgICAgLy8gc2V0IHRvb2x0aXAgdGV4dFxuICAgICAgICBpZiAoY29tcG9uZW50LnRvb2x0aXBUZXh0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmxhYmVsLnRpdGxlID0gY29tcG9uZW50LnRvb2x0aXBUZXh0O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgbWFwQ29tcG9uZW50UmVuZGVyZXIoQ2hlY2tib3gpXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQ29udHJvbFJlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlIGFuZCBhcHBseSBzdHlsZSBzaGVldFxuQ2hlY2tib3guYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTKSk7XG5ET00uU3R5bGVzLmRlZmluZShcIlVJLUNvbnRyb2wgXCIgKyBDU1NfQ0xBU1MsIHtcbiAgICBcIi5+flwiOiB7fSxcbiAgICBcIi5+fiA+IGxhYmVsXCI6IHtcbiAgICAgICAgbWFyZ2luOiBcIjBcIixcbiAgICAgICAgcGFkZGluZ1RvcDogXCIwXCIsIHBhZGRpbmdCb3R0b206IFwiMFwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvSW5wdXRDb250cm9scy9DaGVja2JveC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0ICogYXMgQXN5bmMgZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9Bc3luY1wiO1xuaW1wb3J0IHsgU2VsZWN0RmllbGQsIFN0eWxlLCBtYXBDb21wb25lbnRSZW5kZXJlciB9IGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvVUlcIjtcbmltcG9ydCAqIGFzIERPTSBmcm9tIFwiLi4vLi4vLi4vRE9NXCI7XG5pbXBvcnQgeyBSZW5kZXJlciBhcyBDb250cm9sUmVuZGVyZXIgfSBmcm9tIFwiLi4vQ29udHJvbEVsZW1lbnRcIjtcbi8qKiBCYXNlIGNsYXNzIG5hbWUgdXNlZCBmb3IgQ1NTIHN0eWxlIHNoZWV0ICovXG52YXIgQ1NTX0NMQVNTID0gXCJVSS1TZWxlY3RGaWVsZFwiO1xuLyoqIEBpbnRlcm5hbCBET00tc3BlY2lmaWMgY29tcG9uZW50IHJlbmRlcmVyICovXG52YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZW5kZXJlciwgX3N1cGVyKTtcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHJlbmRlcmVyIGZvciBnaXZlbiBjb21wb25lbnQgKi9cbiAgICBmdW5jdGlvbiBSZW5kZXJlcihjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xuICAgICAgICAvLyBhZGQgbGFiZWwgYW5kIGlucHV0IGNsYXNzZXNcbiAgICAgICAgY29tcG9uZW50LnN0eWxlX2xhYmVsLmFkZENsYXNzKFwiZm9ybS1jb250cm9sLWxhYmVsXCIsIFwiY29udHJvbC1sYWJlbFwiKTtcbiAgICAgICAgY29tcG9uZW50LnN0eWxlX2lucHV0LmFkZENsYXNzKFwiZm9ybS1jb250cm9sXCIpO1xuICAgICAgICAvLyBjcmVhdGUgbGFiZWwgYW5kIGlucHV0IGVsZW1lbnRzXG4gICAgICAgIHZhciBsYWJlbCA9IF90aGlzLmxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xuICAgICAgICB2YXIgc2VsZWN0ID0gX3RoaXMuc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICAgICAgbGFiZWwuaHRtbEZvciA9IHNlbGVjdC5pZCA9IGNvbXBvbmVudC51aWQgKyBcIl9zZWxlY3RcIjtcbiAgICAgICAgX3RoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIF90aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcbiAgICAgICAgc2VsZWN0Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkgeyBjb21wb25lbnQudmFsdWUgPSBzZWxlY3QudmFsdWU7IH07XG4gICAgICAgIHNlbGVjdC5vbmJsdXIgPSBmdW5jdGlvbiAoKSB7IGNvbXBvbmVudC52YWx1ZSA9IHNlbGVjdC52YWx1ZTsgfTtcbiAgICAgICAgLy8gYWRkIHdhdGNoZXJzIGZvciBjb21wb25lbnQgcHJvcGVydGllc1xuICAgICAgICB2YXIgdmFsdWVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5hcHBseVN0eWxlVG8oY29tcG9uZW50LnN0eWxlX2xhYmVsLCBsYWJlbCk7IH0pO1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBET00uYXBwbHlTdHlsZVRvKGNvbXBvbmVudC5zdHlsZV9pbnB1dCwgc2VsZWN0KTsgfSk7XG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvbmVudC5kaXNhYmxlZDsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2VsZWN0LmRpc2FibGVkID0gY29tcG9uZW50LmRpc2FibGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50LnZhbHVlOyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb21wb25lbnQudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IHNlbGVjdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHZhbHVlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICBvdXQubGl2ZUVsZW1lbnQgPSB0aGlzLnNlbGVjdDtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAvLyByZW1vdmUgYWxsIG9wdGlvbnMgYW5kIGFkZCBjdXJyZW50IG9wdGlvbnNcbiAgICAgICAgd2hpbGUgKHRoaXMuc2VsZWN0LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdC5yZW1vdmVDaGlsZCh0aGlzLnNlbGVjdC5maXJzdENoaWxkKTtcbiAgICAgICAgY29tcG9uZW50Lm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbkVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBvcHRpb25FbHQudGV4dENvbnRlbnQgPSBTdHJpbmcob3B0aW9uLnRleHQpO1xuICAgICAgICAgICAgICAgIG9wdGlvbkVsdC52YWx1ZSA9IG9wdGlvbi52YWx1ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9uLnZhbHVlIDogdGV4dDtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uRWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0Lm5hbWUgPSBjb21wb25lbnQubmFtZTtcbiAgICAgICAgLy8gc2hvdyBvciBoaWRlIGxhYmVsXG4gICAgICAgIHZhciBsYWJlbFRleHQgPSB0aGlzLmxhYmVsLnRleHRDb250ZW50ID0gY29tcG9uZW50LmxhYmVsO1xuICAgICAgICBBc3luYy51bm9ic2VydmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5zdHlsZV9sYWJlbC5oaWRlKCFsYWJlbFRleHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2V0IHRvb2x0aXAgdGV4dFxuICAgICAgICBpZiAoY29tcG9uZW50LnRvb2x0aXBUZXh0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmxhYmVsLnRpdGxlID0gY29tcG9uZW50LnRvb2x0aXBUZXh0O1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgUmVuZGVyZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgbWFwQ29tcG9uZW50UmVuZGVyZXIoU2VsZWN0RmllbGQpXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQ29udHJvbFJlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlIGFuZCBhcHBseSBzdHlsZSBzaGVldFxuU2VsZWN0RmllbGQuYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoQ1NTX0NMQVNTKSk7XG5ET00uU3R5bGVzLmRlZmluZShcIlVJLUNvbnRyb2wgXCIgKyBDU1NfQ0xBU1MsIHtcbiAgICBcIi5+flwiOiB7fSxcbiAgICBcIi5+fiA+IGxhYmVsXCI6IHtcbiAgICAgICAgZm9udDogXCJpbmhlcml0XCJcbiAgICB9LFxuICAgIFwiLn5+ID4gc2VsZWN0XCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiXG4gICAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9SZW5kZXJlcnMvQ29udHJvbHMvSW5wdXRDb250cm9scy9TZWxlY3RGaWVsZC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0ICogYXMgQXN5bmMgZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9Bc3luY1wiO1xuaW1wb3J0IHsgVGV4dEZpZWxkLCBTdHlsZSwgbWFwQ29tcG9uZW50UmVuZGVyZXIgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI7XG5pbXBvcnQgKiBhcyBET00gZnJvbSBcIi4uLy4uLy4uL0RPTVwiO1xuaW1wb3J0IHsgUmVuZGVyZXIgYXMgQ29udHJvbFJlbmRlcmVyIH0gZnJvbSBcIi4uL0NvbnRyb2xFbGVtZW50XCI7XG4vKiogQmFzZSBjbGFzcyBuYW1lIHVzZWQgZm9yIENTUyBzdHlsZSBzaGVldCAqL1xudmFyIENTU19DTEFTUyA9IFwiVUktVGV4dEZpZWxkXCI7XG4vKiogQGludGVybmFsIERPTS1zcGVjaWZpYyBjb21wb25lbnQgcmVuZGVyZXIgKi9cbnZhciBSZW5kZXJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlcmVyLCBfc3VwZXIpO1xuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgcmVuZGVyZXIgZm9yIGdpdmVuIGNvbXBvbmVudCAqL1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XG4gICAgICAgIC8vIGFkZCBsYWJlbCBhbmQgaW5wdXQgY2xhc3Nlc1xuICAgICAgICBjb21wb25lbnQuc3R5bGVfbGFiZWwuYWRkQ2xhc3MoXCJmb3JtLWNvbnRyb2wtbGFiZWxcIiwgXCJjb250cm9sLWxhYmVsXCIpO1xuICAgICAgICBjb21wb25lbnQuc3R5bGVfaW5wdXQuYWRkQ2xhc3MoXCJmb3JtLWNvbnRyb2xcIik7XG4gICAgICAgIC8vIGNyZWF0ZSBsYWJlbCBhbmQgaW5wdXQgZWxlbWVudHNcbiAgICAgICAgdmFyIGxhYmVsID0gX3RoaXMubGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgIHZhciBpbnB1dCA9IF90aGlzLmlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjb21wb25lbnQudGV4dGFyZWFMaW5lcyA+IDAgPyBcInRleHRhcmVhXCIgOiBcImlucHV0XCIpO1xuICAgICAgICBsYWJlbC5odG1sRm9yID0gaW5wdXQuaWQgPSBjb21wb25lbnQudWlkICsgXCJfaW5wdXRcIjtcbiAgICAgICAgX3RoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIF90aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICBpbnB1dC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHsgY29tcG9uZW50LnZhbHVlID0gaW5wdXQudmFsdWU7IH07XG4gICAgICAgIGlucHV0Lm9uYmx1ciA9IGZ1bmN0aW9uICgpIHsgY29tcG9uZW50LnZhbHVlID0gaW5wdXQudmFsdWU7IH07XG4gICAgICAgIGlucHV0Lm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmltbWVkaWF0ZVZhbHVlVXBkYXRlKVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGlucHV0LnZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBpbnB1dC5vbmtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDEzKVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGlucHV0LnZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBhZGQgd2F0Y2hlcnMgZm9yIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gICAgICAgIHZhciB2YWx1ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gRE9NLmFwcGx5U3R5bGVUbyhjb21wb25lbnQuc3R5bGVfbGFiZWwsIGxhYmVsKTsgfSk7XG4gICAgICAgIF90aGlzLndhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5hcHBseVN0eWxlVG8oY29tcG9uZW50LnN0eWxlX2lucHV0LCBpbnB1dCk7IH0pO1xuICAgICAgICBfdGhpcy53YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb25lbnQuZGlzYWJsZWQ7IH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmlucHV0LmRpc2FibGVkID0gY29tcG9uZW50LmRpc2FibGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMud2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50LnZhbHVlOyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb21wb25lbnQudmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gaW5wdXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHZhbHVlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBHZW5lcmF0ZSByZW5kZXJlZCBjb21wb25lbnQgb3V0cHV0ICovXG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBvdXRwdXQgb2JqZWN0XG4gICAgICAgIHZhciBvdXQgPSBfc3VwZXIucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICBvdXQubGl2ZUVsZW1lbnQgPSB0aGlzLmlucHV0O1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIC8vIHNldCBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuaW5wdXQubmFtZSA9IGNvbXBvbmVudC5uYW1lO1xuICAgICAgICB0aGlzLmlucHV0LnBsYWNlaG9sZGVyID0gY29tcG9uZW50LnBsYWNlaG9sZGVyVGV4dDtcbiAgICAgICAgaWYgKGNvbXBvbmVudC50ZXh0YXJlYUxpbmVzKSB7XG4gICAgICAgICAgICAvLyBzZXQgbnVtYmVyIG9mIHJvd3NcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucm93cyA9IGNvbXBvbmVudC50ZXh0YXJlYUxpbmVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2V0IHNwZWNpZmljIHRleHQgaW5wdXQgdHlwZVxuICAgICAgICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFRleHRGaWVsZC5UeXBlW2NvbXBvbmVudC50eXBlXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaG93IG9yIGhpZGUgbGFiZWxcbiAgICAgICAgdmFyIGxhYmVsVGV4dCA9IHRoaXMubGFiZWwudGV4dENvbnRlbnQgPSBjb21wb25lbnQubGFiZWw7XG4gICAgICAgIEFzeW5jLnVub2JzZXJ2ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29tcG9uZW50LnN0eWxlX2xhYmVsLmhpZGUoIWxhYmVsVGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzZXQgdG9vbHRpcCB0ZXh0XG4gICAgICAgIGlmIChjb21wb25lbnQudG9vbHRpcFRleHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMubGFiZWwudGl0bGUgPSBjb21wb25lbnQudG9vbHRpcFRleHQ7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBSZW5kZXJlciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBDb21wb25lbnRSZW5kZXJlcihUZXh0RmllbGQpXG4gICAgXSwgUmVuZGVyZXIpO1xuICAgIHJldHVybiBSZW5kZXJlcjtcbn0oQ29udHJvbFJlbmRlcmVyKSk7XG5leHBvcnQgeyBSZW5kZXJlciB9O1xuLy8gaW5qZWN0IHRleHQgc2VsZWN0aW9uIGZ1bmN0aW9uXG5Bc3luYy5pbmplY3QoVGV4dEZpZWxkLCB7XG4gICAgc2VsZWN0VGV4dDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLmdldExhc3RSZW5kZXJlZE91dHB1dCgpO1xuICAgICAgICBpZiAoIW91dCkge1xuICAgICAgICAgICAgLy8gc2VsZWN0IG9ubHkgd2hlbiByZW5kZXJlZFxuICAgICAgICAgICAgdGhpcy5SZW5kZXJlZC5jb25uZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlbGVjdFRleHQoc3RhcnQsIGVuZCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgdGhlIGlucHV0IGVsZW1lbnQgYW5kIGZvY3VzIGl0XG4gICAgICAgIHZhciBpbnB1dCA9IG91dC5saXZlRWxlbWVudDtcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBzZWxlY3QgYWxsIHRoZSB3YXkgdGhyb3VnaCB0byB0aGUgZW5kIGlmIGVuZCBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIGVuZCA9IGlucHV0LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyB1c2Ugd2hhdGV2ZXIgbWV0aG9kIGlzIGF2YWlsYWJsZSB0byBzZWxlY3QgdGV4dFxuICAgICAgICBpZiAoaW5wdXQuY3JlYXRlVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0LnNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuLy8gQWRkIHN0eWxlIG92ZXJyaWRlIGFuZCBhcHBseSBzdHlsZSBzaGVldFxuVGV4dEZpZWxkLmFkZFN0eWxlT3ZlcnJpZGUoU3R5bGUud2l0aENsYXNzKENTU19DTEFTUykpO1xuRE9NLlN0eWxlcy5kZWZpbmUoXCJVSS1Db250cm9sIFwiICsgQ1NTX0NMQVNTLCB7XG4gICAgXCIufn5cIjoge30sXG4gICAgXCIufn4gPiBpbnB1dFwiOiB7XG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIlxuICAgIH0sXG4gICAgXCIufn4gPiB0ZXh0YXJlYVwiOiB7XG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIlxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL0NvbnRyb2xzL0lucHV0Q29udHJvbHMvVGV4dEZpZWxkLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiLy8gY29udGFpbmVyczpcbmltcG9ydCBcIi4vQ29udGFpbmVycy9Db250YWluZXJcIjtcbmltcG9ydCBcIi4vQ29udGFpbmVycy9EaWFsb2dDb250YWluZXJcIjtcbmltcG9ydCBcIi4vQ29udGFpbmVycy9EcmF3ZXJDb250YWluZXJcIjtcbmltcG9ydCBcIi4vQ29udGFpbmVycy9MYXlvdXRDb250YWluZXJcIjtcbi8vIGJsb2NrczpcbmltcG9ydCBcIi4vQmxvY2tzL0Jsb2NrXCI7XG5pbXBvcnQgXCIuL0Jsb2Nrcy9DYXJkXCI7XG5pbXBvcnQgXCIuL0Jsb2Nrcy9Db250YWluZXJCbG9ja1wiO1xuaW1wb3J0IFwiLi9CbG9ja3MvRGl2aWRlclwiO1xuaW1wb3J0IFwiLi9CbG9ja3MvTGlzdFwiO1xuaW1wb3J0IFwiLi9CbG9ja3MvTmF2TGlzdFwiO1xuaW1wb3J0IFwiLi9CbG9ja3MvUm93XCI7XG5pbXBvcnQgXCIuL0Jsb2Nrcy9UYWJsZVwiO1xuaW1wb3J0IFwiLi9CbG9ja3MvVGFibGVSb3dcIjtcbi8vIGNvbnRyb2xzOlxuaW1wb3J0IFwiLi9Db250cm9scy9CbG9ja0NvbnRyb2xcIjtcbmltcG9ydCBcIi4vQ29udHJvbHMvQnV0dG9uXCI7XG5pbXBvcnQgXCIuL0NvbnRyb2xzL0J1dHRvbkdyb3VwXCI7XG5pbXBvcnQgXCIuL0NvbnRyb2xzL0NvbnRhaW5lckNvbnRyb2xcIjtcbmltcG9ydCBcIi4vQ29udHJvbHMvQ29udHJvbEVsZW1lbnRcIjtcbmltcG9ydCBcIi4vQ29udHJvbHMvQ29udHJvbFN0YWNrXCI7XG5pbXBvcnQgXCIuL0NvbnRyb2xzL0ljb25cIjtcbmltcG9ydCBcIi4vQ29udHJvbHMvSW1hZ2VcIjtcbmltcG9ydCBcIi4vQ29udHJvbHMvTGFiZWxcIjtcbmltcG9ydCBcIi4vQ29udHJvbHMvUHJvZ3Jlc3NCYXJcIjtcbmltcG9ydCBcIi4vQ29udHJvbHMvU3BhY2VyXCI7XG5pbXBvcnQgXCIuL0NvbnRyb2xzL0lucHV0Q29udHJvbHMvQ2hlY2tib3hcIjtcbmltcG9ydCBcIi4vQ29udHJvbHMvSW5wdXRDb250cm9scy9TZWxlY3RGaWVsZFwiO1xuaW1wb3J0IFwiLi9Db250cm9scy9JbnB1dENvbnRyb2xzL1RleHRGaWVsZFwiO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvUmVuZGVyZXJzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBQYWdlLCBTY3JlZW4sIE1lbnUsIFN0eWxlIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuaW1wb3J0ICogYXMgRE9NIGZyb20gXCIuL0RPTVwiO1xuaW1wb3J0IHsgRE9NQmxvY2sgfSBmcm9tIFwiLi9ET00vRE9NQmxvY2tcIjtcbmltcG9ydCB7IFJlbmRlcmVyIGFzIExhYmVsUmVuZGVyZXIgfSBmcm9tIFwiLi9SZW5kZXJlcnMvQ29udHJvbHMvTGFiZWxcIjtcbi8qKiBNb3VzZSBob3ZlciB0aW1lb3V0IGFmdGVyIHdoaWNoIHRvIHNob3cvaGlkZSBzdWIgbWVudSAqL1xudmFyIEhPVkVSX1RJTUVPVVQgPSAyMDA7XG4vKiogQ3VycmVudCBob3ZlciB0aW1lb3V0IElEICovXG52YXIgX2hvdmVyVGltZXI7XG4vKiogSXRlbSBoZWlnaHQsIGluIHBpeGVscywgb2Ygb25lIG1lbnUgaXRlbTsgdXNlZCBmb3IgY2FsY3VsYXRpbmcgd2hldGhlciB0aGUgbWVudSBmaXRzIG9uIHNjcmVlbiB2ZXJ0aWNhbGx5LCBiZWZvcmUgZGlzcGxheWluZyB0aGUgbWVudSBiZWxvdyBvciBhYm92ZSB0aGUgbW91c2UgY3Vyc29yIG9yIGNvbnRyb2wgZWxlbWVudCAqL1xudmFyIF9pdGVtSGVpZ2h0ID0gMjg7XG4vKiogRGlzcGxheSBhIG1vZGFsIGNvbnRleHQgbWVudSAqL1xuTWVudS5kaXNwbGF5Q29udGV4dE1lbnUgPSBmdW5jdGlvbiAob3B0aW9ucywgZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IERPTU1lbnVDb21wb25lbnQob3B0aW9ucykuZGlzcGxheShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbn07XG4vKiogRGlzcGxheSBhIG1vZGFsIGRyb3Bkb3duIG1lbnUgKi9cbk1lbnUuZGlzcGxheURyb3Bkb3duID0gZnVuY3Rpb24gKG9wdGlvbnMsIHJlZikge1xuICAgIHZhciBvdXQgPSByZWYuZ2V0TGFzdFJlbmRlcmVkT3V0cHV0KCk7XG4gICAgaWYgKG91dCAmJiBvdXQuZWxlbWVudCkge1xuICAgICAgICB2YXIgciA9IG91dC5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gbmV3IERPTU1lbnVDb21wb25lbnQob3B0aW9ucylcbiAgICAgICAgICAgIC5kaXNwbGF5KHIucmlnaHQsIHIuYm90dG9tLCB0cnVlLCByLmJvdHRvbSAtIHIudG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jLlByb21pc2UucmVqZWN0KG5ldyBFcnJvcigpKTtcbn07XG4vKiogUmVtb3ZlIGN1cnJlbnQgbWVudSAqL1xuTWVudS5kaXNtaXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYWdlID0gUGFnZS5nZXRDdXJyZW50UGFnZSgpO1xuICAgIHBhZ2UgJiYgcGFnZS5nZXRDb21wb25lbnRzQnlUeXBlKERPTU1lbnVDb21wb25lbnQpXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBTY3JlZW4ucmVtb3ZlKGMpOyB9KTtcbn07XG4vKiogQ29tcG9uZW50IHRoYXQgY29udGFpbnMgYSBtZW51IERPTSBlbGVtZW50ICovXG52YXIgRE9NTWVudUNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERPTU1lbnVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBET00gZHJvcGRvd24gbWVudSAqL1xuICAgIGZ1bmN0aW9uIERPTU1lbnVDb21wb25lbnQob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLy8gY3JlYXRlIFVMIG5vZGVcbiAgICAgICAgdmFyIG1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgIG1lbnUuc3R5bGUuY3NzRmxvYXQgPSBcIm5vbmVcIjtcbiAgICAgICAgbWVudS5zdHlsZS5wb3NpdGlvbiA9IFwic3RhdGljXCI7XG4gICAgICAgIG1lbnUuc3R5bGUuYm94U2hhZG93ID0gXCJub25lXCI7XG4gICAgICAgIG1lbnUuc3R5bGUubWFyZ2luID0gXCIwXCI7XG4gICAgICAgIG1lbnUuY2xhc3NOYW1lID0gXCJkcm9wZG93bi1tZW51IHNob3dcIjsgLy8gdjNcbiAgICAgICAgX3RoaXMuX21lbnUgPSBtZW51O1xuICAgICAgICBfdGhpcy5ub2Rlcy5wdXNoKG1lbnUpO1xuICAgICAgICAvLyBzZXQgZGlzcGxheSBvcHRpb25zXG4gICAgICAgIF90aGlzLmRpc3BsYXlPcHRpb25zID0ge1xuICAgICAgICAgICAgbW9kYWw6IHRydWUsXG4gICAgICAgICAgICBvbkVzYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIG9uRXNjOiByZWplY3QgcHJvbWlzZSBhbmQgcmVtb3ZlIG1lbnVcbiAgICAgICAgICAgICAgICBTY3JlZW4ucmVtb3ZlKF90aGlzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVqZWN0b3IobmV3IEVycm9yKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBhZGQgbW91c2VvdXQgaGFuZGxlciB0byBzdG9wIHN1YiBtZW51cyBmcm9tIHNob3dpbmdcbiAgICAgICAgbWVudS5vbm1vdXNlb3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX2hvdmVyVGltZXIpXG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChfaG92ZXJUaW1lcik7XG4gICAgICAgICAgICBfaG92ZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IG1lbnUgJiYgIV90aGlzLl9zdWJNZW51U2hvd24pIHtcbiAgICAgICAgICAgICAgICBfaG92ZXJUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NsZWFyU3ViTWVudXMoKTtcbiAgICAgICAgICAgICAgICAgICAgX2hvdmVyVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSwgSE9WRVJfVElNRU9VVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIERpc3BsYXkgdGhpcyBtZW51IGF0IHRoZSBnaXZlbiBsb2NhdGlvbiBvbiBzY3JlZW4sIGVpdGhlciBiZWxvdyBvciBhYm92ZTsgdmVydC9ob3J6IHB1c2ggZGVmaW5lIHRoZSBhbW91bnQgdG8gZGlzcGxhY2UgdGhlIG1lbnUgaWYgc2hvd2luZyBvbiB0b3AvbGVmdDsgYXBwZW5kZWQgYXMgY2hpbGQgb2YgZ2l2ZW4gRE9NIG5vZGUsIG9yIGRpc3BsYXllZCBvbiBzY3JlZW4gaW4gaXRzIG93biBsYXllciAqL1xuICAgIERPTU1lbnVDb21wb25lbnQucHJvdG90eXBlLmRpc3BsYXkgPSBmdW5jdGlvbiAoeCwgeSwgZm9yY2UsIHZlcnRQdXNoLCBob3JpelB1c2gsIHBhcmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9pc0Jhc2UgPSAhcGFyZW50O1xuICAgICAgICB3aGlsZSAodGhpcy5fbWVudS5maXJzdENoaWxkKVxuICAgICAgICAgICAgdGhpcy5fbWVudS5yZW1vdmVDaGlsZCh0aGlzLl9tZW51LmZpcnN0Q2hpbGQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFzeW5jLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIF90aGlzLl9yZWplY3RvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNldCBwb3NpdGlvbiBhcm91bmQgZ2l2ZW4geCwgeSArIGRpc3BsYWNlbWVudCBjb29yZGluYXRlc1xuICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbih4LCB5LCBmb3JjZSwgdmVydFB1c2gsIGhvcml6UHVzaCk7XG4gICAgICAgIC8vIGFkZCBvcHRpb25zIGZyb20gYXJyYXlcbiAgICAgICAgdmFyIGhhc0ljb24gPSB0aGlzLm9wdGlvbnMuc29tZShmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBvcHRpb24gJiYgISFvcHRpb24uaWNvbjsgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24sIGkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBsaXN0IGl0ZW0gZWxlbWVudCB3aXRoIGRpdmlkZXIgb3Igb3B0aW9uIGxpbmtcbiAgICAgICAgICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgICAgICAgIF90aGlzLl9tZW51LmFwcGVuZENoaWxkKGxpKTtcbiAgICAgICAgICAgIGlmIChvcHRpb24uZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgbGkuY2xhc3NOYW1lID0gXCJkaXNhYmxlZFwiO1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5kaXZpZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgZGl2aWRlclxuICAgICAgICAgICAgICAgIGxpLmNsYXNzTmFtZSA9IFwiZGl2aWRlciBkcm9wZG93bi1kaXZpZGVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0IG9wdGlvbiwgYWRkIGNsaWNrIGhhbmRsZXJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgICAgIGEuY2xhc3NOYW1lID0gXCJkcm9wZG93bi1pdGVtXCI7XG4gICAgICAgICAgICAgICAgYS5ocmVmID0gXCIjXCI7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBhLmNsYXNzTmFtZSArPSBcIiBkaXNhYmxlZFwiO1xuICAgICAgICAgICAgICAgICAgICBhLnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgICAgICAgICBhLm9uY2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGEudGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBhLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbi5zdWJNZW51KVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZExpbmtDbGlja0hhbmRsZXIoYSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9hZGRMaW5rSG92ZXJIYW5kbGVyKGEsIGkpO1xuICAgICAgICAgICAgICAgIGxpLmFwcGVuZENoaWxkKGEpO1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlciB0ZXh0IGludG8gbGlua1xuICAgICAgICAgICAgICAgIHZhciBpdyA9IGhhc0ljb24gPyAxLjUgOiAwO1xuICAgICAgICAgICAgICAgIExhYmVsUmVuZGVyZXIucmVuZGVySW50byhhLCBvcHRpb24uaWNvbiwgaXcsIG9wdGlvbi5sYWJlbCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0ljb24pXG4gICAgICAgICAgICAgICAgICAgIGEuc3R5bGUucGFkZGluZ0xlZnQgPSBcIi41cmVtXCI7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIGZhciBzaWRlIGljb25cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNpZGVJY29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgICAgICAgIHIuY2xhc3NOYW1lID0gXCJiaWRpX2Zsb2F0RW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIExhYmVsUmVuZGVyZXIucmVuZGVySW50byhyLCBvcHRpb24uc2lkZUljb24pO1xuICAgICAgICAgICAgICAgICAgICBhLmFwcGVuZENoaWxkKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHVwZGF0ZSBlbGVtZW50IGhlaWdodCBlc3RpbWF0ZSBhZnRlciBkaXNwbGF5XG4gICAgICAgIHRoaXMuUmVuZGVyZWQuY29ubmVjdE9uY2UoZnVuY3Rpb24gKG91dCkge1xuICAgICAgICAgICAgQXN5bmMuc2xlZXAoMzApLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbHQgPSBvdXQuZWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoZWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZWx0LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaVwiKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgbGkub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4ICYmIF9pdGVtSGVpZ2h0ICE9PSBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVtSGVpZ2h0ID0gbWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldFBvc2l0aW9uKHgsIHksIGZvcmNlLCB2ZXJ0UHVzaCwgaG9yaXpQdXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIG1lbnUgYXMgYSBjaGlsZCBvciBkaXNwbGF5IGFzIG5ldyBtb2RhbCBsYXllclxuICAgICAgICB2YXIgb3V0ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgb3V0KVxuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG91dC5lbGVtZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgU2NyZWVuLmRpc3BsYXlBc3luYyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIERPTU1lbnVDb21wb25lbnQucHJvdG90eXBlLl9zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCBmb3JjZUxlZnQsIHZlcnRQdXNoLCBob3JpelB1c2gpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gcG9zaXRpb24gbWVudSBvbiBsZWZ0IG9yIHJpZ2h0IG9mIGdpdmVuIGNvb3JkaW5hdGVzXG4gICAgICAgIGlmICh4ICsgMjAwIDwgd2luZG93LmlubmVyV2lkdGggJiYgKCFmb3JjZUxlZnQgfHwgeCA8IDIwMCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUuc2V0KHsgbGVmdDogeCArIFwicHhcIiwgcmlnaHQ6IFwiYXV0b1wiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gKHdpbmRvdy5pbm5lcldpZHRoIC0geCArIChob3JpelB1c2ggfHwgMCkpICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQoeyBsZWZ0OiBcImF1dG9cIiwgcmlnaHQ6IHJpZ2h0IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBvc2l0aW9uIG1lbnUgb24gdG9wIG9yIGJvdHRvbSBvZiBnaXZlbiBjb29yZGluYXRlc1xuICAgICAgICBpZiAoeSArIHRoaXMub3B0aW9ucy5sZW5ndGggKiBfaXRlbUhlaWdodCArIDEwIDwgd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNldCh7IHRvcDogeSArIFwicHhcIiwgYm90dG9tOiBcImF1dG9cIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSAod2luZG93LmlubmVySGVpZ2h0IC0geSArICh2ZXJ0UHVzaCB8fCAwKSkgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNldCh7IHRvcDogXCJhdXRvXCIsIGJvdHRvbTogYm90dG9tIH0pO1xuICAgICAgICAgICAgdmFyIGNoZWNrVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHB1c2hlZCBhYm92ZSB3aW5kb3cgdG9wLCBtb3ZlIHRvIHZlcnkgdG9wXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9tZW51Lm9mZnNldFRvcCA8IDApXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlLnNldCh7IHRvcDogXCIwXCIsIGJvdHRvbTogXCJhdXRvXCIgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2tUb3AsIDEwKTtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNoZWNrVG9wLCA1MCk7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjaGVja1RvcCwgMTAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRE9NTWVudUNvbXBvbmVudC5wcm90b3R5cGUuX2NsZWFyU3ViTWVudXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3N1Yk1lbnVTaG93biA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMuZ2V0TGFzdFJlbmRlcmVkT3V0cHV0KCk7XG4gICAgICAgIHZhciBlbHQgPSBvdXQgJiYgb3V0LmVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChlbHQgJiYgZWx0Lm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgZWx0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWx0Lm5leHRTaWJsaW5nKTtcbiAgICB9O1xuICAgIERPTU1lbnVDb21wb25lbnQucHJvdG90eXBlLl9hZGRMaW5rQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGVsdCwgaSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb25zW2ldO1xuICAgICAgICBlbHQub25jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNCYXNlKVxuICAgICAgICAgICAgICAgIFNjcmVlbi5yZW1vdmUoX3RoaXMpO1xuICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmVyKG9wdGlvbi5rZXkgfHwgKGkgKyAxKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBET01NZW51Q29tcG9uZW50LnByb3RvdHlwZS5fYWRkTGlua0hvdmVySGFuZGxlciA9IGZ1bmN0aW9uIChlbHQsIGkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uc1tpXTtcbiAgICAgICAgZWx0Lm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY2xlYXIgdGltZXIgdG8gc2hvdy9oaWRlIChvdGhlcikgc3ViIG1lbnVcbiAgICAgICAgICAgIGlmIChfaG92ZXJUaW1lcikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoX2hvdmVyVGltZXIpO1xuICAgICAgICAgICAgICAgIF9ob3ZlclRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IHRpbWVyIHRvIHNob3cgY3VycmVudCBzdWIgbWVudSwgaWYgbm90IGFscmVhZHkgc2hvd25cbiAgICAgICAgICAgIGlmIChfdGhpcy5fc3ViTWVudVNob3duICE9PSBvcHRpb24pIHtcbiAgICAgICAgICAgICAgICBfaG92ZXJUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NsZWFyU3ViTWVudXMoKTtcbiAgICAgICAgICAgICAgICAgICAgX2hvdmVyVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9uLnN1Yk1lbnUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdWJNZW51U2hvd24gPSBvcHRpb247XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhbmQgZGlzcGxheSBzdWIgbWVudVxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGVsdC5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gX3RoaXMuZ2V0TGFzdFJlbmRlcmVkT3V0cHV0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gb3V0ICYmIG91dC5lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IERPTU1lbnVDb21wb25lbnQob3B0aW9uLnN1Yk1lbnUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGlzcGxheShyLnJpZ2h0IC0gNSwgci50b3AsIGZhbHNlLCAtX2l0ZW1IZWlnaHQsIHIucmlnaHQgLSByLmxlZnQgLSAxMCwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAoY2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzQmFzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTY3JlZW4ucmVtb3ZlKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hvaWNlID09IFwibnVtYmVyXCIgJiYgY2hvaWNlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlID0gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlIDw9IGNob2ljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSAqPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlID0gKGkgKyAxKSAqIGJhc2UgKyBjaG9pY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZXIoY2hvaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgSE9WRVJfVElNRU9VVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gRE9NTWVudUNvbXBvbmVudDtcbn0oRE9NQmxvY2spKTtcbi8vIEFkZCBzdHlsZSBvdmVycmlkZSBhbmQgYXBwbHkgc3R5bGUgc2hlZXRcbkRPTU1lbnVDb21wb25lbnQuYWRkU3R5bGVPdmVycmlkZShTdHlsZS53aXRoQ2xhc3MoXCJVSS1NZW51IGRyb3Bkb3duIG9wZW5cIilcbiAgICAuYWRkU2hhZG93RWZmZWN0KC43NSkpO1xuRE9NLlN0eWxlcy5kZWZpbmUoXCJVSS1CbG9jayBVSS1NZW51XCIsIHtcbiAgICBcIi5+flwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGZvbnRTaXplOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuc2l6ZS50ZXh0OyB9KSxcbiAgICAgICAgbGluZUhlaWdodDogXCJub3JtYWxcIlxuICAgIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvTWVudS5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXN5bmNcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50U2lnbmFsIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuLy8gbG9va3VwIHRhYmxlIGZvciBjdXN0b20gZXZlbnQgbmFtZXNcbnZhciBjdXN0b21FdmVudE5hbWVzID0ge1xuICAgIERvdWJsZUNsaWNrOiBcImRibGNsaWNrXCIsXG4gICAgUHJlc3M6IFwibW91c2Vkb3duXCIsXG4gICAgTW91c2VFbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgICBNb3VzZUxlYXZlOiBcIm1vdXNlb3V0XCIsXG4gICAgRm5LZXlQcmVzc2VkOiBcImtleWRvd25cIixcbiAgICBEcmFnU3RhcnQ6IFwidWlkcmFnc3RhcnRcIixcbiAgICBEcmFnRW50ZXI6IFwidWlkcmFnZW50ZXJcIixcbiAgICBEcmFnTGVhdmU6IFwidWlkcmFnbGVhdmVcIixcbiAgICBEcmFnRHJvcDogXCJ1aWRyYWdkcm9wXCIsXG4gICAgRm9jdXNHYWluZWQ6IFwidWljdXN0b21mb2N1c2luXCIsXG4gICAgQ2xpY2tlZDogXCJ1aWFzeW5jY2xpY2tcIixcbiAgICBEb3VibGVDbGlja2VkOiBcInVpYXN5bmNkYmxjbGlja1wiLFxuICAgIFByZXNzZWQ6IFwidWlhc3luY3ByZXNzXCIsXG4gICAgVmFsdWVDaGFuZ2U6IFwiY2hhbmdlXCIsXG4gICAgVmFsdWVJbnB1dDogXCJpbnB1dFwiXG59O1xuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIERPTSBldmVudCBuYW1lIGZvciBnaXZlbiBzaWduYWwgbmFtZSAqL1xuZnVuY3Rpb24gX2dldE5hbWUoc2lnbmFsTmFtZSkge1xuICAgIHJldHVybiBjdXN0b21FdmVudE5hbWVzW3NpZ25hbE5hbWVdIHx8IHNpZ25hbE5hbWUudG9Mb3dlckNhc2UoKTtcbn1cbi8qKiBDYWxsZWQgd2hlbiBhIGZpcnN0IGhhbmRsZXIgaXMgYWRkZWQgKG1peGluKSAqL1xuZnVuY3Rpb24gb25IYW5kbGVyQ29ubmVjdGVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gd2hlbiBjb25uZWN0ZWQ6IGFkZCBldmVudCBoYW5kbGVyIHdoZW4gZWxlbWVudCBpcyBrbm93blxuICAgIHRoaXMuY29tcG9uZW50LmdldFJlbmRlcmVkT3V0cHV0QXN5bmMoKS50aGVuKGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgdmFyIGFkZEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5kb21FdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdCA9IChfdGhpcy5pc0Nvbm5lY3RlZCgpIHx8IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFfdGhpcy5kb21FdmVudEZpbHRlciB8fCBfdGhpcy5kb21FdmVudEZpbHRlcihldmVudCkpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3VtZSB0aGUgZXZlbnQgaWYgbm90IGluIGNhcHR1cmUgbW9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnVzZUNhcHR1cmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1pdCBzaWduYWwgbm93IGFuZCB3YWl0IGZvciBoYW5kbGVycyB0byBiZSBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gKHVubGVzcyBmaWx0ZXIgZnVuY3Rpb24gcmV0dXJuZWQgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcyhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3luYy5ydW5ZaWVsZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAob3V0LmxpdmVFbGVtZW50IHx8IG91dC5lbGVtZW50KS5hZGRFdmVudExpc3RlbmVyKF90aGlzLmRvbUV2ZW50TmFtZSwgX3RoaXMuZG9tRXZlbnRIYW5kbGVyLCBfdGhpcy51c2VDYXB0dXJlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFfdGhpcy5kb21FdmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIGFkZCBoYW5kbGVyIG9ubHkgYWZ0ZXIgcmVuZGVyaW5nLCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgaWYgKG91dC51cGRhdGVkKVxuICAgICAgICAgICAgICAgIG91dC51cGRhdGVkLnRoZW4oYWRkSGFuZGxlcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKiogQ2FsbGVkIHdoZW4gYWxsIGhhbmRsZXJzIGhhdmUgYmVlbiBkaXNjb25uZWN0ZWQgKG1peGluKSAqL1xuZnVuY3Rpb24gb25IYW5kbGVyc0Rpc2Nvbm5lY3RlZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIHdoZW4gZGlzY29ubmVjdGVkOiByZW1vdmUgZXZlbnQgaGFuZGxlclxuICAgIHRoaXMuY29tcG9uZW50LmdldFJlbmRlcmVkT3V0cHV0QXN5bmMoKS50aGVuKGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgaWYgKF90aGlzLmRvbUV2ZW50SGFuZGxlciAmJiAhX3RoaXMuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIChvdXQubGl2ZUVsZW1lbnQgfHwgb3V0LmVsZW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoX3RoaXMuZG9tRXZlbnROYW1lLCBfdGhpcy5kb21FdmVudEhhbmRsZXIpO1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzLmRvbUV2ZW50SGFuZGxlcjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gaW5qZWN0IGEgbWV0aG9kIHRvIGNyZWF0ZSBET00gZXZlbnQgc2lnbmFscyBpbnRvIHRoZSBDb21wb25lbnQgY2xhc3NcbkFzeW5jLmluamVjdChDb21wb25lbnQsIHtcbiAgICBcIkBjcmVhdGVFdmVudFNpZ25hbFwiOiBmdW5jdGlvbiAoaWQsIHNpZ25hbENsYXNzLCBvcHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGRvbUV2ZW50RmlsdGVyO1xuICAgICAgICB2YXIgdXNlQ2FwdHVyZSA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJQcmVzc1wiOlxuICAgICAgICAgICAgY2FzZSBcIkNsaWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwiRG91YmxlQ2xpY2tcIjpcbiAgICAgICAgICAgIGNhc2UgXCJNb3VzZUNvbnRleHRNZW51XCI6XG4gICAgICAgICAgICAgICAgLy8gb25seSBlbWl0IGlmIHRoZSBlbGVtZW50IGlzIG5vdCBkaXNhYmxlZCAoZS5nLiBidXR0b24pXG4gICAgICAgICAgICAgICAgZG9tRXZlbnRGaWx0ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoZXZlbnQuY3VycmVudFRhcmdldC5kaXNhYmxlZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWZpbmVDb21wb25lbnRTaWduYWwoc2lnbmFsQ2xhc3MsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnROYW1lOiBfZ2V0TmFtZShpZCksIHVzZUNhcHR1cmU6IHVzZUNhcHR1cmUsIGRvbUV2ZW50RmlsdGVyOiBkb21FdmVudEZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgb25IYW5kbGVyQ29ubmVjdGVkOiBvbkhhbmRsZXJDb25uZWN0ZWQsIG9uSGFuZGxlcnNEaXNjb25uZWN0ZWQ6IG9uSGFuZGxlcnNEaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJQcmVzc2VkXCI6XG4gICAgICAgICAgICBjYXNlIFwiQ2xpY2tlZFwiOlxuICAgICAgICAgICAgY2FzZSBcIkRvdWJsZUNsaWNrZWRcIjpcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGVtaXQgaWYgdGhlIGVsZW1lbnQgaXMgbm90IGRpc2FibGVkIChlLmcuIGJ1dHRvbilcbiAgICAgICAgICAgICAgICBkb21FdmVudEZpbHRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIShldmVudC5jdXJyZW50VGFyZ2V0LmRpc2FibGVkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlZmluZUNvbXBvbmVudFNpZ25hbChzaWduYWxDbGFzcywgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBkb21FdmVudE5hbWU6IF9nZXROYW1lKGlkKSwgZG9tRXZlbnRGaWx0ZXI6IGRvbUV2ZW50RmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZXJDb25uZWN0ZWQ6IG9uSGFuZGxlckNvbm5lY3RlZCwgb25IYW5kbGVyc0Rpc2Nvbm5lY3RlZDogb25IYW5kbGVyc0Rpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk1vdXNlRW50ZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJNb3VzZUxlYXZlXCI6XG4gICAgICAgICAgICAgICAgLy8gb25seSBlbWl0IGlmIHRoZXJlIGlzIG5vIHNvdXJjZS9kZXN0aW5hdGlvbiB0YXJnZXQsIG9yXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNvdXJjZS9kZXN0aW5hdGlvbiB0YXJnZXQgaXMgdGhlIGN1cnJlbnQgZWxlbWVudCwgb3JcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc291cmNlL2Rlc3RpbmF0aW9uIGlzIG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIChpLmUuIGN1cnJlbnQgZWxlbWVudCBkb2VzIG5vdCBjb250YWluIHNvdXJjZS9kZXN0aW5hdGlvbilcbiAgICAgICAgICAgICAgICBkb21FdmVudEZpbHRlciA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gKCFldmVudC5yZWxhdGVkVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgICAgIC8vZXZlbnQucmVsYXRlZFRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAgICAgICAgICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ICE9PSBldmVudC5jdXJyZW50VGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGV2ZW50LnJlbGF0ZWRUYXJnZXQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZXZlbnQuY3VycmVudFRhcmdldCkgJiA4KSk7IH07XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVmaW5lQ29tcG9uZW50U2lnbmFsKHNpZ25hbENsYXNzLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50TmFtZTogX2dldE5hbWUoaWQpLFxuICAgICAgICAgICAgICAgICAgICBkb21FdmVudEZpbHRlcjogZG9tRXZlbnRGaWx0ZXIsIHVzZUNhcHR1cmU6IHVzZUNhcHR1cmUsXG4gICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlckNvbm5lY3RlZDogb25IYW5kbGVyQ29ubmVjdGVkLCBvbkhhbmRsZXJzRGlzY29ubmVjdGVkOiBvbkhhbmRsZXJzRGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRm5LZXlQcmVzc2VkXCI6XG4gICAgICAgICAgICAgICAgZG9tRXZlbnRGaWx0ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIChldmVudC5rZXlDb2RlID09IG9wdCB8fCB1bmRlZmluZWQpOyB9O1xuICAgICAgICAgICAgICAgIHVzZUNhcHR1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgXCJLZXlEb3duXCI6XG4gICAgICAgICAgICBjYXNlIFwiS2V5UHJlc3NcIjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWZpbmVDb21wb25lbnRTaWduYWwoc2lnbmFsQ2xhc3MsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnROYW1lOiBfZ2V0TmFtZShpZCksXG4gICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50RmlsdGVyOiBkb21FdmVudEZpbHRlciwgdXNlQ2FwdHVyZTogdXNlQ2FwdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgb25IYW5kbGVyQ29ubmVjdGVkOiBvbkhhbmRsZXJDb25uZWN0ZWQsIG9uSGFuZGxlcnNEaXNjb25uZWN0ZWQ6IG9uSGFuZGxlcnNEaXNjb25uZWN0ZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRm9jdXNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJCbHVyXCI6XG4gICAgICAgICAgICBjYXNlIFwiVmFsdWVDaGFuZ2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJWYWx1ZUlucHV0XCI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVmaW5lQ29tcG9uZW50U2lnbmFsKHNpZ25hbENsYXNzLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50TmFtZTogX2dldE5hbWUoaWQpLCB1c2VDYXB0dXJlOiB1c2VDYXB0dXJlLFxuICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZXJDb25uZWN0ZWQ6IG9uSGFuZGxlckNvbm5lY3RlZCwgb25IYW5kbGVyc0Rpc2Nvbm5lY3RlZDogb25IYW5kbGVyc0Rpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkZvY3VzR2FpbmVkXCI6XG4gICAgICAgICAgICAgICAgZG9tRXZlbnRGaWx0ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZG9tQXN5bmNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRvbUFzeW5jRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGEgcmUtZm9jdXMgbGlzdGVuZXIgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRFbHQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb25SZWZvY3VzQ2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKGVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBpZiBub3QgYmx1cnJlZCBhbmQgbm90IGZvY3VzZWQgc2VsZiBvciBjaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbHQgJiYgKGVsdCA9PT0gY29tcG9uZW50RWx0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihjb21wb25lbnRFbHQpICYgOCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgZW1pdCBGb2N1c0xvc3QgYW5kIHJlbW92ZSBsaXN0ZW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kb21Bc3luY0ZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuRm9jdXNMb3N0KF9sYXN0Qmx1ckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVtaXQgdGhlIEZvY3VzR2FpbmVkIHNpZ25hbCBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFscmVhZHkgZm9jdXNlZCwgZG8gbm90IGVtaXQgYnV0IGNvbnN1bWUgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlZmluZUNvbXBvbmVudFNpZ25hbChzaWduYWxDbGFzcywgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBkb21FdmVudE5hbWU6IF9nZXROYW1lKGlkKSwgZG9tRXZlbnRGaWx0ZXI6IGRvbUV2ZW50RmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZXJDb25uZWN0ZWQ6IG9uSGFuZGxlckNvbm5lY3RlZCwgb25IYW5kbGVyc0Rpc2Nvbm5lY3RlZDogb25IYW5kbGVyc0Rpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkZvY3VzTG9zdFwiOlxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBsaXN0ZW4gdG8gRE9NIGV2ZW50cyBhdCBhbGw7IHRoaXMgc2lnbmFsIGlzIGVtaXR0ZWRcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBjYWxsYmFjayBhZGRlZCB0byBvblJlZm9jdXNDYWxsYmFja3MgYnkgRm9jdXNHYWluZWRcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWZpbmVDb21wb25lbnRTaWduYWwoc2lnbmFsQ2xhc3MsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRyYWdFbnRlclwiOlxuICAgICAgICAgICAgY2FzZSBcIkRyYWdMZWF2ZVwiOlxuICAgICAgICAgICAgICAgIHVzZUNhcHR1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgXCJEcmFnU3RhcnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJEcmFnRHJvcFwiOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlZmluZUNvbXBvbmVudFNpZ25hbChzaWduYWxDbGFzcywgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBkb21FdmVudE5hbWU6IF9nZXROYW1lKGlkKSwgdXNlQ2FwdHVyZTogdXNlQ2FwdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgb25IYW5kbGVyQ29ubmVjdGVkOiBvbkhhbmRsZXJDb25uZWN0ZWQsIG9uSGFuZGxlcnNEaXNjb25uZWN0ZWQ6IG9uSGFuZGxlcnNEaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSk7XG4vKiogTGlzdCBvZiBjYWxsYmFja3MgdGhhdCBhcmUgY2FsbGVkIHdpdGggYSBuZXdseSBmb2N1c2VkIGVsZW1lbnQsIG9yIHVuZGVmaW5lZCBpZiBub25lOyB0byBkaXNwYXRjaCBhIG5vbi1idWJibGluZyBGb2N1c0xvc3QgZXZlbnQgaWYgdGhlIGZvY3VzIG1vdmVkIG91dHNpZGUgb2YgdGhlIG9yaWdpbmFsbHkgZm9jdXNlZCBjb21wb25lbnQ7IGNhbGxiYWNrcyByZXR1cm4gdHJ1ZSBpZiBmb2N1cyB3YXMgbm90IGxvc3QgKGNhbGxiYWNrIHN0YXlzIGluIHRoZSBsaXN0KSBvciBmYWxzZSBvdGhlcndpc2UgKi9cbnZhciBvblJlZm9jdXNDYWxsYmFja3MgPSBbXTtcbi8qKiBMYXN0IGJsdXIgZXZlbnQgdGhhdCBvY2N1cnJlZCwgd2FpdGluZyBmb3IgYW5vdGhlciBmb2N1cyBldmVudCBvciB0aW1lb3V0ICovXG52YXIgX2xhc3RCbHVyRXZlbnQ7XG4vKiogQ3VycmVudCB0aW1lciBJRCBmb3IgYmx1ciBldmVudCBsaXN0ZW5lciBjYWxsYmFjayAqL1xudmFyIF9ibHVyVGltZW91dDtcbi8vIGxpc3RlbiBmb3IgZm9jdXMvYmx1ciBldmVudHMgdG8gbWFuYWdlIEZvY3VzR2FpbmVkL0xvc3QgYmVoYXZpb3JcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBjaGVjayBpZiBibHVyIHRpbWVvdXQgaXMgYWN0aXZlICh3YWl0aW5nIGZvciByZS1mb2N1cylcbiAgICBpZiAoX2xhc3RCbHVyRXZlbnQpIHtcbiAgICAgICAgLy8gcGFzcyBuZXdseSBmb2N1c2VkIGVsZW1lbnQgdG8gbGlzdGVuZXJzLCBzdG9wIHdhaXRpbmdcbiAgICAgICAgb25SZWZvY3VzQ2FsbGJhY2tzID0gb25SZWZvY3VzQ2FsbGJhY2tzLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gZihldmVudC50YXJnZXQpOyB9KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF9ibHVyVGltZW91dCk7XG4gICAgICAgIF9sYXN0Qmx1ckV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBkaXNwYXRjaCBjdXN0b20gZXZlbnQgdG8gdHJpZ2dlciBGb2N1c0dhaW5lZCBvbiBuZXdseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAvLyAoYnViYmxlcyBzbyB0aGF0IGl0IGNhbiBiZSBjb25zdW1lZCBub3JtYWxseSBieSBjb25uZWN0aW5nIHRvIHNpZ25hbClcbiAgICB2YXIgY2FuY2VsZWQgPSAhZXZlbnQudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50TmFtZXNbXCJGb2N1c0dhaW5lZFwiXSwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0pKTtcbiAgICBpZiAoY2FuY2VsZWQpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59LCB0cnVlKTtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICghb25SZWZvY3VzQ2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIHNldCBhIHRpbWVvdXQgdG8gd2FpdCBmb3IgcG9zc2libGUgZm9jdXMgZXZlbnRzXG4gICAgX2JsdXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5vIHJlLWZvY3VzIG9jY3VycmVkLCBpbmZvcm0gYWxsIGxpc3RlbmVyc1xuICAgICAgICBvblJlZm9jdXNDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoZikgeyByZXR1cm4gZigpOyB9KTtcbiAgICAgICAgb25SZWZvY3VzQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgIF9sYXN0Qmx1ckV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIH0sIDApO1xuICAgIF9sYXN0Qmx1ckV2ZW50ID0gZXZlbnQ7XG59LCB0cnVlKTtcbi8vIGxpc3RlbiB0byBjbGljay9kYmxjbGljay9wcmVzcyBhbmQgZGlzcGF0Y2ggYXN5bmNocm9ub3VzIGV2ZW50c1xuZnVuY3Rpb24gYWRkQXN5bmNFdmVudChvcmlnRXZlbnQsIGFzeW5jRXZlbnQpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG9yaWdFdmVudCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvRGlzcGF0Y2ggPSBuZXcgQ3VzdG9tRXZlbnQoYXN5bmNFdmVudCwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgdG9EaXNwYXRjaC5idXR0b24gPSBldmVudC5idXR0b247XG4gICAgICAgICAgICB0b0Rpc3BhdGNoLmNsaWVudFggPSBldmVudC5jbGllbnRYO1xuICAgICAgICAgICAgdG9EaXNwYXRjaC5jbGllbnRZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgIHRvRGlzcGF0Y2guYWx0S2V5ID0gZXZlbnQuYWx0S2V5O1xuICAgICAgICAgICAgdG9EaXNwYXRjaC5jdHJsS2V5ID0gZXZlbnQuY3RybEtleTtcbiAgICAgICAgICAgIHRvRGlzcGF0Y2gubWV0YUtleSA9IGV2ZW50Lm1ldGFLZXk7XG4gICAgICAgICAgICB0b0Rpc3BhdGNoLnNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0b0Rpc3BhdGNoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSwgdHJ1ZSk7XG59XG5hZGRBc3luY0V2ZW50KFwiY2xpY2tcIiwgY3VzdG9tRXZlbnROYW1lc1tcIkNsaWNrZWRcIl0pO1xuYWRkQXN5bmNFdmVudChcImRibGNsaWNrXCIsIGN1c3RvbUV2ZW50TmFtZXNbXCJEYmxDbGlja2VkXCJdKTtcbmFkZEFzeW5jRXZlbnQoXCJtb3VzZWRvd25cIiwgY3VzdG9tRXZlbnROYW1lc1tcIlByZXNzZWRcIl0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvVUkvRXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZXhwb3J0ICogZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9VSVwiO1xuLy8gcGxhdGZvcm0gc3BlY2lmaWNzOlxuaW1wb3J0ICogYXMgRE9NIGZyb20gXCIuL0RPTVwiO1xuZXhwb3J0IHsgRE9NIH07XG5pbXBvcnQgXCIuL0RyYWdcIjtcbmltcG9ydCBcIi4vUGFnZVJlbmRlcmVyXCI7XG5pbXBvcnQgXCIuL1VwZGF0ZUNvbnRleHRcIjtcbmltcG9ydCBcIi4vUmVuZGVyZXJzXCI7XG5pbXBvcnQgXCIuL01lbnVcIjtcbmltcG9ydCBcIi4vRXZlbnRzXCI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImV4cG9ydCAqIGZyb20gXCIuL1VJL2luZGV4XCI7XG5pbXBvcnQgKiBhcyBVSSBmcm9tIFwiLi9VSS9pbmRleFwiO1xuZXhwb3J0IGRlZmF1bHQgVUk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvZG9tL2xpYi9VSS5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCIuLi8uLi9VSVwiO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHZhciBGUkFHX0lEX1BST1AgPSBcIkBfZnJhZ21lbnRfaWRcIjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB2YXIgRlJBR19IQVNIX1BSRUZJWCA9IFwiI2ZyYWc6XCI7XG47XG5leHBvcnQgZnVuY3Rpb24gaXNMYXlvdXRGcmFnbWVudChjb21wb25lbnQsIGxheW91dCkge1xuICAgIC8vIHRoZSBjb21wb25lbnQgbXVzdCBpbmNsdWRlIGEgZnJhZ21lbnQgSUQgcHJvcGVydHksIHdoaWNoIG11c3QgYWxzbyBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYnkgdGhlIHZpZXcgbGF5b3V0IGNsYXNzICh3aXRoIG1hdGNoaW5nIGNsYXNzIHJlZmVyZW5jZSlcbiAgICB2YXIgaWQgPSBjb21wb25lbnQgJiYgY29tcG9uZW50W0ZSQUdfSURfUFJPUF07XG4gICAgaWYgKGlkICYmIGxheW91dCkge1xuICAgICAgICByZXR1cm4gISFsYXlvdXRbRlJBR19IQVNIX1BSRUZJWCArIGlkXSAmJlxuICAgICAgICAgICAgKGNvbXBvbmVudCBpbnN0YW5jZW9mIGxheW91dFtGUkFHX0hBU0hfUFJFRklYICsgaWRdKTtcbiAgICB9XG4gICAgcmV0dXJuICEhaWQ7XG59XG4vKiogKlByb3BlcnR5IGRlY29yYXRvciosIGRlZmluZXMgdGhlIFVJIENvbXBvbmVudCBjbGFzcyAob3IgZmFjdG9yeSkgcmVmZXJlbmNlZCBieSB0aGUgZGVjb3JhdGVkIHN0YXRpYyBwcm9wZXJ0eSBhcyBhIGxheW91dCBmcmFnbWVudCwgZm9yIHVzZSB3aXRoIGxheW91dCB2aWV3cyAoaS5lLiBjbGFzc2VzIGRlZmluZWQgb24gYExheW91dGAgbmFtZXNwYWNlIGFuZCBkZXJpdmVkIGNsYXNzZXMpLCBzdWNoIHRoYXQgaW5zdGFuY2VzIG9mIHRoZSByZWZlcmVuY2VkIGNvbXBvbmVudCBjbGFzcyBhcmUgYWRkZWQgdG8gdGhlIGBmcmFnbWVudHNgIG9iamVjdCBvbiBsYXlvdXQgdmlldyBpbnN0YW5jZXMgW2RlY29yYXRvcl0gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXlvdXRGcmFnbWVudCh0YXJnZXQsIGlkKSB7XG4gICAgdmFyIGNvbXBvbmVudENsYXNzID0gdGFyZ2V0W2lkXTtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgIShjb21wb25lbnRDbGFzcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBDb21wb25lbnQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxheW91dCBmcmFnbWVudCBjb21wb25lbnQgY2xhc3MgZm9yIFwiICsgaWQpO1xuICAgIGlmIChjb21wb25lbnRDbGFzcy5wcm90b3R5cGVbRlJBR19JRF9QUk9QXSAmJlxuICAgICAgICBjb21wb25lbnRDbGFzcy5wcm90b3R5cGVbRlJBR19JRF9QUk9QXSAhPT0gaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXVzZSBmcmFnbWVudCBjb21wb25lbnQgY2xhc3MgXCIgK1xuICAgICAgICAgICAgY29tcG9uZW50Q2xhc3MucHJvdG90eXBlW0ZSQUdfSURfUFJPUF0gKyBcIiBhcyBcIiArIGlkKTtcbiAgICBjb21wb25lbnRDbGFzcy5wcm90b3R5cGVbRlJBR19JRF9QUk9QXSA9IGlkO1xuICAgIGNvbXBvbmVudENsYXNzLmlzRnJhZ21lbnRGYWN0b3J5ID0gdHJ1ZTtcbiAgICB0YXJnZXQucHJvdG90eXBlW0ZSQUdfSEFTSF9QUkVGSVggKyBpZF0gPSBjb21wb25lbnRDbGFzcztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9BcHAvVmlldy9WaWV3TGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBMYXlvdXRDb250YWluZXIsIERpYWxvZ0NvbnRhaW5lciwgQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gXCIuLi8uLi8uLi9VSVwiO1xuaW1wb3J0IHsgRlJBR19IQVNIX1BSRUZJWCwgRlJBR19JRF9QUk9QIH0gZnJvbSBcIi4uL1ZpZXdMYXlvdXRcIjtcbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBsYXlvdXQgdmlldyBpbnN0YW5jZXM6IGFkZCBhIGAuZnJhZ21lbnRzYCBvYmplY3Qgd2l0aCBvYnNlcnZhYmxlIHByb3BlcnRpZXMgZm9yIGFsbCBmcmFnbWVudHMgdGhhdCBoYXZlIGJlZW4gZGVjbGFyZWQgdXNpbmcgYEBsYXlvdXRGcmFnbWVudGAgKi9cbmZ1bmN0aW9uIF9pbml0TGF5b3V0KHRhcmdldCkge1xuICAgIHRhcmdldC5mcmFnbWVudHMgPSBuZXcgQXN5bmMuT2JzZXJ2YWJsZU9iamVjdCgpO1xuICAgIGZvciAodmFyIGlkIGluIHRhcmdldCkge1xuICAgICAgICBpZiAoaWRbMF0gPT09IFwiI1wiICYmIGlkLnNsaWNlKDAsIDYpID09PSBGUkFHX0hBU0hfUFJFRklYKVxuICAgICAgICAgICAgQXN5bmMubWFrZVByb3BlcnR5T2JzZXJ2YWJsZSh0YXJnZXQuZnJhZ21lbnRzLCBpZC5zbGljZSg2KSk7XG4gICAgfVxufVxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBpbXBsZW1lbnQgYC5hcHBlbmRDaGlsZGAgbWV0aG9kIG9uIGxheW91dCB2aWV3IGNsYXNzZXMgKi9cbmZ1bmN0aW9uIF9hcHBlbmRDaGlsZCh0YXJnZXQsIGNoaWxkLCByZWN1cnNlKSB7XG4gICAgaWYgKCFyZWN1cnNlICYmIGNoaWxkIGluc3RhbmNlb2YgQXN5bmMuT2JzZXJ2YWJsZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF9hcHBlbmRDaGlsZCh0YXJnZXQsIHYsIHRydWUpOyB9KTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIGZyYWdtZW50cyB3aXRoIGEgZnJhZ21lbnQgSURcbiAgICB2YXIgaWQgPSBjaGlsZCAmJiBjaGlsZFtGUkFHX0lEX1BST1BdO1xuICAgIGlmIChpZCkge1xuICAgICAgICAvLyBjaGVjayBpZiB0YXJnZXQgZGVmaW5lcyBzYW1lIElEIHdpdGggbWF0Y2hpbmcgY29tcG9uZW50IGNsYXNzXG4gICAgICAgIGlmICghdGFyZ2V0W0ZSQUdfSEFTSF9QUkVGSVggKyBpZF0gfHwgIShjaGlsZCBpbnN0YW5jZW9mIHRhcmdldFtGUkFHX0hBU0hfUFJFRklYICsgaWRdKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZnJhZ21lbnQgdHlwZSBmb3IgdGhpcyBsYXlvdXQ6IFwiICsgaWQpO1xuICAgICAgICB0YXJnZXQuZnJhZ21lbnRzW2lkXSA9IGNoaWxkO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGQ7XG59XG4vKiogUmVwcmVzZW50cyBhIGNvbnRhaW5lciBsYXlvdXQsIGNhbiBiZSBleHRlbmRlZCB0byBkZWZpbmUgY29udGFpbmVyLWJhc2VkIGxheW91dHMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgbGF5b3V0IGZyYWdtZW50cyAodXNpbmcgYGxheW91dEZyYWdtZW50YCBvbiBzdGF0aWMgcHJvcGVydGllcykgKi9cbnZhciBCYXNlTGF5b3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFzZUxheW91dCwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgbGF5b3V0IHZpZXcgKi9cbiAgICBmdW5jdGlvbiBCYXNlTGF5b3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfaW5pdExheW91dChfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEFkZCBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGlzIGNvbXBvbmVudCwgb3Igc3RvcmUgYSB2aWV3IGZyYWdtZW50IGluIHRoZSBgLmZyYWdtZW50c2Agb2JqZWN0OyByZXR1cm5zIHRoaXMgKi9cbiAgICBCYXNlTGF5b3V0LnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZCA9IF9hcHBlbmRDaGlsZCh0aGlzLCBjaGlsZCk7XG4gICAgICAgIGlmIChjaGlsZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5hcHBlbmRDaGlsZC5jYWxsKHRoaXMsIGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogU2V0IGdpdmVuIG9ic2VydmFibGUgcHJvcGVydHkgb2YgdGhpcyBjb21wb25lbnQgdG8gZ2l2ZW4gbmFtZWQgZnJhZ21lbnQgKG9ic2VydmVkIHByb3BlcnR5IG9mIGAuZnJhZ21lbnRzYCBvYmplY3QpLCB3aXRoIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIChydW4gaW5zaWRlIHRoZSBvYnNlcnZhYmxlIGNvbnRleHQsIGZvciBlLmcuIGNvbmRpdGlvbmFsIGFzc2lnbm1lbnQpICovXG4gICAgQmFzZUxheW91dC5wcm90b3R5cGUuYmluZEZyYWdtZW50ID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgZnJhZ21lbnROYW1lLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc09ic2VydmFibGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvcGVydHkgXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIiBpcyBub3Qgb2JzZXJ2YWJsZVwiKTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBfdGhpcy5mcmFnbWVudHNbZnJhZ21lbnROYW1lXTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0oZnJhZ21lbnQpIDogZnJhZ21lbnQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIER1bW15IHByb3BlcnR5IGZvciBkdWNrIHR5cGluZyBvZiBsYXlvdXQgY2xhc3NlcyAqL1xuICAgIEJhc2VMYXlvdXQuaXNMYXlvdXRDbGFzcyA9IHRydWU7XG4gICAgQmFzZUxheW91dCA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LmFwcGVuZENoaWxkQ29tcG9uZW50cyhDb21wb25lbnRGYWN0b3J5LkNMZXZlbC5CbG9jaywgdHJ1ZSlcbiAgICBdLCBCYXNlTGF5b3V0KTtcbiAgICByZXR1cm4gQmFzZUxheW91dDtcbn0oTGF5b3V0Q29udGFpbmVyKSk7XG5leHBvcnQgeyBCYXNlTGF5b3V0IH07XG4vKiogUmVwcmVzZW50cyBhIGRpYWxvZyBsYXlvdXQsIGNhbiBiZSBleHRlbmRlZCB0byBkZWZpbmUgZGlhbG9nIGNvbnRhaW5lci1iYXNlZCBsYXlvdXRzIGFuZCB0aGVpciBhc3NvY2lhdGVkIGxheW91dCBmcmFnbWVudHMgKHVzaW5nIGBsYXlvdXRGcmFnbWVudGAgb24gc3RhdGljIHByb3BlcnRpZXMpICovXG52YXIgQmFzZURpYWxvZ0xheW91dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VEaWFsb2dMYXlvdXQsIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGxheW91dCB2aWV3ICovXG4gICAgZnVuY3Rpb24gQmFzZURpYWxvZ0xheW91dCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX2luaXRMYXlvdXQoX3RoaXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBBZGQgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhpcyBjb21wb25lbnQsIG9yIHN0b3JlIGEgdmlldyBmcmFnbWVudCBpbiB0aGUgYC5mcmFnbWVudHNgIG9iamVjdDsgcmV0dXJucyB0aGlzICovXG4gICAgQmFzZURpYWxvZ0xheW91dC5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQgPSBfYXBwZW5kQ2hpbGQodGhpcywgY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuYXBwZW5kQ2hpbGQuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIFNldCBnaXZlbiBvYnNlcnZhYmxlIHByb3BlcnR5IG9mIHRoaXMgY29tcG9uZW50IHRvIGdpdmVuIG5hbWVkIGZyYWdtZW50IChvYnNlcnZlZCBwcm9wZXJ0eSBvZiBgLmZyYWdtZW50c2Agb2JqZWN0KSwgd2l0aCBvcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiAocnVuIGluc2lkZSB0aGUgb2JzZXJ2YWJsZSBjb250ZXh0LCBmb3IgZS5nLiBjb25kaXRpb25hbCBhc3NpZ25tZW50KSAqL1xuICAgIEJhc2VEaWFsb2dMYXlvdXQucHJvdG90eXBlLmJpbmRGcmFnbWVudCA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGZyYWdtZW50TmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5oYXNPYnNlcnZhYmxlUHJvcGVydHkocHJvcGVydHlOYW1lKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3BlcnR5IFwiICsgcHJvcGVydHlOYW1lICsgXCIgaXMgbm90IG9ic2VydmFibGVcIik7XG4gICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gX3RoaXMuZnJhZ21lbnRzW2ZyYWdtZW50TmFtZV07XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtID8gdHJhbnNmb3JtKGZyYWdtZW50KSA6IGZyYWdtZW50O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBEdW1teSBwcm9wZXJ0eSBmb3IgZHVjayB0eXBpbmcgb2YgbGF5b3V0IGNsYXNzZXMgKi9cbiAgICBCYXNlRGlhbG9nTGF5b3V0LmlzTGF5b3V0Q2xhc3MgPSB0cnVlO1xuICAgIEJhc2VEaWFsb2dMYXlvdXQgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5hcHBlbmRDaGlsZENvbXBvbmVudHMoQ29tcG9uZW50RmFjdG9yeS5DTGV2ZWwuQmxvY2ssIHRydWUpXG4gICAgXSwgQmFzZURpYWxvZ0xheW91dCk7XG4gICAgcmV0dXJuIEJhc2VEaWFsb2dMYXlvdXQ7XG59KERpYWxvZ0NvbnRhaW5lcikpO1xuZXhwb3J0IHsgQmFzZURpYWxvZ0xheW91dCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL0FwcC9WaWV3L0xheW91dC9CYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tIFwiLi4vLi4vLi4vVUlcIjtcbmltcG9ydCB7IGxheW91dEZyYWdtZW50IH0gZnJvbSBcIi4uL1ZpZXdMYXlvdXRcIjtcbmltcG9ydCB7IEJhc2VMYXlvdXQgfSBmcm9tIFwiLi9CYXNlXCI7XG4vKiogUmVwcmVzZW50cyBhIHN0cmljdGx5IHZlcnRpY2FsIGxheW91dCB0aGF0IGNvbnRhaW5zIGEgaGVhZGVyIGNvbnRhaW5lciBmcmFnbWVudCBhbmQgYSBmb290ZXIgY29udGFpbmVyIGZyYWdtZW50OyBhbGwgb3RoZXIgY29udGVudCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtYWluIGNvbnRlbnQgYXJlYSAqL1xudmFyIFZlcnRpY2FsTGF5b3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmVydGljYWxMYXlvdXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmVydGljYWxMYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqIExheW91dCBmcmFnbWVudCBmb3IgdGhlIGNvbnRhaW5lcidzIGZpeGVkIGhlYWRlciAqL1xuICAgIFZlcnRpY2FsTGF5b3V0LkhlYWRlciA9IENvbnRhaW5lci53aXRoKCk7XG4gICAgLyoqIExheW91dCBmcmFnbWVudCBmb3IgdGhlIGNvbnRhaW5lcidzIGZpeGVkIGZvb3RlciAqL1xuICAgIFZlcnRpY2FsTGF5b3V0LkZvb3RlciA9IENvbnRhaW5lci53aXRoKCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGxheW91dEZyYWdtZW50XG4gICAgXSwgVmVydGljYWxMYXlvdXQsIFwiSGVhZGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGxheW91dEZyYWdtZW50XG4gICAgXSwgVmVydGljYWxMYXlvdXQsIFwiRm9vdGVyXCIsIHZvaWQgMCk7XG4gICAgcmV0dXJuIFZlcnRpY2FsTGF5b3V0O1xufShCYXNlTGF5b3V0LndpdGgoZnVuY3Rpb24gKHNlbGYpIHtcbiAgICBzZWxmLmJpbmRGcmFnbWVudChcImhlYWRlclwiLCBcIkhlYWRlclwiKTtcbiAgICBzZWxmLmJpbmRGcmFnbWVudChcImZvb3RlclwiLCBcIkZvb3RlclwiKTtcbn0pKSk7XG5leHBvcnQgeyBWZXJ0aWNhbExheW91dCB9O1xuLyoqIFJlcHJlc2VudHMgYSBzdHJpY3RseSB2ZXJ0aWNhbCBsYXlvdXQgdGhhdCBjb250YWlucyBhIGhlYWRlciBjb250YWluZXIgZnJhZ21lbnQgYW5kIGEgZm9vdGVyIGNvbnRhaW5lciBmcmFnbWVudCwgYWxsIG90aGVyIGNvbnRlbnQgd2lsbCBiZSBhZGRlZCB0byB0aGUgX3Njcm9sbGFibGVfIG1haW4gY29udGVudCBjb250YWluZXIgKi9cbnZhciBTY3JvbGxhYmxlTGF5b3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2Nyb2xsYWJsZUxheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY3JvbGxhYmxlTGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTY3JvbGxhYmxlTGF5b3V0O1xufShWZXJ0aWNhbExheW91dC53aXRoKHtcbiAgICBzY3JvbGxhYmxlOiB0cnVlXG59KSkpO1xuZXhwb3J0IHsgU2Nyb2xsYWJsZUxheW91dCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL0FwcC9WaWV3L0xheW91dC9TaW5nbGUuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IFNjcmVlbiwgQ29udHJvbEVsZW1lbnQsIENvbnRhaW5lciwgUm93LCBEcmF3ZXJDb250YWluZXIsIENvbXBvbmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vLi4vLi4vVUlcIjtcbmltcG9ydCB7IGxheW91dEZyYWdtZW50IH0gZnJvbSBcIi4uL1ZpZXdMYXlvdXRcIjtcbmltcG9ydCB7IFZlcnRpY2FsTGF5b3V0LCBTY3JvbGxhYmxlTGF5b3V0IH0gZnJvbSBcIi4vU2luZ2xlXCI7XG4vKiogUmVwcmVzZW50cyB0aGUgdG9wIGhlYWRlciByb3cgb2YgYW4gYXBwbGljYXRpb24gcGFnZSwgY29udGFpbnMgb25seSBvbmUgUm93IGluc3RhbmNlOyBhbGwgY29udGVudCBwYXNzZWQgaW50byB0aGUgaW5pdGlhbGl6ZXIgaXMgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGlzIHJvdywgbm90IHRoZSBjb250YWluZXIgaXRzZWxmICovXG52YXIgQXBwQmFyTGF5b3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXBwQmFyTGF5b3V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFwcEJhckxheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBcHBCYXJMYXlvdXQucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIC8vIGZpbmQgKGZpcnN0KSBSb3cgaW5zdGFuY2UgYW5kIGFwcGVuZCB0aGVyZSBpZiBwb3NzaWJsZVxuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCAmJiAoY2hpbGQgaW5zdGFuY2VvZiBDb250cm9sRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmdldENvbXBvbmVudHNCeVR5cGUoUm93KVswXTtcbiAgICAgICAgICAgIGlmIChyb3cpXG4gICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFJvdykge1xuICAgICAgICAgICAgLy8gYWRkIHRoZSBSb3cgaXRzZWxmXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmFwcGVuZENoaWxkLmNhbGwodGhpcywgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXBwQmFyTGF5b3V0ID0gX19kZWNvcmF0ZShbXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkuYXBwZW5kQ2hpbGRDb21wb25lbnRzKENvbXBvbmVudEZhY3RvcnkuQ0xldmVsLkNvbnRyb2xFbGVtZW50LCB0cnVlKVxuICAgIF0sIEFwcEJhckxheW91dCk7XG4gICAgcmV0dXJuIEFwcEJhckxheW91dDtcbn0oQ29udGFpbmVyLndpdGgoUm93LndpdGgoeyBoZWlnaHQ6IFwiMTAwJVwiIH0pKSkpO1xuZXhwb3J0IHsgQXBwQmFyTGF5b3V0IH07XG4vKiogUmVwcmVzZW50cyBhIGZ1bGwtcGFnZSBhcHBsaWNhdGlvbiBsYXlvdXQgdGhhdCBjb250YWlucyBhIGhlYWRlciBhcHAgYmFyIGZyYWdtZW50IGFuZCBhIGZvb3RlciBjb250YWluZXIgZnJhZ21lbnQgKi9cbnZhciBBcHBWaWV3TGF5b3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXBwVmlld0xheW91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcHBWaWV3TGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKiBMYXlvdXQgZnJhZ21lbnQgZm9yIHRoZSBhcHBsaWNhdGlvbiBiYXIgYXQgdGhlIHRvcCBvZiB0aGUgc2NyZWVuLCBjb250YWlucyBvbmx5IG9uZSBSb3cgaW5zdGFuY2U7IGFsbCBjb250ZW50IHBhc3NlZCBpbnRvIHRoZSBpbml0aWFsaXplciBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoaXMgcm93LCBub3QgdGhlIGNvbnRhaW5lciBpdHNlbGYgKi9cbiAgICBBcHBWaWV3TGF5b3V0LkhlYWRlciA9IEFwcEJhckxheW91dC53aXRoKCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGxheW91dEZyYWdtZW50XG4gICAgXSwgQXBwVmlld0xheW91dCwgXCJIZWFkZXJcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQXBwVmlld0xheW91dDtcbn0oVmVydGljYWxMYXlvdXQpKTtcbmV4cG9ydCB7IEFwcFZpZXdMYXlvdXQgfTtcbi8qKiBSZXByZXNlbnRzIGEgZnVsbC1wYWdlIGFwcGxpY2F0aW9uIGxheW91dCB0aGF0IGNvbnRhaW5zIGEgaGVhZGVyIGFwcCBiYXIgZnJhZ21lbnQgYW5kIGEgZm9vdGVyIGNvbnRhaW5lciBmcmFnbWVudCwgYXMgd2VsbCBhcyBhIHNjcm9sbGFibGUgbmF2aWdhdGlvbiBzaWRlYmFyOyB0aGUgc2lkZWJhciBpcyBhdXRvbWF0aWNhbGx5IGNvbGxhcHNlZCB3aGlsZSBgLnNpZGViYXJDb2xsYXBzZWRgIGlzIHNldCAoZGVmYXVsdHMgdG8gdHJ1ZSBvbiBzbWFsbCBzY3JlZW5zLCBvYnNlcnZhYmxlKSBidXQgaXMgYWxzbyB3cmFwcGVkIGluIGEgZHJhd2VyIGNvbnRhaW5lciBpbiB0aGUgYC5kcmF3ZXJgIHByb3BlcnR5LCB3aGljaCBjYW4gYmUgb3BlbmVkIHVzaW5nIGl0cyBgb3BlbkFzeW5jKClgIG1ldGhvZCAoZS5nLiBmcm9tIGEgY2xpY2sgaGFuZGxlciBvbiBhIGJ1dHRvbiBhdmFpbGFibGUgaW4gdGhlIGAuQXBwQmFyYCBmcmFnbWVudCkgKi9cbnZhciBIdWJWaWV3TGF5b3V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSHViVmlld0xheW91dCwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgdmlldyBpbnN0YW5jZSBhbmQgaW5pdGlhbGl6ZSB0aGUgc2lkZWJhci9kcmF3ZXIgY29tYmluYXRpb24gKi9cbiAgICBmdW5jdGlvbiBIdWJWaWV3TGF5b3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBwcmVwYXJlIGEgZHJhd2VyIGZhY3RvcnkgaW4gYWR2YW5jZVxuICAgICAgICBfdGhpcy5fZHJhd2VySXNPcGVuID0gbmV3IEFzeW5jLk9ic2VydmFibGVWYWx1ZSgpO1xuICAgICAgICBfdGhpcy5kcmF3ZXIgPSBuZXcgKERyYXdlckNvbnRhaW5lci53aXRoKEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZnJhZ21lbnRzW1wiU2lkZWJhclwiXTsgfSkpKTtcbiAgICAgICAgX3RoaXMuZHJhd2VyLk9wZW5pbmcuY29ubmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgc2lkZWJhciB0byBhdm9pZCBjb21wb25lbnQgcmVkaXNwbGF5XG4gICAgICAgICAgICBfdGhpcy5pbnNpZGVHdXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfdGhpcy5fZHJhd2VySXNPcGVuLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmRyYXdlci5DbG9zZWQuY29ubmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBwdXQgc2lkZWJhciBiYWNrIGlmIChieSBub3cpIHN1cHBvc2VkIHRvXG4gICAgICAgICAgICBfdGhpcy5fZHJhd2VySXNPcGVuLnZhbHVlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhZGQgdGhlIChpbnNpZGUsIGkuZS4gbGVmdCBieSBkZWZhdWx0KSBzaWRlYmFyIGlmIG5vdCBvbiBhIHNtYWxsIHNjcmVlblxuICAgICAgICBfdGhpcy5iaW5kRnJhZ21lbnQoXCJpbnNpZGVHdXR0ZXJcIiwgXCJTaWRlYmFyXCIsIGZ1bmN0aW9uIChzaWRlYmFyKSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLnNpZGViYXJDb2xsYXBzZWQgfHwgX3RoaXMuX2RyYXdlcklzT3Blbi52YWx1ZSkgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6IHNpZGViYXI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIdWJWaWV3TGF5b3V0LnByb3RvdHlwZSwgXCJzaWRlYmFyQ29sbGFwc2VkXCIsIHtcbiAgICAgICAgLyoqIFRydWUgaWYgdGhlIHNpZGViYXIgc2hvdWxkIGJlIGhpZGRlbiwgbm9ybWFsbHkgb25seSBvbiBzbWFsbCBzY3JlZW5zIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBkZWZpbmluZyBhIGdldHRlciBmb3IgdGhpcyBwcm9wZXJ0eSAob2JzZXJ2ZWQsIHJlYWRvbmx5KSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNjcmVlbi5kaW1lbnNpb25zLmlzU21hbGw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBMYXlvdXQgZnJhZ21lbnQgZm9yIHNpZGViYXIgY29udGVudCAqL1xuICAgIEh1YlZpZXdMYXlvdXQuU2lkZWJhciA9IFNjcm9sbGFibGVMYXlvdXQud2l0aCh7IGhlaWdodDogXCIxMDAlXCIgfSk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVcbiAgICBdLCBIdWJWaWV3TGF5b3V0LnByb3RvdHlwZSwgXCJzaWRlYmFyQ29sbGFwc2VkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBsYXlvdXRGcmFnbWVudFxuICAgIF0sIEh1YlZpZXdMYXlvdXQsIFwiU2lkZWJhclwiLCB2b2lkIDApO1xuICAgIHJldHVybiBIdWJWaWV3TGF5b3V0O1xufShBcHBWaWV3TGF5b3V0KSk7XG5leHBvcnQgeyBIdWJWaWV3TGF5b3V0IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXBwL1ZpZXcvTGF5b3V0L0FwcC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImV4cG9ydCAqIGZyb20gXCIuL0Jhc2VcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1NpbmdsZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQXBwXCI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXBwL1ZpZXcvTGF5b3V0L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uL0FzeW5jXCI7XG52YXIgSU5TVEFOQ0VfUFJPVE9fUFJPUCA9IFwiQF9zZXJ2aWNlX2luc3RhbmNlXCI7XG52YXIgU0VSVklDRV9SRUdfSURfUFJFRklYID0gXCIrXCI7XG4vKiogU2VydmljZSBjbGFzc2VzIHJlZ2lzdGVyZWQgYnkgSUQsIGFuZCBvdGhlcnMgd2FpdGluZyB0byBiZSBtYXBwZWQgKi9cbnZhciByZWdpc3RyeSA9IG5ldyBBc3luYy5PYnNlcnZhYmxlT2JqZWN0KCk7XG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIGFkZCBhbiBJRCB0byB0aGUgcmVnaXN0cnkgKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyKHNlcnZpY2VJZCwgc2VydmljZUNsYXNzKSB7XG4gICAgdmFyIHByb3AgPSBTRVJWSUNFX1JFR19JRF9QUkVGSVggKyBzZXJ2aWNlSWQ7XG4gICAgaWYgKCFyZWdpc3RyeS5oYXNPYnNlcnZhYmxlUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgLy8gYWRkIGFuIG9ic2VydmFibGUgcHJvcGVydHkgZm9yIHRoaXMgc2VydmljZVxuICAgICAgICByZWdpc3RyeS5hZGRPYnNlcnZhYmxlUHJvcGVydHkocHJvcCwgc2VydmljZUNsYXNzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VydmljZUNsYXNzKSB7XG4gICAgICAgIC8vIChyZSlzZXQgdGhlIG9ic2VydmFibGUgcHJvcGVydHlcbiAgICAgICAgcmVnaXN0cnlbcHJvcF0gPSBzZXJ2aWNlQ2xhc3M7XG4gICAgfVxufVxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBpbmplY3QgYSBzZXJ2aWNlIGluc3RhbmNlICovXG5mdW5jdGlvbiBkb0luamVjdChjbGFzc09iaiwgcHJvcGVydHlJZCwgc2VydmljZUlkKSB7XG4gICAgLy8gbWFrZSBzdXJlIGEga2V5IGluIHRoZSByZWdpc3RyeSBleGlzdHNcbiAgICB2YXIgcHJvcCA9IFNFUlZJQ0VfUkVHX0lEX1BSRUZJWCArIHNlcnZpY2VJZDtcbiAgICBpZiAoIXJlZ2lzdHJ5Lmhhc09ic2VydmFibGVQcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAvLyBhZGQgYW4gb2JzZXJ2YWJsZSBwcm9wZXJ0eSBmb3IgdGhpcyBzZXJ2aWNlXG4gICAgICAgIHJlZ2lzdHJ5LmFkZE9ic2VydmFibGVQcm9wZXJ0eShwcm9wLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvLyBpbmplY3QgdGhlIG9ic2VydmFibGUgcmVmZXJlbmNlXG4gICAgQXN5bmMuaW5qZWN0KGNsYXNzT2JqLCAoX2EgPSB7fSxcbiAgICAgICAgX2FbcHJvcGVydHlJZF0gPSBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ2lzdHJ5W3Byb3BdOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2VydmljZUNsYXNzKSB7IHJldHVybiBzZXJ2aWNlQ2xhc3MgJiYgc2VydmljZUNsYXNzLmdldEluc3RhbmNlKCk7IH0pLFxuICAgICAgICBfYSkpO1xuICAgIHZhciBfYTtcbn1cbi8qKiBTZXJ2aWNlIGJhc2UgY2xhc3MsIHRvIGJlIGV4dGVuZGVkIHRvIHJlcHJlc2VudCBhIHNlcnZpY2Ugb2Ygd2hpY2ggYSBzaW5nbGV0b24gaW5zdGFuY2UgY2FuIGJlIGluamVjdGVkIGFzIGEgcHJvcGVydHkgb2YgYW55IG90aGVyIGNsYXNzIChlLmcuIGEgdmlldyBvciBhY3Rpdml0eSBjbGFzcywgb3IgYW5vdGhlciBzZXJ2aWNlKTsgc2VydmljZSBjbGFzc2VzIG11c3QgYmUgcmVnaXN0ZXJlZCBieSBJRCwgdXNpbmcgdGhlIGBtYXBTZXJ2aWNlYCBkZWNvcmF0b3IgKi9cbnZhciBTZXJ2aWNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VydmljZSwgX3N1cGVyKTtcbiAgICAvKiogU2luZ2xldG9uIGNvbnN0cnVjdG9yOyBkbyBub3QgdXNlIGRpcmVjdGx5LCB1c2UgYGdldEluc3RhbmNlYCBpbnN0ZWFkICovXG4gICAgZnVuY3Rpb24gU2VydmljZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIElOU1RBTkNFX1BST1RPX1BST1ApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VydmljZSBoYXMgYWxyZWFkeSBiZWVuIGNvbnN0cnVjdGVkXCIpO1xuICAgICAgICBfdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbSU5TVEFOQ0VfUFJPVE9fUFJPUF0gPSBfdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogR2V0IHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhpcyBzZXJ2aWNlIGNsYXNzLCBjYW4gYmUgb3ZlcnJpZGRlbjsgYnkgZGVmYXVsdCByZXR1cm5zIGEgc2luZ2xlIGluc3RhbmNlLCBjb25zdHJ1Y3RlZCB3aXRob3V0IHBhcmFtZXRlcnMgb25seSB3aGVuIG5lZWRlZCwgYW5kIG5ldmVyIGRlcmVmZXJlbmNlZCAqL1xuICAgIFNlcnZpY2UuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wcm90b3R5cGUsIElOU1RBTkNFX1BST1RPX1BST1ApKSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGNvbnN0cnVjdGVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGVbSU5TVEFOQ0VfUFJPVE9fUFJPUF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgPT09IFNlcnZpY2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcygpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZpY2U7XG59KEFzeW5jLk9ic2VydmFibGVPYmplY3QpKTtcbmV4cG9ydCB7IFNlcnZpY2UgfTtcbi8qKiAqQ2xhc3MgZGVjb3JhdG9yKiwgcmVnaXN0ZXJzIHRoZSBkZWNvcmF0ZWQgYFNlcnZpY2VgIGNsYXNzIHVzaW5nIGdpdmVuIFVwcGVyQ2FtZWxDYXNlIElEKHMpLCBzbyB0aGF0IGluamVjdGVkIHByb3BlcnRpZXMgKHNlZSBgaW5qZWN0U2VydmljZWApIGRlY29yYXRlZCB3aXRoIGEgbWF0Y2hpbmcgc2VydmljZSBJRCBhdXRvbWF0aWNhbGx5IGNvbnRhaW4gYSByZWZlcmVuY2UgdG8gYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGRlY29yYXRlZCBgU2VydmljZWAgW2RlY29yYXRvcl0gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBTZXJ2aWNlKCkge1xuICAgIHZhciBpZCA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGlkW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaWRfMSA9IGlkOyBfaSA8IGlkXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGlkXzFbX2ldO1xuICAgICAgICAgICAgcmVnaXN0ZXIocywgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKiogQWRkIGFuIGFsaWFzIGZvciB0aGUgZ2l2ZW4gc2VydmljZSBieSBJRCwgc28gdGhhdCB0aGUgYWxpYXNlZCBzZXJ2aWNlICphbHNvKiBiZWNvbWVzIGF2YWlsYWJsZSB1c2luZyB0aGUgZ2l2ZW4gYWxpYXM7IHRoZSBhbGlhc2VkIHNlcnZpY2UgZG9lcyBub3QgbmVlZCB0byBoYXZlIGJlZW4gbWFwcGVkIHlldCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNlcnZpY2VBbGlhcyhuZXdJZCwgc2VydmljZUlkKSB7XG4gICAgdmFyIHNlcnZpY2VSZWZQcm9wID0gU0VSVklDRV9SRUdfSURfUFJFRklYICsgc2VydmljZUlkO1xuICAgIGlmICghcmVnaXN0cnkuaGFzT2JzZXJ2YWJsZVByb3BlcnR5KHNlcnZpY2VSZWZQcm9wKSkge1xuICAgICAgICAvLyBhZGQgYW4gb2JzZXJ2YWJsZSBwcm9wZXJ0eSBmb3IgdGhpcyBzZXJ2aWNlXG4gICAgICAgIHJlZ2lzdHJ5LmFkZE9ic2VydmFibGVQcm9wZXJ0eShzZXJ2aWNlUmVmUHJvcCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIobmV3SWQsIEFzeW5jLm9ic2VydmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVnaXN0cnlbc2VydmljZVJlZlByb3BdOyB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0U2VydmljZShpZE9yVGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICBpZiAodHlwZW9mIGlkT3JUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYW4gaW5qZWN0YWJsZSBwcm9wZXJ0eSBmaXJzdFxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEFzeW5jLmluamVjdGFibGUodGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzYyk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgcmVzdWx0KTtcbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBzZXJ2aWNlIGlmIG5lZWRlZCwgYW5kIGNyZWF0ZSBhbiBvYnNlcnZhYmxlIHJlZmVyZW5jZVxuICAgICAgICAgICAgZG9JbmplY3QodGFyZ2V0LmNvbnN0cnVjdG9yLCBwcm9wZXJ0eUtleSwgaWRPclRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaWRPclRhcmdldCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0eXBlb2YgaWRPclRhcmdldC5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gY3JlYXRlIGFuIGluamVjdGFibGUgcHJvcGVydHkgZmlyc3RcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFzeW5jLmluamVjdGFibGUoaWRPclRhcmdldCwga2V5LCBkZXNjKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGlkT3JUYXJnZXQsIGtleSwgcmVzdWx0KTtcbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIHNlcnZpY2UgaWYgbmVlZGVkLCBhbmQgY3JlYXRlIGFuIG9ic2VydmFibGUgcmVmZXJlbmNlXG4gICAgICAgIHZhciBpZCA9IFN0cmluZyhrZXkpO1xuICAgICAgICBpZCA9IGlkWzBdLnRvVXBwZXJDYXNlKCkgKyBpZC5zbGljZSgxKTtcbiAgICAgICAgZG9JbmplY3QoaWRPclRhcmdldC5jb25zdHJ1Y3Rvciwga2V5LCBpZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL0FwcC9TZXJ2aWNlL1NlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJleHBvcnQgKiBmcm9tIFwiLi9TZXJ2aWNlXCI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXBwL1NlcnZpY2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYywgeyBTaWduYWwgfSBmcm9tIFwiLi4vQXN5bmNcIjtcbmltcG9ydCB7IFNjcmVlbiwgTmF2TGlzdCwgQnV0dG9uIH0gZnJvbSBcIi4uL1VJXCI7XG5pbXBvcnQgeyBBY3RpdmF0aW9uLCBBY3Rpdml0eSwgQWN0aXZpdHlTdGFjayB9IGZyb20gXCIuL0FjdGl2aXR5XCI7XG5pbXBvcnQgeyBpbmplY3RTZXJ2aWNlIH0gZnJvbSBcIi4vU2VydmljZVwiO1xuLyoqIFJlZ0V4cCB0byBwYXJzZSBhIFVSTCAqL1xudmFyIHVybFJFID0gL14oPzooW146Lz8jXSspOik/KD86XFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSopKFxcP1teI10qKT8oIy4qKT8vO1xuLyoqIEhlbHBlciB0byBjaGVjayBpZiBnaXZlbiByZWZlcmVuY2UgcmVmZXJzIHRvIGFuIEFjdGl2aXR5IGNsYXNzICovXG5mdW5jdGlvbiBpc0FjdGl2aXR5Q2xhc3MoYSkge1xuICAgIHJldHVybiAodHlwZW9mIGEgPT09IFwiZnVuY3Rpb25cIiAmJiBhLnByb3RvdHlwZSBpbnN0YW5jZW9mIEFjdGl2aXR5KTtcbn1cbi8qKiBFbmNhcHN1bGF0ZXMgdGhlIGFwcGxpY2F0aW9uIGFzIGEgc2luZ2xldG9uIG9iamVjdDsgdG8gYmUgb3ZlcnJpZGRlbiB3aXRoIGEgcGxhdGZvcm0tc3BlY2lmaWMgaW1wbGVtZW50YXRpb24sIGRvIG5vdCBpbnN0YW50aWF0ZSBkaXJlY3RseSAqL1xudmFyIEFwcGxpY2F0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXBwbGljYXRpb24sIF9zdXBlcik7XG4gICAgLyoqIENyZWF0ZSB0aGUgYXBwbGljYXRpb24gaW5zdGFuY2UgKGZyb20gYSBkZXJpdmVkIGNsYXNzKTsgY2FuIGJlIGNhbGxlZCBvbmx5IG9uY2UgKi9cbiAgICBmdW5jdGlvbiBBcHBsaWNhdGlvbih0aXRsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKiogVGhlIGFwcGxpY2F0aW9uIG5hbWUgdG8gYmUgZGlzcGxheWVkIGluIHRoZSB3aW5kb3cgdGl0bGUgYmFyIChvYnNlcnZlZCkgKi9cbiAgICAgICAgX3RoaXMudGl0bGUgPSBcIlwiO1xuICAgICAgICAvKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCB3aGVuIG5vIGFjdGl2aXR5IGlzIGZvdW5kIGZvciBhIGxvY2F0aW9uICovXG4gICAgICAgIF90aGlzLlBhZ2VOb3RGb3VuZCA9IFNpZ25hbC5jcmVhdGUoKTtcbiAgICAgICAgLyoqIFNpZ25hbCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBhbGwgYWN0aXZpdGllcyBoYXZlIGJlZW4gZHJvcHBlZCBhbmQgbm9uZSBoYXZlIGJlZW4gc3RhcnRlZCAqL1xuICAgICAgICBfdGhpcy5Ob0FjdGl2aXR5ID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICAvKiogQWN0aXZpdHkgc3RhY2sgaW5zdGFuY2UgKi9cbiAgICAgICAgX3RoaXMuYWN0aXZpdGllcyA9IG5ldyBBY3Rpdml0eVN0YWNrKCk7XG4gICAgICAgIGlmIChBcHBsaWNhdGlvbi5jdXJyZW50IHx8ICFBcHBsaWNhdGlvbi5fcmVzb2x2ZV9yZWFkeSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgbW9yZSB0aGFuIG9uZSBBcHBsaWNhdGlvbiBpbnN0YW5jZVwiKTtcbiAgICAgICAgQXBwbGljYXRpb24uY3VycmVudCA9IF90aGlzLmNvbnN0cnVjdG9yLmN1cnJlbnQgPSBfdGhpcztcbiAgICAgICAgX3RoaXMudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBwYWdlIHZpZXdcbiAgICAgICAgU2NyZWVuLnJlYWR5LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQXBwbGljYXRpb24uX3Jlc29sdmVfcmVhZHkoX3RoaXMpO1xuICAgICAgICAgICAgQXBwbGljYXRpb24uX3Jlc29sdmVfcmVhZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpbnN0YWxsIGhhbmRsZXJzIGZvciBOYXZMaXN0IGFuZCBCdXR0b24gYWN0aXZhdGlvblxuICAgICAgICB2YXIgYWN0aXZhdGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7IF90aGlzLnN0YXJ0QWN0aXZpdHlBc3luYyh0YXJnZXQpOyB9O1xuICAgICAgICB2YXIgaXNBY3RpdmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7IF90aGlzLmlzQWN0aXZlKHRhcmdldCk7IH07XG4gICAgICAgIEFzeW5jLmluamVjdChCdXR0b24uQWN0aXZhdGlvbiwgeyBhY3RpdmF0ZTogYWN0aXZhdGUgfSk7XG4gICAgICAgIEFzeW5jLmluamVjdChOYXZMaXN0LkFjdGl2YXRpb24sIHsgYWN0aXZhdGU6IGFjdGl2YXRlLCBpc0FjdGl2ZTogaXNBY3RpdmUgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGFjdGl2aXR5IHRoYXQgaXMgY3VycmVudGx5IGluIHRoZSBmb3JlZ3JvdW5kIChvYnNlcnZhYmxlKSAqL1xuICAgIEFwcGxpY2F0aW9uLnByb3RvdHlwZS5nZXRUb3BBY3Rpdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZpdGllcy50b3A7XG4gICAgfTtcbiAgICAvKiogU3RhcnQgZ2l2ZW4gYWN0aXZpdHkgYXMgZm9yZWdyb3VuZCBhY3Rpdml0eSAocHVzaC9yZXBsYWNlLCBzYW1lIGFzIGNhbGxpbmcgYC5hY3Rpdml0aWVzLnB1c2gvcmVwbGFjZSguLi4pYCBkaXJlY3RseSksIG9yIHN0YXJ0IGFjdGl2aXR5IHVzaW5nIGdpdmVuIHJlc291cmNlIHBhdGggb3Igc3RyaW5nIChgIy8uLi5gIG9yIGAvLi4uYCwgb3IgcmVsYXRpdmUgcGF0aCBhcyBgIy4vLi4uYCwgYCMuLi8uLi5gLCBgLi8uLi5gIG9yIGAuLi8uLi5gKTsgaWYgYG5hdmlnYXRlSWZOb3RGb3VuZGAgaXMgbm90IGZhbHNlLCB0aGVuIHRoZSBicm93c2VyL2FwcCB3aWxsIG5hdmlnYXRlIHRvIHRoZSBuZXcgbG9jYXRpb24gaWYgbm8gbWF0Y2hpbmcgYWN0aXZpdHkgaXMgZm91bmQgKGF1dG9tYXRpYyBmb3IgZXh0ZXJuYWwgVVJMcyksIG90aGVyd2lzZSBpbnZva2VzIG9uUGFnZU5vdEZvdW5kIGhhbmRsZXI7IG5vdGUgdGhhdCBhY3Rpdml0aWVzIHRyYW5zaXRpb24gYXN5bmNocm9ub3VzbHkgYW5kIGFueSB1cGRhdGVzIHdpbGwgbm90IGJlIHJlZmxlY3RlZCB1bnRpbCBhIGZldyBtaWxsaXNlY29uZHMgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCAqL1xuICAgIEFwcGxpY2F0aW9uLnByb3RvdHlwZS5zdGFydEFjdGl2aXR5QXN5bmMgPSBmdW5jdGlvbiAoYWN0aXZhdGFibGUsIHJlcGxhY2UsIG5hdmlnYXRlSWZOb3RGb3VuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaXNBY3Rpdml0eUNsYXNzKGFjdGl2YXRhYmxlKSkge1xuICAgICAgICAgICAgYWN0aXZhdGFibGUgPSBhY3RpdmF0YWJsZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCEoYWN0aXZhdGFibGUgaW5zdGFuY2VvZiBBY3Rpdml0eSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhY3Rpdml0eSBpbnN0YW5jZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZhdGFibGUgaW5zdGFuY2VvZiBBY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZhdGFibGUuZ2V0QWN0aXZpdHlBc3luYygpLnRoZW4oZnVuY3Rpb24gKGFjdGl2aXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RhcnRBY3Rpdml0eUFzeW5jKGFjdGl2aXR5KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5QYWdlTm90Rm91bmQoYWN0aXZhdGFibGUuZ2V0UGF0aCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2YXRhYmxlIGluc3RhbmNlb2YgQWN0aXZpdHkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGJhY2tncm91bmQgYWN0aXZpdHlcbiAgICAgICAgICAgIGlmIChhY3RpdmF0YWJsZS5vcHRpb25zLmlzQmFja2dyb3VuZEFjdGl2aXR5KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdGFydCBiYWNrZ3JvdW5kIGFjdGl2aXR5IGRpcmVjdGx5XCIpO1xuICAgICAgICAgICAgLy8gcHVzaCBvciByZXBsYWNlIGRpcmVjdGx5XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZSA/IHRoaXMuYWN0aXZpdGllcy5yZXBsYWNlQXN5bmMoYWN0aXZhdGFibGUpIDpcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2aXRpZXMucHVzaEFzeW5jKGFjdGl2YXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3JtYWxpemUgZ2l2ZW4gcGF0aC9VUkwgdG8gYWJzb2x1dGUgcGF0aCwgaWYgcG9zc2libGVcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLm5vcm1hbGl6ZVBhdGgoYWN0aXZhdGFibGUpO1xuICAgICAgICAvLyBjaGVjayBpZiBwYXRoIGFscmVhZHkgYWN0aXZlXG4gICAgICAgIHZhciBjdXJyZW50QWN0aXZpdHlQYXRoID0gdGhpcy5hY3Rpdml0aWVzLnRvcCAmJlxuICAgICAgICAgICAgdGhpcy5hY3Rpdml0aWVzLnRvcC5hY3RpdmF0aW9uLmdldFBhdGgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRBY3Rpdml0eVBhdGggJiYgY3VycmVudEFjdGl2aXR5UGF0aCA9PT0gcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIEFzeW5jLlByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJvdXRlIGJhc2VkIG9uIHRoZSByZXN1bHRpbmcgcGF0aFxuICAgICAgICB2YXIgYWN0aXZhdGlvbiA9IEFjdGl2YXRpb24ucm91dGUocGF0aCk7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uKSB7XG4gICAgICAgICAgICAvLyByZWN1cnNlIGZvciBhY3RpdmF0aW9uIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRBY3Rpdml0eUFzeW5jKGFjdGl2YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hdmlnYXRlSWZOb3RGb3VuZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGlmIG5vIHJvdXRlL2FjdGl2aXR5IG1hcHBlZCwgbmF2aWdhdGUgZGlyZWN0bHlcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGVUb1VybChhY3RpdmF0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBub3Qgc3VwcG9zZWQgdG8gbmF2aWdhdGUsIGVtaXQgc2lnbmFsXG4gICAgICAgICAgICB0aGlzLlBhZ2VOb3RGb3VuZChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXN5bmMuUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICAvKiogR28gYmFjayBpbiBhY3Rpdml0eSBoaXN0b3J5OyBlaXRoZXIgdG8gcHJldmlvdXMgYWN0aXZpdHkgb3IgdG8gYWN0aXZpdHkgb2YgZ2l2ZW4gY2xhc3M7IHJldHVybnMgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgZm9yZWdyb3VuZCBhY3Rpdml0eSwgb3IgdW5kZWZpbmVkIGlmIGFjdGl2aXR5IHdhcyBub3QgZm91bmQ7IHRoZSBOb0FjdGl2aXR5IHNpZ25hbCBpcyBlbWl0dGVkIGlmIGFsbCBhY3Rpdml0aWVzIGhhdmUgYmVlbiBkcm9wcGVkIGFuZCB0aGVyZSBpcyBubyBjdXJyZW50IGFjdGl2aXR5IGFueW1vcmUgKi9cbiAgICBBcHBsaWNhdGlvbi5wcm90b3R5cGUuZHJvcEFjdGl2aXR5QXN5bmMgPSBmdW5jdGlvbiAoQWN0aXZpdHlDbGFzcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoQWN0aXZpdHlDbGFzcykge1xuICAgICAgICAgICAgLy8gZ28gdXAgdG8gZ2l2ZW4gYWN0aXZpdHksIGFuZCBzdGF5IHB1dCBmb3IgMm1zIHRvIGFsbG93XG4gICAgICAgICAgICAvLyBwbGF0Zm9ybSB0byBjYXRjaCB1cFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZpdGllcy51cEFzeW5jKEFjdGl2aXR5Q2xhc3MpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEFzeW5jLnNsZWVwKDIsIGEpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2aXRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBwb3AgY3VycmVudCBhY3Rpdml0eVxuICAgICAgICAgICAgdmFyIHJlc29sdmVfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gX3RoaXMuYWN0aXZpdGllcy50b3A7XG4gICAgICAgICAgICAgICAgLy8gcG9wIGFnYWluIGlmIHRvcCBhY3Rpdml0eSBpcyBub3cgYSBiYWNrZ3JvdW5kIGFjdGl2aXR5XG4gICAgICAgICAgICAgICAgaWYgKHRvcCAmJiB0b3Aub3B0aW9ucy5pc0JhY2tncm91bmRBY3Rpdml0eSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFjdGl2aXRpZXMucG9wQXN5bmModG9wKS50aGVuKHJlc29sdmVfMSk7XG4gICAgICAgICAgICAgICAgLy8gZW1pdCBOb0FjdGl2aXR5IGlmIG5vbmUgbGVmdCBhZnRlciAxMG1zXG4gICAgICAgICAgICAgICAgaWYgKCF0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFzeW5jLnNsZWVwKDEwKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuYWN0aXZpdGllcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuTm9BY3Rpdml0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b3A7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZpdGllcy5wb3BBc3luYygpLnRoZW4ocmVzb2x2ZV8xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gcG9wLCBlbWl0IE5vQWN0aXZpdHkgYW5kIHJldHVybiBlbXB0eSBwcm9taXNlXG4gICAgICAgICAgICB0aGlzLk5vQWN0aXZpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBBc3luYy5Qcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXBwbGljYXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKHBhdGhPckFjdGl2aXR5KSB7XG4gICAgICAgIGlmICgocGF0aE9yQWN0aXZpdHkgaW5zdGFuY2VvZiBBY3Rpdml0eSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiBwYXRoT3JBY3Rpdml0eSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBvbmx5IGNoZWNrIHRvcCBhY3Rpdml0eSBhbmQgaXRzIHBhcmVudCBhY3Rpdml0aWVzXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYWN0aXZpdGllcy50b3A7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBwYXRoT3JBY3Rpdml0eSB8fFxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudCBpbnN0YW5jZW9mIHBhdGhPckFjdGl2aXR5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGN1cnJlbnQub3B0aW9ucy5wYXJlbnRBY3Rpdml0eTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgcGFyZW50IGFjdGl2aXR5IGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBwYXJlbnQgYWN0aXZpdHkgaW4gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLmFjdGl2aXRpZXMuZ2V0UGFyZW50KHBhcmVudCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGdpdmVuIHBhdGggYW5kIGNoZWNrIGFnYWluc3QgY3VycmVudCBVUkxcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5ub3JtYWxpemVQYXRoKHBhdGhPckFjdGl2aXR5KTtcbiAgICAgICAgICAgIGlmICghcGF0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY3VyID0gdGhpcy5nZXRDdXJyZW50VXJsKCk7XG4gICAgICAgICAgICBpZiAocGF0aFswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBsb29raW5nIGZvciBoYXNoOiB0cmltIGV2ZXJ5dGhpbmcgZXhjZXB0IGhhc2ggcGF0aFxuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKC9bXiNdKi8sIFwiXCIpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGxvb2tpbmcgZm9yIGJhc2UgcGF0aDoga2VlcCBwYXRoIGFuZCBoYXNoXG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UoL14oPzooW146Lz8jXSspOik/KD86XFwvXFwvKFteXFwvPyNdKikpLywgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcLz9cXD9bXiNdKi8sIFwiL1wiKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIChjdXIuc2xpY2UoMCwgbCkgPT09IHBhdGggJiZcbiAgICAgICAgICAgICAgICAoY3VyLmxlbmd0aCA9PT0gbCB8fCBjdXJbbF0gPT09IFwiL1wiKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBSZW1vdmUgdGhlIGFjdGl2aXR5IHRoYXQgaXMgY3VycmVudGx5IGluIHRoZSBmb3JlZ3JvdW5kLCBhbmQgcmVpbnN0YW50aWF0ZSBhIG5ldyBhY3Rpdml0eSB1c2luZyB0aGUgYEFjdGl2YXRpb25gIG9iamVjdCB0aGF0IHdhcyB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBjdXJyZW50IGFjdGl2aXR5OyB0aGlzIGFsc28gcmUtZGlzcGxheXMgdGhlIHZpZXcsIGlmIGFueTsgYWxzbyBpbmNyZW1lbnRzIHRoZSBgLmFjdGl2YXRpb25JbmRleGAgcHJvcGVydHk7IHJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIGFmdGVyIHRoZSBhY3Rpdml0eSBoYXMgYmVlbiBzdGFydGVkICovXG4gICAgQXBwbGljYXRpb24ucHJvdG90eXBlLnJlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5hY3Rpdml0aWVzLnRvcClcbiAgICAgICAgICAgIHJldHVybiBBc3luYy5Qcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIGFjdGl2YXRpb24gPSB0aGlzLmFjdGl2aXRpZXMudG9wLmFjdGl2YXRpb247XG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZhdGlvbkluZGV4KVxuICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGlvbkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGlvbkluZGV4Kys7XG4gICAgICAgIHJldHVybiB0aGlzLmRyb3BBY3Rpdml0eUFzeW5jKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdGFydEFjdGl2aXR5QXN5bmMoYWN0aXZhdGlvbik7IH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uLnByb3RvdHlwZSwgXCJhY3RpdmF0aW9uSW5kZXhcIiwge1xuICAgICAgICAvKiogQ291bnRlciB0aGF0IGlzIGluY3JlbWVudGVkIGV2ZXJ5IHRpbWUgYC5yZWFjdGl2YXRlYCBpcyBjYWxsZWQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hY3RpdmF0aW9uSW5kZXg7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBSZXR1cm5zIGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIGdpdmVuIHBhdGgvVVJMLCBpLmUuIGVpdGhlciBgLy4uLmAgb3IgYCMvLi4uYCwgb3IgdW5kZWZpbmVkIGlmIGdpdmVuIHBhdGgvVVJMIGNhbm5vdCBiZSBub3JtYWxpemVkOyByZWxhdGl2ZSBwYXRocyBhcmUgYWxzbyBzdXBwb3J0ZWQgKGUuZy4gYC4uL2Zvb2Agb3IgYCMuLi9mb29gKSAqL1xuICAgIEFwcGxpY2F0aW9uLnByb3RvdHlwZS5ub3JtYWxpemVQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxuICAgICAgICB2YXIgX2EgPSBTdHJpbmcocGF0aCkubWF0Y2godXJsUkUpIHx8IFtdLCBfID0gX2FbMF0sIHByb3RvID0gX2FbMV0sIGhvc3QgPSBfYVsyXSwgdGFyZ2V0UGF0aCA9IF9hWzNdLCBxdWVyeSA9IF9hWzRdLCB0YXJnZXRIYXNoID0gX2FbNV07XG4gICAgICAgIC8vIGlmIHBhdGggaXMgZW1wdHksIGZvcmNlIGhvbWUgYW5kIHVzZSBlaXRoZXIgYC9gIG9yIGAjL2BcbiAgICAgICAgaWYgKCFfKVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmdldEN1cnJlbnRVcmwoKS5pbmRleE9mKFwiI1wiKSA+PSAwKSA/IFwiIy9cIiA6IFwiL1wiO1xuICAgICAgICAvLyBjaGVjayBpZiBnaXZlbiBhIGZ1bGwgVVJMIHRoYXQgaXMgYWN0dWFsbHkgb24gdGhlIHNhbWUgZG9tYWluXG4gICAgICAgIGlmIChwcm90byB8fCBob3N0KSB7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLmdldEN1cnJlbnRVcmwoKS5tYXRjaCh1cmxSRSkgfHwgW10sIF8xID0gX2JbMF0sIGN1clByb3RvID0gX2JbMV0sIGN1ckhvc3QgPSBfYlsyXSwgY3VyUGF0aCA9IF9iWzNdLCBjdXJRdWVyeSA9IF9iWzRdO1xuICAgICAgICAgICAgaWYgKCFfMSB8fCBjdXJQcm90byAhPT0gcHJvdG8gfHwgY3VySG9zdCAhPT0gaG9zdCkge1xuICAgICAgICAgICAgICAgIC8vIGRvbWFpbiBkb2VzIG5vdCBtYXRjaFxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJQYXRoID0gY3VyUGF0aC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgICAgICB0YXJnZXRQYXRoID0gdGFyZ2V0UGF0aC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SGFzaCAmJiBjdXJQYXRoID09PSB0YXJnZXRQYXRoICYmIGN1clF1ZXJ5ID09IHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIGhhc2ggcGFydCBvbmx5XG4gICAgICAgICAgICAgICAgcGF0aCA9IHRhcmdldEhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgZnVsbCBwYXRoXG4gICAgICAgICAgICAgICAgdGFyZ2V0UGF0aCArPSAodGFyZ2V0SGFzaCA/IFwiL1wiICsgdGFyZ2V0SGFzaCA6IFwiXCIpO1xuICAgICAgICAgICAgICAgIHBhdGggPSB0YXJnZXRQYXRoIHx8IFwiL1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHRhcmdldCB0eXBlXG4gICAgICAgIGlmICgvXiM/XFwvLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICAvLyBmdWxsIHBhdGggb3IgaGFzaCBwYXRoOiBzdG9wIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGhbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAvLyByZWxhdGl2ZSBoYXNoIHBhdGg6IHJlc29sdmUgYWdhaW5zdCBjdXJyZW50IFVSTFxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldEN1cnJlbnRVcmwoKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJlcGxhY2UoL1teI10qLywgXCJcIikucmVwbGFjZSgvXFwvJC8sIFwiXCIpLnNsaWNlKDEpO1xuICAgICAgICAgICAgcGF0aCA9IChjdXJyZW50ICsgXCIvXCIgKyBwYXRoLnNsaWNlKDEpKS5yZXBsYWNlKC9cXC5cXC8vZywgXCJcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBvbGRQYXRoID0gcGF0aDsgb2xkUGF0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoL1teXFwvXStcXC9cXC5cXC5cXC8vLCBcIlwiKSk7KVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJldHVybiBcIiNcIiArIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZWxhdGl2ZSBwYXRoOiByZXNvbHZlIGFnYWluc3QgY3VycmVudCBVUkxcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRDdXJyZW50VXJsKCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yZXBsYWNlKC9eKD86KFteOi8/I10rKTopPyg/OlxcL1xcLyhbXlxcLz8jXSopKS8sIFwiXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcIy4qLywgXCJcIikucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgICAgICAgICAgcGF0aCA9IChjdXJyZW50ICsgXCIvXCIgKyBwYXRoKS5yZXBsYWNlKC9cXC5cXC8vZywgXCJcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBvbGRQYXRoID0gcGF0aDsgb2xkUGF0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoL1teXFwvXStcXC9cXC5cXC5cXC8vLCBcIlwiKSk7KVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgKGJyb3dzZXIvYXBwKSBwbGF0Zm9ybSdzIGN1cnJlbnQgVVJJIGFzIGEgc3RyaW5nLCBpZiBhdmFpbGFibGUgKi9cbiAgICBBcHBsaWNhdGlvbi5wcm90b3R5cGUuZ2V0Q3VycmVudFVybCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXCI7IH07XG4gICAgLyoqIERpcmVjdHMgdGhlIChicm93c2VyL2FwcCkgcGxhdGZvcm0gdG8gZ2l2ZW4gVVJMLCBlLmcuIGEgZnVsbCBVUkwgdG8gbmF2aWdhdGUgYXdheSBmcm9tIHRoZSBjdXJyZW50IGFwcGxpY2F0aW9uICovXG4gICAgQXBwbGljYXRpb24ucHJvdG90eXBlLm5hdmlnYXRlVG9VcmwgPSBmdW5jdGlvbiAodXJsKSB7IC8qIHBsYXRmb3JtIGRlZmluZWQgKi8gdXJsOyB9O1xuICAgIC8qKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGFwcGxpY2F0aW9uIGluc3RhbmNlIGFmdGVyIGl0IGhhcyBiZWVuIGNyZWF0ZWQgKi9cbiAgICBBcHBsaWNhdGlvbi5yZWFkeSA9IG5ldyBBc3luYy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IEFwcGxpY2F0aW9uLl9yZXNvbHZlX3JlYWR5ID0gcmVzb2x2ZTsgfSk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLm9ic2VydmFibGVfc3RyaW5nXG4gICAgXSwgQXBwbGljYXRpb24ucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGluamVjdFNlcnZpY2UoXCJjdWx0dXJlXCIpXG4gICAgXSwgQXBwbGljYXRpb24ucHJvdG90eXBlLCBcImN1bHR1cmVcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQXBwbGljYXRpb247XG59KEFzeW5jLk9ic2VydmFibGVPYmplY3QpKTtcbmV4cG9ydCB7IEFwcGxpY2F0aW9uIH07XG4vKiogQWxpYXMgZm9yIGBBcHBsaWNhdGlvbiNzdGFydEFjdGl2aXR5QXN5bmNgIG9uIHRoZSBjdXJyZW50IGBBcHBsaWNhdGlvbmAgaW5zdGFuY2U7IGlmIHRoZXJlIGlzIG5vIGN1cnJlbnQgaW5zdGFuY2UsIHRoaXMgZnVuY3Rpb24gd2FpdHMgZm9yIGFuIEFwcGxpY2F0aW9uIGluc3RhbmNlIHRvIGJlIGNyZWF0ZWQgZmlyc3QgKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydEFjdGl2aXR5QXN5bmMoYWN0aXZpdHlPclBhdGgsIHJlcGxhY2UsIG5hdmlnYXRlSWZOb3RGb3VuZCkge1xuICAgIHZhciBnbyA9IGZ1bmN0aW9uIChhcHApIHtcbiAgICAgICAgcmV0dXJuIGFwcC5zdGFydEFjdGl2aXR5QXN5bmMoYWN0aXZpdHlPclBhdGgsIHJlcGxhY2UsIG5hdmlnYXRlSWZOb3RGb3VuZCk7XG4gICAgfTtcbiAgICBpZiAoQXBwbGljYXRpb24uY3VycmVudClcbiAgICAgICAgcmV0dXJuIGdvKEFwcGxpY2F0aW9uLmN1cnJlbnQpO1xuICAgIHJldHVybiBBcHBsaWNhdGlvbi5yZWFkeS50aGVuKGZ1bmN0aW9uIChhcHApIHsgcmV0dXJuIGdvKGFwcCk7IH0pO1xufVxuLyoqIEdldCB0aGUgYWN0aXZpdHkgY2xvc2VzdCB0byB0aGUgZm9yZWdyb3VuZCBvZiBnaXZlbiB0eXBlLCBpZiBhbnkgKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQWN0aXZpdHkoQWN0aXZpdHlDbGFzcykge1xuICAgIGlmICghQXBwbGljYXRpb24uY3VycmVudClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoQXBwbGljYXRpb24uY3VycmVudC5hY3Rpdml0aWVzLnRvcCBpbnN0YW5jZW9mIEFjdGl2aXR5Q2xhc3MpXG4gICAgICAgIHJldHVybiBBcHBsaWNhdGlvbi5jdXJyZW50LmFjdGl2aXRpZXMudG9wO1xuICAgIHJldHVybiBBcHBsaWNhdGlvbi5jdXJyZW50LmFjdGl2aXRpZXMuZ2V0UGFyZW50KEFjdGl2aXR5Q2xhc3MpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL0FwcC9BcHBsaWNhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgUGFnZSwgU2NyZWVuIH0gZnJvbSBcIi4uLy4uL1VJXCI7XG5pbXBvcnQgeyBpc0xheW91dEZyYWdtZW50IH0gZnJvbSBcIi4vVmlld0xheW91dFwiO1xuaW1wb3J0IHsgQXBwbGljYXRpb24gfSBmcm9tIFwiLi4vQXBwbGljYXRpb25cIjtcbnZhciBWSUVXX0lOSVRJQUxJWkVEX1BST1AgPSBcIkBfdmlld19cIjtcbnZhciBWSUVXX01BUF9QUkVGSVggPSBcIiN2aWV3OlwiO1xuLyoqIE5leHQgVUlEIHRvIGJlIHVzZWQgYnkgbWFwVmlld0FjdGl2aXR5ICovXG52YXIgX25leHRVSUQgPSAwO1xuLyoqIFJlcHJlc2VudHMgYSBtYXBwaW5nIGJldHdlZW4gYW4gYWN0aXZpdHkgYW5kIGEgdmlldyBjbGFzcyAqL1xudmFyIFZpZXdNYXBwaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogUHJpdmF0ZSBjb25zdHJ1Y3RvciwgZG8gbm90IHVzZSBkaXJlY3RseTogdXNlIHN0YXRpYyBtZXRob2QgYC5tYXBWaWV3YCBpbnN0ZWFkICovXG4gICAgZnVuY3Rpb24gVmlld01hcHBpbmcoKSB7XG4gICAgICAgIHRoaXMuX3JlZiA9IDA7XG4gICAgfVxuICAgIC8qKiBNYXAgdGhlIGdpdmVuIGFjdGl2aXR5IHRvIGdpdmVuIHZpZXcgY2xhc3MsIHdpdGggZ2l2ZW4gZGVyZWZlcmVuY2UgdGltZW91dCAob3IgMCB0byBkaXNhYmxlIGRlcmVmZXJlbmNpbmcpOyBhbHNvIGNvbm5lY3RzIHRvIHRoZSBhY3Rpdml0eSdzIFJlc3VtZWQgc2lnbmFsLCBvbmNlIHBlciBhY3Rpdml0eSBpbnN0YW5jZSAqL1xuICAgIFZpZXdNYXBwaW5nLm1hcFZpZXcgPSBmdW5jdGlvbiAoYWN0aXZpdHksIFZpZXcsIHRpbWVvdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gY3JlYXRlIGFuZCBzdG9yZSB0aGUgdmlldyBtYXBwaW5nIGluIHRoZSBhY3Rpdml0eSBvYmplY3RcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBhY3Rpdml0eVtWSUVXX01BUF9QUkVGSVggKyBfbmV4dFVJRCsrXSA9IG5ldyBWaWV3TWFwcGluZztcbiAgICAgICAgbWFwcGluZy5fYWN0aXZpdHkgPSBhY3Rpdml0eTtcbiAgICAgICAgbWFwcGluZy5fVmlldyA9IFZpZXc7XG4gICAgICAgIG1hcHBpbmcuX3RpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICAvLyBjb25uZWN0IHRvIHRoZSBSZXN1bWVkIHNpZ25hbCB0byBkaXNwbGF5IChwYXJlbnQpIHZpZXcocylcbiAgICAgICAgLy8gYW5kIGFkZCBsYXlvdXQocykgLS0gYnV0IG9ubHkgb25jZSBmb3IgZWFjaCBhY3Rpdml0eSBpbnN0YW5jZVxuICAgICAgICBpZiAoIWFjdGl2aXR5W1ZJRVdfSU5JVElBTElaRURfUFJPUF0pIHtcbiAgICAgICAgICAgIGFjdGl2aXR5W1ZJRVdfSU5JVElBTElaRURfUFJPUF0gPSB0cnVlO1xuICAgICAgICAgICAgYWN0aXZpdHkuUmVzdW1lZC5jb25uZWN0KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgLy8gd2FpdCBqdXN0IGEgYml0IHRvIHNlZSBpZiBzdGFjayB3aWxsIHNraXAgb3ZlclxuICAgICAgICAgICAgICAgIEFzeW5jLnNsZWVwKDIpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gdC5hY3Rpdml0eVN0YWNrLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmFjdGl2aXR5ID09PSBhY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGlzcGxheShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuYWN0aXZpdHlTdGFjay5wb3BBc3luYyhhY3Rpdml0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIERpc3BsYXkgdmlld3MgZm9yIHRoZSBhY3Rpdml0eSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjazsgdGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gZGlzcGxheSAqL1xuICAgIFZpZXdNYXBwaW5nLl9kaXNwbGF5ID0gZnVuY3Rpb24gKGN1cnNvcikge1xuICAgICAgICB2YXIgYWN0aXZpdHkgPSBjdXJzb3IuYWN0aXZpdHk7XG4gICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX2ZpbmRWaWV3cyhhY3Rpdml0eSwgY3Vyc29yKTtcbiAgICAgICAgaWYgKCF2aWV3cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGJhY2sgdXAgaWYgbm90aGluZyB0byBkaXNwbGF5XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2aWV3IG1hcHBlZCBmb3IgdGhpcyBhY3Rpdml0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3cy5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodiBpbnN0YW5jZW9mIFBhZ2UpOyB9KSkge1xuICAgICAgICAgICAgLy8gZGlzcGxheWluZyBhIChuZXcpIHBhZ2UsIGxldCBTY3JlZW4gZmlndXJlIGl0IG91dFxuICAgICAgICAgICAgdmlld3MuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gU2NyZWVuLmRpc3BsYXlBc3luYyh2KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8gdXNlIGV4aXN0aW5nIHBhZ2UgaWYgaXQgZmVhdHVyZXMgdGhlIHNhbWUgY29udGVudFxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBQYWdlLmdldEN1cnJlbnRQYWdlKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmNvbnRlbnRbMF0gPT09IHZpZXdzWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8ganVzdCByZXBsYWNlIGNvbnRlbnQgYXJyYXlcbiAgICAgICAgICAgICAgICBjdXJyZW50LmNvbnRlbnQgPSB2aWV3cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBwYWdlIGFuZCBkaXNwbGF5IGV2ZXJ5dGhpbmcgaW4gb25lIGdvXG4gICAgICAgICAgICAgICAgbmV3IFBhZ2Uodmlld3MpLmRpc3BsYXlBc3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogRmluZCAocGFyZW50KSB2aWV3cyB1cCB0byB0aGUgZmlyc3QgZnVsbCAobm9uLW1vZGFsKSB2aWV3IGluc3RhbmNlLCBhbmQgYWRkIGxheW91dCBmcmFnbWVudHMgb24gdGhlIHdheSBiYWNrIHVwOyByZXR1cm5zIGFuIGFycmF5IG9mIHZpZXdzIHRvIGJlIGRpc3BsYXllZCAqL1xuICAgIFZpZXdNYXBwaW5nLl9maW5kVmlld3MgPSBmdW5jdGlvbiAoZmcsIGN1cnNvciwgc2VlbiwgdHJhY2VQYXJlbnRzKSB7XG4gICAgICAgIGlmIChzZWVuID09PSB2b2lkIDApIHsgc2VlbiA9IHt9OyB9XG4gICAgICAgIHZhciBhY3Rpdml0eSA9IGN1cnNvci5hY3Rpdml0eTtcbiAgICAgICAgd2hpbGUgKGFjdGl2aXR5ICYmXG4gICAgICAgICAgICAoIWFjdGl2aXR5W1ZJRVdfSU5JVElBTElaRURfUFJPUF0gfHwgc2VlblthY3Rpdml0eS51aWRdKSkge1xuICAgICAgICAgICAgaWYgKHRyYWNlUGFyZW50cylcbiAgICAgICAgICAgICAgICBhY3Rpdml0eSA9IGN1cnNvci5nb1BhcmVudCgpLmFjdGl2aXR5O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFjdGl2aXR5ID0gY3Vyc29yLmdvQmFjaygpLmFjdGl2aXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpdml0eSkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoaXMgYWN0aXZpdHkgaXMgbm90IGNoZWNrZWQgYWdhaW5cbiAgICAgICAgICAgIHNlZW5bYWN0aXZpdHkudWlkXSA9IHRydWU7XG4gICAgICAgICAgICAvLyBmb3VuZCBhIG1hcHBlZCBhY3Rpdml0eSwgZ2V0IGluc3RhbmNlcyBmb3IgYWxsIHZpZXdzXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnRzID0gW107XG4gICAgICAgICAgICB2YXIgaGFzRnVsbFZpZXc7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBhY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgIGlmIChpZFswXSA9PT0gXCIjXCIgJiYgaWQuc2xpY2UoMCwgNikgPT09IFZJRVdfTUFQX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IGFjdGl2aXR5W2lkXS5fZ2V0SW5zdGFuY2UoZmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgcGFnZSwgdXNlIGl0IGFzIGEgZnVsbCB2aWV3IChzb3J0IHRvIGZyb250KVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRnVsbFZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQodmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzFdICYmIChyZXN1bHRbMV0gaW5zdGFuY2VvZiBQYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgb25seSBvbmUgcGFnZSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoMSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNMYXlvdXRGcmFnbWVudCh2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBmcmFnbWVudCBvbmx5LCB0cnkgdG8gdXNlIGl0IGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudHMucHVzaCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2aWV3LmRpc3BsYXlPcHRpb25zICYmIHZpZXcuZGlzcGxheU9wdGlvbnMubW9kYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgbW9kYWwgdmlldywgdXNlIGl0IG9uIHRvcCBvZiBvdGhlciB2aWV3c1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHRvIENsb3NlZCBzaWduYWwgdG8gcG9wIGFjdGl2aXR5IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDbG9zZWQgPSB2aWV3LkNsb3NlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDbG9zZWQgJiYgdHlwZW9mIENsb3NlZC5jb25uZWN0T25jZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xvc2VkLmNvbm5lY3RPbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmFjdGl2aXR5U3RhY2sucG9wQXN5bmMoYWN0aXZpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBmdWxsIHZpZXcgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNGdWxsVmlldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlZXAgbG9va2luZyBpZiBubyBmdWxsIHZpZXcgY29tcG9uZW50IHdhcyBmb3VuZFxuICAgICAgICAgICAgaWYgKCFoYXNGdWxsVmlldyAmJiBmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gZ290IGEgZnJhZ21lbnQ6IGNoZWNrIHdpdGggcGFyZW50cyBmaXJzdFxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRWaWV3cyA9IHRoaXMuX2ZpbmRWaWV3cyhmZywgY3Vyc29yLmNsb25lKCkuZ29QYXJlbnQoKSwgc2VlbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBhcmVudFZpZXdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRWaWV3ID0gcGFyZW50Vmlld3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgocGFyZW50VmlldyBpbnN0YW5jZW9mIFBhZ2UpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhcGFyZW50Vmlldy5kaXNwbGF5T3B0aW9ucyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXBhcmVudFZpZXcuZGlzcGxheU9wdGlvbnMubW9kYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNGdWxsVmlldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHBhcmVudFZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzRnVsbFZpZXcpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB3aXRoIHByZXZpb3VzIGFjdGl2aXRpZXNcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9maW5kVmlld3MoZmcsIGN1cnNvci5nb0JhY2soKSwgc2VlbilcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGZyYWdtZW50cyB0byBmdWxsIHZpZXdzIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgICAgICBmcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdfMSA9IHJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2aWV3XzEgaW5zdGFuY2VvZiBDb21wb25lbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xheW91dEZyYWdtZW50KGZyYWcsIHZpZXdfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdfMS5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIC8qKiBDcmVhdGUgYSB2aWV3IGluc3RhbmNlIChvciB1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlKSwgYW5kIHdhdGNoIGdpdmVuIGZvcmVncm91bmQgYWN0aXZpdHkgZm9yIHN1c3BlbnNpb24gdG8gZGVyZWZlcmVuY2UgdGhlIHZpZXcgaW5zdGFuY2UgKi9cbiAgICBWaWV3TWFwcGluZy5wcm90b3R5cGUuX2dldEluc3RhbmNlID0gZnVuY3Rpb24gKGZnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpbnN0YW5jZTtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gKyt0aGlzLl9yZWY7XG4gICAgICAgICAgICBmZy5TdXNwZW5kZWQuY29ubmVjdE9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHJlYWN0aXZhdGVkIGFwcGxpY2F0aW9uIGFjdGl2aXR5XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pbnN0YW5jZUluZGV4ICE9PSBBcHBsaWNhdGlvbi5jdXJyZW50LmFjdGl2YXRpb25JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXJlZmVyZW5jZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX2luc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRlcmVmZXJlbmNlIGFmdGVyIHRpbWVvdXQsIHVubGVzcyBvdmVydGFrZW5cbiAgICAgICAgICAgICAgICAvLyBieSBhbm90aGVyIGNhbGwgdG8gZ2V0SW5zdGFuY2VcbiAgICAgICAgICAgICAgICBBc3luYy5zbGVlcChfdGhpcy5fdGltZW91dCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWYgPT09IF90aGlzLl9yZWYgJiYgaW5zdGFuY2UgPT09IF90aGlzLl9pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5faW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2VJbmRleCAhPT0gQXBwbGljYXRpb24uY3VycmVudC5hY3RpdmF0aW9uSW5kZXgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlSW5kZXggPSBBcHBsaWNhdGlvbi5jdXJyZW50LmFjdGl2YXRpb25JbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZSB8fCAodGhpcy5faW5zdGFuY2UgPVxuICAgICAgICAgICAgbmV3IHRoaXMuX1ZpZXcodGhpcy5fYWN0aXZpdHkpKTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3TWFwcGluZztcbn0oKSk7XG4vKiogKkNsYXNzIGRlY29yYXRvciosIG1hcHMgdGhlIGRlY29yYXRlZCB2aWV3IGNsYXNzIHRvIGFuIGBBY3Rpdml0eWAgY2xhc3M7IHRoZSB2aWV3IGNsYXNzIHNob3VsZCBiZSBhIFVJIGBDb21wb25lbnRgIG9yIGBQYWdlYCBjbGFzcyB3aXRoIGEgY29uc3RydWN0b3IgdGhhdCBoYXMgYSBzaW5nbGUgbWF0Y2hpbmcgYWN0aXZpdHkgYXJndW1lbnQsIHBvc3NpYmx5IGEgdmlldyBsYXlvdXQgb3IgZnJhZ21lbnQgY2xhc3MgdGhhdCBkZXJpdmVzIGZyb20gdGhlIHR5cGVzIGluIHRoZSBgTGF5b3V0YCBuYW1lc3BhY2U7IGlmIHRoZSB2aWV3IGNsYXNzIGlzIGEgZnJhZ21lbnQsIGl0IGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIChwYXJlbnQpIGFjdGl2aXR5J3MgbWF0Y2hpbmcgdmlldzsgcmUtdXNlcyB2aWV3IGluc3RhbmNlcyB3aGVuIHBvc3NpYmxlLCBidXQgdmlld3MgYXJlIGRlcmVmZXJlbmNlZCB3aXRoaW4gZ2l2ZW4gdGltZW91dCB3aGVuIG5vIGxvbmdlciBpbiB1c2UgKGluIG1zLCBkZWZhdWx0cyB0byAycywgc2V0IHRvIDAgdG8gZGlzYWJsZSkgW2RlY29yYXRvcl0gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBWaWV3QWN0aXZpdHkoYWN0aXZpdHlDbGFzcywgZGVyZWZlcmVuY2VUaW1lb3V0KSB7XG4gICAgaWYgKGRlcmVmZXJlbmNlVGltZW91dCA9PT0gdm9pZCAwKSB7IGRlcmVmZXJlbmNlVGltZW91dCA9IDIwMDA7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAvLyBpbmplY3QgaW5pdGlhbGl6ZXIgaW50byB0aGUgYWN0aXZpdHkgY2xhc3NcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBBc3luYy5pbmplY3QoYWN0aXZpdHlDbGFzcywge1xuICAgICAgICAgICAgXCJAaW5pdGlhbGl6ZVwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgVmlld01hcHBpbmcubWFwVmlldyh0aGlzLCB0YXJnZXQsIGRlcmVmZXJlbmNlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFtcIkBpbml0aWFsaXplXCJdLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXBwL1ZpZXcvVmlld01hcHBpbmcuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCBBc3luYyBmcm9tIFwiLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IEJhc2VEaWFsb2dMYXlvdXQgfSBmcm9tIFwiLi9MYXlvdXRcIjtcbmltcG9ydCB7IGxheW91dEZyYWdtZW50IH0gZnJvbSBcIi4vVmlld0xheW91dFwiO1xuaW1wb3J0IHsgUm93LCBCdXR0b24sIFRleHRMYWJlbEZhY3RvcnksIERpYWxvZ0NvbnRhaW5lciwgV2lkZUxhYmVsLCBQYXJhZ3JhcGggfSBmcm9tIFwiLi4vLi4vVUlcIjtcbi8qKiBNb2RhbCBkaWFsb2cgbGF5b3V0IHZpZXcgdXNlZCBieSBgc2hvd01lc3NhZ2VCb3hgIHRoYXQgY29udGFpbnMgYSB0aXRsZSByb3cgZnJhZ21lbnQgYW5kIGEgYnV0dG9uIHJvdyBmcmFnbWVudCwgYW5kIGFsbCBtZXNzYWdlcyBhcyBzZXBhcmF0ZSByb3dzIGluIHRoZSBtYWluIGNvbnRlbnQgYXJlYSAqL1xudmFyIE1lc3NhZ2VCb3hMYXlvdXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlQm94TGF5b3V0LCBfc3VwZXIpO1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgbWVzc2FnZSBib3ggKHdpdGhvdXQgY29udGVudCk7IHVzZSBgc2hvd01lc3NhZ2VCb3hgIGZ1bmN0aW9uIGluc3RlYWQsIHRvIGluaXRpYWxpemUgYW5kIGRpc3BsYXkgYSBtZXNzYWdlIGJveCB3aXRoIGEgdGl0bGUsIG1lc3NhZ2UsIGFuZCBwcmVkZWZpbmVkIGJ1dHRvbnMgKi9cbiAgICBmdW5jdGlvbiBNZXNzYWdlQm94TGF5b3V0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5iaW5kRnJhZ21lbnQoXCJoZWFkZXJcIiwgXCJUaXRsZVJvd1wiKTtcbiAgICAgICAgX3RoaXMuYmluZEZyYWdtZW50KFwiZm9vdGVyXCIsIFwiQnV0dG9uUm93XCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBMYXlvdXQgZnJhZ21lbnQgZm9yIHRoZSBtZXNzYWdlIGJveCB0aXRsZSByb3csIHVzZWQgYnkgYHNob3dNZXNzYWdlQm94YCBhcyB0aGUgaGVhZGVyIG9mIG1lc3NhZ2UgYm94IGRpYWxvZ3MgdGhhdCBjb250YWluIGEgdGl0bGU7IGNhbiBiZSB1c2VkIHRvIGFwcGx5IGdsb2JhbCBzdHlsZSBvdmVycmlkZXMgKi9cbiAgICBNZXNzYWdlQm94TGF5b3V0LlRpdGxlUm93ID0gUm93LndpdGgoKTtcbiAgICAvKiogTGF5b3V0IGZyYWdtZW50IGZvciB0aGUgbWVzc2FnZSBib3ggYnV0dG9uIHJvdywgdXNlZCBieSBgc2hvd01lc3NhZ2VCb3hgIGFzIGEgZm9vdGVyIHJvdyBvbiBtZXNzYWdlIGJveCBkaWFsb2dzOyBjYW4gYmUgdXNlZCB0byBhcHBseSBnbG9iYWwgc3R5bGUgb3ZlcnJpZGVzICovXG4gICAgTWVzc2FnZUJveExheW91dC5CdXR0b25Sb3cgPSBSb3cud2l0aCgpO1xuICAgIC8qKiBNZXNzYWdlIHJvdyBjb21wb25lbnQgZmFjdG9yeSAoTk9UIGEgZnJhZ21lbnQpLCB1c2VkIGJ5IGBzaG93TWVzc2FnZUJveGAgdG8gY29uc3RydWN0IHRoZSBfZmlyc3RfIG1lc3NhZ2Ugcm93OyBjYW4gYmUgdXNlZCB0byBhcHBseSBnbG9iYWwgc3R5bGUgb3ZlcnJpZGVzICovXG4gICAgTWVzc2FnZUJveExheW91dC5GaXJzdE1lc3NhZ2VSb3cgPSBSb3cud2l0aCgpO1xuICAgIC8qKiBNZXNzYWdlIHJvdyBjb21wb25lbnQgZmFjdG9yeSAoTk9UIGEgZnJhZ21lbnQpLCB1c2VkIGJ5IGBzaG93TWVzc2FnZUJveGAgdG8gY29uc3RydWN0IHRoZSBhbGwgbWVzc2FnZSByb3dzIF9vdGhlciB0aGFuIHRoZSBmaXJzdCByb3dfOyBjYW4gYmUgdXNlZCB0byBhcHBseSBnbG9iYWwgc3R5bGUgb3ZlcnJpZGVzICovXG4gICAgTWVzc2FnZUJveExheW91dC5NZXNzYWdlUm93ID0gUm93LndpdGgoKTtcbiAgICAvKiogTGFiZWwgdXNlZCBmb3IgdGhlIGRlZmF1bHQgXCJEaXNtaXNzXCIgYnV0dG9uIHdoZW4gdGhlIGFyZ3VtZW50cyB0byBgc2hvd01lc3NhZ2VCb3hgIGRvIG5vdCBpbmNsdWRlIGEgc2luZ2xlIGJ1dHRvbjsgY2FuIGJlIGNoYW5nZWQgYnV0IG11c3QgYmUgYSBgVUkuVGV4dExhYmVsRmFjdG9yeWAgKGkuZS4gcmVzdWx0IG9mIGBVSS50bGApICovXG4gICAgTWVzc2FnZUJveExheW91dC5ESVNNSVNTX0xBQkVMID0gbmV3IFRleHRMYWJlbEZhY3RvcnkoXCJEaXNtaXNzXCIpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBsYXlvdXRGcmFnbWVudFxuICAgIF0sIE1lc3NhZ2VCb3hMYXlvdXQsIFwiVGl0bGVSb3dcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgbGF5b3V0RnJhZ21lbnRcbiAgICBdLCBNZXNzYWdlQm94TGF5b3V0LCBcIkJ1dHRvblJvd1wiLCB2b2lkIDApO1xuICAgIHJldHVybiBNZXNzYWdlQm94TGF5b3V0O1xufShCYXNlRGlhbG9nTGF5b3V0KSk7XG5leHBvcnQgeyBNZXNzYWdlQm94TGF5b3V0IH07XG4vLyBpbXBsZW1lbnRhdGlvbjpcbmV4cG9ydCBmdW5jdGlvbiBzaG93TWVzc2FnZUJveCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGxheW91dEFyZ3MgPSBbXTtcbiAgICAvLyBjaGVjayBmb3IgdGl0bGUgdGV4dFxuICAgIGlmIChhcmdzWzFdICYmICFhcmdzWzFdLmlzQ29tcG9uZW50RmFjdG9yeSkge1xuICAgICAgICAvLyBmaXJzdCBhcmd1bWVudCBpcyBub3QgdGhlIG9ubHkgdGV4dDogaXQgaXMgdGhlIHRpdGxlIHRleHRcbiAgICAgICAgdmFyIHRpdGxlQXJnID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBpZiAodHlwZW9mIHRpdGxlQXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyB1c2UgYSB3aWRlIGxhYmVsIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHRpdGxlQXJnID0gbmV3IFRleHRMYWJlbEZhY3RvcnkoXCJ7fVwiICsgdGl0bGVBcmcsIHVuZGVmaW5lZCwgZmFsc2UsIFdpZGVMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGF5b3V0QXJncy5wdXNoKE1lc3NhZ2VCb3hMYXlvdXQuVGl0bGVSb3cud2l0aCh0aXRsZUFyZywgRGlhbG9nQ29udGFpbmVyLlRvcENsb3NlQnV0dG9uKSk7XG4gICAgfVxuICAgIC8vIGFwcGVuZCBtZXNzYWdlIHRleHRcbiAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHRleHRBcmcgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIGlmICghKHRleHRBcmcgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgICAgICAgICB0ZXh0QXJnID0gW3RleHRBcmddO1xuICAgICAgICB0ZXh0QXJnLmZvckVhY2goZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBhIHBhcmFncmFwaCBsYWJlbCBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgdCA9IG5ldyBUZXh0TGFiZWxGYWN0b3J5KFwie31cIiArICh0IHx8IFwiXCIpLCB1bmRlZmluZWQsIGZhbHNlLCBQYXJhZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5b3V0QXJncy5wdXNoKGkgP1xuICAgICAgICAgICAgICAgIE1lc3NhZ2VCb3hMYXlvdXQuTWVzc2FnZVJvdy53aXRoKHQpIDpcbiAgICAgICAgICAgICAgICBNZXNzYWdlQm94TGF5b3V0LkZpcnN0TWVzc2FnZVJvdy53aXRoKHQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGlmIG5vIGJ1dHRvbiBwYXNzZWQgaW4sIHVzZSBhIGRlZmF1bHQgXCJEaXNtaXNzXCIgYnV0dG9uXG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICBhcmdzLnB1c2goQnV0dG9uLndpdGhMYWJlbChNZXNzYWdlQm94TGF5b3V0LkRJU01JU1NfTEFCRUwpKTtcbiAgICB9XG4gICAgLy8gcmVtYWluaW5nIGFyZ3Mgc2hvdWxkIGJlIEJ1dHRvbiBjb21wb25lbnQgZmFjdG9yaWVzIGF0IHRoaXMgcG9pbnRcbiAgICB2YXIgYnV0dG9ucyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIG5ldyBhcmcoKTsgfSk7XG4gICAgbGF5b3V0QXJncy5wdXNoKG5ldyBNZXNzYWdlQm94TGF5b3V0LkJ1dHRvblJvdyhidXR0b25zKSk7XG4gICAgLy8gY3JlYXRlIGFuZCBzaG93IHRoZSBkaWFsb2dcbiAgICB2YXIgZGlhbG9nID0gbmV3IChNZXNzYWdlQm94TGF5b3V0LndpdGguYXBwbHkoTWVzc2FnZUJveExheW91dCwgbGF5b3V0QXJncykpKCk7XG4gICAgZGlhbG9nLm9wZW5Bc3luYygpO1xuICAgIHJldHVybiBuZXcgQXN5bmMuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAvLyByZXNvbHZlIHdpdGggYnV0dG9uIGluZGV4IHdoZW4gY2xpY2tlZCwgYW5kIGNsb3NlIGRpYWxvZ1xuICAgICAgICBidXR0b25zLmZvckVhY2goZnVuY3Rpb24gKGIsIGkpIHtcbiAgICAgICAgICAgIGIuQ2xpY2suY29ubmVjdE9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoaSk7XG4gICAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlc29sdmUgd2l0aCB1bmRlZmluZWQgdmFsdWUgaWYgZGlzbWlzc2VkIG90aGVyd2lzZVxuICAgICAgICBkaWFsb2cuQ2xvc2VkLmNvbm5lY3RPbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXBwL1ZpZXcvTWVzc2FnZUJveC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImV4cG9ydCAqIGZyb20gXCIuL0xheW91dFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vVmlld0xheW91dFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vVmlld01hcHBpbmdcIjtcbmV4cG9ydCAqIGZyb20gXCIuL01lc3NhZ2VCb3hcIjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9BcHAvVmlldy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IEFzeW5jLCB7IFNpZ25hbCB9IGZyb20gXCIuLi8uLi9Bc3luY1wiO1xuaW1wb3J0IHsgQWN0aXZhdGlvbiB9IGZyb20gXCIuL0FjdGl2YXRpb25cIjtcbmltcG9ydCB7IEFwcGxpY2F0aW9uIH0gZnJvbSBcIi4uL0FwcGxpY2F0aW9uXCI7XG4vKiogQ3VycmVudCB1bmlxdWUgSUQgZm9yIEFjdGl2aXR5IGluc3RhbmNlcyAqL1xudmFyIF9uZXh0VUlEID0gMDtcbi8qKiBBY3Rpdml0eSBiYXNlIGNsYXNzLCByZXByZXNlbnRzIGEgVUkgYWN0aXZpdHk7IHRvIGJlIGV4dGVuZGVkIGJ5IGFwcGxpY2F0aW9uIGNvZGUsIGFuZCByZWdpc3RlcmVkIHVzaW5nIGFuIGFjdGl2YXRpb24gZGVjb3JhdG9yIChpLmUuIGBtYXBBY3RpdmF0aW9uYCBvciBgbWFwUm91dGVgKTsgY2FuIGJlIGxpbmtlZCB0byBhIHZpZXcgY2xhc3MgdG8gYmUgZGlzcGxheWVkIGJ5IGRlY29yYXRpbmcgdGhlIHZpZXcgKGBVSS5Db21wb25lbnRgIG9yIGBVSS5QYWdlYCBjbGFzcyB1c2luZyBgbWFwVmlld0FjdGl2aXR5YCkgKi9cbnZhciBBY3Rpdml0eSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGl2aXR5LCBfc3VwZXIpO1xuICAgIC8qKiBDcmVhdGUgYW4gYWN0aXZpdHkgaW5zdGFuY2UsIHVzaW5nIGdpdmVuIGFjdGl2YXRpb24gb2JqZWN0IGlmIGFueTsgaWYgdGhlIGFjdGl2YXRpb24gb2JqZWN0IGlzIHRoZSByZXN1bHQgb2YgYSByb3V0ZSBtYXBwaW5nLCBpdCBjb250YWlucyBhbGwgcm91dGluZyBwYXJhbWV0ZXJzIGFzIHN0cmluZyBwcm9wZXJ0aWVzOyBvdGhlcndpc2UgdGhlIGFjdGl2YXRpb24gb2JqZWN0IG1heSBjb250YWluIGFueSB0eXBlIG9mIGRhdGEgdGhhdCBjYW4gYmUgdXNlZCB0byBpbml0aWFsaXplIHRoZSBuZXcgYWN0aXZpdHksIGFuZCByZXBsYWNlIGl0IHdpdGggYSBuZXcgaW5zdGFuY2UgKGZvbGxvd2luZyBgQXBwbGljYXRpb24ucmVhY3RpdmF0ZWApICovXG4gICAgZnVuY3Rpb24gQWN0aXZpdHkoYWN0aXZhdGlvbikge1xuICAgICAgICBpZiAoYWN0aXZhdGlvbiA9PT0gdm9pZCAwKSB7IGFjdGl2YXRpb24gPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKiogR2xvYmFsbHkgdW5pcXVlIGFjdGl2aXR5IGlkZW50aWZpZXIgKi9cbiAgICAgICAgX3RoaXMudWlkID0gXCJBXCIgKyBfbmV4dFVJRCsrO1xuICAgICAgICAvKiogT2JqZWN0IHRoYXQgY29udGFpbnMgb3B0aW9ucyBmb3IgdGhpcyBhY3Rpdml0eSAob2JzZXJ2YWJsZSwgbmV2ZXIgbnVsbCBvciB1bmRlZmluZWQpICovXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgLyoqIFNpZ25hbCB0aGF0IGlzIGVtaXR0ZWQgYmVmb3JlIHRoaXMgYWN0aXZpdHkgaXMgcHVzaGVkIHRvIGZvcmVncm91bmQsIGlmIGFueSBoYW5kbGVyIHRocm93cyBhbiBlcnJvciB0aGVuIHRoZSBhY3Rpdml0eSBpcyBub3QgYWN0aXZhdGVkICovXG4gICAgICAgIF90aGlzLlN0YXJ0aW5nID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICAvKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCBhZnRlciB0aGlzIGFjdGl2aXR5IGlzIHB1c2hlZCB0byBmb3JlZ3JvdW5kIChub3RlIHRoYXQgYC5SZXN1bWVkYCB3aWxsIGFsc28gYWx3YXlzIGJlIGVtaXR0ZWQpICovXG4gICAgICAgIF90aGlzLlN0YXJ0ZWQgPSBTaWduYWwuY3JlYXRlKCk7XG4gICAgICAgIC8qKiBTaWduYWwgdGhhdCBpcyBlbWl0dGVkIGJlZm9yZSBhbm90aGVyIGFjdGl2aXR5IGlzIHB1c2hlZCB0byBmb3JlZ3JvdW5kLCBpZiBhbnkgaGFuZGxlciB0aHJvd3MgYW4gZXJyb3IgdGhlbiB0aGUgYWN0aXZpdHkgaXMgbm90IHN1c3BlbmRlZCAqL1xuICAgICAgICBfdGhpcy5TdXNwZW5kaW5nID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICAvKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCBhZnRlciB0aGlzIGFjdGl2aXR5IGlzIG5vIGxvbmdlciBpbiBmb3JlZ3JvdW5kICovXG4gICAgICAgIF90aGlzLlN1c3BlbmRlZCA9IFNpZ25hbC5jcmVhdGUoKTtcbiAgICAgICAgLyoqIFNpZ25hbCB0aGF0IGlzIGVtaXR0ZWQgYmVmb3JlIHRoaXMgYWN0aXZpdHkgaXMgcHV0IGJhY2sgaW4gZm9yZWdyb3VuZCwgaWYgYW55IGhhbmRsZXIgdGhyb3dzIGFuIGVycm9yIHRoZW4gdGhlIHByZXZpb3VzIGFjdGl2aXR5IGlzIG5vdCBzdXNwZW5kZWQgKi9cbiAgICAgICAgX3RoaXMuUmVzdW1pbmcgPSBTaWduYWwuY3JlYXRlKCk7XG4gICAgICAgIC8qKiBTaWduYWwgdGhhdCBpcyBlbWl0dGVkIGFmdGVyIHRoaXMgYWN0aXZpdHkgaXMgaW4gZm9yZWdyb3VuZCAoZW1pdHRlZCBhZnRlciBgLlJlc3VtaW5nYCwgb3IgYWZ0ZXIgYC5TdGFydGluZ2AgdG9nZXRoZXIgd2l0aCBgLlN0YXJ0ZWRgKSAqL1xuICAgICAgICBfdGhpcy5SZXN1bWVkID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICAvKiogU2lnbmFsIHRoYXQgaXMgZW1pdHRlZCBhZnRlciB0aGlzIGFjdGl2aXR5IGlzIHJlbW92ZWQgZnJvbSBoaXN0b3J5LCBhbmQgd2lsbCBub3QgYmUgcmVzdW1lZCBhbnltb3JlICovXG4gICAgICAgIF90aGlzLkRlYWN0aXZhdGVkID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgICAgICBpZiAoYWN0aXZhdGlvbiBpbnN0YW5jZW9mIEFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIC8vIHVzZSBnaXZlbiBhY3RpdmF0aW9uIG9iamVjdFxuICAgICAgICAgICAgX3RoaXMuYWN0aXZhdGlvbiA9IGFjdGl2YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBvYmplY3Qgc3BlY2lmaWVkLCBjcmVhdGUgY2xhc3Mgb24gdGhlIGZseVxuICAgICAgICAgICAgdmFyIERpcmVjdEFjdGl2YXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhEaXJlY3RBY3RpdmF0aW9uLCBfc3VwZXIpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIERpcmVjdEFjdGl2YXRpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIERpcmVjdEFjdGl2YXRpb247XG4gICAgICAgICAgICB9KEFjdGl2YXRpb24pKTtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2YXRpb24gPSBuZXcgRGlyZWN0QWN0aXZhdGlvbihhY3RpdmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpc1tcIkBpbml0aWFsaXplXCJdKCk7XG4gICAgICAgIEFzeW5jLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwID0gX3RoaXMub25DcmVhdGVBc3luYygpO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgX3RoaXMuU3RhcnRpbmcuY29ubmVjdE9uY2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gcDsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBHZXQgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhY3Rpdml0eSBjbGFzcywgY2FuIGJlIG92ZXJyaWRkZW4gdG8gYWx0ZXIgYmVoYXZpb3Igd2hlbiBlLmcuIHB1c2hpbmcgYSBwYXJlbnQgYWN0aXZpdHkgYnkgY2xhc3M7IGJ5IGRlZmF1bHQgc2ltcGx5IGNvbnN0cnVjdHMgdGhlIGluc3RhbmNlIHdpdGhvdXQgcGFyYW1ldGVycyAqL1xuICAgIEFjdGl2aXR5LmdldEluc3RhbmNlID0gZnVuY3Rpb24gKGFjdGl2YXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IEFjdGl2aXR5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoYWN0aXZhdGlvbik7XG4gICAgfTtcbiAgICAvKiogTWV0aG9kIHRoYXQgaXMgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHRoaXMgYWN0aXZpdHkgaXMgY3JlYXRlZDsgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBhbnkgaW5pdGlhbGl6YXRpb24gdGhhdCBtdXN0IGJlIGNvbXBsZXRlZCBiZWZvcmUgdGhlIGFjdGl2aXR5IGlzIHN0YXJ0ZWQ7IGlmIHRoaXMgbWV0aG9kIHJldHVybnMgYSBwcm9taXNlLCBpdCBtdXN0IGJlIGZ1bGZpbGxlZCBfYmVmb3JlXyB0aGUgYWN0aXZpdHkgY2FuIGJlIHB1c2hlZCB0byB0aGUgZm9yZWdyb3VuZCAqL1xuICAgIEFjdGl2aXR5LnByb3RvdHlwZS5vbkNyZWF0ZUFzeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiBub3RoaW5nIGhlcmUgKi9cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgSW5qZWN0YWJsZSBtZXRob2QgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciwgdXNlZCBieSBhY3Rpdml0eSBkZWNvcmF0b3JzICovXG4gICAgQWN0aXZpdHkucHJvdG90eXBlW19hID0gXCJAaW5pdGlhbGl6ZVwiXSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMuaW5qZWN0YWJsZVxuICAgIF0sIEFjdGl2aXR5LnByb3RvdHlwZSwgX2EsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX3N0cmluZ1xuICAgIF0sIEFjdGl2aXR5LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBBc3luYy5vYnNlcnZhYmxlX25vdF9udWxsXG4gICAgXSwgQWN0aXZpdHkucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICByZXR1cm4gQWN0aXZpdHk7XG4gICAgdmFyIF9hO1xufShBc3luYy5PYnNlcnZhYmxlT2JqZWN0KSk7XG5leHBvcnQgeyBBY3Rpdml0eSB9O1xuLyoqIFJlcHJlc2VudHMgYW4gYWN0aXZpdHkgdGhhdCBzaG91bGQgYmUgY3JlYXRlZCBvbmx5IG9uY2UgYW5kIHJlLXVzZWQgaWYgcmVxdWlyZWQgKG92ZXJyaWRlcyAuZ2V0SW5zdGFuY2Ugc3RhdGljIG1ldGhvZCk7IGFic3RyYWN0IGNsYXNzLCB0byBiZSBvdmVycmlkZGVuICovXG52YXIgU2luZ2xldG9uQWN0aXZpdHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaW5nbGV0b25BY3Rpdml0eSwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIGEgbmV3IGFjdGl2aXR5OyBjYW4gYmUgdXNlZCBvbmx5IG9uY2UgKi9cbiAgICBmdW5jdGlvbiBTaW5nbGV0b25BY3Rpdml0eShhY3RpdmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGFjdGl2YXRpb24pIHx8IHRoaXM7XG4gICAgICAgIHZhciBzZWxmID0gX3RoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChzZWxmLl9pbnN0YW5jZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgYW5vdGhlciBpbnN0YW5jZSBvZiB0aGlzIGFjdGl2aXR5XCIpO1xuICAgICAgICBzZWxmLl9pbnN0YW5jZSA9IF90aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBHZXQgdGhlIGluc3RhbmNlIG9mIHRoaXMgYWN0aXZpdHkgY2xhc3MsIGNvbnN0cnVjdHMgdGhlIGluc3RhbmNlIHdpdGhvdXQgcGFyYW1ldGVycyBvbmNlIGFuZCByZXR1cm5zIHRoaXMgaW5zdGFuY2UgZXZlcnkgdGltZSAqL1xuICAgIFNpbmdsZXRvbkFjdGl2aXR5LmdldEluc3RhbmNlID0gZnVuY3Rpb24gKGFjdGl2YXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlSW5kZXggIT09IEFwcGxpY2F0aW9uLmN1cnJlbnQuYWN0aXZhdGlvbkluZGV4KSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faW5zdGFuY2U7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZUluZGV4ID0gQXBwbGljYXRpb24uY3VycmVudC5hY3RpdmF0aW9uSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlIHx8IG5ldyB0aGlzKGFjdGl2YXRpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIFNpbmdsZXRvbkFjdGl2aXR5O1xufShBY3Rpdml0eSkpO1xuZXhwb3J0IHsgU2luZ2xldG9uQWN0aXZpdHkgfTtcbi8qKiBSZXByZXNlbnRzIGEgc2luZ2xldG9uIGFjdGl2aXR5IHRoYXQgbWF5IG9ubHkgZXhpc3QgaW4gdGhlIGJhY2tncm91bmQgKGkuZS4gaXQgc2hvdWxkIG5vdCBiZSBzdGFydGVkIGRpcmVjdGx5LCBhbmQgaXQgc2hvdWxkIGJlIHNraXBwZWQgd2hlbiBuYXZpZ2F0aW5nIGJhY2sgaW4gaGlzdG9yeSwgZW5mb3JjZWQgYnkgYEFwcGxpY2F0aW9uYCksIGNyZWF0ZWQgb25seSBvbmNlIGFuZCByZS11c2VkIGlmIHJlcXVpcmVkIChvdmVycmlkZXMgLmdldEluc3RhbmNlIHN0YXRpYyBtZXRob2QpOyBhYnN0cmFjdCBjbGFzcywgbmVlZHMgdG8gYmUgb3ZlcnJpZGRlbiAqL1xudmFyIFN1cHBvcnRBY3Rpdml0eSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1cHBvcnRBY3Rpdml0eSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdXBwb3J0QWN0aXZpdHkoYWN0aXZhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBhY3RpdmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25zLmlzQmFja2dyb3VuZEFjdGl2aXR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3VwcG9ydEFjdGl2aXR5O1xufShTaW5nbGV0b25BY3Rpdml0eSkpO1xuZXhwb3J0IHsgU3VwcG9ydEFjdGl2aXR5IH07XG4vKiogUmVwcmVzZW50cyBhIHNpbmdsZXRvbiBhY3Rpdml0eSB0aGF0IGlzIGJvdGggYSByb290IGFjdGl2aXR5IChpLmUuIG1heSBleGlzdCBvbmx5IG9uY2Ugb24gdGhlIGFjdGl2aXR5IHN0YWNrLCBzdGFydGluZy9yZXBsYWNpbmcgdGhlIGFjdGl2aXR5IGFnYWluIHRyYW5zaXRpb25zIHRoZSBzdGFjayB1cCB0byB0aGUgZXhpc3RpbmcgYWN0aXZpdHkgaW5zdGVhZCksIGFuZCBhIGh1YiBhY3Rpdml0eSAoaS5lLiBzdGFydGluZyBhbnkgYWN0aXZpdHkgdGhhdCBzcGVjaWZpZXMgdGhpcyBhY3Rpdml0eSBhcyBpdHMgcGFyZW50IGFjdGl2aXR5LCB0cmFuc2l0aW9ucyB0aGUgc3RhY2sgdXAgdG8gdGhlIGh1YiBhY3Rpdml0eSBmaXJzdCwgc3VzcGVuZGluZyBhbGwgb3RoZXIgYWN0aXZpdGllcyB0aGF0IHVzZWQgdG8gYmUgaW4gdGhlIGZvcmVncm91bmQpLCBjcmVhdGVkIG9ubHkgb25jZSBhbmQgcmUtdXNlZCBpZiByZXF1aXJlZCAob3ZlcnJpZGVzIC5nZXRJbnN0YW5jZSBzdGF0aWMgbWV0aG9kKTsgYWJzdHJhY3QgY2xhc3MsIHRvIGJlIG92ZXJyaWRkZW4gKi9cbnZhciBSb290QWN0aXZpdHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSb290QWN0aXZpdHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUm9vdEFjdGl2aXR5KGFjdGl2YXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYWN0aXZhdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3B0aW9ucy5pc0h1YkFjdGl2aXR5ID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMub3B0aW9ucy5pc1Jvb3RBY3Rpdml0eSA9IHRydWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJvb3RBY3Rpdml0eTtcbn0oU2luZ2xldG9uQWN0aXZpdHkpKTtcbmV4cG9ydCB7IFJvb3RBY3Rpdml0eSB9O1xuLyoqICpDbGFzcyBkZWNvcmF0b3IqLCBhc3NvY2lhdGVzIGEgcGFyZW50IGFjdGl2aXR5IGNsYXNzIHdpdGggdGhlIGRlY29yYXRlZCBgQWN0aXZpdHlgIGNsYXNzOiB3aGVuZXZlciBhbiBhY3Rpdml0eSBpbnN0YW5jZSBvZiB0aGUgY2xhc3MgZGVjb3JhdGVkIHdpdGggdGhpcyBkZWNvcmF0b3IgaXMgc3RhcnRlZCwgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIHBhcmVudCBhY3Rpdml0eSBjbGFzcyBtdXN0IGFscmVhZHkgZXhpc3Qgb24gdGhlIHN0YWNrLCBvciBhIChuZXcpIGluc3RhbmNlIHdpbGwgYmUgc3RhcnRlZCBpbiBhZHZhbmNlIFtkZWNvcmF0b3JdICovXG5leHBvcnQgZnVuY3Rpb24gbWFwUGFyZW50QWN0aXZpdHkocGFyZW50QWN0aXZpdHlDbGFzcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gQXN5bmMuaW5qZWN0KHRhcmdldCwge1xuICAgICAgICAgICAgXCJAaW5pdGlhbGl6ZVwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtcIkBpbml0aWFsaXplXCJdLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHBhcmVudCBhY3Rpdml0eSBjbGFzcyByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBpZiAoIShwYXJlbnRBY3Rpdml0eUNsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIEFjdGl2aXR5KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgcGFyZW50IGFjdGl2aXR5XCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyZW50QWN0aXZpdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBhcmVudEFjdGl2aXR5ICE9PSBwYXJlbnRBY3Rpdml0eUNsYXNzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIG1vcmUgdGhhbiBvbmUgcGFyZW50IGFjdGl2aXR5XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wYXJlbnRBY3Rpdml0eSA9IHBhcmVudEFjdGl2aXR5Q2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXBwL0FjdGl2aXR5L0FjdGl2aXR5LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMgZnJvbSBcIi4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBDb21wb25lbnQsIFBhZ2UgfSBmcm9tIFwiLi4vLi4vVUlcIjtcbmltcG9ydCB7IG1hcFZpZXdBY3Rpdml0eSB9IGZyb20gXCIuLi9WaWV3XCI7XG5pbXBvcnQgeyBBY3Rpdml0eSB9IGZyb20gXCIuL0FjdGl2aXR5XCI7XG4vKiogTmFtZSBmb3IgdGhlIHByb3BlcnR5IG9uIGFjdGl2YXRpb24gb2JqZWN0cywgc2V0IGJ5IGBBY3RpdmF0aW9uUm91dGVyI21hdGNoYCBhbmQgdXNlZCBieSB0aGUgYGdldFBhdGhgIG1ldGhvZCBpbmplY3RlZCBieSBgbWFwUm91dGVgLCB0aGF0IGhvbGRzIHRoZSBwYXRoIHRoYXQgYWN0dWFsbHkgbGVhZCB0byB0aGUgYWN0aXZhdGlvbiAqL1xudmFyIE1BUFJPVVRFX1BBVEhfUFJPUEVSVFkgPSBcIkBtYXBSb3V0ZS5wYXRoXCI7XG4vKiogRnVuY3Rpb25zIHRoYXQgcmV0dXJuIGFuIEFjdGl2YXRpb24gaW5zdGFuY2UgaWYgYSBnaXZlbiBwYXRoIG1hdGNoZXMgdGhlIHN0b3JlZCByb3V0ZTsgaGFzaGVkIGJ5IHJvdXRlIHN0cmluZyB0byBhdm9pZCBkdXBsaWNhdGlvbiAqL1xudmFyIHJvdXRlcnNCeVJvdXRlID0ge307XG4vKiogTGlzdCBvZiByb3V0ZXMgY3VycmVudGx5IG1hcHBlZCAod2l0aCBtYXRjaGVycyBpbiBgcm91dGVyc0J5Um91dGVgKSAqL1xudmFyIHJvdXRlc0xpc3QgPSBbXTtcbi8qKiBMb29rdXAgdGFibGUgb2Yga25vd24gbmFtZWQgcm91dGVzICovXG52YXIgbmFtZWRSb3V0ZXMgPSB7fTtcbi8qKiBFbmNhcHN1bGF0ZXMgYSBjb21tYW5kIHRvIHN0YXJ0IGFuIGFjdGl2aXR5OyBzaG91bGQgYmUgZXh0ZW5kZWQgaW50byB1bmlxdWUgY2xhc3NlcyB0aGF0IGBBY3Rpdml0eWAgY2xhc3NlcyBjYW4gYmUgbWFwcGVkIHRvIHVzaW5nIGBtYXBBY3RpdmF0aW9uYCwgYW5kIHdoaWNoIGNhbiBiZSBtYXBwZWQgdG8gcm91dGVzIHVzaW5nIGBtYXBSb3V0ZWA7IHRoZSBsYXR0ZXIgd2lsbCBlbmFibGUgc2F2aW5nIHBhcnRzIG9mIGEgcGF0aCAoVVJMKSB0byBwcm9wZXJ0aWVzIG9uIHRoZSBhY3RpdmF0aW9uIG9iamVjdCAqL1xudmFyIEFjdGl2YXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgYWN0aXZhdGlvbiBvYmplY3QsIHdoaWNoIGNhbiBiZSB1c2VkICh3aXRoIGEgZGVyaXZlZCBjbGFzcykgdG8gc3RhcnQgYW4gYWN0aXZpdHkgYmFzZWQgb24gdGhlIEFjdGl2YXRpb24gY2xhc3MgdHlwZSwgYW5kIHN0b3JlZCBwcm9wZXJ0eSB2YWx1ZXM7IGNvcGllcyBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBnaXZlbiBvYmplY3QsIGlmIGFueSAqL1xuICAgIGZ1bmN0aW9uIEFjdGl2YXRpb24ocHJvcGVydGllcykge1xuICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgLy8gY29weSBhbGwgZ2l2ZW4gcHJvcGVydGllcyB0byB0aGlzIGluc3RhbmNlXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9wZXJ0aWVzLCBwKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpc1twXSA9IHByb3BlcnRpZXNbcF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBuZXcgYWN0aXZhdGlvbiBvYmplY3QgZm9yIHRoZSBnaXZlbiByb3V0ZSBwYXRoIChtdXN0IHN0YXJ0IHdpdGggYC9gIG9yIGAjL2ApLCBvciB1bmRlZmluZWQgaWYgbm9uZSBvZiB0aGUgY3VycmVudGx5IG1hcHBlZCByb3V0ZXMgbWF0Y2ggKi9cbiAgICBBY3RpdmF0aW9uLnJvdXRlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbGlzdCBvZiBtYXBwZWQgcm91dGVzIGFuZCBydW4gbWF0Y2hlcnMgb25lIGJ5IG9uZVxuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgJiYgL14jP1xcLy8udGVzdChwYXRoKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByb3V0ZXNMaXN0XzEgPSByb3V0ZXNMaXN0OyBfaSA8IHJvdXRlc0xpc3RfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHJvdXRlc0xpc3RfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJvdXRlcnNCeVJvdXRlW3JdLm1hdGNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYWN0aXZpdHkgaW5zdGFuY2UsIG9yIGZvciB1bmRlZmluZWQgaWYgbm8gYEFjdGl2aXR5YCBjbGFzcyBpcyBtYXBwZWQgdG8gdGhpcyBhY3RpdmF0aW9uIHR5cGU7IHRoaXMgbWV0aG9kIGlzIGluamVjdGVkIGJ5IGBtYXBBY3RpdmF0aW9uYCwgYnV0IGNhbiBhbHNvIGJlIG92ZXJyaWRkZW4gZGlyZWN0bHkgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZiBjcmVhdGluZyBhY3Rpdml0aWVzIGZvciBhY3RpdmF0aW9uIG9iamVjdHMgKGUuZy4gdGVzdGluZyBmb3IgdmFsaWQgSURzLCBvciBsYXp5IGxvYWRpbmcpICovXG4gICAgQWN0aXZhdGlvbi5wcm90b3R5cGUuZ2V0QWN0aXZpdHlBc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gKGluamVjdGVkIGJ5IG1hcEFjdGl2YXRpb24pXG4gICAgICAgIHJldHVybiBBc3luYy5Qcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBmdWxsIHBhdGggdGhhdCB3aWxsIHJvdXRlIHRvIHRoaXMgYWN0aXZhdGlvbiBvYmplY3QgKG9yIHRoZSBwYXRoIHRoYXQgdGhpcyBvYmplY3Qgd2FzIGFjdHVhbGx5IGNyZWF0ZWQgZm9yLCB1c2luZyBgbWFwUm91dGVgKSwgb3IgdW5kZWZpbmVkIGlmIG5vIHJvdXRlIGhhcyBiZWVuIG1hcHBlZCB0byB0aGlzIGFjdGl2YXRpb24gY2xhc3Mgb3IgaWYgb25lIG9mIHRoZSByb3V0ZSBwYXJhbWV0ZXJzIGlzIG1pc3NpbmcgKi9cbiAgICBBY3RpdmF0aW9uLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAoaW5qZWN0ZWQgYnkgbWFwUm91dGUpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgQXN5bmMuaW5qZWN0YWJsZVxuICAgIF0sIEFjdGl2YXRpb24ucHJvdG90eXBlLCBcImdldEFjdGl2aXR5QXN5bmNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIEFzeW5jLmluamVjdGFibGVcbiAgICBdLCBBY3RpdmF0aW9uLnByb3RvdHlwZSwgXCJnZXRQYXRoXCIsIG51bGwpO1xuICAgIHJldHVybiBBY3RpdmF0aW9uO1xufSgpKTtcbmV4cG9ydCB7IEFjdGl2YXRpb24gfTtcbi8qKiBBY3RpdmF0aW9uIHJvdXRlciAoaW50ZXJuYWwpLCBjcmVhdGVkIGZvciBhIG1hcHBlZCByb3V0ZSAqL1xudmFyIEFjdGl2YXRpb25Sb3V0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjdGl2YXRpb25Sb3V0ZXIocm91dGUsIHRhcmdldCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgLy8gZGlzc2VjdCBnaXZlbiByb3V0ZSBmb3IgZmFzdGVyIG1hdGNoaW5nIGxhdGVyXG4gICAgICAgIHRoaXMuX3JvdXRlU2VnbWVudHMgPSByb3V0ZS5zcGxpdChcIi9cIikuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiAhIXM7IH0pO1xuICAgICAgICB0aGlzLl9pc0hhc2hSb3V0ZSA9IHRoaXMuX3JvdXRlU2VnbWVudHNbMF0gPT09IFwiI1wiO1xuICAgICAgICBpZiAodGhpcy5faXNIYXNoUm91dGUpXG4gICAgICAgICAgICB0aGlzLl9yb3V0ZVNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0aGlzLl9yb3V0ZVNlZ21lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGhpcy5fcm91dGVTZWdtZW50c1swXVswXSA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzdWIgcm91dGUsIHJlbW92ZSAmIHN0b3JlIGZpcnN0IHNlZ21lbnRcbiAgICAgICAgICAgIHRoaXMuX2lzU3ViUm91dGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50Um91dGVOYW1lID0gdGhpcy5fcm91dGVTZWdtZW50cy5zaGlmdCgpLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBmdWxsIHBhdGggdGhhdCB3aWxsIHJvdXRlIHRvIGdpdmVuIGFjdGl2YXRpb24gb2JqZWN0IChvciB0aGUgcGF0aCB0aGF0IHRoZSBvYmplY3Qgd2FzIGFjdHVhbGx5IGNyZWF0ZWQgZm9yLCB1c2luZyBgbWFwUm91dGVgKSwgb3IgdW5kZWZpbmVkIGlmIG5vIHJvdXRlIGhhcyBiZWVuIG1hcHBlZCB0byB0aGUgYWN0aXZhdGlvbiBjbGFzcyBvciBpZiBvbmUgb2YgdGhlIHJvdXRlIHBhcmFtZXRlcnMgaXMgbWlzc2luZyAqL1xuICAgIEFjdGl2YXRpb25Sb3V0ZXIucHJvdG90eXBlLmdldFBhdGhGb3IgPSBmdW5jdGlvbiAoYWN0aXZhdGlvbikge1xuICAgICAgICBpZiAoYWN0aXZhdGlvbltNQVBST1VURV9QQVRIX1BST1BFUlRZXSkge1xuICAgICAgICAgICAgLy8gdXNlIGFjdHVhbCBwYXRoIHVzZWRcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmF0aW9uW01BUFJPVVRFX1BBVEhfUFJPUEVSVFldO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5faXNTdWJSb3V0ZSkge1xuICAgICAgICAgICAgLy8gZ2V0IHBhdGggZnJvbSBwYXJlbnQgYWN0aXZhdGlvbiByb3V0ZXIgZmlyc3RcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBuYW1lZFJvdXRlc1t0aGlzLl9wYXJlbnRSb3V0ZU5hbWVdO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudC5nZXRQYXRoRm9yKGFjdGl2YXRpb24pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faXNIYXNoUm91dGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiI1wiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBhbGwgcGF0aCBzZWdtZW50cyBmb3IgdGhpcyByb3V0ZVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fcm91dGVTZWdtZW50czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRbMF0gPT09IFwiKlwiIHx8IHNlZ21lbnRbMF0gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gc3Vic3RpdHV0ZSBhY3RpdmF0aW9uIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYWN0aXZhdGlvbltzZWdtZW50LnNsaWNlKDEpXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIvXCIgKyB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgc2VnbWVudCBsaXRlcmFsbHlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIvXCIgKyBzZWdtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIG5ldyBhY3RpdmF0aW9uIG9iamVjdCBpZiB0aGUgZ2l2ZW4gcGF0aCBtYXRjaGVzIHRoZSBtYXBwZWQgcm91dGUgKi9cbiAgICBBY3RpdmF0aW9uUm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBpZHggPSAocGF0aFswXSA9PT0gXCIjXCIpID8gMSA6IDA7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3JvdXRlU2VnbWVudHM7XG4gICAgICAgIGlmICghc2VnbWVudHMubGVuZ3RoICYmIHRoaXMuX2lzSGFzaFJvdXRlICYmIC9eW14jXSojPyQvKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgbWF0Y2ggaG9tZSBwYXRoICMvIGZvciBhIGhhc2hsZXNzIHBhdGhcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy50YXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNTdWJSb3V0ZSkge1xuICAgICAgICAgICAgLy8gbG9vayBmb3IgcGFyZW50IHJvdXRlIGZpcnN0LCBwcmVwZW5kIHNlZ21lbnRzXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbmFtZWRSb3V0ZXNbdGhpcy5fcGFyZW50Um91dGVOYW1lXTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoISFpZHggIT09IHBhcmVudC5faXNIYXNoUm91dGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHNlZ21lbnRzID0gcGFyZW50Ll9yb3V0ZVNlZ21lbnRzLnNsaWNlKDApO1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaC5hcHBseShzZWdtZW50cywgdGhpcy5fcm91dGVTZWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnaXZlIHVwIGVhcmx5IGlmIG5vdCBoYXNoIHJvdXRlIGFuZCBwYXRoXG4gICAgICAgICAgICBpZiAoISFpZHggIT09IHRoaXMuX2lzSGFzaFJvdXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWF0Y2ggcm91dGUgc2VnbWVudHMgb25lIGJ5IG9uZVxuICAgICAgICB2YXIgc2VnbWVudElkeCA9IDAsIHBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgd2hpbGUgKHNlZ21lbnRJZHggPCBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2lkeCsrXSAhPT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA8PSBpZHgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBzcGVjID0gc2VnbWVudHNbc2VnbWVudElkeCsrXTtcbiAgICAgICAgICAgIGlmIChzcGVjWzBdID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgIC8vIG1hdGNoIGdsb2I6IHN0b3JlIHJlbWFpbmRlciBpbiBhIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbc3BlYy5zbGljZSgxKV0gPSBwYXRoLnNsaWNlKGlkeCk7XG4gICAgICAgICAgICAgICAgaWR4ID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaW5kIG5leHQgc2VnbWVudCBpbiBnaXZlbiBwYXRoXG4gICAgICAgICAgICB2YXIgZW5kID0gcGF0aC5pbmRleE9mKFwiL1wiLCBpZHgpO1xuICAgICAgICAgICAgaWYgKGVuZCA8IDApXG4gICAgICAgICAgICAgICAgZW5kID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc3BlY1swXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXRjaCBwYXJhbWV0ZXI6IHN0b3JlIG5leHQgc2VnbWVudCBpbiBhIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbc3BlYy5zbGljZSgxKV0gPSBwYXRoLnNsaWNlKGlkeCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNwZWMgIT09IHBhdGguc2xpY2UoaWR4LCBlbmQpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VnbWVudCBkb2VzIG5vdCBtYXRjaFxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZHggPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsIHNlZ21lbnRzIG1hdGNoZWQsIGlmIHBhdGggaXMgZnVsbHkgY29uc3VtZWQgdGhlbiBjcmVhdGUgdGhlIGFjdGl2YXRpb25cbiAgICAgICAgaWYgKGlkeCA+PSBwYXRoLmxlbmd0aCB8fCBwYXRoLnNsaWNlKGlkeCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzW01BUFJPVVRFX1BBVEhfUFJPUEVSVFldID0gcGF0aDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy50YXJnZXQocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gbWF0Y2g6IHBhdGggaXMgbG9uZ2VyIHRoYW4gcm91dGVcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBBY3RpdmF0aW9uUm91dGVyO1xufSgpKTtcbi8qKiAqQ2xhc3MgZGVjb3JhdG9yKiwgbWFwcyB0aGUgZGVjb3JhdGVkIGBBY3RpdmF0aW9uYCAoc3ViKSBjbGFzcyBPUiBgQWN0aXZpdHlgIGNsYXNzIE9SIGBDb21wb25lbnRgICh1aSBtb2R1bGUpIGNsYXNzIHRvIHRoZSBnaXZlbiByb3V0ZSAoZS5nIGBkYXNoYm9hcmRgLCBgL3VzZXJzLzp1c2VySUQvcG9zdC86cG9zdElEYCBvciBgIy9kb2NzLypkb2NOYW1lYCk7IGlmIGEgbmFtZSBpcyBwcm92aWRlZCwgaXQgY2FuIGJlIHVzZWQgYXQgdGhlIHN0YXJ0IG9mIHN1YiByb3V0ZXMsIHVzaW5nIGAmbmFtZS9zdWIvcm91dGVgICh3aXRob3V0IGxlYWRpbmcgaGFzaC9zbGFzaCBjaGFycyk7IG11bHRpcGxlIHJvdXRlcyBjYW4gYmUgYWRkZWQgcGVyIGNsYXNzOyBpZiB0aGUgZGVjb3JhdGVkIGNsYXNzIGlzIGFuIGBBY3Rpdml0eWAgY2xhc3MsIGEgdW5pcXVlIGBBY3RpdmF0aW9uYCBzdWIgY2xhc3MgaXMgZ2VuZXJhdGVkIGF1dG9tYXRpY2FsbHksIGFuZCBpZiB0aGUgZGVjb3JhdGVkIGNsYXNzIGlzIGEgVUkgYENvbXBvbmVudGAgb3IgYFBhZ2VgIGNsYXNzLCBhIHVuaXF1ZSBgQWN0aXZpdHlgIGNsYXNzIGlzIGFsc28gZ2VuZXJhdGVkIFtkZWNvcmF0b3JdICovXG5leHBvcnQgZnVuY3Rpb24gbWFwUm91dGUocm91dGUsIG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAvLyBpZiB0YXJnZXQgaXMgYSB2aWV3IGNsYXNzLCBnZW5lcmF0ZSB1bmlxdWUgQWN0aXZpdHkgY2xhc3NcbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUgaW5zdGFuY2VvZiBDb21wb25lbnQgfHxcbiAgICAgICAgICAgIHRhcmdldC5wcm90b3R5cGUgaW5zdGFuY2VvZiBQYWdlKSB7XG4gICAgICAgICAgICB2YXIgVmlld0FjdGl2aXR5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoTWFwcGVkVmlld0FjdGl2aXR5LCBfc3VwZXIpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1hcHBlZFZpZXdBY3Rpdml0eSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTWFwcGVkVmlld0FjdGl2aXR5O1xuICAgICAgICAgICAgfShBY3Rpdml0eSkpO1xuICAgICAgICAgICAgbWFwVmlld0FjdGl2aXR5KFZpZXdBY3Rpdml0eSkodGFyZ2V0KTtcbiAgICAgICAgICAgIHRhcmdldCA9IFZpZXdBY3Rpdml0eTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0YXJnZXQgaXMgYW4gYWN0aXZpdHkgY2xhc3MsIGdlbmVyYXRlIHVuaXF1ZSBBY3RpdmF0aW9uIGNsYXNzXG4gICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlIGluc3RhbmNlb2YgQWN0aXZpdHkpIHtcbiAgICAgICAgICAgIHZhciBhY3RpdmF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoTWFwcGVkQWN0aXZhdGlvbiwgX3N1cGVyKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBNYXBwZWRBY3RpdmF0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBNYXBwZWRBY3RpdmF0aW9uO1xuICAgICAgICAgICAgfShBY3RpdmF0aW9uKSk7XG4gICAgICAgICAgICBtYXBBY3RpdmF0aW9uKGFjdGl2YXRpb24pKHRhcmdldCk7XG4gICAgICAgICAgICB0YXJnZXQgPSBhY3RpdmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlIGFjdGl2YXRpb24gcm91dGUgZm9yIHVzZSB3aGlsZSBtYXRjaGluZyBwYXRocyB0byByb3V0ZXNcbiAgICAgICAgaWYgKHJvdXRlc0xpc3QuaW5kZXhPZihyb3V0ZSkgPCAwKVxuICAgICAgICAgICAgcm91dGVzTGlzdC51bnNoaWZ0KHJvdXRlKTtcbiAgICAgICAgdmFyIHJvdXRlciA9IG5ldyBBY3RpdmF0aW9uUm91dGVyKHJvdXRlLCB0YXJnZXQpO1xuICAgICAgICByb3V0ZXJzQnlSb3V0ZVtyb3V0ZV0gPSByb3V0ZXI7XG4gICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgbmFtZWRSb3V0ZXNbbmFtZV0gPSByb3V0ZXI7XG4gICAgICAgIC8vIGluamVjdCBtZXRob2QgZm9yIGdlbmVyYXRpbmcgYSBmdWxsIHBhdGggZm9yIGFuIGFjdGl2YXRpb24gb2JqZWN0XG4gICAgICAgIEFzeW5jLmluamVjdCh0YXJnZXQsIHtcbiAgICAgICAgICAgIGdldFBhdGg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5nZXRQYXRoRm9yKHRoaXMpOyB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKiogKkNsYXNzIGRlY29yYXRvciosIG1hcHMgdGhlIGRlY29yYXRlZCBgQWN0aXZpdHlgIGNsYXNzIHRvIGdpdmVuIGBBY3RpdmF0aW9uYCB0eXBlLCBzbyB0aGF0IHJvdXRlZCAocGF0aC9VUkwpIGFuZCBtYW51YWwgYWN0aXZhdGlvbnMgKHVzaW5nIGFuIGFjdGl2YXRpb24gb2JqZWN0KSBsZWFkIHRvIHRoZSBpbnN0YW50aWF0aW9uIG9mIHRoZSBkZWNvcmF0ZWQgYEFjdGl2aXR5YCBbZGVjb3JhdG9yXSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEFjdGl2YXRpb24oYWN0aXZhdGlvblR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAvLyBpbmplY3QgbWV0aG9kIHRvIG9idGFpbiBhbiBhY3Rpdml0eSBmb3IgaW5zdGFuY2VzIG9mIHRoaXMgYWN0aXZhdGlvbiB0eXBlXG4gICAgICAgIEFzeW5jLmluamVjdChhY3RpdmF0aW9uVHlwZSwge1xuICAgICAgICAgICAgZ2V0QWN0aXZpdHlBc3luYzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBc3luYy5Qcm9taXNlLnJlc29sdmUodGFyZ2V0LmdldEluc3RhbmNlKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9BcHAvQWN0aXZpdHkvQWN0aXZhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCBBc3luYywgeyBTaWduYWwgfSBmcm9tIFwiLi4vLi4vQXN5bmNcIjtcbmltcG9ydCB7IEFjdGl2aXR5IH0gZnJvbSBcIi4vQWN0aXZpdHlcIjtcbnZhciBjdXJyZW50SGlzdG9yeUlEQmFzZSA9IFwiX0FcIiArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgtNSk7XG52YXIgY3VycmVudEhpc3RvcnlJRCA9IDA7XG52YXIgbmV4dFRyYW5zaXRpb25JRCA9IDA7XG52YXIgcHJldmlvdXNUcmFuc2l0aW9uO1xuLyoqIFJlcHJlc2VudHMgYSBzdGFjayBvZiBhY3RpdmF0ZWQgYWN0aXZpdGllcyAobGlrZSBicm93c2VyIGhpc3RvcnkpICovXG52YXIgQWN0aXZpdHlTdGFjayA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWN0aXZpdHlTdGFjaygpIHtcbiAgICAgICAgLyoqIFNpZ25hbCB0aGF0IGlzIGVtaXR0ZWQgd2hlbiBhIHRyYW5zaXRpb24gb2NjdXJzIChhZnRlciBTdGFydGluZy9SZXN1bWluZy9TdXNwZW5kaW5nIGJ1dCBiZWZvcmUgU3RhcnRlZC9SZXN1bWVkKSAqL1xuICAgICAgICB0aGlzLlRyYW5zaXRpb24gPSBTaWduYWwuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMuX2lkeCA9IEFzeW5jLk9ic2VydmFibGVWYWx1ZS5mcm9tVmFsdWUoLTEpO1xuICAgICAgICB0aGlzLl9zdGFjayA9IG5ldyBBc3luYy5PYnNlcnZhYmxlQXJyYXkoKTtcbiAgICAgICAgdGhpcy5faWRzID0gW107XG4gICAgfVxuICAgIC8qKiBBZGQgYW4gYWN0aXZpdHkgdG8gdGhlIGZvcmVncm91bmQgYXN5bmNocm9ub3VzbHksIGRvZXMgbm90aGluZyBpZiBnaXZlbiBhY3Rpdml0eSB3YXMgYWxyZWFkeSBpbiB0aGUgZm9yZWdyb3VuZDsgcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNvbXBsZXRlZCB0cmFuc2l0aW9uICovXG4gICAgQWN0aXZpdHlTdGFjay5wcm90b3R5cGUucHVzaEFzeW5jID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghKGFjdGl2aXR5IGluc3RhbmNlb2YgQWN0aXZpdHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhY3Rpdml0eVwiKTtcbiAgICAgICAgLy8gcHVzaCBhY3Rpdml0eSBhbmQgaXRzIHBhcmVudHMgb24gdGhlIHN0YWNrXG4gICAgICAgIHRoaXMuX3BvcFRyYW5zaWVudCgpO1xuICAgICAgICB0aGlzLl91cFRvSHViT3JSb290KGFjdGl2aXR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25QID0gKHRoaXMuX3RyYW5zaXRpb25QIHx8IEFzeW5jLlByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzVHJhbnNpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBfdGhpcy5fZmluZFBhcmVudHMoYWN0aXZpdHkpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9wcm9jZXNzVHJhbnNpdGlvbihhLCBBY3Rpdml0eVRyYW5zaXRpb24uT3BlcmF0aW9uLlB1c2gpOyB9O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdC50aGVuKHApIDogcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJlcGxhY2UgdGhlIGN1cnJlbnQgYWN0aXZpdHkgYXN5bmNocm9ub3VzbHkgKHRocm93cyBlcnJvciBpZiBub25lKSwgb3IgcmVtb3ZlIGN1cnJlbnQgYWN0aXZpdHkgaWYgZ2l2ZW4gYWN0aXZpdHkgd2FzIGFscmVhZHkgZGlyZWN0bHkgYmVsb3cgY3VycmVudCBhY3Rpdml0eSBpbiB0aGUgYWN0aXZpdHkgc3RhY2s7IHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjb21wbGV0ZWQgdHJhbnNpdGlvbiAqL1xuICAgIEFjdGl2aXR5U3RhY2sucHJvdG90eXBlLnJlcGxhY2VBc3luYyA9IGZ1bmN0aW9uIChhY3Rpdml0eSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIShhY3Rpdml0eSBpbnN0YW5jZW9mIEFjdGl2aXR5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYWN0aXZpdHlcIik7XG4gICAgICAgIC8vIHByb2Nlc3MgcmVwbGFjZSB0cmFuc2FjdGlvblxuICAgICAgICB0aGlzLl9wb3BUcmFuc2llbnQoKTtcbiAgICAgICAgdGhpcy5fdXBUb0h1Yk9yUm9vdChhY3Rpdml0eSk7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uUCA9ICh0aGlzLl90cmFuc2l0aW9uUCB8fCBBc3luYy5Qcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICBwcmV2aW91c1RyYW5zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgbG9uZWx5ID0gKF90aGlzLnRvcEluZGV4IDwgMCk7XG4gICAgICAgICAgICAvLyBwb3AgaWYgYWxyZWFkeSBkaXJlY3RseSBiZWxvdywgb3RoZXJ3aXNlIHJlcGxhY2Ugb3IgcHVzaFxuICAgICAgICAgICAgaWYgKCFsb25lbHkgJiYgX3RoaXMuX3N0YWNrW190aGlzLnRvcEluZGV4IC0gMV0gPT09IGFjdGl2aXR5KVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcHJvY2Vzc1RyYW5zaXRpb24oYWN0aXZpdHksIEFjdGl2aXR5VHJhbnNpdGlvbi5PcGVyYXRpb24uUG9wKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UvcHVzaCBhY3Rpdml0eSBhbmQgaXRzIHBhcmVudHMgb24gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZmluZFBhcmVudHMoYWN0aXZpdHksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcHJvY2Vzc1RyYW5zaXRpb24oYSwgKHJlc3VsdCB8fCBsb25lbHkpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIEFjdGl2aXR5VHJhbnNpdGlvbi5PcGVyYXRpb24uUHVzaCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBBY3Rpdml0eVRyYW5zaXRpb24uT3BlcmF0aW9uLlJlcGxhY2UpOyB9O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQudGhlbihwKSA6IHAoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQWN0aXZpdHlTdGFjay5wcm90b3R5cGUucG9wQXN5bmMgPSBmdW5jdGlvbiAoYWN0aXZpdHkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25QID0gKHRoaXMuX3RyYW5zaXRpb25QIHx8IEFzeW5jLlByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJldmlvdXNUcmFuc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKF90aGlzLnRvcEluZGV4IDwgMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhY3Rpdml0eSB0byBzdXNwZW5kXCIpO1xuICAgICAgICAgICAgaWYgKGFjdGl2aXR5ICE9PSB1bmRlZmluZWQgJiYgX3RoaXMudG9wICE9PSBhY3Rpdml0eSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQXN5bmMuUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAvLyBzZW5kIHNpZ25hbHMgYW5kIHJldHVybiBwcm9taXNlXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3Byb2Nlc3NUcmFuc2l0aW9uKF90aGlzLl9zdGFja1tfdGhpcy50b3BJbmRleCAtIDFdLCBBY3Rpdml0eVRyYW5zaXRpb24uT3BlcmF0aW9uLlBvcCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFJlbW92ZSBmb3JlZ3JvdW5kIGFjdGl2aXRpZXMgdW50aWwgZ2l2ZW4gYWN0aXZpdHkgb3IgYWN0aXZpdHkgb2YgZ2l2ZW4gdHlwZSBpcyBpbiB0aGUgZm9yZWdyb3VuZDsgcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYWN0aXZpdHksIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2hpbmcgYWN0aXZpdHkgb24gdGhlIHN0YWNrICovXG4gICAgQWN0aXZpdHlTdGFjay5wcm90b3R5cGUudXBBc3luYyA9IGZ1bmN0aW9uIChhY3Rpdml0eU9yQ2xhc3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlzQWN0aXZpdHkgPSAoYWN0aXZpdHlPckNsYXNzIGluc3RhbmNlb2YgQWN0aXZpdHkpO1xuICAgICAgICB2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc0FjdGl2aXR5ID9cbiAgICAgICAgICAgICAgICAoX3RoaXMudG9wID09PSBhY3Rpdml0eU9yQ2xhc3MpIDpcbiAgICAgICAgICAgICAgICAoX3RoaXMudG9wIGluc3RhbmNlb2YgYWN0aXZpdHlPckNsYXNzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQXN5bmMuUHJvbWlzZS5yZXNvbHZlKF90aGlzLnRvcCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3N0YWNrLnNvbWUoZnVuY3Rpb24gKGFjdGl2aXR5KSB7IHJldHVybiBpc0FjdGl2aXR5ID9cbiAgICAgICAgICAgICAgICAoYWN0aXZpdHkgPT09IGFjdGl2aXR5T3JDbGFzcykgOlxuICAgICAgICAgICAgICAgIChhY3Rpdml0eSBpbnN0YW5jZW9mIGFjdGl2aXR5T3JDbGFzcyk7IH0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcHJvY2Vzc1RyYW5zaXRpb24oX3RoaXMuX3N0YWNrW190aGlzLnRvcEluZGV4IC0gMV0sIEFjdGl2aXR5VHJhbnNpdGlvbi5PcGVyYXRpb24uUG9wKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZWN1cnNlKCk7IH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBBc3luYy5Qcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25QID0gKHRoaXMuX3RyYW5zaXRpb25QIHx8IEFzeW5jLlByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJldmlvdXNUcmFuc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogUmVsb2FkIHN0YXRlIHVzaW5nIGdpdmVuIGhpc3RvcnkgSUQsIGlmIHBvc3NpYmxlIChpLmUuIG5vdCB5ZXQgZGVhY3RpdmF0ZWQgcmVsZXZhbnQgYWN0aXZpdGllcyBpbiB0aGUgbWVhbnRpbWUpOyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIHJlYWNoZWQgKi9cbiAgICBBY3Rpdml0eVN0YWNrLnByb3RvdHlwZS5yZXN0b3JlSGlzdG9yeVN0YXRlQXN5bmMgPSBmdW5jdGlvbiAoaGlzdG9yeUlEKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLl9pZHMubGFzdEluZGV4T2YoaGlzdG9yeUlEKTtcbiAgICAgICAgaWYgKGlkeCA8IDAgJiYgaGlzdG9yeUlEICE9PSBcIjBcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXN1bWUgYWN0aXZpdGllc1wiKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gdGhpcy50b3BJbmRleClcbiAgICAgICAgICAgIHJldHVybiBBc3luYy5Qcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgLy8gZWl0aGVyIGdvIGJhY2sgb3IgZ28gZm9yd2FyZCBhbmQgY2hlY2sgYWdhaW5cbiAgICAgICAgcmV0dXJuIChpZHggPCB0aGlzLnRvcEluZGV4ID9cbiAgICAgICAgICAgIHRoaXMucG9wQXN5bmMoKSA6XG4gICAgICAgICAgICB0aGlzLnB1c2hBc3luYyh0aGlzLl9zdGFja1t0aGlzLnRvcEluZGV4ICsgMV0pKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVzdG9yZUhpc3RvcnlTdGF0ZUFzeW5jKGhpc3RvcnlJRCk7IH0pO1xuICAgIH07XG4gICAgLyoqIEdldCBhbiBJRCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgc3RhdGUsIGZvciB1c2Ugd2l0aCBgLnJlc3RvcmVIaXN0b3J5U3RhdGVBc3luY2AgKi9cbiAgICBBY3Rpdml0eVN0YWNrLnByb3RvdHlwZS5nZXRIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZHNbdGhpcy50b3BJbmRleF0gfHwgXCIwXCI7XG4gICAgfTtcbiAgICAvKiogR2V0IHRoZSBhY3Rpdml0eSBjbG9zZXN0IHRvIHRoZSBmb3JlZ3JvdW5kIG9mIHRoZSBnaXZlbiB0eXBlLCBpZiBhbnkgKGV4Y2x1ZGluZyBmb3JlZ3JvdW5kIGFjdGl2aXR5IGl0c2VsZiwgYW5kIGJlZm9yZSBnaXZlbiBhY3Rpdml0eSBpbiBzZWNvbmQgcGFyYW1ldGVyLCBpZiBhbnkpICovXG4gICAgQWN0aXZpdHlTdGFjay5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKEFjdGl2aXR5Q2xhc3MsIGJlZm9yZSkge1xuICAgICAgICB2YXIgc2VlbkJlZm9yZSA9ICh0aGlzLl9zdGFja1t0aGlzLnRvcEluZGV4XSA9PT0gYmVmb3JlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudG9wSW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKChzZWVuQmVmb3JlIHx8ICFiZWZvcmUpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhY2tbaV0gaW5zdGFuY2VvZiBBY3Rpdml0eUNsYXNzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFja1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGFja1tpXSA9PT0gYmVmb3JlKVxuICAgICAgICAgICAgICAgIHNlZW5CZWZvcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBzdGFjayBjb250YWlucyBnaXZlbiBhY3Rpdml0eSAqL1xuICAgIEFjdGl2aXR5U3RhY2sucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRvcEluZGV4OyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGFja1tpXSA9PT0gYWN0aXZpdHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVN0YWNrLnByb3RvdHlwZSwgXCJ0b3BcIiwge1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgZm9yZWdyb3VuZCBhY3Rpdml0eSAodG9wIG9mIHN0YWNrLCBpZiBhbnk7IG9ic2VydmFibGUpICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9wSW5kZXggPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy50b3BJbmRleF07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVN0YWNrLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBhY3Rpdml0aWVzIG9uIHRoZSBzdGFjayAob2JzZXJ2YWJsZSkgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3BJbmRleCArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVN0YWNrLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB7XG4gICAgICAgIC8qKiBUaGUgdGl0bGUgb2YgdGhlIHRvcG1vc3QgYWN0aXZpdHkgdGhhdCBoYXMgYSB0aXRsZSBkZWZpbmVkIChvYnNlcnZhYmxlKSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRvcEluZGV4OyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhY2tbaV0udGl0bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrW2ldLnRpdGxlO1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBDcmVhdGUgYW4gYWN0aXZpdHkgY3Vyc29yIHRoYXQgc3RhcnRzIGF0IHRoZSB0b3Agb2YgdGhpcyBzdGFjaywgYW5kIGNhbiBtb3ZlIGJhY2sgb24gdGhlIHN0YWNrIGFuZCB0byBwYXJlbnQgYWN0aXZpdGllczsgaWYgdGhlIGBhY3Rpdml0eWAgcHJvcGVydHkgaXMgdW5kZWZpbmVkLCB0aGUgY3Vyc29yIGhhcyByZWFjaGVkIHRoZSBlbmQ7IG5vdGUgdGhhdCBhbnkgY2hhbmdlcyB0byB0aGUgc3RhY2sgd2hpbGUgdGhlIGN1cnNvciBpcyBpbiB1c2UgbWF5IHlpZWxkIHVuZXhwZWN0ZWQgcmVzdWx0cyAqL1xuICAgIEFjdGl2aXR5U3RhY2sucHJvdG90eXBlLmdldEN1cnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGN1cnNvciA9IGZ1bmN0aW9uIChpZHgsIHN0YWNrKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgYWN0aXZpdHlTdGFjazogX3RoaXMsXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3Vyc29yKGlkeCwgc3RhY2spOyB9LFxuICAgICAgICAgICAgZ2V0IGFjdGl2aXR5KCkge1xuICAgICAgICAgICAgICAgIGlmIChpZHggPj0gc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBpZHggPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGlmIChpZHggPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tpZHhdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdvQmFjazogZnVuY3Rpb24gKCkgeyBpZHgtLTsgcmV0dXJuIHRoaXM7IH0sXG4gICAgICAgICAgICBnb1BhcmVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5hY3Rpdml0eTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gY3VycmVudC5vcHRpb25zLnBhcmVudEFjdGl2aXR5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDbGFzcyA9ICh0eXBlb2YgcGFyZW50ID09PSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGlkeC0tOyBpZHggPj0gMDsgaWR4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBzdGFja1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHBhcmVudCB8fCBpc0NsYXNzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnQgaW5zdGFuY2VvZiBwYXJlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTsgfTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcih0aGlzLnRvcEluZGV4LCB0aGlzLl9zdGFjayk7XG4gICAgfTtcbiAgICAvKiogSGVscGVyIG1ldGhvZCB0byBmaW5kIHBhcmVudCBhY3Rpdml0eS9pZXMgZm9yIGdpdmVuIGFjdGl2aXR5OyByZXR1cm5zIGFuIGFycmF5IG9mIGFjdGl2aXRpZXMgdG8gYmUgcHVzaGVkIChpbmNsdWRpbmcgYWN0aXZpdHkgaXRzZWxmKSAqL1xuICAgIEFjdGl2aXR5U3RhY2sucHJvdG90eXBlLl9maW5kUGFyZW50cyA9IGZ1bmN0aW9uIChhY3Rpdml0eSwgZXhjbHVkZVRvcCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW2FjdGl2aXR5XTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdFswXS5vcHRpb25zLnBhcmVudEFjdGl2aXR5KSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgcGFyZW50IGlzIG9uIHN0YWNrIHNvbWV3aGVyZVxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJlc3VsdFswXS5vcHRpb25zLnBhcmVudEFjdGl2aXR5O1xuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFjdGl2aXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbnMocGFyZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWV4Y2x1ZGVUb3AgfHwgdGhpcy50b3AgIT09IHBhcmVudCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKCFleGNsdWRlVG9wICYmICh0aGlzLnRvcCBpbnN0YW5jZW9mIHBhcmVudCkpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UGFyZW50KHBhcmVudCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHBhcmVudC5nZXRJbnN0YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqIEhlbHBlciBtZXRob2QgdG8gbW92ZSB1cCB0byBleGlzdGluZyByb290IGFjdGl2aXR5LCBvciBodWIgcGFyZW50IGFjdGl2aXR5IGlmIG5lZWRlZCAqL1xuICAgIEFjdGl2aXR5U3RhY2sucHJvdG90eXBlLl91cFRvSHViT3JSb290ID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGFjdGl2aXR5IGlzIGEgcm9vdCBhY3Rpdml0eSBhbmQgbW92ZSB1cCBpZiBwb3NzaWJsZVxuICAgICAgICBpZiAoYWN0aXZpdHkub3B0aW9ucy5pc1Jvb3RBY3Rpdml0eSAmJiB0aGlzLmNvbnRhaW5zKGFjdGl2aXR5KSkge1xuICAgICAgICAgICAgdGhpcy51cEFzeW5jKGFjdGl2aXR5KTtcbiAgICAgICAgICAgIC8vIHdhaXQgdW50aWwgYnJvd3NlciBoaXN0b3J5IGlzIHN5bmNocm9uaXplZFxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvblAgPVxuICAgICAgICAgICAgICAgICh0aGlzLl90cmFuc2l0aW9uUCB8fCBBc3luYy5Qcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gQXN5bmMuc2xlZXAoMik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgZXhpc3RpbmcgcGFyZW50IGFjdGl2aXR5IGlzIGEgaHViIGFjdGl2aXR5XG4gICAgICAgICAgICB2YXIgcGFyZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9IGFjdGl2aXR5Lm9wdGlvbnMucGFyZW50QWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBBY3Rpdml0eSkpXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KHBhcmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQub3B0aW9ucy5pc0h1YkFjdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwQXN5bmMocGFyZW50KTtcbiAgICAgICAgICAgICAgICAvLyB3YWl0IHVudGlsIGJyb3dzZXIgaGlzdG9yeSBpcyBzeW5jaHJvbml6ZWRcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uUCA9XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl90cmFuc2l0aW9uUCB8fCBBc3luYy5Qcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFzeW5jLnNsZWVwKDIpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEhlbHBlciBtZXRob2QgdG8gcmVtb3ZlIGEgdHJhbnNpZW50IGFjdGl2aXR5IGlmIG5lZWRlZCAqL1xuICAgIEFjdGl2aXR5U3RhY2sucHJvdG90eXBlLl9wb3BUcmFuc2llbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRvcCAmJiB0aGlzLnRvcC5vcHRpb25zLmlzVHJhbnNpZW50KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudC5hY3Rpdml0eSAmJiBjdXJyZW50LmFjdGl2aXR5Lm9wdGlvbnMuaXNUcmFuc2llbnQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmdvQmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQuYWN0aXZpdHkpXG4gICAgICAgICAgICAgICAgdGhpcy51cEFzeW5jKGN1cnJlbnQuYWN0aXZpdHkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogSGVscGVyIG1ldGhvZCBmb3Igc2VuZGluZyBzaWduYWxzIGFuZCBjcmVhdGluZyBwcm9taXNlICovXG4gICAgQWN0aXZpdHlTdGFjay5wcm90b3R5cGUuX3Byb2Nlc3NUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHRvLCBvcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBjcmVhdGUgdHJhbnNpdGlvbiBvcGVyYXRpb25cbiAgICAgICAgdmFyIHQgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIGlkOiBcIlRcIiArIG5leHRUcmFuc2l0aW9uSUQrKyxcbiAgICAgICAgICAgIGFjdGl2aXR5U3RhY2s6IHRoaXMsXG4gICAgICAgICAgICBvcDogb3AsIHRvOiB0bywgZnJvbTogdGhpcy50b3AsXG4gICAgICAgICAgICBwcmV2aW91czogcHJldmlvdXNUcmFuc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91c1RyYW5zaXRpb24gPSB0O1xuICAgICAgICAvLyBjaGVjayBpZiBhbnl0aGluZyB0byBkbyBhdCBhbGxcbiAgICAgICAgaWYgKHRoaXMudG9wID09PSB0bykge1xuICAgICAgICAgICAgaWYgKG9wID09PSBBY3Rpdml0eVRyYW5zaXRpb24uT3BlcmF0aW9uLlBvcClcbiAgICAgICAgICAgICAgICB0aGlzLnRvcEluZGV4LS07XG4gICAgICAgICAgICByZXR1cm4gQXN5bmMuUHJvbWlzZS5yZXNvbHZlKHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdhdGhlciBwcm9taXNlcyBmb3IgU3VzcGVuZGluZyByZXN1bHRzXG4gICAgICAgIHZhciB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdmFyIHN1c3BlbnNlID0gdG9wID8gbmV3IHRvcC5TdXNwZW5kaW5nKHQpLmVtaXQoKS5yZXN1bHRzIDogW107XG4gICAgICAgIC8vIHRyeSB0byBhY3RpdmF0ZS9yZXN1bWUgbmV3IGFjdGl2aXR5IGFuZCByZXR1cm4gcHJvbWlzZVxuICAgICAgICB2YXIgcmVzdW1pbmcgPSAhIXRvICYmIHRoaXMuY29udGFpbnModG8pO1xuICAgICAgICByZXR1cm4gQXN5bmMuUHJvbWlzZS5hbGwoc3VzcGVuc2UpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBzaWduYWwgdGhhdCB0cmFuc2l0aW9uIGlzIGFib3V0IHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIEFzeW5jLlByb21pc2UuYWxsKHJlc3VtaW5nID9cbiAgICAgICAgICAgICAgICBuZXcgdC50by5SZXN1bWluZyh0KS5lbWl0KCkucmVzdWx0cyA6XG4gICAgICAgICAgICAgICAgdC50byA/IG5ldyB0LnRvLlN0YXJ0aW5nKHQpLmVtaXQoKS5yZXN1bHRzIDogW10pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gd2hlbiBhbGwgaGFuZGxlcnMgYXJlIE9LLCBnbyBhaGVhZDpcbiAgICAgICAgICAgIF90aGlzLlRyYW5zaXRpb24odCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHQub3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlIEFjdGl2aXR5VHJhbnNpdGlvbi5PcGVyYXRpb24uUG9wOlxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGRlY3JlYXNlIHN0YWNrIHRvcFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50b3BJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEFjdGl2aXR5VHJhbnNpdGlvbi5PcGVyYXRpb24uUmVwbGFjZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVjcmVhc2Ugc3RhY2sgdG9wIGFuZCB0aGVuIHB1c2hcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9wSW5kZXgtLTtcbiAgICAgICAgICAgICAgICBjYXNlIEFjdGl2aXR5VHJhbnNpdGlvbi5PcGVyYXRpb24uUHVzaDpcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBtb3ZlIHN0YWNrIHRvcCBpZiBzYW1lIGFjdGl2aXR5IGFib3ZlXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhY2subGVuZ3RoID4gX3RoaXMudG9wSW5kZXggKyAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3RhY2tbX3RoaXMudG9wSW5kZXggKyAxXSA9PT0gdC50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9wSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlYWN0aXZhdGUgb3ZlcndyaXR0ZW4gc3RhY2sgdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoX3RoaXMuX3N0YWNrLmxlbmd0aCA+IF90aGlzLnRvcEluZGV4ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRUb3AgPSBfdGhpcy5fc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5jb250YWlucyhvbGRUb3ApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRUb3AuRGVhY3RpdmF0ZWQodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIG5ldyBhY3Rpdml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9wSW5kZXggPSBfdGhpcy5fc3RhY2sucHVzaCh0LnRvKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faWRzLmxlbmd0aCA9IF90aGlzLl9zdGFjay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faWRzW190aGlzLnRvcEluZGV4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEhpc3RvcnlJREJhc2UgKyBjdXJyZW50SGlzdG9yeUlEKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNpZ25hbCB0aGF0IHRyYW5zaXRpb24gaGFzIGhhcHBlbmVkXG4gICAgICAgICAgICBpZiAodC50bykge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdW1pbmcpXG4gICAgICAgICAgICAgICAgICAgIHQudG8uU3RhcnRlZCh0KTtcbiAgICAgICAgICAgICAgICB0LnRvLlJlc3VtZWQodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3AgJiYgdG9wLlN1c3BlbmRlZCh0KTtcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBY3Rpdml0eVN0YWNrLnByb3RvdHlwZSwgXCJ0b3BJbmRleFwiLCB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZHgudmFsdWU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHsgdGhpcy5faWR4LnZhbHVlID0gdjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEFjdGl2aXR5U3RhY2s7XG59KCkpO1xuZXhwb3J0IHsgQWN0aXZpdHlTdGFjayB9O1xuZXhwb3J0IHZhciBBY3Rpdml0eVRyYW5zaXRpb247XG4oZnVuY3Rpb24gKEFjdGl2aXR5VHJhbnNpdGlvbikge1xuICAgIC8qKiBPcGVyYXRpb24gdHlwZSB0aGF0IHRyaWdnZXJlZCBhIHRyYW5zaXRpb24gKi9cbiAgICB2YXIgT3BlcmF0aW9uO1xuICAgIChmdW5jdGlvbiAoT3BlcmF0aW9uKSB7XG4gICAgICAgIC8qKiBQdXNoIG9wZXJhdGlvbiAqL1xuICAgICAgICBPcGVyYXRpb25bT3BlcmF0aW9uW1wiUHVzaFwiXSA9IDBdID0gXCJQdXNoXCI7XG4gICAgICAgIC8qKiBSZXBsYWNlIG9wZXJhdGlvbiAqL1xuICAgICAgICBPcGVyYXRpb25bT3BlcmF0aW9uW1wiUmVwbGFjZVwiXSA9IDFdID0gXCJSZXBsYWNlXCI7XG4gICAgICAgIC8qKiBQb3Agb3BlcmF0aW9uICovXG4gICAgICAgIE9wZXJhdGlvbltPcGVyYXRpb25bXCJQb3BcIl0gPSAyXSA9IFwiUG9wXCI7XG4gICAgfSkoT3BlcmF0aW9uID0gQWN0aXZpdHlUcmFuc2l0aW9uLk9wZXJhdGlvbiB8fCAoQWN0aXZpdHlUcmFuc2l0aW9uLk9wZXJhdGlvbiA9IHt9KSk7XG4gICAgO1xufSkoQWN0aXZpdHlUcmFuc2l0aW9uIHx8IChBY3Rpdml0eVRyYW5zaXRpb24gPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL0FwcC9BY3Rpdml0eS9BY3Rpdml0eVN0YWNrLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZXhwb3J0ICogZnJvbSBcIi4vQWN0aXZhdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vQWN0aXZpdHlcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0FjdGl2aXR5U3RhY2tcIjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9BcHAvQWN0aXZpdHkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmltcG9ydCB7IFNlcnZpY2UsIG1hcFNlcnZpY2UgfSBmcm9tIFwiLi4vU2VydmljZVwiO1xuLyoqIFF1aWNrIDItZGlnaXQgbnVtYmVyIHBhZGRpbmcgaW1wbGVtZW50YXRpb24gZm9yIGRhdGUvdGltZSBmb3JtYXR0aW5nICovXG52YXIgZDIgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gbiA8IDEwID8gXCIwXCIgKyBuIDogU3RyaW5nKG4pOyB9O1xuLyoqIFF1aWNrIDQtZGlnaXQgbnVtYmVyIHBhZGRpbmcgaW1wbGVtZW50YXRpb24gZm9yIHllYXIgZm9ybWF0dGluZyAqL1xuZnVuY3Rpb24gZDQobikge1xuICAgIHZhciBzID0gU3RyaW5nKGQ0KTtcbiAgICByZXR1cm4gXCIwMDBcIi5zbGljZSgwLCBNYXRoLm1heCgzIC0gcy5sZW5ndGgsIDApKSArIHM7XG59XG47XG4vKiogU3RyaW5nIHNwbGl0dGVyIGZvciBkYXkvbW9udGggbmFtZXMgKi9cbnZhciBjYXBTcGxpdCA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnNwbGl0KC8oPz1bQS1aXSkvKTsgfTtcbi8qKiBFbmdsaXNoIHdlZWtkYXkgbmFtZXMgKi9cbnZhciBkYXlOYW1lcyA9IGNhcFNwbGl0KFwiU3VuZGF5TW9uZGF5VHVlc2RheVdlZG5lc2RheVRodXJzZGF5RnJpZGF5U2F0dXJkYXlcIik7XG4vKiogRW5nbGlzaCBhYmJyZXZpYXRlZCB3ZWVrZGF5IG5hbWVzICovXG52YXIgZGF5TmFtZXNBYmJyID0gY2FwU3BsaXQoXCJTdW5Nb25UdWVXZWRUaHVGcmlTYXRcIik7XG4vKiogRW5nbGlzaCBtb250aCBuYW1lcyAqL1xudmFyIG1vbnRoTmFtZXMgPSBjYXBTcGxpdChcIkphbnVhcnlGZWJydWFyeU1hcmNoQXByaWxNYXlKdW5lSnVseUF1Z3VzdFNlcHRlbWJlck9jdG9iZXJOb3ZlbWJlckRlY2VtYmVyXCIpO1xuLyoqIEVuZ2xpc2ggYWJicmV2aWF0ZWQgbW9udGggbmFtZXMgKi9cbnZhciBtb250aE5hbWVzQWJiciA9IGNhcFNwbGl0KFwiSmFuRmViTWFyQXByTWF5SnVuSnVsQXVnU2VwT2N0Tm92RGVjXCIpO1xuLyoqIEJhc2UgY3VsdHVyZSBzZXJ2aWNlIChtYXBwZWQgb24gYGN1bHR1cmUtbmV1dHJhbGAgYW5kIGBjdWx0dXJlYCBpbml0aWFsbHkpOyB0byBiZSBvdmVycmlkZGVuIHdpdGggYSBsYW5ndWFnZSBhbmQgcmVnaW9uIHNwZWNpZmljIGN1bHR1cmUgc2VydmljZSwgbWFwcGVkIGFzIGBjdWx0dXJlLXh4LVlZL3p6YCwgYW5kIGFsaWFzZWQgYXMgYGN1bHR1cmVgIHVzaW5nIGBhZGRTZXJ2aWNlQWxpYXNgIHRvIHNldCBhcyB0aGUgY3VycmVudCBjdWx0dXJlICovXG52YXIgQ3VsdHVyZVNlcnZpY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDdWx0dXJlU2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdWx0dXJlU2VydmljZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGlzIGN1bHR1cmUsIGRlZmF1bHRzIHRvIFwibm9uZVwiIGJ1dCBzaG91bGQgYmUgc2V0IHRvIF9sYW5ndWFnZWNvZGUtY291bnRyeWNvZGUvcmVnaW9uY29kZV8gYW5kL29yIHNob3J0ZXIgZm9ybXMgc3VjaCBhcyBfbGFuZ3VhZ2Vjb2RlLWNvdW50cnljb2RlXyBhbmQgX2xhbmd1YWdlY29kZV8gKi9cbiAgICAgICAgX3RoaXMubmFtZSA9IFwibmV1dHJhbFwiO1xuICAgICAgICAvKiogQ29sbGVjdGlvbiBvZiBkYXRlL3RpbWUgZm9ybWF0dGVycyBzcGVjaWZpYyB0byB0aGlzIGN1bHR1cmUsIHVzZWQgYnkgYC5mb3JtYXREYXRlVGltZWA7IGRlZmF1bHRzIHRvIGEgbW9zdGx5IGludGVybmF0aW9uYWwgRW5nbGlzaCBmb3JtYXQ7IHJlcGxhY2VtZW50IGFsZ29yaXRobSByZXF1aXJlcyBpbmNsdXNpb24gb2YgYWxsIGxlbmd0aHMgb2YgcG9zc2libGUgcGxhY2Vob2xkZXJzIChpbmNsdWRpbmcgZS5nLiBgeXl5YCBhbmQgYCVgKSAqL1xuICAgICAgICBfdGhpcy5kYXRlVGltZUZvcm1hdHRlcnMgPSB7XG4gICAgICAgICAgICBcImRcIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZ2V0RGF0ZSgpLnRvU3RyaW5nKCk7IH0sXG4gICAgICAgICAgICBcImRkXCI6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkMihkLmdldERhdGUoKSk7IH0sXG4gICAgICAgICAgICBcImRkZFwiOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGF5TmFtZXNBYmJyW2QuZ2V0RGF5KCldOyB9LFxuICAgICAgICAgICAgXCJkZGRkXCI6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkYXlOYW1lc1tkLmdldERheSgpXTsgfSxcbiAgICAgICAgICAgIFwiaFwiOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gKGQuZ2V0SG91cnMoKSAlIDEyIHx8IDEyKS50b1N0cmluZygpOyB9LFxuICAgICAgICAgICAgXCJoaFwiOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZDIoZC5nZXRIb3VycygpICUgMTIgfHwgMTIpOyB9LFxuICAgICAgICAgICAgXCJIXCI6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmdldEhvdXJzKCkudG9TdHJpbmcoKTsgfSxcbiAgICAgICAgICAgIFwiSEhcIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQyKGQuZ2V0SG91cnMoKSk7IH0sXG4gICAgICAgICAgICBcIm1cIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZ2V0TWludXRlcygpLnRvU3RyaW5nKCk7IH0sXG4gICAgICAgICAgICBcIm1tXCI6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkMihkLmdldE1pbnV0ZXMoKSk7IH0sXG4gICAgICAgICAgICBcIk1cIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIFN0cmluZyhkLmdldE1vbnRoKCkgKyAxKTsgfSxcbiAgICAgICAgICAgIFwiTU1cIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQyKGQuZ2V0TW9udGgoKSArIDEpOyB9LFxuICAgICAgICAgICAgXCJNTU1cIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIG1vbnRoTmFtZXNBYmJyW2QuZ2V0TW9udGgoKV07IH0sXG4gICAgICAgICAgICBcIk1NTU1cIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIG1vbnRoTmFtZXNbZC5nZXRNb250aCgpXTsgfSxcbiAgICAgICAgICAgIFwic1wiOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5nZXRTZWNvbmRzKCkudG9TdHJpbmcoKTsgfSxcbiAgICAgICAgICAgIFwic3NcIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQyKGQuZ2V0U2Vjb25kcygpKTsgfSxcbiAgICAgICAgICAgIFwidFwiOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gKGQuZ2V0SG91cnMoKSA8IDEyID8gXCJhXCIgOiBcInBcIik7IH0sXG4gICAgICAgICAgICBcInR0XCI6IGZ1bmN0aW9uIChkKSB7IHJldHVybiAoZC5nZXRIb3VycygpIDwgMTIgPyBcIkFNXCIgOiBcIlBNXCIpOyB9LFxuICAgICAgICAgICAgXCJ5XCI6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBTdHJpbmcoZC5nZXRGdWxsWWVhcigpICUgMTAwKTsgfSxcbiAgICAgICAgICAgIFwieXlcIjogZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQyKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCk7IH0sXG4gICAgICAgICAgICBcInl5eVwiOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZDIoZC5nZXRGdWxsWWVhcigpICUgMTAwKTsgfSxcbiAgICAgICAgICAgIFwieXl5eVwiOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7IH0sXG4gICAgICAgICAgICBcIi9cIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCIvXCI7IH0sXG4gICAgICAgICAgICBcIjpcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCI6XCI7IH0sXG4gICAgICAgICAgICBcIiVcIjogZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJcIjsgfSxcbiAgICAgICAgICAgIFwiJWRcIjogZnVuY3Rpb24gKGQsIHMpIHsgcmV0dXJuIHMuZm9ybWF0RGF0ZVRpbWUoZCwgXCJkL00veVwiKTsgfSxcbiAgICAgICAgICAgIFwiJWRkXCI6IGZ1bmN0aW9uIChkLCBzKSB7IHJldHVybiBzLmZvcm1hdERhdGVUaW1lKGQsIFwiZCBNTU0geXl5eVwiKTsgfSxcbiAgICAgICAgICAgIFwiJWRkZFwiOiBmdW5jdGlvbiAoZCwgcykgeyByZXR1cm4gcy5mb3JtYXREYXRlVGltZShkLCBcImQgTU1NTSB5eXl5XCIpOyB9LFxuICAgICAgICAgICAgXCIlZGRkZFwiOiBmdW5jdGlvbiAoZCwgcykgeyByZXR1cm4gcy5mb3JtYXREYXRlVGltZShkLCBcImRkZGQsIGQgTU1NTSB5eXl5XCIpOyB9LFxuICAgICAgICAgICAgXCIldFwiOiBmdW5jdGlvbiAoZCwgcykgeyByZXR1cm4gcy5mb3JtYXREYXRlVGltZShkLCBcImg6bW0gdHRcIik7IH0sXG4gICAgICAgICAgICBcIiV0dFwiOiBmdW5jdGlvbiAoZCwgcykgeyByZXR1cm4gcy5mb3JtYXREYXRlVGltZShkLCBcImg6bW06c3MgdHRcIik7IH0sXG4gICAgICAgICAgICBcIiVUXCI6IGZ1bmN0aW9uIChkLCBzKSB7IHJldHVybiBzLmZvcm1hdERhdGVUaW1lKGQsIFwiSDptbVwiKTsgfSxcbiAgICAgICAgICAgIFwiJVRUXCI6IGZ1bmN0aW9uIChkLCBzKSB7IHJldHVybiBzLmZvcm1hdERhdGVUaW1lKGQsIFwiSDptbTpzc1wiKTsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogVHJhbnNsYXRlIGdpdmVuIHRleHQgKG1heSBpbmNsdWRlIHBsYWNlaG9sZGVycyBhbmQgcHJlZml4ZXMgdXNlZCBieSBgVUkudGxgKSAqL1xuICAgIEN1bHR1cmVTZXJ2aWNlLnByb3RvdHlwZS50cmFuc2xhdGVUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICAvKiogUGx1cmFsaXplIHRleHQgYmFzZWQgb24gZ2l2ZW4gbnVtYmVyIGFuZCBzdWJzdGl0dXRpb24gZm9ybShzKTsgZGVmYXVsdHMgdG8gRW5nbGlzaCBzaW5ndWxhci9wbHVyYWwgcnVsZXMgd2l0aG91dCBhdXRvbWF0aWMgcGx1cmFsaXphdGlvbiAoaS5lLiBib3RoIHNpbmd1bGFyIGFuZCBwbHVyYWwgZm9ybXMgbmVlZCB0byBiZSBzcGVjaWZpZWQgaW4gdGhlIHBsYWNlaG9sZGVyKSAqL1xuICAgIEN1bHR1cmVTZXJ2aWNlLnByb3RvdHlwZS5wbHVyYWxpemVUZXh0ID0gZnVuY3Rpb24gKG4sIGZvcm1zKSB7XG4gICAgICAgIHJldHVybiAobiA+IDEgfHwgbiA8IC0xKSA/IChmb3Jtc1sxXSB8fCBmb3Jtc1swXSkgOiBmb3Jtc1swXTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGdpdmVuIG51bWJlciBmb3JtYXR0ZWQgdXNpbmcgY3VsdHVyZSBzcGVjaWZpYyBydWxlcywgYW5kIHVzaW5nIGdpdmVuIHByZWNpc2lvbiAoaS5lLiBmaXhlZCBudW1iZXIgb2YgZGVjaW1hbHMgdG8gZGlzcGxheSBlLmcuIGAyLjAwYCwgYW5kL29yIHJvdW5kaW5nIGF0IGdpdmVuIG51bWJlciBvZiBkZWNpbWFscywgZGVmYXVsdCA4LCB0byBhdm9pZCBiaW5hcnktdG8tZGVjaW1hbCByb3VuZGluZyBlcnJvcnMgc3VjaCBhcyBgMS45OTk5OTk5OWAuLi4pOyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHVzZXMgZGVjaW1hbCBwb2ludCAoYC5gKSBhbmQgbm8gdGhvdXNhbmRzIHNlcGFyYXRvcnMsIGJ1dCBtYXkgcmV2ZXJ0IHRvIHNjaWVudGlmaWMgbm90YXRpb24gZm9yIG51bWJlcnMgd2l0aCBtb3JlIHRoYW4gMjAgZGlnaXRzIChwbGF0Zm9ybSBkZWZhdWx0KSAqL1xuICAgIEN1bHR1cmVTZXJ2aWNlLnByb3RvdHlwZS5mb3JtYXROdW1iZXIgPSBmdW5jdGlvbiAobiwgZml4ZWREZWNpbWFscywgcm91bmREZWNpbWFscykge1xuICAgICAgICBpZiAocm91bmREZWNpbWFscyA9PT0gdm9pZCAwKSB7IHJvdW5kRGVjaW1hbHMgPSA4OyB9XG4gICAgICAgIGlmICh0eXBlb2YgbiAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIG4gPSBwYXJzZUZsb2F0KG4pO1xuICAgICAgICBpZiAocm91bmREZWNpbWFscyA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gMTtcbiAgICAgICAgICAgIHdoaWxlIChyb3VuZERlY2ltYWxzLS0pXG4gICAgICAgICAgICAgICAgZmFjdG9yICo9IDEwO1xuICAgICAgICAgICAgbiA9IE1hdGgucm91bmQobiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpeGVkRGVjaW1hbHMgPj0gMCA/IG4udG9GaXhlZChmaXhlZERlY2ltYWxzKSA6IFN0cmluZyhuKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGdpdmVuIG51bWJlciBmb3JtYXR0ZWQgYXMgYSBjdXJyZW5jeSwgd2l0aCBnaXZlbiBjdXJyZW5jeSBzeW1ib2wgYW5kIGZpeGVkIG51bWJlciBvZiBkZWNpbWFsczsgZGVmYXVsdHMgdG8gXCIkXCIsIG5vbi1icmVha2luZyBzcGFjZSwgYW5kIG51bWJlciB3aXRoIDIgZml4ZWQgZGVjaW1hbHM7IHNwZWNpZmljIGN1bHR1cmUgaW1wbGVtZW50YXRpb25zIHNob3VsZCBvdmVycmlkZSBkZWZhdWx0cyBidXQgc3RpbGwgYWNjZXB0IHRoZSBzYW1lIGFyZ3VtZW50cyAqL1xuICAgIEN1bHR1cmVTZXJ2aWNlLnByb3RvdHlwZS5mb3JtYXRDdXJyZW5jeSA9IGZ1bmN0aW9uIChuLCBjdXJyZW5jeVN5bWJvbCwgZml4ZWREZWNpbWFscykge1xuICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2wgPT09IHZvaWQgMCkgeyBjdXJyZW5jeVN5bWJvbCA9IFwiJFwiOyB9XG4gICAgICAgIGlmIChmaXhlZERlY2ltYWxzID09PSB2b2lkIDApIHsgZml4ZWREZWNpbWFscyA9IDI7IH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5U3ltYm9sICsgXCJcXHhhMFwiICsgdGhpcy5mb3JtYXROdW1iZXIobiwgZml4ZWREZWNpbWFscyk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBnaXZlbiBudW1iZXIgZm9ybWF0dGVkIGFzIGEgcGVyY2VudGFnZSwgd2l0aCBnaXZlbiBwZXJjZW50YWdlIHN5bWJvbCBhbmQgZml4ZWQgbnVtYmVyIG9mIGRlY2ltYWxzOyBkZWZhdWx0cyB0byBudW1iZXIgd2l0aG91dCBmaXhlZCBkZWNpbWFscyBhbmQgXCIlXCIgY2hhcmFjdGVyOyBzcGVjaWZpYyBjdWx0dXJlIGltcGxlbWVudGF0aW9ucyBzaG91bGQgb3ZlcnJpZGUgZGVmYXVsdHMgYnV0IHN0aWxsIGFjY2VwdCB0aGUgc2FtZSBhcmd1bWVudHMgKi9cbiAgICBDdWx0dXJlU2VydmljZS5wcm90b3R5cGUuZm9ybWF0UGVyY2VudGFnZSA9IGZ1bmN0aW9uIChuLCBwZXJjU3ltYm9sLCBmaXhlZERlY2ltYWxzKSB7XG4gICAgICAgIGlmIChwZXJjU3ltYm9sID09PSB2b2lkIDApIHsgcGVyY1N5bWJvbCA9IFwiJVwiOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdE51bWJlcihuLCBmaXhlZERlY2ltYWxzKSArIHBlcmNTeW1ib2w7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBnaXZlbiBkYXRlL3RpbWUgZm9ybWF0dGVkIHVzaW5nIGdpdmVuIGZvcm1hdCBzdHJpbmcgKGUuZy4gYGRkL01NTS95eXl5IEhIOm1tYCkgdXNpbmcgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHBsYWNlaG9sZGVycywgd2hpY2ggbWF5IGJlIChyZS0pIGRlZmluZWQgYnkgdGhlIGN1bHR1cmUgc2VydmljZSAoZGVmYXVsdHMgdG8gYCVkZCAldGApOlxuICAgICAqICogYCVkYDogc2hvcnQgZGF0ZSwgZS5nLiAyMC8xLzE3LFxuICAgICAqICogYCVkZGA6IG1lZGl1bSBkYXRlLCBlLmcuIDIwIEphbiAyMDE3XG4gICAgICogKiBgJWRkZGA6IGxvbmcgZGF0ZSwgZS5nLiAyMCBKYW51YXJ5IDIwMTdcbiAgICAgKiAqIGAlZGRkZGA6IGZ1bGwgZGF0ZSwgZS5nLiBGcmlkYXksIDIwIEphbnVhcnkgMjAxN1xuICAgICAqICogYCV0YDogdGltZSwgZS5nLiAyOjIwIFBNXG4gICAgICogKiBgJXR0YDogdGltZSB3aXRoIHNlY29uZHMsIGUuZy4gMjoyMDowMCBQTVxuICAgICAqICogYCVUYDogMjQtaG91ciB0aW1lLCBlLmcuIDE0OjIwXG4gICAgICogKiBgJVRUYDogMjQtaG91ciB0aW1lIHdpdGggc2Vjb25kcywgZS5nLiAxNDoyMDowMFxuICAgICAqICogYGRgOiBkYXRlIDAtMzEsXG4gICAgICogKiBgZGRgOiBkYXRlIDAwLTMxLFxuICAgICAqICogYGRkZGA6IGFiYnJldmlhdGVkIHdlZWtkYXkgbmFtZSxcbiAgICAgKiAqIGBkZGRkYDogZnVsbCB3ZWVrZGF5IG5hbWUsXG4gICAgICogKiBgaGA6IGhvdXJzIDAtMTIsXG4gICAgICogKiBgaGhgOiBob3VycyAwMC0xMixcbiAgICAgKiAqIGBIYDogaG91cnMgMC0yMyxcbiAgICAgKiAqIGBISGA6IGhvdXJzIDAwLTIzLFxuICAgICAqICogYG1gOiBtaW51dGVzIDAtNTksXG4gICAgICogKiBgbW1gOiBtaW51dGVzIDAwLTU5LFxuICAgICAqICogYE1gOiBtb250aCAwLTEyLFxuICAgICAqICogYE1NYDogbW9udGggMDAtMTIsXG4gICAgICogKiBgTU1NYDogYWJicmV2aWF0ZWQgbW9udGggbmFtZSxcbiAgICAgKiAqIGBNTU1NYDogZnVsbCBtb250aCBuYW1lLFxuICAgICAqICogYHNgOiBzZWNvbmRzIDAtNTksXG4gICAgICogKiBgc3NgOiBzZWNvbmRzIDAwLTU5LFxuICAgICAqICogYHRgOiBhL3AsXG4gICAgICogKiBgdHRgOiBBTS9QTSxcbiAgICAgKiAqIGB5YDogeWVhciAwLTk5LFxuICAgICAqICogYHl5YDogeWVhciAwMC05OSxcbiAgICAgKiAqIGB5eXl5YDogeWVhciAwMDAwLTk5OTksXG4gICAgICogKiBgL2A6IGRhdGUgc2VwYXJhdG9yLFxuICAgICAqICogYDpgOiB0aW1lIHNlcGFyYXRvclxuICAgICAqL1xuICAgIEN1bHR1cmVTZXJ2aWNlLnByb3RvdHlwZS5mb3JtYXREYXRlVGltZSA9IGZ1bmN0aW9uIChkLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7IGZvcm1hdCA9IFwiJWRkICV0XCI7IH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmb3JtYXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRbaV0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGZvcm1hdFtpICsgMV0gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpLCBidWYgPSBcIlwiOyBqIDwgbGVuICYmIHRoaXMuZGF0ZVRpbWVGb3JtYXR0ZXJzW2J1ZiArIGZvcm1hdFtqXV07KVxuICAgICAgICAgICAgICAgIGJ1ZiArPSBmb3JtYXRbaisrXTtcbiAgICAgICAgICAgIGlmIChidWYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5kYXRlVGltZUZvcm1hdHRlcnNbYnVmXShkLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpID0gaiAtIDE7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gZm9ybWF0W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBDdWx0dXJlU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBtYXBTZXJ2aWNlKFwiY3VsdHVyZS1uZXV0cmFsXCIsIFwiY3VsdHVyZVwiKVxuICAgIF0sIEN1bHR1cmVTZXJ2aWNlKTtcbiAgICByZXR1cm4gQ3VsdHVyZVNlcnZpY2U7XG59KFNlcnZpY2UpKTtcbmV4cG9ydCB7IEN1bHR1cmVTZXJ2aWNlIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXBwL0N1bHR1cmUvQ3VsdHVyZVNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5pbXBvcnQgQXN5bmMsIHsgU2lnbmFsIH0gZnJvbSBcIi4uLy4uL0FzeW5jXCI7XG5pbXBvcnQgeyBTY3JlZW4sIFRleHRMYWJlbEZhY3RvcnkgfSBmcm9tIFwiLi4vLi4vVUlcIjtcbmltcG9ydCB7IGluamVjdFNlcnZpY2UgfSBmcm9tIFwiLi4vU2VydmljZVwiO1xuLyoqIEhlbHBlciBjbGFzcyB1c2VkIHRvIHN1YnNjcmliZSB0byBjdWx0dXJlIGNoYW5nZXMgYW5kIHVwZGF0ZSBVSSBtb2R1bGUgcHJvcGVydGllcyAqL1xudmFyIE9ic2VydmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYnNlcnZlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGN1cnJlbnRDdWx0dXJlO1xuICAgICAgICBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmN1bHR1cmU7IH0pLnN1YnNjcmliZShmdW5jdGlvbiAoY3VsdHVyZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDdWx0dXJlICYmIGN1cnJlbnRDdWx0dXJlICE9PSBjdWx0dXJlKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1pdCBnbG9iYWwgc2lnbmFsXG4gICAgICAgICAgICAgICAgQ3VsdHVyZUNoYW5nZWQoY3VsdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VsdHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBnbG9iYWwgZmxvdyBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICBTY3JlZW4uZGVmYXVsdEZsb3dEaXJlY3Rpb24gPSBjdWx0dXJlLnRleHRGbG93RGlyZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEN1bHR1cmUgPSBjdWx0dXJlO1xuICAgICAgICB9KTtcbiAgICAgICAgQXN5bmMuaW5qZWN0KFRleHRMYWJlbEZhY3RvcnksIChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbXCJAdHJhbnNsYXRlVGV4dFwiXSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNsYXRlIGFjY29yZGluZyB0byBjdXJyZW50IGN1bHR1cmUgKHNldCBhYm92ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEN1bHR1cmUgPyBjdXJyZW50Q3VsdHVyZS50cmFuc2xhdGVUZXh0KHRleHQpIDogXCJcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYVtcIkBwbHVyYWxpemVUZXh0XCJdID0gZnVuY3Rpb24gKG4sIGZvcm1zKSB7XG4gICAgICAgICAgICAgICAgLy8gcGx1cmFsaXplIGFjY29yZGluZyB0byBjdXJyZW50IGN1bHR1cmUgKHNldCBhYm92ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEN1bHR1cmUgPyBjdXJyZW50Q3VsdHVyZS5wbHVyYWxpemVUZXh0KG4sIGZvcm1zKSA6IFwiXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2EpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH1cbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgaW5qZWN0U2VydmljZShcImN1bHR1cmVcIilcbiAgICBdLCBPYnNlcnZlci5wcm90b3R5cGUsIFwiY3VsdHVyZVwiLCB2b2lkIDApO1xuICAgIHJldHVybiBPYnNlcnZlcjtcbn0oKSk7XG4vLyBjcmVhdGUgYW4gaW5zdGFuY2UgdG8gc3RhcnQgb2JzZXJ2aW5nXG5Bc3luYy5kZWZlcihmdW5jdGlvbiAoKSB7IG5ldyBPYnNlcnZlcigpOyB9KTtcbi8qKiBTaWduYWwgdGhhdCBpcyBlbWl0dGVkIHdoZW4gdGhlIGdsb2JhbCBpMThuIGN1bHR1cmUgY2hhbmdlcyAodGhyb3VnaCBgQ3VsdHVyZVNlcnZpY2VgKSAqL1xuZXhwb3J0IHZhciBDdWx0dXJlQ2hhbmdlZCA9IFNpZ25hbC5jcmVhdGUoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9BcHAvQ3VsdHVyZS9PYnNlcnZlci5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImV4cG9ydCAqIGZyb20gXCIuL0N1bHR1cmVTZXJ2aWNlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9PYnNlcnZlclwiO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2NvcmUvbGliL0FwcC9DdWx0dXJlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZXhwb3J0ICogZnJvbSBcIi4vQWN0aXZpdHlcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1ZpZXdcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1NlcnZpY2VcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0FwcGxpY2F0aW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9DdWx0dXJlXCI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXBwL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiZXhwb3J0ICogZnJvbSBcIi4vQXBwL2luZGV4XCI7XG5pbXBvcnQgKiBhcyBBcHAgZnJvbSBcIi4vQXBwL2luZGV4XCI7XG5leHBvcnQgZGVmYXVsdCBBcHA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3QvY29yZS9saWIvQXBwLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5pbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBTY3JlZW4gfSBmcm9tIFwiLi4vVUlcIjtcbmltcG9ydCB7IEFwcGxpY2F0aW9uLCBBY3Rpdml0eVRyYW5zaXRpb24gfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FwcFwiO1xuLyoqIFRydWUgaWYgYnJvd3NlciBoaXN0b3J5IGlzIGVuYWJsZWQgKi9cbnZhciB1c2VCcm93c2VySGlzdG9yeSA9IHRydWU7XG4vKiogUGxhdGZvcm0gc3BlY2lmaWMgZW5jYXBzdWxhdGlvbiBvZiB0aGUgYXBwbGljYXRpb24gYXMgYSBzaW5nbGV0b24gb2JqZWN0ICovXG52YXIgRE9NQXBwbGljYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhET01BcHBsaWNhdGlvbiwgX3N1cGVyKTtcbiAgICAvKiogQ3JlYXRlIHRoZSBhcHBsaWNhdGlvbiBpbnN0YW5jZSAoZWl0aGVyIGZyb20gYSBkZXJpdmVkIGNsYXNzIG9yIGZyb20gdGhlIEFwcGxpY2F0aW9uIGNsYXNzIGl0c2VsZik7IGNhbiBiZSBjYWxsZWQgb25seSBvbmNlICovXG4gICAgZnVuY3Rpb24gRE9NQXBwbGljYXRpb24odGl0bGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdGl0bGUpIHx8IHRoaXM7XG4gICAgICAgIC8vIGluaXRpYWxpemUgcGFnZSB2aWV3XG4gICAgICAgIFNjcmVlbi5yZWFkeS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGxpc3RlbiBmb3IgZXZlbnRzIGFuZCBhY3Rpdml0eSB0cmFuc2l0aW9uc1xuICAgICAgICAgICAgX3RoaXMuX2xpc3RlbigpO1xuICAgICAgICAgICAgLy8gc3RhcnQgaW5pdGlhbCBwYWdlIHZpZXdcbiAgICAgICAgICAgIEFzeW5jLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmFjdGl2aXRpZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3RhcnRMb2NhdGlvbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNldCB0aXRsZSBhbmQga2VlcCBpdCB1cGRhdGVkXG4gICAgICAgICAgICBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZpdHlUaXRsZSA9IF90aGlzLmFjdGl2aXRpZXMudGl0bGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlUaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGl0bGUgIT09IGFjdGl2aXR5VGl0bGUgPyBfdGhpcy50aXRsZSA6IFwiXCJcbiAgICAgICAgICAgICAgICBdLmZpbHRlcihmdW5jdGlvbiAocykgeyByZXR1cm4gISFzOyB9KS5qb2luKFwiIC0gXCIpO1xuICAgICAgICAgICAgfSkuc3Vic2NyaWJlKGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICAgICAgICAgIC8vIGFwcGx5IHRvIERPTSBkb2N1bWVudCB3aW5kb3dcbiAgICAgICAgICAgICAgICBkb2N1bWVudC50aXRsZSA9IHRpdGxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBEaXNhYmxlIHN5bmNocm9uaXphdGlvbiBvZiBhY3Rpdml0eSBzdGFjayB3aXRoIGJyb3dzZXIgaGlzdG9yeSAqL1xuICAgIERPTUFwcGxpY2F0aW9uLmRpc2FibGVCcm93c2VySGlzdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXNlQnJvd3Nlckhpc3RvcnkgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRoZSBmdWxsIFVSTCBmcm9tIGB3aW5kb3cubG9jYXRpb24uaHJlZmA7IHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBVUkxzIHRvIHN0YXJ0IHJvdXRlZCBhY3Rpdml0aWVzICovXG4gICAgRE9NQXBwbGljYXRpb24ucHJvdG90eXBlLmdldEN1cnJlbnRVcmwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBTdHJpbmcod2luZG93LmxvY2F0aW9uLmhyZWYpOyB9O1xuICAgIC8qKiBTZXRzIHRoZSBicm93c2VyJ3MgY3VycmVudCBVUkwgKHVzaW5nIGB3aW5kb3cubG9jYXRpb24uaHJlZmApLCB0byBuYXZpZ2F0ZSB0byBhbm90aGVyIHBhZ2Ugb3Igd2Vic2l0ZSAqL1xuICAgIERPTUFwcGxpY2F0aW9uLnByb3RvdHlwZS5uYXZpZ2F0ZVRvVXJsID0gZnVuY3Rpb24gKHVybCkgeyB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDsgfTtcbiAgICAvKiogQGludGVybmFsIEhlbHBlciB0aGF0IHNldHMgZXZlbnQgaGFuZGxlcnMgYW5kIGxpc3RlbnMgZm9yIGFjdGl2aXR5IHRyYW5zaXRpb25zICovXG4gICAgRE9NQXBwbGljYXRpb24ucHJvdG90eXBlLl9saXN0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIHRydWUgaWYgZXh0ZXJuYWwgdHJpZ2dlciBjYXVzZWQgYWN0aXZpdHkgY2hhbmdlc1xuICAgICAgICB2YXIgZXh0ZXJuYWxUcmlnZ2VyID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIHdpdGhFeHRlcm5hbChmKSB7XG4gICAgICAgICAgICBleHRlcm5hbFRyaWdnZXIgPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZigpLnRoZW4oZnVuY3Rpb24gKCkgeyBleHRlcm5hbFRyaWdnZXIgPSBmYWxzZTsgfSwgZnVuY3Rpb24gKCkgeyBleHRlcm5hbFRyaWdnZXIgPSBmYWxzZTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxUcmlnZ2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxpc3RlbiBmb3IgaGFzaCBjaGFuZ2VzICh0cmlnZ2VyZWQgYnkgdXNlcilcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdXNlQnJvd3Nlckhpc3RvcnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGhhc2ggPSBTdHJpbmcod2luZG93LmxvY2F0aW9uLmhhc2ggfHwgXCIjXCIpO1xuICAgICAgICAgICAgLy8gcmV0dXJuIGlmIHRoaXMgaXMgYSBrbm93biBzdGF0ZVxuICAgICAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnN0YXRlICYmIHdpbmRvdy5oaXN0b3J5LnN0YXRlLmFjdGl2aXR5SUQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgYWN0aXZpdHkgaGlzdG9yeSBJRCAobm8gcHVzaFN0YXRlIHN1cHBvcnQpXG4gICAgICAgICAgICBpZiAoaGFzaC5zbGljZSgwLCAzKSA9PT0gXCIjX19cIikge1xuICAgICAgICAgICAgICAgIHdpdGhFeHRlcm5hbChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hY3Rpdml0aWVzLnJlc3RvcmVIaXN0b3J5U3RhdGVBc3luYyhoYXNoLnNsaWNlKDMpKTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHVzaCBhY3Rpdml0aWVzXG4gICAgICAgICAgICBpZiAoaGFzaFsxXSAhPT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgaGFzaCA9IFwiIy9cIiArIGhhc2guc2xpY2UoMSk7XG4gICAgICAgICAgICB3aXRoRXh0ZXJuYWwoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3RhcnRBY3Rpdml0eUFzeW5jKGhhc2gsIGZhbHNlLCBmYWxzZSk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbGlzdGVuIGZvciBicm93c2VyIGhpc3RvcnkgbW92ZW1lbnQgKGVpdGhlciB0cmlnZ2VyZWQgYnkgdXNlcixcbiAgICAgICAgLy8gb3IgYnkgZnVuY3Rpb24gYmVsb3cgYWZ0ZXIgcG9wcGluZyBhbiBhY3Rpdml0eSk6IHJlc2V0IHN0YXRlXG4gICAgICAgIHZhciBsYXN0UG9wU3RhdGVJRCA9IG51bGw7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXVzZUJyb3dzZXJIaXN0b3J5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpZCA9IGxhc3RQb3BTdGF0ZUlEID0gZXZlbnQuc3RhdGUgJiYgZXZlbnQuc3RhdGUuYWN0aXZpdHlJRDtcbiAgICAgICAgICAgIC8vIGRlZmVyIHJlc2V0IHRvIHByb2Nlc3Mgb25seSBsYXRlc3QgcG9wc3RhdGUgZXZlbnRcbiAgICAgICAgICAgIGlkICYmIEFzeW5jLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaWQgPT09IGxhc3RQb3BTdGF0ZUlEICYmIGlkICE9PSBfdGhpcy5hY3Rpdml0aWVzLmdldEhpc3RvcnlTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aXRoRXh0ZXJuYWwoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWN0aXZpdGllcy5yZXN0b3JlSGlzdG9yeVN0YXRlQXN5bmMoaWQpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBzdWNjZXNzZnVsLCB0cnkgdG8gcmV2ZXJ0IGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZUhpc3RvcnlTdGF0ZShBY3Rpdml0eVRyYW5zaXRpb24uT3BlcmF0aW9uLlB1c2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2Fubm90IHJlc2V0IGFjdGl2aXR5LCBqdXN0IHVzZSBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0YXJ0TG9jYXRpb25BY3Rpdml0eSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29ubmVjdCB0byBhY3Rpdml0eSBtYW5hZ2VyXG4gICAgICAgIHRoaXMuYWN0aXZpdGllcy5UcmFuc2l0aW9uLmNvbm5lY3QoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGlmIChleHRlcm5hbFRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQgYnkgYWJvdmUsIHJlcGxhY2Ugc3RhdGUgaWYgY3VycnJlbnRseSBubyBJRFxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5zdGF0ZSAmJiAhd2luZG93Lmhpc3Rvcnkuc3RhdGUuYWN0aXZpdHlJRClcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZUhpc3RvcnlTdGF0ZShBY3Rpdml0eVRyYW5zaXRpb24uT3BlcmF0aW9uLlJlcGxhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlcmVkIGJ5IGFwcGxpY2F0aW9uOiB1cGRhdGUgYnJvd3NlciBoaXN0b3J5XG4gICAgICAgICAgICAgICAgdmFyIG9wID0gdC5vcDtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdXBkYXRlSGlzdG9yeVN0YXRlKG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBzdGFydCBhY3Rpdml0eSBiYXNlZCBvbiBjdXJyZW50IGxvY2F0aW9uXG4gICAgRE9NQXBwbGljYXRpb24ucHJvdG90eXBlLl9zdGFydExvY2F0aW9uQWN0aXZpdHkgPSBmdW5jdGlvbiAocmVwbGFjZSkge1xuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhhc2ggJiYgd2luZG93LmxvY2F0aW9uLmhhc2ggIT09IFwiI1wiKVxuICAgICAgICAgICAgdGhpcy5zdGFydEFjdGl2aXR5QXN5bmMod2luZG93LmxvY2F0aW9uLmhhc2gsIHJlcGxhY2UsIGZhbHNlKVxuICAgICAgICAgICAgICAgIC50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkgeyB3aW5kb3cubG9jYXRpb24uaGFzaCA9IFwiXCI7IH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnN0YXJ0QWN0aXZpdHlBc3luYyh3aW5kb3cubG9jYXRpb24uaHJlZiwgcmVwbGFjZSwgZmFsc2UpO1xuICAgIH07XG4gICAgLy8gdXBkYXRlIGJyb3dzZXIgaGlzdG9yeSBmb2xsb3dpbmcgYW4gYWN0aXZpdHkgdHJhbnNpdGlvblxuICAgIERPTUFwcGxpY2F0aW9uLnByb3RvdHlwZS5fdXBkYXRlSGlzdG9yeVN0YXRlID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5hY3Rpdml0aWVzLnRvcDtcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5vcHRpb25zLmlzQmFja2dyb3VuZEFjdGl2aXR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXVzZUJyb3dzZXJIaXN0b3J5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBjaGFuZ2UgZmlyc3QgcHVzaCB0byBhIHJlcGxhY2UgdG8gYXZvaWQgbGluZ2VyaW5nIGluaXRpYWwgc3RhdGVcbiAgICAgICAgaWYgKG9wID09PSBBY3Rpdml0eVRyYW5zaXRpb24uT3BlcmF0aW9uLlB1c2ggJiZcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSAmJlxuICAgICAgICAgICAgKCF3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCAhd2luZG93Lmhpc3Rvcnkuc3RhdGUuYWN0aXZpdHlJRCkpXG4gICAgICAgICAgICBvcCA9IEFjdGl2aXR5VHJhbnNpdGlvbi5PcGVyYXRpb24uUmVwbGFjZTtcbiAgICAgICAgLy8gY2hlY2sgd2hhdCB0byBkbzogcHVzaCwgcmVwbGFjZSwgb3IgcG9wIGhpc3Rvcnkgc3RhdGVcbiAgICAgICAgaWYgKG9wID09PSBBY3Rpdml0eVRyYW5zaXRpb24uT3BlcmF0aW9uLlB1c2gpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gY3VycmVudCAmJiBjdXJyZW50LmFjdGl2YXRpb24uZ2V0UGF0aCgpO1xuICAgICAgICAgICAgdmFyIGFjdGl2aXR5SUQgPSB0aGlzLmFjdGl2aXRpZXMuZ2V0SGlzdG9yeVN0YXRlKCk7XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHsgYWN0aXZpdHlJRDogYWN0aXZpdHlJRCwgcGF0aDogcGF0aCB9LCB0aGlzLnRpdGxlLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gXCIjX19cIiArIGFjdGl2aXR5SUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoeyBhY3Rpdml0eUlEOiBhY3Rpdml0eUlEIH0sIHRoaXMudGl0bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBcIiNfX1wiICsgYWN0aXZpdHlJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3AgPT09IEFjdGl2aXR5VHJhbnNpdGlvbi5PcGVyYXRpb24uUmVwbGFjZSkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBjdXJyZW50ICYmIGN1cnJlbnQuYWN0aXZhdGlvbi5nZXRQYXRoKCk7XG4gICAgICAgICAgICB2YXIgYWN0aXZpdHlJRCA9IHRoaXMuYWN0aXZpdGllcy5nZXRIaXN0b3J5U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBhY3Rpdml0eUlEOiBhY3Rpdml0eUlELCBwYXRoOiBwYXRoIH0sIHRoaXMudGl0bGUsIHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHsgYWN0aXZpdHlJRDogYWN0aXZpdHlJRCB9LCB0aGlzLnRpdGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3AgPT09IEFjdGl2aXR5VHJhbnNpdGlvbi5PcGVyYXRpb24uUG9wKSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgJiYgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRE9NQXBwbGljYXRpb247XG59KEFwcGxpY2F0aW9uKSk7XG5leHBvcnQgeyBET01BcHBsaWNhdGlvbiB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvQXBwL0RPTUFwcGxpY2F0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IHsgUHJvbWlzZSwgU2lnbmFsIH0gZnJvbSBcIkB0eXBlc2NlbmUvY29yZS9Bc3luY1wiO1xuLy8gZGVjbGFyZSBmZXRjaCBmdW5jdGlvbiBpZiBub3QgZGVmaW5lZFxudmFyIF9oYXNOYXRpdmVGZXRjaCA9ICh0eXBlb2Ygd2luZG93LmZldGNoID09PSBcImZ1bmN0aW9uXCIpO1xudmFyIF9jYW5CbG9iID0gKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBGaWxlUmVhZGVyICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBuZXcgQmxvYihbXSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGFsbCkgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufSkoKTtcbi8qKiBOYW1lc3BhY2UgdGhhdCBlbmNhcHN1bGF0ZXMgYC5mZXRjaGAgYW5kIHJlbGF0ZWQgZnVuY3Rpb25hbGl0eSAqL1xuZXhwb3J0IHZhciBIdHRwO1xuKGZ1bmN0aW9uIChIdHRwKSB7XG4gICAgLyoqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyAqL1xuICAgIEh0dHAuY29uZmlnID0ge1xuICAgICAgICBGT1JDRV9YSFJfRkVUQ0g6IGZhbHNlLFxuICAgICAgICBGRVRDSF9JTkNMVURFX0NSRURFTlRJQUxTOiB0cnVlXG4gICAgfTtcbiAgICA7XG4gICAgLyoqIFNpZ25hbCB0aGF0IGlzIGVtaXR0ZWQgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0OyBjYW4gYmUgdXNlZCB0byBpbnRlcmNlcHQgcmVxdWVzdHMsIG1vZGlmeSByZXF1ZXN0IG9wdGlvbnMsIGFuZCBwcm92aWRlIGFuIGFsdGVybmF0ZSByZXNwb25zZTsgaWYgb25lIG9mIHRoZSBjb25uZWN0ZWQgaGFuZGxlcnMgcmV0dXJucyBhIChwcm9taXNlIGZvcikgYW4gYWx0ZXJuYXRlIHJlc3BvbnNlLCBpLmUuIGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHMgYEZldGNoUmVzcG9uc2VgLCB0aGVuIHRoZSByZXF1ZXN0IHdpbGwgbm90IGJlIHNlbnQsIGFuZCB0aGUgKGZpcnN0KSByZXN1bHRpbmcgYWx0ZXJuYXRlIHJlc3BvbnNlIGlzIHVzZWQgaW5zdGVhZDsgaWYgb25lIG9mIHRoZSBjb25uZWN0ZWQgaGFuZGxlcnMgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdGhlIG9yaWdpbmFsIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0IGlzIHJlamVjdGVkOyBvdGhlcndpc2UgdGhlIHJlcXVlc3QgaXMgc2VudCBhcyBwZXIgbm9ybWFsICovXG4gICAgSHR0cC5SZXF1ZXN0aW5nID0gU2lnbmFsLmNyZWF0ZSgpO1xuICAgIC8qKiBTaWduYWwgdGhhdCBpcyBlbWl0dGVkIGFmdGVyIG9idGFpbmluZyBhIHJlbW90ZSByZXNwb25zZSAoZnJvbSBhbiBhY3R1YWwgcmVxdWVzdCwgbm90IGFuIGFsdGVybmF0ZSByZXNwb25zZSBwcm92aWRlZCBieSBhIGNvbm5lY3RlZCBoYW5kbGVyIG9mIGAuUmVxdWVzdGluZ2ApICovXG4gICAgSHR0cC5SZXNwb25kZWQgPSBTaWduYWwuY3JlYXRlKCk7XG4gICAgLyoqIEltcGxlbWVudHMgdGhlIEZldGNoUmVzcG9uc2UgaW50ZXJmYWNlLCBjYW4gYmUgdXNlZCB0byBtb2NrIHJlc3BvbnNlcyBvciBpbml0aWFsaXplIGEgcmVzcG9uc2UgZnJvbSBhbiBYTUxIdHRwUmVxdWVzdCAqL1xuICAgIHZhciBNb2NrUmVzcG9uc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiogQ3JlYXRlIGEgcmVzcG9uc2Ugd2l0aCBnaXZlbiBwcm9wZXJ0aWVzIChhbiBYTUxIdHRwUmVxdWVzdCBvYmplY3QgY2FuIGJlIHBhc3NlZCBpbiBkaXJlY3RseSwgYWxvbmcgd2l0aCBhIG5hdGl2ZSBmZXRjaCBgSGVhZGVyc2AgaW5zdGFuY2Ugb3IgYSBNb2NrUmVzcG9uc2VIZWFkZXJzIGluc3RhbmNlKTsgdGhlIHJlc3BvbnNlIGl0c2VsZiBpcyB0YWtlbiBmcm9tIGAucmVzcG9uc2VUZXh0YCBpZiBpdCBpcyBub3QgdW5kZWZpbmVkLCBvciBmcm9tIGAucmVzcG9uc2VgIGlmIGl0IGlzIGEgQmxvYiAqL1xuICAgICAgICBmdW5jdGlvbiBNb2NrUmVzcG9uc2UoaW5pdCwgaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKCFpbml0KVxuICAgICAgICAgICAgICAgIGluaXQgPSB7IHJlc3BvbnNlVGV4dDogXCJcIiB9O1xuICAgICAgICAgICAgdGhpcy5faW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IChpbml0LnN0YXR1cyAhPT0gdW5kZWZpbmVkID8gaW5pdC5zdGF0dXMgOiAyMDApO1xuICAgICAgICAgICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IGluaXQuc3RhdHVzVGV4dCB8fCBcIk9LXCI7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzIHx8IG5ldyBNb2NrUmVzcG9uc2VIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIENyZWF0ZSBhIHJlc3BvbnNlIHdpdGggZ2l2ZW4gZGF0YSBlbmNvZGVkIGFzIEpTT04sIHRoZSBgYXBwbGljYXRpb24vanNvbmAgY29udGVudCB0eXBlLCBhbmQgc3RhdHVzIDIwMCAqL1xuICAgICAgICBNb2NrUmVzcG9uc2Uud2l0aEpTT05Db250ZW50ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9ja1Jlc3BvbnNlKHsgcmVzcG9uc2VUZXh0OiBKU09OLnN0cmluZ2lmeShkYXRhKSB9LCBuZXcgTW9ja1Jlc3BvbnNlSGVhZGVycyhcIkNvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc3BvbnNlIGJvZHkgcmVhZCBpbnRvIGEgQmxvYiwgaWYgc3VwcG9ydGVkICovXG4gICAgICAgIE1vY2tSZXNwb25zZS5wcm90b3R5cGUuYmxvYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX2NhbkJsb2IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoKSk7XG4gICAgICAgICAgICBlbHNlIGlmICghKHRoaXMuX2luaXQucmVzcG9uc2UgaW5zdGFuY2VvZiBCbG9iKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9pbml0LnJlc3BvbnNlVGV4dCB8fCBcIlwiXSwgeyB0eXBlOiB0aGlzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwidGV4dC9wbGFpblwiIH0pKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2luaXQucmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNwb25zZSBib2R5ICovXG4gICAgICAgIE1vY2tSZXNwb25zZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlYWRUZXh0KCk7IH07XG4gICAgICAgIC8qKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc3BvbnNlIGJvZHksIHBhcnNlZCBhcyBKU09OICovXG4gICAgICAgIE1vY2tSZXNwb25zZS5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3JlYWRUZXh0KCkudGhlbihmdW5jdGlvbiAocykgeyByZXR1cm4gSlNPTi5wYXJzZShzKTsgfSk7IH07XG4gICAgICAgIC8qKiBIZWxwZXIgbWV0aG9kIHRoYXQgcmV0dXJucyBhIFByb21pc2Ugd2l0aCB0aGUgdGV4dCBmcm9tIHRoZSBjb25zdHJ1Y3RvciBpbml0aWFsaXplciAod2l0aCB0ZXh0IGluIGAucmVzcG9uc2VUZXh0YCwgb3IgYSBibG9iIGluIGAucmVzcG9uc2VgKSAqL1xuICAgICAgICBNb2NrUmVzcG9uc2UucHJvdG90eXBlLl9yZWFkVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0byB1c2UgcmVwb25zZVRleHQgcHJvcGVydHkgZmlyc3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5pdC5yZXNwb25zZVR5cGUgIT09IFwiYmxvYlwiICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXQucmVzcG9uc2VUZXh0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5faW5pdC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGFsbCkgeyB9XG4gICAgICAgICAgICAvLyAuLi4gb3RoZXJ3aXNlIHJlYWQgZnJvbSByZXNwb25zZSBibG9iXG4gICAgICAgICAgICBpZiAodGhpcy5faW5pdC5yZXNwb25zZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZShmaWxlUmVhZGVyLnJlc3VsdCk7IH07XG4gICAgICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChmaWxlUmVhZGVyLmVycm9yKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNUZXh0KF90aGlzLl9pbml0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJSZXNwb25zZSBpcyBuZWl0aGVyIHRleHQgbm9yIGJsb2JcIikpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTW9ja1Jlc3BvbnNlO1xuICAgIH0oKSk7XG4gICAgSHR0cC5Nb2NrUmVzcG9uc2UgPSBNb2NrUmVzcG9uc2U7XG4gICAgLyoqIEltcGxlbWVudHMgdGhlIEZldGNoUmVzcG9uc2UgaW50ZXJmYWNlLCBjYW4gYmUgdXNlZCB0byBtb2NrIHJlc3BvbnNlIGhlYWRlcnMgb3IgaW5pdGlhbGl6ZSByZXNwb25zZSBoZWFkZXJzIGZyb20gYW4gWE1MSHR0cFJlcXVlc3QgKi9cbiAgICB2YXIgTW9ja1Jlc3BvbnNlSGVhZGVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBJbml0aWFsaXplIHRoZSBsaXN0IG9mIGhlYWRlcnMgdXNpbmcgZ2l2ZW4gSFRUUCBoZWFkZXIgdGV4dCAoaS5lLiBvbmUgb3IgbW9yZSBsaW5lcyB3aXRoIGhlYWRlciBuYW1lLCBjb2xvbiwgYW5kIGhlYWRlciB2YWx1ZTsgc3RyaXBzIGFsbCB3aGl0ZXNwYWNlIGFyb3VuZCBuYW1lcyBhbmQgdmFsdWVzKSAqL1xuICAgICAgICBmdW5jdGlvbiBNb2NrUmVzcG9uc2VIZWFkZXJzKGFsbFJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIC8vIHBhcnNlIGFsbCByZXNwb25zZSBoZWFkZXJzIGZyb20gdGV4dFxuICAgICAgICAgICAgaWYgKGFsbFJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICAgICAgICAgIGFsbFJlc3BvbnNlSGVhZGVycy5zcGxpdCgvXFxyXFxufFxcblxccnxcXHJ8XFxuLykuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBzLm1hdGNoKC9eXFxzKyhbXjpdKyk6XFxzKiguKikvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gbWF0Y2hbMF0sIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxzKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2hlYWRlcnNba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGVhZGVyc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGVhZGVyc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTW9ja1Jlc3BvbnNlSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyc1tuYW1lXSAmJiB0aGlzLl9oZWFkZXJzW25hbWVdWzBdO1xuICAgICAgICB9O1xuICAgICAgICBNb2NrUmVzcG9uc2VIZWFkZXJzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzW25hbWVdO1xuICAgICAgICB9O1xuICAgICAgICBNb2NrUmVzcG9uc2VIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiAhISh0aGlzLl9oZWFkZXJzW25hbWVdKTtcbiAgICAgICAgfTtcbiAgICAgICAgTW9ja1Jlc3BvbnNlSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW10sIGlkeCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX2hlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2hlYWRlcnMsIG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA+PSBrZXlzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBrZXlzW2lkeF0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTW9ja1Jlc3BvbnNlSGVhZGVycztcbiAgICB9KCkpO1xuICAgIEh0dHAuTW9ja1Jlc3BvbnNlSGVhZGVycyA9IE1vY2tSZXNwb25zZUhlYWRlcnM7XG4gICAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICAgICAgdmFyIHByb3BzO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyB1c2UgaW5pdCBvciBjcmVhdGUgbmV3IG9wdGlvbnMgaW5zdGFuY2VcbiAgICAgICAgICAgIHByb3BzID0gaW5pdCB8fCB7fTtcbiAgICAgICAgICAgIHByb3BzLnVybCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlIG9wdGlvbnMvUmVxdWVzdCBpbnN0YW5jZSBkaXJlY3RseVxuICAgICAgICAgICAgcHJvcHMgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmNsdWRlIGNyZWRlbnRpYWxzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKF9oYXNOYXRpdmVGZXRjaCAmJiAhcHJvcHMuY3JlZGVudGlhbHMgJiZcbiAgICAgICAgICAgIEh0dHAuY29uZmlnLkZFVENIX0lOQ0xVREVfQ1JFREVOVElBTFMpXG4gICAgICAgICAgICBwcm9wcy5jcmVkZW50aWFscyA9IFwic2FtZS1vcmlnaW5cIjtcbiAgICAgICAgLy8gcmV0dXJuIGEgcHJvbWlzZSBmb3IgdGhlIHJlbW90ZS9tb2NrIHJlc3BvbnNlXG4gICAgICAgIHJldHVybiBuZXcgSHR0cC5SZXF1ZXN0aW5nKHByb3BzKS5lbWl0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgLy8gdXNlIHJlc3VsdGluZyByZXNwb25zZSwgaWYgYW55XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHJlc3VsdHNfMSA9IHJlc3VsdHM7IF9pIDwgcmVzdWx0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciByID0gcmVzdWx0c18xW19pXTtcbiAgICAgICAgICAgICAgICBpZiAocilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGFydCByZXF1ZXN0XG4gICAgICAgICAgICBpZiAoIXByb3BzLmhlYWRlcnMpXG4gICAgICAgICAgICAgICAgcHJvcHMuaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuICgoX2hhc05hdGl2ZUZldGNoICYmICFIdHRwLmNvbmZpZy5GT1JDRV9YSFJfRkVUQ0gpID9cbiAgICAgICAgICAgICAgICB3aW5kb3cuZmV0Y2gocHJvcHMudXJsLCBwcm9wcykgOiBfeGhyKHByb3BzKSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIChIdHRwLlJlc3BvbmRlZChyZXNwb25zZSksIHJlc3BvbnNlKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBIdHRwLmZldGNoID0gZmV0Y2g7XG4gICAgLyoqIEhlbHBlciBmdW5jdGlvbiBmb3Igc2VuZGluZyBhIHNpbXBsZSByZXF1ZXN0IHRocm91Z2ggWE1MSHR0cFJlcXVlc3QsIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgWEhSIHJlc3BvbnNlVGV4dCAqL1xuICAgIGZ1bmN0aW9uIF94aHIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgcmVxdWVzdCBhbmQgc2VuZCBkYXRhXG4gICAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIGlmIChfY2FuQmxvYilcbiAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYmxvYlwiO1xuICAgICAgICAgICAgICAgIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIsIG9wdGlvbnMudXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5oZWFkZXJzLmtleXMgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBhbGwgaGVhZGVycyBmcm9tIHRoZSBuYXRpdmUvcG9seWZpbGwgSGVhZGVycyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdCA9IG9wdGlvbnMuaGVhZGVycy5rZXlzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgociA9IGl0Lm5leHQoKSkgJiYgIXIuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5nZXRBbGwoci52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHhoci5zZXRSZXF1ZXN0SGVhZGVyKHIudmFsdWUsIHYpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBoZWFkZXJzIGZyb20gYSBwbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsIGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhd2FpdCByZXNwb25zZSBhbmQgcmVzb2x2ZSBvciByZWplY3QgcHJvbWlzZVxuICAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gbmV3IE1vY2tSZXNwb25zZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgTW9ja1Jlc3BvbnNlKHhociwgaCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJlamVjdChuZXcgRXJyb3IoXCJIVFRQIGVycm9yXCIpKTsgfTtcbiAgICAgICAgICAgICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkgeyByZWplY3QobmV3IEVycm9yKFwiSFRUUCB0aW1lb3V0XCIpKTsgfTtcbiAgICAgICAgICAgICAgICB4aHIuc2VuZChvcHRpb25zLmJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGFsbCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChhbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEhlbHBlciBmdW5jdGlvbiB0byBhZGQgYW4gXCJBY2NlcHRcIiBoZWFkZXIgKi9cbiAgICBmdW5jdGlvbiBfaGVhZGVyc1dpdGhBY2NlcHQoaGVhZGVycywgYWNjZXB0LCB0eXBlKSB7XG4gICAgICAgIGlmIChoZWFkZXJzID09PSB2b2lkIDApIHsgaGVhZGVycyA9IHt9OyB9XG4gICAgICAgIGlmIChhY2NlcHQgPT09IHZvaWQgMCkgeyBhY2NlcHQgPSBcImFwcGxpY2F0aW9uL2pzb25cIjsgfVxuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIjsgfVxuICAgICAgICBpZiAoKHR5cGVvZiBoZWFkZXJzLmhhcyA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAgICAgIWhlYWRlcnMuaGFzKFwiYWNjZXB0XCIpKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0KVxuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKFwiYWNjZXB0XCIsIGFjY2VwdCk7XG4gICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChcImNvbnRlbnQtVHlwZVwiLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaGVhZGVyc1tcImFjY2VwdFwiXSAmJiAhaGVhZGVyc1tcIkFjY2VwdFwiXSkge1xuICAgICAgICAgICAgaWYgKGFjY2VwdClcbiAgICAgICAgICAgICAgICBoZWFkZXJzW1wiYWNjZXB0XCJdID0gYWNjZXB0O1xuICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gYWRkIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYSBVUkwgKi9cbiAgICBmdW5jdGlvbiBfYWRkUXVlcnlQYXJhbXModXJsLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gKHVybC5pbmRleE9mKFwiP1wiKSA8IDApO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCArPSAoZmlyc3QgPyBcIj9cIiA6IFwiJlwiKSArIGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgLyoqIEhlbHBlciBmdW5jdGlvbiB0byBtYWtlIGEgcmVxdWVzdCB3aXRoIGEgSlNPTiBib2R5LCB0aGF0IG9ubHkgYWNjZXB0cyBKU09OICovXG4gICAgZnVuY3Rpb24gX2ZldGNoSlNPTihvcHRpb25zLCBkYXRhKSB7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IF9oZWFkZXJzV2l0aEFjY2VwdChvcHRpb25zLmhlYWRlcnMgfHwge30pO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgcmV0dXJuIGZldGNoKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhUVFAgXCIgKyByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmxlbmd0aCA/IEpTT04ucGFyc2UocykgOiB1bmRlZmluZWQ7IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFBlcmZvcm0gYSBHRVQgcmVxdWVzdCB3aXRoIGdpdmVuIHBhcmFtZXRlcnMgYW5kIGhlYWRlcnMsIGlmIGFueTsgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgdGV4dCwgb3IgZ2V0cyByZWplY3RlZCBpZiB0aGUgcmVxdWVzdCBmYWlscyBvciByZXNwb25zZSBzdGF0dXMgaXMgbm90IGluIDJ4eCByYW5nZSAqL1xuICAgIGZ1bmN0aW9uIGdldFRleHRBc3luYyh1cmwsIHBhcmFtcywgaGVhZGVycykge1xuICAgICAgICB1cmwgPSBfYWRkUXVlcnlQYXJhbXModXJsLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7IG1ldGhvZDogXCJHRVRcIiwgaGVhZGVyczogaGVhZGVycyB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIVFRQIFwiICsgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBIdHRwLmdldFRleHRBc3luYyA9IGdldFRleHRBc3luYztcbiAgICAvKiogUGVyZm9ybSBhIEdFVCByZXF1ZXN0IHdpdGggZ2l2ZW4gcGFyYW1ldGVycyBhbmQgaGVhZGVycywgaWYgYW55OyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYmxvYiwgb3IgZ2V0cyByZWplY3RlZCBpZiB0aGUgcmVxdWVzdCBmYWlscyBvciByZXNwb25zZSBzdGF0dXMgaXMgbm90IGluIDJ4eCByYW5nZTsgcmVxdWlyZXMgYSBicm93c2VyIHRoYXQgc3VwcG9ydHMgQmxvYiBjb25zdHJ1Y3RvcnMgKi9cbiAgICBmdW5jdGlvbiBnZXRCbG9iQXN5bmModXJsLCBwYXJhbXMsIGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCFfY2FuQmxvYilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgdXJsID0gX2FkZFF1ZXJ5UGFyYW1zKHVybCwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCwgeyBtZXRob2Q6IFwiR0VUXCIsIGhlYWRlcnM6IGhlYWRlcnMgfSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSFRUUCBcIiArIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgSHR0cC5nZXRCbG9iQXN5bmMgPSBnZXRCbG9iQXN5bmM7XG4gICAgLyoqIFBlcmZvcm0gYSBHRVQgcmVxdWVzdCB3aXRoIGdpdmVuIHBhcmFtZXRlcnMgYW5kIGhlYWRlcnMsIGlmIGFueTsgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcGFyc2VkIEhUTUwgcmVzdWx0IGJvZHkgYXMgYSBkb2N1bWVudCBmcmFnbWVudCAoaWdub3JlcyBldmVyeXRoaW5nIGJlZm9yZSBhbmQgYWZ0ZXIgYm9keSB0YWcsIGlmIGFueTsgaW5zZXJ0cyBldmVyeXRoaW5nIGlmIG5vIGJvZHkgdGFnIGlzIGZvdW5kLCBpLmUuIHBhcnRpYWwgSFRNTCksIG9yIGdldHMgcmVqZWN0ZWQgaWYgdGhlIHJlcXVlc3QgZmFpbHMgb3IgcmVzcG9uc2Ugc3RhdHVzIGlzIG5vdCBpbiAyeHggcmFuZ2UgKi9cbiAgICBmdW5jdGlvbiBnZXRIdG1sQ29udGVudEFzeW5jKHVybCwgcGFyYW1zLCBoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiBnZXRUZXh0QXN5bmModXJsLCBwYXJhbXMsIF9oZWFkZXJzV2l0aEFjY2VwdChoZWFkZXJzLCBcInRleHQvaHRtbFwiLCBcIlwiKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZVRleHQpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgYm9keSB0YWcgYW5kIGtlZXAgb25seSBpdHMgY29udGVudFxuICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gU3RyaW5nKHJlc3BvbnNlVGV4dCB8fCBcIlwiKTtcbiAgICAgICAgICAgIHZhciBzdGFydFRhZyA9IHJlc3BvbnNlVGV4dC5tYXRjaCgvPGJvZHkoPzo+fFxcc1tePl0rPikvbSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRUYWcpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgPSByZXNwb25zZVRleHQuc2xpY2Uoc3RhcnRUYWcuaW5kZXggKyBzdGFydFRhZ1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRUYWdQb3MgPSByZXNwb25zZVRleHQubGFzdEluZGV4T2YoXCI8L2JvZHk+XCIpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRUYWdQb3MgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gcmVzcG9uc2VUZXh0LnNsaWNlKDAsIGVuZFRhZ1Bvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgaW5uZXIgSFRNTCBvZiBhIHBsYWNlaG9sZGVyIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBwbGFjZWhvbGRlci5pbm5lckhUTUwgPSByZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAvLyB0cmFuc2ZlciByZXN1bHRpbmcgZWxlbWVudHMgdG8gZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICB3aGlsZSAocGxhY2Vob2xkZXIuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kQ2hpbGQocGxhY2Vob2xkZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgSHR0cC5nZXRIdG1sQ29udGVudEFzeW5jID0gZ2V0SHRtbENvbnRlbnRBc3luYztcbiAgICAvKiogUGVyZm9ybSBhIEdFVCByZXF1ZXN0IHdpdGggZ2l2ZW4gcGFyYW1ldGVycyBhbmQgaGVhZGVycywgaWYgYW55OyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBwYXJzZWQgSlNPTiByZXNwb25zZSAob3IgdW5kZWZpbmVkIGlmIHJlc3BvbnNlIHdhcyBlbXB0eSksIG9yIGdldHMgcmVqZWN0ZWQgaWYgdGhlIHJlcXVlc3QgZmFpbHMgb3IgcmVzcG9uc2Ugc3RhdHVzIGlzIG5vdCBpbiAyeHggcmFuZ2UgKi9cbiAgICBmdW5jdGlvbiBnZXRBc3luYyh1cmwsIHBhcmFtcywgaGVhZGVycykge1xuICAgICAgICByZXR1cm4gZ2V0VGV4dEFzeW5jKHVybCwgcGFyYW1zLCBfaGVhZGVyc1dpdGhBY2NlcHQoaGVhZGVycywgdW5kZWZpbmVkLCBcIlwiKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmxlbmd0aCA/IEpTT04ucGFyc2UocykgOiB1bmRlZmluZWQ7IH0pO1xuICAgIH1cbiAgICBIdHRwLmdldEFzeW5jID0gZ2V0QXN5bmM7XG4gICAgLyoqIFBlcmZvcm0gYSBQT1NUIHJlcXVlc3Qgd2l0aCBnaXZlbiBvYmplY3QgKHNlbnQgYXMgSlNPTikgYW5kIGhlYWRlcnMsIGlmIGFueTsgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcGFyc2VkIEpTT04gcmVzcG9uc2UgKG9yIHVuZGVmaW5lZCBpZiByZXNwb25zZSB3YXMgZW1wdHkpLCBvciBnZXRzIHJlamVjdGVkIGlmIHRoZSByZXF1ZXN0IGZhaWxzIG9yIHJlc3BvbnNlIHN0YXR1cyBpcyBub3QgaW4gMnh4IHJhbmdlICovXG4gICAgZnVuY3Rpb24gcG9zdEFzeW5jKHVybCwgZGF0YSwgaGVhZGVycykge1xuICAgICAgICByZXR1cm4gX2ZldGNoSlNPTih7IHVybDogdXJsLCBtZXRob2Q6IFwiUE9TVFwiLCBoZWFkZXJzOiBoZWFkZXJzIH0sIGRhdGEpO1xuICAgIH1cbiAgICBIdHRwLnBvc3RBc3luYyA9IHBvc3RBc3luYztcbiAgICAvKiogUGVyZm9ybSBhIFBVVCByZXF1ZXN0IHdpdGggZ2l2ZW4gb2JqZWN0IChzZW50IGFzIEpTT04pIGFuZCBoZWFkZXJzLCBpZiBhbnk7IHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBhcnNlZCBKU09OIHJlc3BvbnNlIChvciB1bmRlZmluZWQgaWYgcmVzcG9uc2Ugd2FzIGVtcHR5KSwgb3IgZ2V0cyByZWplY3RlZCBpZiB0aGUgcmVxdWVzdCBmYWlscyBvciByZXNwb25zZSBzdGF0dXMgaXMgbm90IGluIDJ4eCByYW5nZSAqL1xuICAgIGZ1bmN0aW9uIHB1dEFzeW5jKHVybCwgZGF0YSwgaGVhZGVycykge1xuICAgICAgICByZXR1cm4gX2ZldGNoSlNPTih7IHVybDogdXJsLCBtZXRob2Q6IFwiUFVUXCIsIGhlYWRlcnM6IGhlYWRlcnMgfSwgZGF0YSk7XG4gICAgfVxuICAgIEh0dHAucHV0QXN5bmMgPSBwdXRBc3luYztcbiAgICAvKiogUGVyZm9ybSBhIERFTEVURSByZXF1ZXN0IHdpdGggZ2l2ZW4gb2JqZWN0IChzZW50IGFzIEpTT04pIGFuZCBoZWFkZXJzLCBpZiBhbnk7IHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBhcnNlZCBKU09OIHJlc3BvbnNlIChvciB1bmRlZmluZWQgaWYgcmVzcG9uc2Ugd2FzIGVtcHR5KSwgb3IgZ2V0cyByZWplY3RlZCBpZiB0aGUgcmVxdWVzdCBmYWlscyBvciByZXNwb25zZSBzdGF0dXMgaXMgbm90IGluIDJ4eCByYW5nZSAqL1xuICAgIGZ1bmN0aW9uIGRlbGV0ZUFzeW5jKHVybCwgZGF0YSwgaGVhZGVycykge1xuICAgICAgICByZXR1cm4gX2ZldGNoSlNPTih7IHVybDogdXJsLCBtZXRob2Q6IFwiREVMRVRFXCIsIGhlYWRlcnM6IGhlYWRlcnMgfSwgZGF0YSk7XG4gICAgfVxuICAgIEh0dHAuZGVsZXRlQXN5bmMgPSBkZWxldGVBc3luYztcbn0pKEh0dHAgfHwgKEh0dHAgPSB7fSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvQXBwL0h0dHAuanNcbi8vIG1vZHVsZSBpZCA9IG51bGxcbi8vIG1vZHVsZSBjaHVua3MgPSAiLCJpbXBvcnQgKiBhcyBBc3luYyBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI7XG5pbXBvcnQgeyBET00sIFN0eWxlIH0gZnJvbSBcIi4uL1VJXCI7XG5pbXBvcnQgeyBBcHBWaWV3TGF5b3V0LCBIdWJWaWV3TGF5b3V0LCBBcHBCYXJMYXlvdXQsIE1lc3NhZ2VCb3hMYXlvdXQgfSBmcm9tIFwiQHR5cGVzY2VuZS9jb3JlL0FwcFwiO1xuLy8gb3ZlcnJpZGUgTWVzc2FnZUJveCBhcHBlYXJhbmNlXG5NZXNzYWdlQm94TGF5b3V0LlRpdGxlUm93Lm92ZXJyaWRlKHtcbiAgICBoZWlnaHQ6IFwiMi40cmVtXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBET00uU3R5bGVzLmNvbG9yLnRpdGxlQmFyQmFja2dyb3VuZDsgfSksXG4gICAgICAgIGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuY29sb3IudGl0bGVCYXJUZXh0OyB9KVxuICAgIH1cbn0pO1xuTWVzc2FnZUJveExheW91dC5CdXR0b25Sb3cub3ZlcnJpZGUoe1xuICAgIGhlaWdodDogXCI0cmVtXCIsXG4gICAgaG9yekFsaWduOiBcImVuZFwiXG59KTtcbk1lc3NhZ2VCb3hMYXlvdXQuRmlyc3RNZXNzYWdlUm93Lm92ZXJyaWRlKHtcbiAgICB2ZXJ0aWNhbFNwYWNpbmc6IFwiMS41cmVtXCJcbn0pO1xuLy8gb3ZlcnJpZGUgQXBwTGF5b3V0IGNvbG9yc1xuQXBwVmlld0xheW91dC5vdmVycmlkZSh7XG4gICAgYmFja2dyb3VuZDogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBET00uU3R5bGVzLmNvbG9yLmJhY2tncm91bmQ7IH0pLFxuICAgIGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuY29sb3IudGV4dDsgfSlcbn0pO1xuLy8gb3ZlcnJpZGUgQXBwQmFyIGFwcGVhcmFuY2VcbkFwcEJhckxheW91dC5vdmVycmlkZSh7XG4gICAgaGVpZ2h0OiBcIjMuNXJlbVwiLFxuICAgIHNoYWRvd0VmZmVjdDogLjMsXG59KTtcbkFwcEJhckxheW91dC5hZGRTdHlsZU92ZXJyaWRlKFN0eWxlLndpdGhDbGFzcyhcIkFwcC1MYXlvdXQtQXBwQmFyXCIpKTtcbkRPTS5hcHBseVN0eWxlc2hlZXQobmV3IERPTS5TdHlsZXNoZWV0KFwiQXBwLUxheW91dC1BcHBCYXJcIiwge1xuICAgIFwiLn5+XCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuY29sb3IucHJpbWFyeTsgfSksXG4gICAgICAgIGNvbG9yOiBBc3luYy5vYnNlcnZlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERPTS5TdHlsZXMuY29sb3IucHJpbWFyeVRleHQ7IH0pXG4gICAgfSxcbiAgICBcIi5+fiAuVUktQnV0dG9uIGFcIjoge1xuICAgICAgICBjb2xvcjogQXN5bmMub2JzZXJ2ZShmdW5jdGlvbiAoKSB7IHJldHVybiBET00uU3R5bGVzLmNvbG9yLnByaW1hcnlUZXh0OyB9KVxuICAgIH1cbn0pLCB0cnVlKTtcbi8vIG92ZXJyaWRlIEh1YlZpZXcgc2lkZWJhciB3aWR0aFxuSHViVmlld0xheW91dC5vdmVycmlkZSh7XG4gICAgbGVmdEd1dHRlcldpZHRoOiBcIjE5cmVtXCJcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvQXBwL0xheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImV4cG9ydCAqIGZyb20gXCJAdHlwZXNjZW5lL2NvcmUvQXBwXCI7XG4vLyBwbGF0Zm9ybSBzcGVjaWZpY3M6XG5leHBvcnQgKiBmcm9tIFwiLi9ET01BcHBsaWNhdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vSHR0cFwiO1xuaW1wb3J0IFwiLi9MYXlvdXRcIjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL0FwcC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImV4cG9ydCAqIGZyb20gXCIuL0FwcC9pbmRleFwiO1xuaW1wb3J0ICogYXMgQXBwIGZyb20gXCIuL0FwcC9pbmRleFwiO1xuZXhwb3J0IGRlZmF1bHQgQXBwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kaXN0L2RvbS9saWIvQXBwLmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IEFzeW5jIGZyb20gXCIuL0FzeW5jXCI7XG5pbXBvcnQgKiBhcyBVSSBmcm9tIFwiLi9VSVwiO1xuaW1wb3J0ICogYXMgQXBwIGZyb20gXCIuL0FwcFwiO1xuZXhwb3J0IHsgQXN5bmMsIFVJLCBBcHAgfTtcbmV4cG9ydCBkZWZhdWx0IHsgQXN5bmM6IEFzeW5jLCBVSTogVUksIEFwcDogQXBwIH07XG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiMC45LjExXCJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9jb3JlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gbnVsbFxuLy8gbW9kdWxlIGNodW5rcyA9ICIsImltcG9ydCAqIGFzIEFzeW5jIGZyb20gXCIuL0FzeW5jXCI7XG5pbXBvcnQgKiBhcyBVSSBmcm9tIFwiLi9VSVwiO1xuaW1wb3J0ICogYXMgQXBwIGZyb20gXCIuL0FwcFwiO1xuZXhwb3J0IHsgQXN5bmMsIFVJLCBBcHAgfTtcbmV4cG9ydCBkZWZhdWx0IHsgQXN5bmM6IEFzeW5jLCBVSTogVUksIEFwcDogQXBwIH07XG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gXCJAdHlwZXNjZW5lL2NvcmVcIjtcbi8vIGV4cG9ydCBhbGwgbW9kdWxlcyBhcyBnbG9iYWwgdmFyaWFibGVzXG52YXIgdyA9IHdpbmRvdztcbndbXCJ0eXBlc2NlbmVcIl0gPSB7IEFzeW5jOiBBc3luYywgVUk6IFVJLCBBcHA6IEFwcCwgY29yZTogY29yZSB9O1xuLy8gZXhwb3J0IFByb21pc2UgcG9seWZpbGwgaWYgbmVlZGVkXG5pZiAoIXdbXCJQcm9taXNlXCJdKVxuICAgIHdbXCJQcm9taXNlXCJdID0gQXN5bmMuUHJvbWlzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZGlzdC9kb20vbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSBudWxsXG4vLyBtb2R1bGUgY2h1bmtzID0gIiwiaW1wb3J0IHsgQXN5bmMsIEFwcCB9IGZyb20gXCJAdHlwZXNjZW5lL2RvbVwiO1xuZGVjbGFyZSB2YXIgVkVSU0lPTjogc3RyaW5nO1xuXG4vKiogVHlwZSBkZWZpbml0aW9uIG9mIGEgZGVjbGFyZWQgY29kZSBpdGVtICovXG5leHBvcnQgaW50ZXJmYWNlIENvZGVEb2NJdGVtIHtcbiAgICAvKiogRGVjbGFyYXRpb24gY29kZSAobXVsdGlwbGUgbGluZXMgaW4gY2FzZSBvZiBtdWx0aXBsZSBkZWNsYXJhdGlvbnMpICovXG4gICAgY29kZT86IHN0cmluZztcbiAgICAvKiogUGFyc2VkIEpTRG9jIChIVE1MKSAqL1xuICAgIGRvYz86IHN0cmluZztcbiAgICAvKiogRGVjbGFyYXRpb24gZmlsZSBuYW1lICovXG4gICAgZmlsZT86IHN0cmluZztcbiAgICAvKiogTGluZSBvZiBkZWNsYXJhdGlvbiBpbiBmaWxlICovXG4gICAgbGluZT86IG51bWJlcjtcbiAgICAvKiogTGlzdCBvZiBjbGFzc2VzL2ludGVyZmFjZXMgKHdpdGhvdXQgdHlwZSBwYXJhbWV0ZXJzKSB0aGF0IHRoaXMgY2xhc3MvaW50ZXJmYWNlIGRlcml2ZXMgZnJvbSAqL1xuICAgIGV4dGVuZHM/OiBzdHJpbmdbXTtcbiAgICAvKiogTGlzdCBvZiBJRHMgb2YgaW5oZXJpdGVkIGl0ZW1zICovXG4gICAgaW5oZXJpdHM/OiBzdHJpbmdbXTtcbiAgICAvKiogVHlwZSBwYXJhbWV0ZXJzIChhcyBkZWNsYXJlZCkgKi9cbiAgICB0eXBlUGFyYW1zPzogc3RyaW5nW107XG4gICAgLyoqIFZhbHVlIHR5cGUgb3IgcmV0dXJuIHR5cGUgKGFzIGRlY2xhcmVkKSAqL1xuICAgIGRlY2xUeXBlOiBzdHJpbmc7XG4gICAgLy8gZmxhZ3M6XG4gICAgaXNOYW1lc3BhY2U/OiBib29sZWFuO1xuICAgIGlzQ2xhc3M/OiBib29sZWFuO1xuICAgIGlzSW50ZXJmYWNlPzogYm9vbGVhbjtcbiAgICBoYXNQYXJhbXM/OiBib29sZWFuO1xuICAgIGlzU3RhdGljPzogYm9vbGVhbjtcbiAgICBpc01ldGhvZD86IGJvb2xlYW47XG4gICAgaXNGdW5jdGlvbj86IGJvb2xlYW47XG4gICAgaXNDdG9yPzogYm9vbGVhbjtcbiAgICBpc1Byb3BlcnR5PzogYm9vbGVhbjtcbiAgICBpc1Byb3RlY3RlZD86IGJvb2xlYW47XG4gICAgaXNWYXI/OiBib29sZWFuO1xuICAgIGlzUmVhZE9ubHk/OiBib29sZWFuO1xuICAgIGlzQ29uc3Q/OiBib29sZWFuO1xuICAgIGlzVHlwZT86IGJvb2xlYW47XG4gICAgaXNFbnVtPzogYm9vbGVhbjtcbiAgICBpc0RlY29yYXRvcj86IGJvb2xlYW47XG4gICAgaXNTaWduYWw/OiBib29sZWFuO1xuICAgIGlzQXN5bmM/OiBib29sZWFuO1xufVxuXG4vKiogVHlwZSBkZWZpbml0aW9uIG9mIGEgZG9jdW1lbnRhdGlvbiBpdGVtICovXG5leHBvcnQgaW50ZXJmYWNlIERvY0l0ZW0gZXh0ZW5kcyBDb2RlRG9jSXRlbSB7XG4gICAgLyoqIFBhcmVudCBpdGVtLCBpZiBhbnkgKHBvcHVsYXRlZCB3aGVuIHBhcnNlZCkgKi9cbiAgICBwYXJlbnRJdGVtPzogRG9jSXRlbTtcbiAgICAvKiogSWNvbiBuYW1lIChwb3B1bGF0ZWQgd2hlbiBwYXJzZWQpICovXG4gICAgaWNvbjogc3RyaW5nO1xuICAgIC8qKiBVbmlxdWUgSUQgb2YgdGhpcyBpdGVtICovXG4gICAgaWQ6IHN0cmluZztcbiAgICAvKiogQ29tbW9uIG5hbWUgb2YgdGhpcyBpdGVtICovXG4gICAgbmFtZTogc3RyaW5nO1xuICAgIC8qKiBMaXN0IG9mIHN1YiBpdGVtcyAqL1xuICAgIGl0ZW1zPzogRG9jSXRlbVtdO1xuICAgIC8qKiBJRCBvZiB0aGUgcGFyZW50IHRvcGljIGluIHRoZSBUT0MgKi9cbiAgICB0ZXh0UGFyZW50Pzogc3RyaW5nO1xuICAgIC8qKiBTaG9ydCB0aXRsZSBvZiB0aGlzICh0ZXh0KSBpdGVtIGZvciB0aGUgVE9DICovXG4gICAgdGV4dFRvcGljPzogc3RyaW5nO1xuICAgIC8qKiBBbHRlcm5hdGl2ZSBJRCB1c2VkIGFzIGEgVVJMIHNsdWcgKGUuZy4gXCJpbnRyby8xMjNcIikgKi9cbiAgICB0ZXh0U2x1Zz86IHN0cmluZztcbiAgICAvKiogQ29tbWEvc2VtaWNvbG9uL3BpcGUgc2VwYXJhdGVkIGxpc3Qgb2YgSURzIHRvIGluY2x1ZGUgdW5kZXIgXCJTZWUgYWxzb1wiICovXG4gICAgdGV4dFNlZUFsc28/OiBzdHJpbmc7XG4gICAgLyoqIFNob3J0IGRlc2NyaXB0aW9uIGluIHBsYWNlIG9mIEpTRG9jIHN1bW1hcnkgaW4gbGlzdCBvZiBsaW5rcyAqL1xuICAgIHRleHRTdW1tYXJ5Pzogc3RyaW5nO1xuICAgIC8qKiBUcnVlIGlmIHRoaXMgc2VjdGlvbidzIFRPQyBzaG91bGQgb3BlbiB1cCBhdXRvbWF0aWNhbGx5ICovXG4gICAgdGV4dEF1dG9PcGVuPzogYm9vbGVhbjtcbiAgICAvKiogVHJ1ZSBpZiB0aGlzIHNlY3Rpb24ncyBUT0Mgc2hvdWxkIGJlIGhpZGRlbiBpbiB0aGUgZG9jdW1lbnQgKi9cbiAgICB0ZXh0U2tpcFRPQz86IGJvb2xlYW47XG4gICAgLyoqIFRydWUgaWYgdGhpcyBzZWN0aW9uJ3MgdGl0bGUgc2hvdWxkIGJlIGhpZGRlbiBpbiB0aGUgZG9jdW1lbnQgKi9cbiAgICB0ZXh0U2tpcFRpdGxlPzogYm9vbGVhbjtcbiAgICAvKiogVGV4dCBzZWN0aW9ucyAqL1xuICAgIHRleHQ/OiBBcnJheTx7XG4gICAgICAgIC8qKiBTZWN0aW9uIHRpdGxlLCBtYXkgYmUgZW1wdHkgKi9cbiAgICAgICAgdGl0bGU/OiBzdHJpbmc7XG4gICAgICAgIC8qKiBTZWN0aW9uIHR5cGUgKGUuZy4gXCJub3RlXCIpICovXG4gICAgICAgIHR5cGU/OiBzdHJpbmc7XG4gICAgICAgIC8qKiBUcnVlIGlmIHN1Yi1sZXZlbCBoZWFkaW5nICovXG4gICAgICAgIHN1YkhlYWRpbmc/OiBib29sZWFuO1xuICAgICAgICAvKiogVGV4dCBjb250ZW50IChIVE1MKSAqL1xuICAgICAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgICAgIC8qKiBPdXRwdXQgaWRlbnRpZmllciBmb3IgZXhhbXBsZXMgKi9cbiAgICAgICAgZGlzcGxheVJlc3VsdD86IHN0cmluZztcbiAgICAgICAgLyoqIFNldCB0byBcImhlYWRpbmdcIiBpZiBzaG91bGQgc2hvdyBzZWN0aW9uIGFzIGNvbGxhcHNlZCBoZWFkaW5nICovXG4gICAgICAgIGNvbGxhcHNlPzogc3RyaW5nO1xuICAgIH0+O1xuICAgIC8qKiBMaXN0IG9mIHN1YiBpdGVtIElEcyBmb3IgdGhlIFRPQyAqL1xuICAgIHRvYz86IHN0cmluZ1tdO1xufTtcblxuQEFwcC5tYXBTZXJ2aWNlKFwiRG9jdW1lbnRTZXJ2aWNlXCIpXG5leHBvcnQgY2xhc3MgRG9jdW1lbnRTZXJ2aWNlIGV4dGVuZHMgQXBwLlNlcnZpY2Uge1xuICAgIC8qKiBMb2FkIHRoZSBkb2N1bWVudGF0aW9uIEpTT04gZGF0YSAob3IgbWFrZSBzdXJlIGl0IGhhcyBiZWVuIGxvYWRlZCBhbHJlYWR5KTsgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIHdoZW4gdGhlIGRhdGEgaXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSAqL1xuICAgIHB1YmxpYyBsb2FkQXN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9hZGVkKSByZXR1cm4gQXN5bmMuUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICBpZiAoRG9jdW1lbnRTZXJ2aWNlLl9sb2FkaW5nUCkgcmV0dXJuIERvY3VtZW50U2VydmljZS5fbG9hZGluZ1A7XG4gICAgICAgIHJldHVybiBEb2N1bWVudFNlcnZpY2UuX2xvYWRpbmdQID0gQXBwLkh0dHAuZ2V0QXN5bmMoXG4gICAgICAgICAgICBcIi9cIiArIFZFUlNJT04gKyBcIi9kb2N1bWVudGF0aW9uLmpzb25cIilcbiAgICAgICAgICAgIC50aGVuKChqc29uOiBhbnkpOiB0cnVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21KU09OKGpzb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFByb21pc2UgZm9yIGxvYWRBc3luYyAqL1xuICAgIHByaXZhdGUgc3RhdGljIF9sb2FkaW5nUD86IFByb21pc2VMaWtlPHRydWU+O1xuXG4gICAgLyoqIFRydWUgaWYgdGhlIGRvY3VtZW50YXRpb24gZGF0YSB3YXMgbG9hZGVkICovXG4gICAgQEFzeW5jLm9ic2VydmFibGVcbiAgICBwdWJsaWMgaXNMb2FkZWQgPSBmYWxzZTtcblxuICAgIC8qKiBTaWduYWwgdGhhdCBpcyBlbWl0dGVkIHdoZW4gdGhlIGRvY3VtZW50IGRhdGEgaGFzIGJlZW4gbG9hZGVkIHN1Y2Nlc3NmdWxseSAqL1xuICAgIHB1YmxpYyBMb2FkZWQgPSBBc3luYy5TaWduYWwuY3JlYXRlKCk7XG5cbiAgICAvKiogSW5pdGlhbGl6ZSB3aXRoIGdpdmVuIEpTT04gZGF0YSAqL1xuICAgIHByb3RlY3RlZCBmcm9tSlNPTihqc29uRGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBqc29uRGF0YTtcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gZ28gdGhyb3VnaCBhbGwgaXRlbXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBpbnN0YW5jZVxuICAgICAgICB2YXIgaXRlbXNUb0luZGV4ID0gdGhpcy5fZGF0YS5pdGVtcztcbiAgICAgICAgdmFyIGl0ZW1zV2l0aFRPQzogRG9jSXRlbVtdID0gW107XG4gICAgICAgIHdoaWxlIChpdGVtc1RvSW5kZXgubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zVG9JbmRleC5wb3AoKSE7XG4gICAgICAgICAgICB0aGlzLl9pdGVtc0J5SWRbaXRlbS5pZF0gPSBpdGVtO1xuXG4gICAgICAgICAgICAvLyBwb3B1bGF0ZSBpY29uIG5hbWUgKFRPRE86IHNlcGFyYXRlIHRoaXMgb3V0KVxuICAgICAgICAgICAgaWYgKGl0ZW0uaXNDbGFzcyB8fCBpdGVtLmlzTmFtZXNwYWNlKVxuICAgICAgICAgICAgICAgIGl0ZW0uaWNvbiA9IFwiZmEtY3ViZXNcIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uaXNJbnRlcmZhY2UpXG4gICAgICAgICAgICAgICAgaXRlbS5pY29uID0gXCJmYS1jdWJlcyBvcGFjaXR5PS43XCI7XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmlzQ3RvcilcbiAgICAgICAgICAgICAgICBpdGVtLmljb24gPSBcImZhLW1hZ2ljXCI7XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmlzU2lnbmFsKVxuICAgICAgICAgICAgICAgIGl0ZW0uaWNvbiA9IFwiZmEtYm9sdFwiO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5pc0RlY29yYXRvcilcbiAgICAgICAgICAgICAgICBpdGVtLmljb24gPSBcImZhLXRhZ1wiO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5pc01ldGhvZCB8fCBpdGVtLmlzRnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgaXRlbS5pY29uID0gXCJmYS1kb3QtY2lyY2xlLW9cIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uaXNUeXBlIHx8IGl0ZW0uaXNFbnVtKVxuICAgICAgICAgICAgICAgIGl0ZW0uaWNvbiA9IFwiZmEtc3F1YXJlLW9cIjtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpdGVtLmNvZGUpXG4gICAgICAgICAgICAgICAgaXRlbS5pY29uID0gXCJmYS1maWxlLXRleHQtb1wiO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGl0ZW0uaWNvbiA9IFwiZmEtY3ViZVwiO1xuXG4gICAgICAgICAgICAvLyBjbGVhbiB1cCBzbHVnJ3MgbGVhZGluZy90cmFpbGluZyBzbGFzaGVzXG4gICAgICAgICAgICBpZiAoaXRlbS50ZXh0U2x1Zykge1xuICAgICAgICAgICAgICAgIHZhciBzbHVnID0gaXRlbS50ZXh0U2x1ZztcbiAgICAgICAgICAgICAgICBzbHVnID0gc2x1Zy5yZXBsYWNlKC9eXFwvfFxcLyQvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXNCeUlkW3NsdWddID0gaXRlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVjdXJzZSBmb3IgY2hpbGQgaXRlbXNcbiAgICAgICAgICAgIGlmIChpdGVtLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5pdGVtcy5mb3JFYWNoKHogPT4ge1xuICAgICAgICAgICAgICAgICAgICB6LnBhcmVudEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1RvSW5kZXgucHVzaCh6KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS50b2MpIHtcbiAgICAgICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIFRPQyBwYXJlbnQgaXRlbXNcbiAgICAgICAgICAgICAgICBpdGVtc1dpdGhUT0MucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlZmVyZW5jZSBUT0MgcGFyZW50IGl0ZW1zIGZyb20gY2hpbGQgaXRlbXMgdG9vXG4gICAgICAgIGZvciAodmFyIGl0ZW0gb2YgaXRlbXNXaXRoVE9DKSB7XG4gICAgICAgICAgICBpdGVtLnRvYyEuZm9yRWFjaChzdWJJZCA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Ykl0ZW0gPSB0aGlzLl9pdGVtc0J5SWRbc3ViSWRdO1xuICAgICAgICAgICAgICAgIGlmIChzdWJJdGVtICYmICFzdWJJdGVtLnBhcmVudEl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIHN1Ykl0ZW0ucGFyZW50SXRlbSA9IGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIG51bWJlciBsb2FkZWQgZnJvbSB0aGUgZG9jIEpTT04gKi9cbiAgICBwdWJsaWMgZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgJiYgdGhpcy5fZGF0YS52ZXJzaW9uO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSBkb2N1bWVudGF0aW9uIHRpdGxlICovXG4gICAgcHVibGljIGdldFRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YSAmJiAodGhpcy5fZGF0YS50aXRsZSArIFwiIChcIiArIHRoaXMuX2RhdGEudmVyc2lvbiArIFwiKVwiKTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyBhbiAoYWJzb2x1dGUpIGl0ZW0gSUQgYmFzZWQgb24gdGhlIGdpdmVuIChwb3RlbnRpYWxseSByZWxhdGl2ZSkgSUQgaW4gdGhlIGNvbnRleHQgb2YgZ2l2ZW4gaXRlbSAqL1xuICAgIHB1YmxpYyBmaW5kKGlkOiBzdHJpbmcsIGNvbnRleHQ/OiBEb2NJdGVtKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gY29udGV4dDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtc0J5SWRbY3VycmVudC5pZCArIFwiLlwiICsgaWRdKSB7XG4gICAgICAgICAgICAgICAgLy8gZm91bmQgYSBtYXRjaGluZyBpdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuaWQgKyBcIi5cIiArIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50SXRlbVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pdGVtc0J5SWRbaWRdKSByZXR1cm4gaWQ7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBpdGVtIHdpdGggZ2l2ZW4gSUQgZXhpc3RzICovXG4gICAgcHVibGljIGV4aXN0cyhpZDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2l0ZW1zQnlJZFtpZF0gJiYgdGhpcy5faXRlbXNCeUlkW2lkXS5pZCA9PT0gaWQ7XG4gICAgfVxuXG4gICAgLyoqIEZpbmQgaXRlbSBkYXRhIGJ5IHVuaXF1ZSBJRCBvciBzbHVnICovXG4gICAgcHVibGljIGdldEl0ZW1CeUlkKGlkOiBzdHJpbmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2l0ZW1zQnlJZFtpZF07XG4gICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0ZW0gZG9lcyBub3QgZXhpc3Q6IFwiICsgaWQpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGRpc3BsYXkgdGV4dCBmb3IgY3Jvc3MtcmVmZXJlbmNlcyBhbmQgVE9DICovXG4gICAgcHVibGljIGdldERpc3BsYXlOYW1lRm9yKGlkOiBzdHJpbmcpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW1CeUlkKGlkKTtcbiAgICAgICAgaWYgKGl0ZW0udGV4dFRvcGljKSByZXR1cm4gaXRlbS50ZXh0VG9waWM7XG5cbiAgICAgICAgLy8gaWYgbm8gdGV4dCB0b3BpYyBkZWZpbmVkLCB1c2UgY29kZSBpZGVudGlmaWVyXG4gICAgICAgIHZhciByZXN1bHQgPSBpdGVtLm5hbWU7XG4gICAgICAgIGlmIChpdGVtLmlzTWV0aG9kIHx8IGl0ZW0uaXNGdW5jdGlvbiB8fCBpdGVtLmlzQ3Rvcikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGl0ZW0uaGFzUGFyYW1zID8gXCIoLi4uKVwiIDogXCIoKVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLmlzRGVjb3JhdG9yKSByZXN1bHQgPSBcIkBcIiArIHJlc3VsdDtcbiAgICAgICAgZWxzZSBpZiAoaXRlbS5pc1N0YXRpYykgcmVzdWx0ID0gXCIuXCIgKyByZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgYSBsaXN0IG9mIGl0ZW1zIHRoYXQgbWFrZSB1cCB0aGUgc3ViIFRPQyBiZWxvdyB0aGUgaXRlbSB3aXRoIGdpdmVuIElELCBvciB0aGUgcm9vdCBUT0MgaWYgbm8gSUQgaXMgZ2l2ZW4gKi9cbiAgICBwdWJsaWMgZ2V0VE9DSXRlbXMoaWQ/OiBzdHJpbmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdDogRG9jSXRlbVtdID0gW107XG4gICAgICAgIHZhciBpdGVtID0gaWQgPyB0aGlzLmdldEl0ZW1CeUlkKGlkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHRvYyA9IGl0ZW0gPyBpdGVtLnRvYyA6ICh0aGlzLl9kYXRhICYmIHRoaXMuX2RhdGEudG9jKTtcbiAgICAgICAgaWYgKHRvYykgdG9jLmZvckVhY2gocyA9PiByZXN1bHQucHVzaCh0aGlzLmdldEl0ZW1CeUlkKHMpKSk7XG4gICAgICAgIGl0ZW0gJiYgaXRlbS5pdGVtcyAmJiByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGl0ZW0uaXRlbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKiBUaGUgZG9jdW1lbnRhdGlvbiBkYXRhIGl0c2VsZiAqL1xuICAgIHByaXZhdGUgX2RhdGE6IHtcbiAgICAgICAgLyoqIFRoZSBUeXBlc2NlbmUgdmVyc2lvbiB0aGlzIGRvYyByZWxhdGVzIHRvICovXG4gICAgICAgIHZlcnNpb246IHN0cmluZztcbiAgICAgICAgLyoqIFRoZSBkb2N1bWVudCB0aXRsZSAqL1xuICAgICAgICB0aXRsZTogc3RyaW5nO1xuICAgICAgICAvKiogTGlzdCBvZiBJRHMgdGhhdCBtYWtlIHVwIHRoZSByb290IFRPQyAqL1xuICAgICAgICB0b2M6IHN0cmluZ1tdO1xuICAgICAgICAvKiogTGlzdCBvZiBjb250ZW50IGl0ZW1zICovXG4gICAgICAgIGl0ZW1zOiBBcnJheTxEb2NJdGVtPjtcbiAgICB9O1xuXG4gICAgLyoqIEFsbCBkb2N1bWVudGF0aW9uIGl0ZW1zIGluZGV4ZWQgYnkgSUQgYW5kIHNsdWcgKi9cbiAgICBwcml2YXRlIF9pdGVtc0J5SWQ6IHsgW2lkOiBzdHJpbmddOiBEb2NJdGVtIH0gPSB7fTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZG9jcy12aWV3ZXIvRG9jdW1lbnRTZXJ2aWNlLnRzIiwiaW1wb3J0IHsgQXN5bmMsIEFwcCB9IGZyb20gXCJAdHlwZXNjZW5lL2RvbVwiO1xuaW1wb3J0IHsgRG9jdW1lbnRTZXJ2aWNlLCBEb2NJdGVtIH0gZnJvbSBcIi4vRG9jdW1lbnRTZXJ2aWNlXCI7XG5cbi8qKiBBY3Rpdml0eSB0aGF0IHNob3VsZCBiZSBvbiB0aGUgc3RhY2sgYmVmb3JlIGFsbCBvdGhlcnMgKi9cbmV4cG9ydCBjbGFzcyBNYWluQWN0aXZpdHkgZXh0ZW5kcyBBcHAuU3VwcG9ydEFjdGl2aXR5IHtcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmF0aW9uOiBBcHAuQWN0aXZhdGlvbikge1xuICAgICAgICBzdXBlcihhY3RpdmF0aW9uKTtcbiAgICAgICAgdGhpcy50aXRsZSA9IFwiVHlwZXNjZW5lXCI7XG4gICAgICAgIHRoaXMuU3RhcnRpbmcuY29ubmVjdCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50U2VydmljZS5sb2FkQXN5bmMoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy50aXRsZSA9IHRoaXMuZG9jdW1lbnRTZXJ2aWNlLmdldFRpdGxlKCk7XG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIEBBcHAuaW5qZWN0U2VydmljZVxuICAgIHB1YmxpYyBkb2N1bWVudFNlcnZpY2U6IERvY3VtZW50U2VydmljZTtcblxuICAgIC8qKiBUcnVlIGlmIGRvY3VtZW50YXRpb24gaXMgbG9hZGluZyAob2JzZXJ2YWJsZSkgKi9cbiAgICBAQXN5bmMub2JzZXJ2YWJsZVxuICAgIHB1YmxpYyBsb2FkaW5nID0gdHJ1ZTtcblxuICAgIC8qKiBUcnVlIGlmIGFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgZG9jdW1lbnRhdGlvbiAob2JzZXJ2YWJsZSkgKi9cbiAgICBAQXN5bmMub2JzZXJ2YWJsZVxuICAgIHB1YmxpYyBlcnJvciA9IGZhbHNlO1xufVxuXG4vKiogQWN0aXZpdHkgdGhhdCBpcyBtYXBwZWQgdG8gcm9vdCBVUkxzIGFuZCBmb3J3YXJkcyB0byBmaXJzdCBhcnRpY2xlICovXG5AQXBwLm1hcFJvdXRlKFwiL1wiKVxuQEFwcC5tYXBSb3V0ZShcIi9kb2MvXCIpXG5AQXBwLm1hcFBhcmVudEFjdGl2aXR5KE1haW5BY3Rpdml0eSlcbmV4cG9ydCBjbGFzcyBIb21lQWN0aXZpdHkgZXh0ZW5kcyBBcHAuQWN0aXZpdHkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLlN0YXJ0aW5nLmNvbm5lY3QoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFNlcnZpY2UubG9hZEFzeW5jKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gdGhpcy5kb2N1bWVudFNlcnZpY2UuZ2V0VE9DSXRlbXMoKVswXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgIEFwcC5BcHBsaWNhdGlvbi5jdXJyZW50LnN0YXJ0QWN0aXZpdHlBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiL2RvYy9cIiArIChmaXJzdC50ZXh0U2x1ZyB8fCBmaXJzdC5pZCksIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgQEFwcC5pbmplY3RTZXJ2aWNlXG4gICAgcHVibGljIGRvY3VtZW50U2VydmljZTogRG9jdW1lbnRTZXJ2aWNlO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kb2NzLXZpZXdlci9NYWluQWN0aXZpdHkudHMiLCJpbXBvcnQgeyBBcHAsIEFzeW5jLCBVSSB9IGZyb20gXCJAdHlwZXNjZW5lL2RvbVwiO1xuaW1wb3J0IHsgTWFpbkFjdGl2aXR5IH0gZnJvbSBcIi4vTWFpbkFjdGl2aXR5XCI7XG5cbkBBcHAubWFwVmlld0FjdGl2aXR5KE1haW5BY3Rpdml0eSlcbmV4cG9ydCBjbGFzcyBNYWluVmlldyBleHRlbmRzIEFwcC5IdWJWaWV3TGF5b3V0LndpdGgoXG4gICAgeyBob3J6QWxpZ246IFwiY2VudGVyXCIsIG1heENvbnRlbnRXaWR0aDogXCJjYWxjKDQwdncgKyAyMHJlbSlcIiB9LFxuICAgIEFwcC5IdWJWaWV3TGF5b3V0LkhlYWRlci53aXRoKFxuICAgICAgICB7IHN0eWxlOiB7IGJhY2tncm91bmQ6IFwibGluZWFyLWdyYWRpZW50KDI4NGRlZywgIzJiZiAwJSwgIzUwOSAxMDAlKSB8fCAjNGFlXCIgfSB9LFxuICAgICAgICBVSS5UZXh0QnV0dG9uLndpdGgoe1xuICAgICAgICAgICAgaGlkZGVuOiBVSS5iaW5kKFwiIXNpZGViYXJDb2xsYXBzZWRcIiksXG4gICAgICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgICAgIGljb246IFwiZmEtYmFyc1wiLFxuICAgICAgICAgICAgQ2xpY2s6IFwic2hvd0RyYXdlclwiXG4gICAgICAgIH0pLFxuICAgICAgICBVSS5JbWFnZS53aXRoKHtcbiAgICAgICAgICAgIGltYWdlVXJsOiBcIi9sb2dvLnBuZ1wiLFxuICAgICAgICAgICAgd2lkdGg6IFwiMS41cmVtXCIsXG4gICAgICAgICAgICBzdHlsZV9pbWc6IHsgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIiB9XG4gICAgICAgIH0pLFxuICAgICAgICBVSS50bGB7aDF8MS41cmVtfDYwMH1Eb2N1bWVudGF0aW9uYCxcbiAgICAgICAgVUkuU3BhY2VyLFxuICAgICAgICBVSS5MaW5rQnV0dG9uLndpdGgoe1xuICAgICAgICAgICAgaGlkZGVuOiBVSS5iaW5kKFwic2lkZWJhckNvbGxhcHNlZFwiKSxcbiAgICAgICAgICAgIGxhYmVsOiBcIlR5cGVzY2VuZSBob21lXCIsXG4gICAgICAgICAgICB0YXJnZXQ6IFwiaHR0cDovL3R5cGVzY2VuZS5vcmdcIlxuICAgICAgICB9KSxcbiAgICAgICAgVUkuTGlua0J1dHRvbi53aXRoKHtcbiAgICAgICAgICAgIGhpZGRlbjogVUkuYmluZChcInNpZGViYXJDb2xsYXBzZWRcIiksXG4gICAgICAgICAgICBsYWJlbDogXCJHaXRodWJcIixcbiAgICAgICAgICAgIHRhcmdldDogXCJodHRwczovL3d3dy5naXRodWIuY29tL3R5cGVzY2VuZS90eXBlc2NlbmVcIlxuICAgICAgICB9KVxuICAgICksXG4gICAgQXBwLkh1YlZpZXdMYXlvdXQuU2lkZWJhci53aXRoKFxuICAgICAgICB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBcIjFweCBzb2xpZCAjZWVlXCIsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogXCIjZjhmOGY4XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY3JvbGxhYmxlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBBcHAuSHViVmlld0xheW91dC5TaWRlYmFyLkhlYWRlci53aXRoKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGhpZGRlbjogVUkuYmluZChcIiFzaWRlYmFyQ29sbGFwc2VkXCIpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogXCI3cmVtXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHsgYmFja2dyb3VuZDogXCIjMzMzXCIsIGNvbG9yOiBcIiNmZmZcIiB9LFxuICAgICAgICAgICAgICAgIHZlcnRBbGlnbjogXCJib3R0b21cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFVJLnRsYHtoNH1UYWJsZSBvZiBDb250ZW50c2BcbiAgICAgICAgKSxcbiAgICAgICAgVUkuYmluZChcImZyYWdtZW50cy5UT0NWaWV3XCIpXG4gICAgKSxcbiAgICBVSS5iaW5kKFwiZnJhZ21lbnRzLkRvY1ZpZXdcIilcbikge1xuICAgIEBBcHAubGF5b3V0RnJhZ21lbnRcbiAgICBzdGF0aWMgVE9DVmlldyA9IEFwcC5TY3JvbGxhYmxlTGF5b3V0LndpdGgoeyBpZDogXCJ0b2NcIiwgaGVpZ2h0OiBcIjEwMCVcIiB9KTtcblxuICAgIEBBcHAubGF5b3V0RnJhZ21lbnRcbiAgICBzdGF0aWMgRG9jVmlldyA9IFVJLkNvbnRhaW5lci53aXRoKHsgaWQ6IFwiZG9jXCIgfSk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgYWN0aXZpdHk6IE1haW5BY3Rpdml0eSkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIC8qKiBTaG93IHRoZSBUT0MgZHJhd2VyIChvbiBzbWFsbCBzY3JlZW5zKSAqL1xuICAgIHB1YmxpYyBzaG93RHJhd2VyKCkge1xuICAgICAgICB0aGlzLmRyYXdlci5vcGVuQXN5bmMoKTtcbiAgICAgICAgQXBwLkFwcGxpY2F0aW9uLmN1cnJlbnQuYWN0aXZpdGllcy5UcmFuc2l0aW9uLmNvbm5lY3RPbmNlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhd2VyLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZG9jcy12aWV3ZXIvTWFpblZpZXcudHMiLCJpbXBvcnQgeyBBcHAsIEFzeW5jLCBVSSB9IGZyb20gXCJAdHlwZXNjZW5lL2RvbVwiO1xuaW1wb3J0IHsgRG9jSXRlbSwgRG9jdW1lbnRTZXJ2aWNlIH0gZnJvbSBcIi4vRG9jdW1lbnRTZXJ2aWNlXCI7XG5pbXBvcnQgeyBNYWluQWN0aXZpdHkgfSBmcm9tIFwiLi9NYWluQWN0aXZpdHlcIjtcblxuQEFwcC5tYXBSb3V0ZShcIi9kb2MvKmdsb2JcIilcbmNsYXNzIERvY0FjdGl2YXRpb24gZXh0ZW5kcyBBcHAuQWN0aXZhdGlvbiB7XG4gICAgcHVibGljIGdsb2I6IHN0cmluZztcbn1cblxuQEFwcC5tYXBBY3RpdmF0aW9uKERvY0FjdGl2YXRpb24pXG5AQXBwLm1hcFBhcmVudEFjdGl2aXR5KE1haW5BY3Rpdml0eSlcbmV4cG9ydCBjbGFzcyBEb2NBY3Rpdml0eSBleHRlbmRzIEFwcC5BY3Rpdml0eSB7XG4gICAgcHJvdGVjdGVkIG9uQ3JlYXRlQXN5bmMoKSB7XG4gICAgICAgIC8vIGZpbmQgbWFpbiBhY3Rpdml0eSBhbmQgZ2V0IGRhdGFcbiAgICAgICAgdmFyIGdsb2IgPSB0aGlzLmFjdGl2YXRpb25bXCJnbG9iXCJdO1xuICAgICAgICB0aGlzLlN0YXJ0ZWQuY29ubmVjdCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50U2VydmljZS5sb2FkQXN5bmMoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVsYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVE9ETzogZG8gdGhpcyBpbiBhIG1vcmUgc3RydWN0dXJhbCB3YXkuLi5cbiAgICAgICAgLy8gc2F2ZSAmIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9ucyB3aGVuIG1vdmluZyBiYWNrL2ZvcndhcmRcbiAgICAgICAgbGV0IHdpdGhTY3JvbGxFbHQgPSAoZjogKGVsdDogSFRNTEVsZW1lbnQpID0+IHZvaWQpID0+ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBwYWdlID0gVUkuUGFnZS5nZXRDdXJyZW50UGFnZSgpO1xuICAgICAgICAgICAgaWYgKHBhZ2UgJiYgKHBhZ2UuY29udGVudFswXSBpbnN0YW5jZW9mIFVJLkxheW91dENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBwYWdlLmNvbnRlbnRbMF0hLmdldFJlbmRlcmVkT3V0cHV0QXN5bmMoKS50aGVuKG91dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbHQ6IEhUTUxFbGVtZW50ID0gb3V0ICYmIG91dC5lbGVtZW50ICYmIG91dC5lbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTdHJpbmcoZWx0LmNsYXNzTmFtZSkuc3BsaXQoL1xccysvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb21lKHMgPT4gcyA9PT0gXCJVSS1MYXlvdXRDb250YWluZXJfc2Nyb2xsXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYoZWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsdCA9IDxIVE1MRWxlbWVudD5lbHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLlN1c3BlbmRpbmcuY29ubmVjdCh3aXRoU2Nyb2xsRWx0KGVsdCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxUb3AgPSBlbHQuc2Nyb2xsVG9wO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuUmVzdW1lZC5jb25uZWN0KHdpdGhTY3JvbGxFbHQoZWx0ID0+IHtcbiAgICAgICAgICAgIGVsdC5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgbGV0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChBcHAuQXBwbGljYXRpb24uY3VycmVudC5nZXRUb3BBY3Rpdml0eSgpID09PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wID0gdGhpcy5fc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEFzeW5jLnNsZWVwKDEwKS50aGVuKHJlc2V0KTtcbiAgICAgICAgICAgIEFzeW5jLnNsZWVwKDEwMCkudGhlbihyZXNldCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBAQXBwLmluamVjdFNlcnZpY2VcbiAgICBwdWJsaWMgZG9jdW1lbnRTZXJ2aWNlOiBEb2N1bWVudFNlcnZpY2U7XG5cbiAgICBwdWJsaWMgcG9wdWxhdGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZG9jdW1lbnRTZXJ2aWNlLmdldEl0ZW1CeUlkKHRoaXMuYWN0aXZhdGlvbltcImdsb2JcIl0pO1xuICAgICAgICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMudGl0bGUgPSB0aGlzLml0ZW0ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBBcHAuc3RhcnRBY3Rpdml0eUFzeW5jKFwiL1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBBc3luYy5vYnNlcnZhYmxlX3NoYWxsb3dcbiAgICBwdWJsaWMgaXRlbT86IERvY0l0ZW07XG5cbiAgICBwcml2YXRlIF9zY3JvbGxUb3AgPSAwO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kb2NzLXZpZXdlci9Eb2NBY3Rpdml0eS50cyIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9tb25hY28uZC50c1wiIC8+XG5pbXBvcnQgeyBBc3luYyB9IGZyb20gXCJAdHlwZXNjZW5lL2RvbVwiO1xuXG4vKiogVGhlIHJlbGF0aXZlIHBhdGggdGhhdCByZWZlcnMgdG8gdGhlIE1vbmFjbyBFZGl0b3IgXCJ2c1wiIGRpcmVjdG9yeSAqL1xuZGVjbGFyZSB2YXIgVkVSU0lPTjogc3RyaW5nO1xuY29uc3QgVlNfUEFUSCA9IFwiL1wiICsgVkVSU0lPTiArIFwiL21vbmFjby1lZGl0b3IvbWluL3ZzXCI7XG5cbi8qKiBHbG9iYWwgdmFyaWFibGUgZGVmaW5lZCBieSB0aGUgTW9uYWNvIGVkaXRvciBsb2FkZXIuanMgc2NyaXB0ICovXG5kZWNsYXJlIHZhciBBTURMb2FkZXI6IGFueTtcblxuLyoqIFdyYXBwZXIgYXJvdW5kIHRoZSBNUyBNb25hY28gZWRpdG9yLCBjb25maWd1cmVkIGZvciBUeXBlU2NyaXB0IGNvZGUgKGVzNSkgKi9cbmV4cG9ydCBjbGFzcyBNb25hY29FZGl0b3Ige1xuICAgIC8qKiBMb2FkIHRoZSBlZGl0b3Igc2NyaXB0LCByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGV2ZXJ5dGhpbmcgaXMgbG9hZGVkICovXG4gICAgc3RhdGljIGxvYWQoKSB7XG4gICAgICAgIC8vIGxvYWQgdGhlIE1vbmFjbyBlZGl0b3IgQU1EIGxvYWRlciBzY3JpcHRcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzTG9hZGVkIHx8ICh0aGlzLl9pc0xvYWRlZCA9IG5ldyBBc3luYy5Qcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5zcmMgPSBWU19QQVRIICsgXCIvbG9hZGVyLmpzXCI7XG4gICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblxuICAgICAgICAgICAgLy8gcG9sbCB0byBzZWUgaWYgdGhlIHNjcmlwdCBoYXMgcnVuIHlldFxuICAgICAgICAgICAgdmFyIGludHYgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBBTURMb2FkZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnR2KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAoPGFueT53aW5kb3cpW1wicmVxdWlyZVwiXTtcbiAgICAgICAgICAgICAgICAgICAgci5jb25maWcoeyBwYXRoczogeyB2czogVlNfUEFUSCB9IH0pO1xuICAgICAgICAgICAgICAgICAgICByKFtcInZzL2VkaXRvci9lZGl0b3IubWFpblwiXSwgKCkgPT4gcmVzb2x2ZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKiBTZXQgdG8gYSBwcm9taXNlIG9uY2UgdHJ5aW5nIHRvIGxvYWQgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBfaXNMb2FkZWQ6IEFzeW5jLlByb21pc2U8Ym9vbGVhbj47XG5cbiAgICAvKiogTG9hZCBhIC5kLnRzIGZpbGUgaW50byB0aGUgdHlwZXNjcmlwdCBjb250ZXh0ICovXG4gICAgc3RhdGljIGxvYWREZWNsYXJhdGlvbnMoZmlsZU5hbWU6IHN0cmluZywgc291cmNlOiBzdHJpbmcpIHtcbiAgICAgICAgbW9uYWNvLmxhbmd1YWdlcy50eXBlc2NyaXB0LnR5cGVzY3JpcHREZWZhdWx0cy5hZGRFeHRyYUxpYihcbiAgICAgICAgICAgIHNvdXJjZSwgZmlsZU5hbWUpO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIGVkaXRvciwgaW5zaWRlIGdpdmVuIEhUTUwgZWxlbWVudCAqL1xuICAgIGNvbnN0cnVjdG9yKGVsdDogSFRNTEVsZW1lbnQsIGNvZGUgPSBcIlwiKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsdDtcbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuX2VkaXRvciA9IG1vbmFjby5lZGl0b3IuY3JlYXRlKGVsdCwge1xuICAgICAgICAgICAgdGhlbWU6IFwidnMtZGFya1wiLFxuICAgICAgICAgICAgdmFsdWU6IGNvZGUsXG4gICAgICAgICAgICBsYW5ndWFnZTogXCJ0eXBlc2NyaXB0XCIsXG4gICAgICAgICAgICBmb2xkaW5nOiB0cnVlLFxuICAgICAgICAgICAgc2Nyb2xsQmV5b25kTGFzdExpbmU6IGZhbHNlLFxuICAgICAgICAgICAgZm9ybWF0T25UeXBlOiB0cnVlLFxuICAgICAgICAgICAgZm9ybWF0T25QYXN0ZTogdHJ1ZSxcbiAgICAgICAgICAgIHdvcmRCYXNlZFN1Z2dlc3Rpb25zOiBmYWxzZSxcbiAgICAgICAgICAgIG1pbmltYXA6IHsgZW5hYmxlZDogZmFsc2UgfVxuICAgICAgICB9KTtcbiAgICAgICAgbW9uYWNvLmxhbmd1YWdlcy50eXBlc2NyaXB0LnR5cGVzY3JpcHREZWZhdWx0cy5zZXRDb21waWxlck9wdGlvbnMoe1xuICAgICAgICAgICAgdGFyZ2V0OiBtb25hY28ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQuU2NyaXB0VGFyZ2V0LkVTMjAxNSxcbiAgICAgICAgICAgIG1vZHVsZTogbW9uYWNvLmxhbmd1YWdlcy50eXBlc2NyaXB0Lk1vZHVsZUtpbmQuQ29tbW9uSlMsXG4gICAgICAgICAgICBhbGxvd05vblRzRXh0ZW5zaW9uczogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbERlY29yYXRvcnM6IHRydWUsXG4gICAgICAgICAgICBzdHJpY3ROdWxsQ2hlY2tzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3Iub25EaWRDaGFuZ2VDdXJzb3JQb3NpdGlvbigoKSA9PiB7XG4gICAgICAgICAgICB2YXIgcG9zID0gZWRpdG9yLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zLmxpbmVOdW1iZXIgKyBcIjpcIiArIHBvcy5jb2x1bW47XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBET00gZWxlbWVudCB0aGF0IHRoaXMgZWRpdG9yIGlzIGluc2lkZSBvZiAqL1xuICAgIHB1YmxpYyBlbGVtZW50OiBIVE1MRWxlbWVudDtcblxuICAgIC8qKiBDdXJzb3IgcG9zaXRpb24gYXMgYSBzdHJpbmcgKGxpbmU6Y29sdW1uKSAqL1xuICAgIEBBc3luYy5vYnNlcnZhYmxlXG4gICAgcHVibGljIHBvc2l0aW9uID0gXCIxOjFcIjtcblxuICAgIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRleHQgY29udGVudHMgb2YgdGhlIGVkaXRvciAqL1xuICAgIHB1YmxpYyBnZXRDb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgLyoqIE92ZXJ3cml0ZXMgdGhlIGN1cnJlbnQgdGV4dCBjb250ZW50cyBvZiB0aGUgZWRpdG9yLCBhbmQgZm9jdXNlcyBlbGVtZW50ICovXG4gICAgcHVibGljIHNldENvZGUoc291cmNlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZWRpdG9yLnNldFZhbHVlKHNvdXJjZSk7XG4gICAgICAgIHRoaXMuX2VkaXRvci5zZXRQb3NpdGlvbih7IGxpbmVOdW1iZXI6IDEsIGNvbHVtbjogMSB9KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFwiMToxXCI7XG4gICAgICAgIHRoaXMuX2VkaXRvci5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKiBVcGRhdGUgbGF5b3V0IGFuZCByZS1mb2N1cyB0aGUgZWRpdG9yICovXG4gICAgcHVibGljIGZvY3VzKCkge1xuICAgICAgICB0aGlzLl9lZGl0b3IubGF5b3V0KCk7XG4gICAgICAgIHRoaXMuX2VkaXRvci5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKiBEaXNwb3NlIHRoZSBlZGl0b3IgKi9cbiAgICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZWRpdG9yLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9lZGl0b3I6IG1vbmFjby5lZGl0b3IuSVN0YW5kYWxvbmVDb2RlRWRpdG9yO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kb2NzLXZpZXdlci9Nb25hY29FZGl0b3IudHMiLCJpbXBvcnQgeyBBc3luYywgVUksIEFwcCB9IGZyb20gXCJAdHlwZXNjZW5lL2RvbVwiO1xuaW1wb3J0IHsgTW9uYWNvRWRpdG9yIH0gZnJvbSBcIi4vTW9uYWNvRWRpdG9yXCI7XG5pbXBvcnQgeyBEb2N1bWVudFNlcnZpY2UgfSBmcm9tIFwiLi9Eb2N1bWVudFNlcnZpY2VcIjtcbmRlY2xhcmUgdmFyIFZFUlNJT046IHN0cmluZztcblxuLyoqIEdsb2JhbCBUeXBlU2NyaXB0IGNvbXBpbGVyIGluc3RhbmNlICovXG52YXIgdHM6IGFueTtcblxuLyoqIE1vZHVsZXMgYnkgSUQgKi9cbnZhciB0eXBlc2NlbmU6IGFueSA9ICg8YW55PndpbmRvdykudHlwZXNjZW5lO1xuY29uc3QgbW9kdWxlczogeyBbaWQ6IHN0cmluZ106IGFueSB9ID0ge1xuICAgIFwiQHR5cGVzY2VuZS9jb3JlXCI6IHR5cGVzY2VuZS5jb3JlLFxuICAgIFwiQHR5cGVzY2VuZS9jb3JlL0FzeW5jXCI6IHR5cGVzY2VuZS5jb3JlLkFzeW5jLFxuICAgIFwiQHR5cGVzY2VuZS9jb3JlL1VJXCI6IHR5cGVzY2VuZS5jb3JlLlVJLFxuICAgIFwiQHR5cGVzY2VuZS9jb3JlL0FwcFwiOiB0eXBlc2NlbmUuY29yZS5BcHAsXG4gICAgXCJAdHlwZXNjZW5lL2RvbVwiOiB0eXBlc2NlbmUsXG4gICAgXCJAdHlwZXNjZW5lL2RvbS9Bc3luY1wiOiB0eXBlc2NlbmUuQXN5bmMsXG4gICAgXCJAdHlwZXNjZW5lL2RvbS9VSVwiOiB0eXBlc2NlbmUuVUksXG4gICAgXCJAdHlwZXNjZW5lL2RvbS9BcHBcIjogdHlwZXNjZW5lLkFwcFxufTtcblxuLyoqIENvZGUgbW9kaWZpZWQgYnkgdXNlciwgYnkgZXhhbXBsZSBJRCAqL1xuY29uc3QgbW9kaWZpZWRDb2RlOiB7IFtleGFtcGxlSUQ6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG5cbi8qKiBMYXN0IG9wZW5lZCBleGFtcGxlIGNvZGUgSUQgKi9cbnZhciBsYXN0RWRpdGVkRXhhbXBsZUlEOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbi8qKiBMYXN0IG9wZW4gZWRpdG9yIChzaG91bGQgYmUgZGVzdHJveWVkIHdoZW4gb3BlbmluZyBhIG5ldyBlZGl0b3IgKi9cbnZhciBsYXN0RWRpdG9yOiBNb25hY29FZGl0b3IgfCB1bmRlZmluZWQ7XG5cbi8vIHN0YXJ0IHdpdGggYSBmcmVzaCBoaWRkZW4gZWRpdG9yIHRvIGxvYWQgdHlwZXNjcmlwdFxudmFyIF9sb2FkZWQgPSBVSS5TY3JlZW4ucmVhZHkudGhlbigoKSA9PiB7XG4gICAgcmV0dXJuIE1vbmFjb0VkaXRvci5sb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAgIG5ldyBNb25hY29FZGl0b3IoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIHZhciBzdmM6IERvY3VtZW50U2VydmljZSA9IERvY3VtZW50U2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICByZXR1cm4gc3ZjLmxvYWRBc3luYygpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIEFwcC5IdHRwLmdldFRleHRBc3luYyhcIi9cIiArIFZFUlNJT04gKyBcIi90eXBlc2NlbmUuZC50cy50eHRcIilcbiAgICAgICAgfSkudGhlbihkZWZzID0+IHtcbiAgICAgICAgICAgIE1vbmFjb0VkaXRvci5sb2FkRGVjbGFyYXRpb25zKFwidHlwZXNjZW5lLmQudHNcIiwgZGVmcyk7XG4gICAgICAgICAgICBNb25hY29FZGl0b3IubG9hZERlY2xhcmF0aW9ucyhcImVkaXRvci5kLnRzXCIsXG4gICAgICAgICAgICAgICAgXCJkZWNsYXJlIHZhciBkaXNwbGF5UmVzdWx0OiAodmFsdWU6IGFueSkgPT4gdm9pZFwiKTtcbiAgICAgICAgICAgIGxldCBkb1BvbGxUeXBlc2NyaXB0ID0gKCk6IGFueSA9PlxuICAgICAgICAgICAgICAgIEFzeW5jLnNsZWVwKDEwMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRzID0gKDxhbnk+d2luZG93KVtcInRzXCJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHMpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBkb1BvbGxUeXBlc2NyaXB0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZG9Qb2xsVHlwZXNjcmlwdCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuXG5leHBvcnQgY2xhc3MgQ29kZU91dHB1dENvbnRhaW5lciBleHRlbmRzIFVJLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IocHVibGljIGNJRDogc3RyaW5nLCBwdWJsaWMgY29kZTogc3RyaW5nLCBvdXRwdXRJZGVudGlmaWVyPzogc3RyaW5nLFxuICAgICAgICBwdWJsaWMgaGFzRWRpdEJ1dHRvbiA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXcgKFVJLkNsb3NlUm93LndpdGgoXG4gICAgICAgICAgICBVSS50bChcIntpfCM1NTV9U3RhcnRpbmcgVHlwZVNjcmlwdCBlbnZpcm9ubWVudC4uLlwiKVxuICAgICAgICApKSk7XG5cbiAgICAgICAgLy8gd3JhcCBjb2RlIGluIGEgZnVsbCBwcm9ncmFtXG4gICAgICAgIHRoaXMuY29kZSA9XG4gICAgICAgICAgICAoL15pbXBvcnQvLnRlc3QoY29kZSkgPyBcIlwiIDpcbiAgICAgICAgICAgICAgICBcImltcG9ydCB7IEFzeW5jLCBVSSwgQXBwIH0gZnJvbSBcXFwiQHR5cGVzY2VuZS9kb21cXFwiO1xcblxcblwiKSArXG4gICAgICAgICAgICBjb2RlO1xuICAgICAgICBpZiAob3V0cHV0SWRlbnRpZmllcilcbiAgICAgICAgICAgIHRoaXMuY29kZSArPSBcIlxcbmRpc3BsYXlSZXN1bHQoXCIgKyBvdXRwdXRJZGVudGlmaWVyICsgXCIpO1wiO1xuICAgICAgICBlbHNlIGlmICghL2NvbnNvbGVcXC5sb2cvLnRlc3QoY29kZSkpXG4gICAgICAgICAgICB0aGlzLmNvZGUgKz0gXCJcXG5jb25zb2xlLmxvZyhcXFwiT0tcXFwiKVwiO1xuXG4gICAgICAgIC8vIHdhaXQgZm9yIFR5cGVzY3JpcHQgZW52aXJvbm1lbnQgdG8gYmUgbG9hZGVkXG4gICAgICAgIF9sb2FkZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmFkZENsYXNzKFwiZG9jLXRleHQtZXhhbXBsZS1vdXRwdXRcIilcbiAgICAgICAgICAgICAgICAuYWRkU2hhZG93RWZmZWN0KC4yKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlT3V0cHV0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBOdW1iZXIgb2YgdGltZXMgdXBkYXRlZCAqL1xuICAgIHB1YmxpYyBjb3VudCA9IDA7XG5cbiAgICAvKiogUmV2ZXJ0IGNoYW5nZXMgYW5kIHVwZGF0ZSBvdXRwdXQgKi9cbiAgICBwdWJsaWMgcmV2ZXJ0Q2hhbmdlcygpIHtcbiAgICAgICAgZGVsZXRlIG1vZGlmaWVkQ29kZVt0aGlzLmNJRF07XG4gICAgICAgIHRoaXMudXBkYXRlT3V0cHV0KCk7XG4gICAgfVxuXG4gICAgLyoqIFNob3cgZWRpdG9yIGZvciBjdXJyZW50IGV4YW1wbGUgY29kZSAqL1xuICAgIHB1YmxpYyBzaG93RWRpdG9yKCkge1xuICAgICAgICBuZXcgQ29kZUVkaXRvcih0aGlzKS5vcGVuQXN5bmMoKTtcbiAgICB9XG5cbiAgICAvKiogVXBkYXRlIHRoZSBvdXRwdXQgd2l0aGluIHRoaXMgY29udGFpbmVyLCBmb3IgY3VycmVudCBleGFtcGxlIGNvZGUgKi9cbiAgICBwdWJsaWMgdXBkYXRlT3V0cHV0KCkge1xuICAgICAgICAvLyBtYWtlIHRoZSBmYWN0b3J5IHRoYXQgY3JlYXRlcyB0aGUgYnlsaW5lIGFuZCBidXR0b25zIG9uIHRvcFxuICAgICAgICB2YXIgaXNNb2RpZmllZCA9ICEhKG1vZGlmaWVkQ29kZVt0aGlzLmNJRF0pO1xuICAgICAgICB2YXIgZGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgZGRNaW5zID0gZGQuZ2V0TWludXRlcygpO1xuICAgICAgICB2YXIgZGRTZWNzID0gZGQuZ2V0U2Vjb25kcygpO1xuICAgICAgICB2YXIgZGRTdHIgPSBcIlVwZGF0ZWQgXCIgKyBkZC5nZXRIb3VycygpICsgXCI6XCIgK1xuICAgICAgICAgICAgKGRkTWlucyA8IDEwID8gXCIwXCIgKyBkZE1pbnMgOiBkZE1pbnMpICsgXCI6XCIgK1xuICAgICAgICAgICAgKGRkU2VjcyA8IDEwID8gXCIwXCIgKyBkZFNlY3MgOiBkZFNlY3MpO1xuICAgICAgICB2YXIgYnlsaW5lID0gVUkuUm93LndpdGgoe1xuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIFVJLnRsKCh0aGlzLmNvdW50KysgPyBkZFN0ciA6IFwiT3V0cHV0XCIpXG4gICAgICAgICAgICAgICAgICAgICsgKGlzTW9kaWZpZWQgPyBcIiAobW9kaWZpZWQpXCIgOiBcIlwiKSksXG4gICAgICAgICAgICAgICAgVUkuU3BhY2VyLFxuICAgICAgICAgICAgICAgIFVJLlRleHRCdXR0b24ud2l0aCh7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBcIkVkaXQgdGhpcyBleGFtcGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIENsaWNrZWQ6IFwic2hvd0VkaXRvclwiLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46IEFzeW5jLm9ic2VydmUoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLmhhc0VkaXRCdXR0b24gfHwgVUkuU2NyZWVuLmRpbWVuc2lvbnMuaXNTbWFsbClcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpc01vZGlmaWVkID9cbiAgICAgICAgICAgICAgICAgICAgVUkuVGV4dEJ1dHRvbi53aXRoTGFiZWwoXCJSZXZlcnQgY2hhbmdlc1wiLCBcInJldmVydENoYW5nZXNcIikgOlxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjEuNzVyZW1cIixcbiAgICAgICAgICAgIHN0eWxlOiBVSS5TdHlsZS53aXRoQ2xhc3MoXCJkb2MtdGV4dC1leGFtcGxlLWJ5bGluZVwiKSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHsgYXBwZWFyOiBVSS5ET00uRE9NQW5pbWF0aW9uLmJhc2ljLmluLnNsaWRlRG93biB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRyYW5zcGlsZSB0aGUgcHJvZ3JhbVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBtb2RpZmllZENvZGVbdGhpcy5jSURdIHx8IHRoaXMuY29kZTtcbiAgICAgICAgICAgIHZhciB0ID0gdHMudHJhbnNwaWxlTW9kdWxlKGNvZGUsIHtcbiAgICAgICAgICAgICAgICByZXBvcnREaWFnbm9zdGljczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb21waWxlck9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImVzNVwiLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IFwiY29tbW9uanNcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsRGVjb3JhdG9yczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0TnVsbENoZWNrczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGliOiBbXCJlczIwMTVcIiwgXCJkb21cIl1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBtb2NrQ29uc29sZSA9IHtcbiAgICAgICAgICAgICAgICBsb2c6ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBBc3luYy51bm9ic2VydmVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IGFsbCBvdXRwdXQgdG8gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dDogc3RyaW5nW10gPSBhcmdzLm1hcCh2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHJldHVybiB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHsgcmV0dXJuIFN0cmluZyh2KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHsgcmV0dXJuIFN0cmluZyhlcnIpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVdpdGgoeyBjb250ZW50OiBbYnlsaW5lXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENvbXBvbmVudHNCeVR5cGUoVUkuUm93KVswXS5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51bnNoaWZ0KG5ldyBVSS5JY29uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmYS10ZXJtaW5hbCBjb2xvcj1ncmVlbiBmb250U2l6ZT0xcmVtXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGFsbCBsb2dnZWQgdGV4dCBpbiBhIHJvdyB3aXRoIGEgc2luZ2xlIGxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBuZXcgVUkuTGFiZWwob3V0cHV0LmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLndyYXBUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLnNocmlua3dyYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKG5ldyBVSS5Sb3coW2xhYmVsXSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHsgKDxhbnk+T2JqZWN0KS5zZXRQcm90b3R5cGVPZihtb2NrQ29uc29sZSwgY29uc29sZSkgfVxuICAgICAgICAgICAgY2F0Y2ggKGFsbCkgeyB9XG5cbiAgICAgICAgICAgIC8vIHJ1biB0aGUgKG1vZGlmaWVkKSBwcm9ncmFtIHdpdGggZnVuY3Rpb24gcGFyYW1ldGVyc1xuICAgICAgICAgICAgdGhpcy5jb250ZW50Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAobmV3IEZ1bmN0aW9uKFwiZXhwb3J0c1wiLCBcInJlcXVpcmVcIiwgXCJkaXNwbGF5UmVzdWx0XCIsIFwiY29uc29sZVwiLCB0Lm91dHB1dFRleHQpKVxuICAgICAgICAgICAgICAgIC5jYWxsKHZvaWQgMCxcbiAgICAgICAgICAgICAgICAvLyBleHBvcnRzIChpZ25vcmVkKVxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmUgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgKG5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlc1tuYW1lXSkgcmV0dXJuIG1vZHVsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZTogXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIGRpc3BsYXlSZXN1bHQgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplV2l0aCh7IGNvbnRlbnQ6IFtieWxpbmUsIHZhbHVlXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50c0J5VHlwZShVSS5Sb3cpWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRlbnQudW5zaGlmdChuZXcgVUkuSWNvbihcImZhLWNoZWNrIGNvbG9yPWdyZWVuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZSB3aXRoIG93biBgbG9nYCBtZXRob2RcbiAgICAgICAgICAgICAgICBtb2NrQ29uc29sZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIEFzeW5jLnNsZWVwKDEwMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGZvcmNlIGRpc3BsYXkgb2YgZW1wdHkgcmVzdWx0IGFmdGVyIDFzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPT09IDApIG1vY2tDb25zb2xlLmxvZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gZGlzcGxheSBlcnJvciBpbnN0ZWFkXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBVSS50bChcIntpfCNjMzB9XCIgKyBTdHJpbmcoZXJyKSk7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVXaXRoKHsgY29udGVudDogW2J5bGluZSwgbGFiZWxdIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDb2RlRWRpdG9yIGV4dGVuZHMgVUkuRGlhbG9nQ29udGFpbmVyLndpdGgoXG4gICAge1xuICAgICAgICBoZWlnaHQ6IFwiMTAwdmhcIixcbiAgICAgICAgd2lkdGg6IFwiNTV2d1wiLFxuICAgICAgICBzY3JvbGxhYmxlOiBmYWxzZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIG92ZXJmbG93OiBcInZpc2libGVcIixcbiAgICAgICAgICAgIG1pbldpZHRoOiBcIjQ1cmVtXCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzMzNcIlxuICAgICAgICB9LFxuICAgICAgICBzaGFkb3dFZmZlY3Q6IDEsXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIGFwcGVhcjogVUkuRE9NLkRPTUFuaW1hdGlvbi5iYXNpYy5pbi5zbGlkZVJpZ2h0XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gdG9vbGJhciByb3dcbiAgICBVSS5Sb3cud2l0aChcbiAgICAgICAge1xuICAgICAgICAgICAgaGVpZ2h0OiBcIjJyZW1cIixcbiAgICAgICAgICAgIG92ZXJsYXlQb3NpdGlvbjogVUkuUm93Lk92ZXJsYXlQb3NpdGlvbi5Ub3AsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogXCIzLjVyZW1cIixcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzMzNcIiwgY29sb3I6IFwiI2NjY1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFVJLlRleHRCdXR0b24ud2l0aCh7XG4gICAgICAgICAgICBsYWJlbDogXCJTYXZlIGFuZCBydW5cIixcbiAgICAgICAgICAgIGljb246IFwiZmEtcGxheVwiLFxuICAgICAgICAgICAgcmVtR3V0dGVyOiAyLFxuICAgICAgICAgICAgc3R5bGU6IHsgY3Vyc29yOiBcInBvaW50ZXJcIiB9LFxuICAgICAgICAgICAgc3R5bGVfYnV0dG9uOiB7IGNvbG9yOiBcIlwiIH0sXG4gICAgICAgICAgICBDbGlja2VkOiBcImNsb3NlQW5kUnVuXCJcbiAgICAgICAgfSksXG4gICAgICAgIFVJLlNwYWNlcixcbiAgICAgICAgVUkudGwoVUkuYmluZChcImVkaXRvci5wb3NpdGlvblwiLCBzID0+IChzIHx8IFwiXCIpKSlcbiAgICApLFxuXG4gICAgLy8gdG9wIHJvdyB3aXRoIGJhY2sgYnV0dG9uOlxuICAgIFVJLlJvdy53aXRoKFxuICAgICAgICB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiMy41cmVtXCIsXG4gICAgICAgICAgICBvdmVybGF5UG9zaXRpb246IFVJLlJvdy5PdmVybGF5UG9zaXRpb24uVG9wLFxuICAgICAgICAgICAgc3R5bGU6IHsgYmFja2dyb3VuZDogXCIjNTU1XCIsIGNvbG9yOiBcIiNmZmZcIiB9LFxuICAgICAgICAgICAgc2hhZG93RWZmZWN0OiAuNVxuICAgICAgICB9LFxuICAgICAgICBVSS5Sb3VuZEJ1dHRvbi53aXRoSWNvbihcImZhLWFycm93LWxlZnRcIiwgXCJjbG9zZVwiKSxcbiAgICAgICAgVUkudGxgezFyZW19TGl2ZSBjb2RlIGVkaXRvcmBcbiAgICApLFxuXG4gICAgLy8gXCJQbGF5XCIgYnV0dG9uIHRvIGNsb3NlIGFuZCBydW4gY29kZVxuICAgIFVJLkNlbnRlclJvdy53aXRoKFxuICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogXCIzLjVyZW1cIixcbiAgICAgICAgICAgIGhlaWdodDogXCIzLjVyZW1cIixcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIHRvcDogXCI0MCVcIixcbiAgICAgICAgICAgICAgICByaWdodDogXCItMS43NXJlbVwiLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiI2ZkM1wiLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIiMzMzNcIixcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiMS43NXJlbVwiLFxuICAgICAgICAgICAgICAgIHpJbmRleDogXCIxXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaGFkb3dFZmZlY3Q6IDEsXG4gICAgICAgICAgICBDbGlja2VkOiBcImNsb3NlQW5kUnVuXCJcbiAgICAgICAgfSxcbiAgICAgICAgVUkuSWNvbi53aXRoKHtcbiAgICAgICAgICAgIGljb246IFwiZmEtcGxheSBmYS0yeFwiLFxuICAgICAgICAgICAgdG9vbHRpcFRleHQ6IFwiQ2xvc2UgJiBydW5cIixcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aWNhbGx5IGNlbnRlciB0aGUgdHJpYW5nbGU6XG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IFwiLjJyZW1cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIClcbikge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBjb2RlT3V0cHV0OiBDb2RlT3V0cHV0Q29udGFpbmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlzcGxheU9wdGlvbnMubW9kYWxIb3J6QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgdmFyIGNvZGUgPSBtb2RpZmllZENvZGVbY29kZU91dHB1dC5jSURdIHx8IGNvZGVPdXRwdXQuY29kZTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGVkaXRvciwgb3IgdXNlIGxhc3QgZWRpdG9yXG4gICAgICAgIGlmIChsYXN0RWRpdGVkRXhhbXBsZUlEID09PSBjb2RlT3V0cHV0LmNJRCkge1xuICAgICAgICAgICAgLy8gcmUtdXNlXG4gICAgICAgICAgICB0aGlzLmVkaXRvciA9IGxhc3RFZGl0b3IhO1xuICAgICAgICAgICAgaWYgKCFtb2RpZmllZENvZGVbdGhpcy5jb2RlT3V0cHV0LmNJRF0pXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc2V0Q29kZSh0aGlzLmNvZGVPdXRwdXQuY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkaXNwb3NlIG9mIG9sZCBlZGl0b3JcbiAgICAgICAgICAgIGxhc3RFZGl0b3IgJiYgbGFzdEVkaXRvci5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgZWRpdG9yXG4gICAgICAgICAgICB2YXIgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yID0gbmV3IE1vbmFjb0VkaXRvcihlbHQsIGNvZGUpO1xuICAgICAgICAgICAgbGFzdEVkaXRlZEV4YW1wbGVJRCA9IGNvZGVPdXRwdXQuY0lEO1xuICAgICAgICAgICAgbGFzdEVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBlZGl0b3IgaW5zaWRlIG9mIGEgRE9NIGJsb2NrIGNvbXBvbmVudFxuICAgICAgICB2YXIgZG9tQmxvY2sgPSBuZXcgVUkuRE9NLkRPTUJsb2NrKHRoaXMuZWRpdG9yLmVsZW1lbnQpO1xuICAgICAgICBkb21CbG9jay5oZWlnaHQgPSBcIjEwMHZoXCI7XG4gICAgICAgIGRvbUJsb2NrLnN0eWxlLnNldChcInBhZGRpbmdUb3BcIiwgXCI1LjVyZW1cIik7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmNvbnRlbnQudW5zaGlmdChkb21CbG9jayk7XG5cbiAgICAgICAgLy8gaWdub3JlIEVTQyBwcmVzc2VzIHdpdGhpbiBlZGl0b3JcbiAgICAgICAgZG9tQmxvY2suRXNjYXBlS2V5UHJlc3NlZC5jb25uZWN0KCgpID0+IHsgfSk7XG5cbiAgICAgICAgLy8gZm9jdXMgdGhlIGVkaXRvciB3aGVuIHJlbmRlcmluZyBmaW5pc2hlc1xuICAgICAgICB0aGlzLlJlbmRlcmVkLmNvbm5lY3Qob3V0ID0+IHtcbiAgICAgICAgICAgIG91dC51cGRhdGVkICYmIG91dC51cGRhdGVkLnRoZW4oKCkgPT4gdGhpcy5lZGl0b3IuZm9jdXMoKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNhdmUgdGhlIGNvZGUgd2hlbiB1c2VyIGNsb3NlcyB0aGlzIGRpYWxvZyAoZS5nLiBjbGlja2luZyBvdXRzaWRlKVxuICAgICAgICB0aGlzLkNsb3NlZC5jb25uZWN0KCgpID0+IHtcbiAgICAgICAgICAgIG1vZGlmaWVkQ29kZVt0aGlzLmNvZGVPdXRwdXQuY0lEXSA9IHRoaXMuZWRpdG9yLmdldENvZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBNb25hY28gZWRpdG9yIGluc3RhbmNlIGluIHVzZSAqL1xuICAgIEBBc3luYy5vYnNlcnZhYmxlXG4gICAgcHVibGljIGVkaXRvcjogTW9uYWNvRWRpdG9yO1xuXG4gICAgLyoqIENsb3NlIHRoZSBkaWFsb2cgYW5kIHVwZGF0ZSBvcmlnaW5hbCBvdXRwdXQgKi9cbiAgICBwdWJsaWMgY2xvc2VBbmRSdW4oKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgbW9kaWZpZWRDb2RlW3RoaXMuY29kZU91dHB1dC5jSURdID0gdGhpcy5lZGl0b3IuZ2V0Q29kZSgpO1xuICAgICAgICBBc3luYy5zbGVlcCgxMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvZGVPdXRwdXQudXBkYXRlT3V0cHV0KCk7XG4gICAgICAgIH0pOyAgICBcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RvY3Mtdmlld2VyL0NvZGVPdXRwdXQudHMiLCJpbXBvcnQgeyBBcHAsIEFzeW5jLCBVSSB9IGZyb20gXCJAdHlwZXNjZW5lL2RvbVwiO1xuaW1wb3J0IHsgTWFpbkFjdGl2aXR5IH0gZnJvbSBcIi4vTWFpbkFjdGl2aXR5XCI7XG5pbXBvcnQgeyBEb2NJdGVtLCBEb2N1bWVudFNlcnZpY2UgfSBmcm9tIFwiLi9Eb2N1bWVudFNlcnZpY2VcIjtcbmltcG9ydCB7IENvZGVPdXRwdXRDb250YWluZXIgfSBmcm9tIFwiLi9Db2RlT3V0cHV0XCI7XG5kZWNsYXJlIHZhciBobGpzOiBhbnk7XG5cbmNvbnN0IFRBR19CR19DTEFTU1RZUEUgPSBcIiMzMzNcIjtcbmNvbnN0IFRBR19CR19JTlRGVFlQRSA9IFwiIzg4OFwiO1xuY29uc3QgVEFHX0JHX0NUT1IgPSBcIiNjM2VcIjtcbmNvbnN0IFRBR19CR19NRU1CRVJUWVBFID0gXCIjMzhlXCI7XG5jb25zdCBUQUdfQkdfQVNZTkMgPSBcIiNhYzZcIjtcbmNvbnN0IFRBR19CR19ERUNPUkFUT1IgPSBcIiM1NTVcIjtcbmNvbnN0IFRBR19CR19PVEhSVFlQRSA9IFwiI2FhYVwiO1xuY29uc3QgVEFHX0JHX1NUQVRJQyA9IFwiI2ViNlwiO1xuY29uc3QgVEFHX0JHX0FDQ0VTUyA9IFwiI2M2M1wiO1xuXG4vKiogSGVscGVyIGZ1bmN0aW9uIHRvIHJlcGxhY2UgY29kZSB0YWdzIHdpdGggbGlua3MgaWYgYXBwbGljYWJsZSAqL1xuZnVuY3Rpb24gbGlua2lmeUNvZGUocm9vdDogSFRNTEVsZW1lbnQsIHN2YzogRG9jdW1lbnRTZXJ2aWNlLCBiYXNlPzogRG9jSXRlbSkge1xuICAgIHZhciBhRWx0cyA9IHJvb3QucXVlcnlTZWxlY3RvckFsbChcImFcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhRWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZWx0ID0gYUVsdHNbaV07XG4gICAgICAgIGxldCBocmVmID0gZWx0LmhyZWY7XG4gICAgICAgIGlmIChocmVmLmluZGV4T2YoXCJ+L1wiKSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBjaGFuZ2UgaHJlZiBmcm9tIH4vZm9vIHRvIC9kb2MvZm9vXG4gICAgICAgICAgICBocmVmID0gaHJlZi5yZXBsYWNlKC8uKn5cXC8vLCBcIi9kb2MvXCIpO1xuICAgICAgICAgICAgZWx0LmhyZWYgPSBocmVmO1xuICAgICAgICAgICAgZWx0Lm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgQXBwLnN0YXJ0QWN0aXZpdHlBc3luYyhocmVmKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvZGVFbHRzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwiY29kZVwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVFbHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBlbHQgPSBjb2RlRWx0c1tpXTtcbiAgICAgICAgaWYgKGVsdC5wYXJlbnROb2RlIS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIkFcIikgY29udGludWU7XG4gICAgICAgIGxldCB0ZXh0ID0gZWx0LmlubmVyVGV4dDtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFwoXFwuKlxcKSQvLCBcIlwiKS5yZXBsYWNlKC9cXCMoXFx3KykkLywgXCIvJDFcIik7XG4gICAgICAgIGlmIChiYXNlICYmICh0ZXh0WzBdID09PSBcIi5cIiB8fCB0ZXh0WzBdID09PSBcIi9cIikpIHtcbiAgICAgICAgICAgIC8vIHVzZSByZWxhdGl2ZSBJRFxuICAgICAgICAgICAgdGV4dCA9IGJhc2UuaWQgKyAoc3ZjLmV4aXN0cyhiYXNlLmlkICsgdGV4dCkgP1xuICAgICAgICAgICAgICAgIHRleHQgOiB0ZXh0LnJlcGxhY2UoL1xcLi9nLCBcIi9cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IHN2Yy5maW5kKHRleHQsIGJhc2UpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIC8vIHdyYXAgPGNvZGU+IGVsZW1lbnQgaW50byA8YT4gZWxlbWVudFxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdmMuZ2V0SXRlbUJ5SWQoaWQpO1xuICAgICAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICAgIGxldCBocmVmID0gXCIvZG9jL1wiICsgKGl0ZW0udGV4dFNsdWcgfHwgaXRlbS5pZCk7XG4gICAgICAgICAgICBhLmhyZWYgPSBocmVmO1xuICAgICAgICAgICAgZWx0LnBhcmVudE5vZGUhLmluc2VydEJlZm9yZShhLCBlbHQpO1xuICAgICAgICAgICAgYS5hcHBlbmRDaGlsZChlbHQpO1xuICAgICAgICAgICAgYS5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIEFwcC5zdGFydEFjdGl2aXR5QXN5bmMoaHJlZik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0byBwZXJmb3JtIHN5bnRheCBoaWdobGlnaHRpbmcgKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodENvZGUoZWx0OiBIVE1MRWxlbWVudCkge1xuICAgIHZhciBwcmVFbHRzID0gZWx0LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwcmUgY29kZVwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZUVsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGVsdCA9IHByZUVsdHNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgaGxqcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIGhsanMuaGlnaGxpZ2h0QmxvY2soZWx0KTtcbiAgICB9XG59XG5cbi8qKiBDb250YWluZXIgd2l0aCBhIGZ1bGwgYXJ0aWNsZSBhYm91dCBhIGRvY3VtZW50YXRpb24gaXRlbS90b3BpYyAqL1xuZXhwb3J0IGNsYXNzIERvY0FydGljbGUgZXh0ZW5kcyBVSS5Db250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBpdGVtOiBEb2NJdGVtKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3R5bGUuc2V0KFwiZm9udFNpemVcIiwgXCIxLjEyNXJlbVwiKTtcblxuICAgICAgICAvLyBhZGQgcm93IHdpdGggdGhlIGl0ZW0gaGVhZGluZywgYW5kIGEgZGl2aWRlclxuICAgICAgICBpZiAoIWl0ZW0udGV4dFNraXBUaXRsZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IChVSS5Sb3cud2l0aChcbiAgICAgICAgICAgICAgICAgICAgeyB2ZXJ0aWNhbFNwYWNpbmc6IFwiLjVyZW1cIiB9LFxuICAgICAgICAgICAgICAgICAgICBVSS5IZWFkaW5nMi53aXRoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNocmlua3dyYXA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBcInByZS13cmFwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMnJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiMzAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogXCIxLjRlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgbmV3IFVJLkRpdmlkZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiMFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJ1aWxkIHVwIHRoZSBhcnRpY2xlIHdpdGggSFRNTCBlbGVtZW50cyxcbiAgICAgICAgLy8gc3RhcnRpbmcgZnJvbSBhIGNvZGUgZGVjbGFyYXRpb24gaWYgYW55XG4gICAgICAgIGlmIChpdGVtLmNvZGUpIHtcbiAgICAgICAgICAgIHZhciBjb2RlRWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNvZGVcIik7XG4gICAgICAgICAgICBjb2RlRWx0LmlubmVyVGV4dCA9IGl0ZW0uY29kZTtcbiAgICAgICAgICAgIHZhciBjb2RlQmxvY2sgPSBuZXcgVUkuRE9NLkRPTUJsb2NrKGNvZGVFbHQpO1xuICAgICAgICAgICAgY29kZUJsb2NrLnN0eWxlLmFkZENsYXNzKFwiZG9jLWNvZGVcIik7XG4gICAgICAgICAgICBjb2RlQmxvY2suc3R5bGUuc2V0KHsgbWFyZ2luOiBcIjFyZW1cIiB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKGNvZGVCbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBlbmQgSlNEb2MgdGV4dFxuICAgICAgICBpZiAoaXRlbS5kb2MpIHtcbiAgICAgICAgICAgIHZhciBkb2NFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZG9jRWx0LmlubmVySFRNTCA9IGl0ZW0uZG9jO1xuICAgICAgICAgICAgbGlua2lmeUNvZGUoZG9jRWx0LCB0aGlzLmRvY3VtZW50U2VydmljZSwgaXRlbS5wYXJlbnRJdGVtKTtcbiAgICAgICAgICAgIHZhciBkb2NCbG9jayA9IG5ldyBVSS5ET00uRE9NQmxvY2soZG9jRWx0KTtcbiAgICAgICAgICAgIGRvY0Jsb2NrLnN0eWxlLmFkZENsYXNzKFwiZG9jLXRleHQtYXJ0aWNsZVwiKTtcbiAgICAgICAgICAgIGRvY0Jsb2NrLnN0eWxlLnNldCh7IG1hcmdpbjogXCIxcmVtXCIgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaChkb2NCbG9jayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBlbmQgbW9yZSB0ZXh0XG4gICAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBpdGVtLnRleHQgJiYgaXRlbS50ZXh0LmZvckVhY2goKHRleHRJdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICB2YXIgdGV4dEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0SXRlbS50eXBlKVxuICAgICAgICAgICAgICAgIHRleHRFbHQuY2xhc3NOYW1lID0gXCJkb2MtdGV4dC10eXBlLVwiICsgdGV4dEl0ZW0udHlwZTtcblxuICAgICAgICAgICAgLy8gcG9wdWxhdGUgdGV4dCBjb250ZW50XG4gICAgICAgICAgICB0ZXh0RWx0LmlubmVySFRNTCA9IHRleHRJdGVtLmNvbnRlbnQ7XG4gICAgICAgICAgICBsaW5raWZ5Q29kZSh0ZXh0RWx0LCB0aGlzLmRvY3VtZW50U2VydmljZSxcbiAgICAgICAgICAgICAgICAoaXRlbS5pc0NsYXNzIHx8IGl0ZW0uaXNJbnRlcmZhY2UgfHwgaXRlbS5pc05hbWVzcGFjZSkgP2l0ZW0gOiBpdGVtLnBhcmVudEl0ZW0pO1xuICAgICAgICAgICAgaGlnaGxpZ2h0Q29kZSh0ZXh0RWx0KTtcblxuICAgICAgICAgICAgLy8gc2hvdyBleGFtcGxlcyB3aXRoIGNvZGUgb3V0cHV0XG4gICAgICAgICAgICBpZiAodGV4dEl0ZW0udHlwZSA9PT0gXCJleGFtcGxlXCIgfHwgdGV4dEl0ZW0udHlwZSA9PT0gXCJwbGF5Z3JvdW5kXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IFwiXCIsIG91dElEID0gdGV4dEl0ZW0uZGlzcGxheVJlc3VsdDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlbHQgb2YgPGFueT50ZXh0RWx0LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwcmVcIikpXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgKz0gKGNvZGUgPyBcIlxcblwiIDogXCJcIikgKyBlbHQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIG91dEVsdDogTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJvdXRwdXRcIik7XG4gICAgICAgICAgICAgICAgdGV4dEVsdC5hcHBlbmRDaGlsZChvdXRFbHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0IGV4cHJlc3Npb24gaW4gdGhlIGV4YW1wbGUgaWZcbiAgICAgICAgICAgICAgICAvLyBkaXNwbGF5UmVzdWx0IGlzIFwiKlwiXG4gICAgICAgICAgICAgICAgaWYgKG91dElEID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICBvdXRJRCA9IFwicmVzdWx0XCI7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBcInZhciByZXN1bHQgPSBcIiArIGNvZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWRkIG9ic2VydmFibGUgdG8gd2F0Y2ggY29kZSBvdXRwdXQgd2hpbGUgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyBpcyBkaXNwbGF5ZWQsIGJ1dCBzaG93IG91dHB1dCBhcyBhbiBlbGVtZW50IGluc2lkZVxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSB0ZXh0IGVsZW1lbnQgaXRzZWxmXG4gICAgICAgICAgICAgICAgdmFyIGV4YW1wbGVJRCA9IGl0ZW0uaWQgKyBcInxleFwiICsgaTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBDb2RlT3V0cHV0Q29udGFpbmVyKGV4YW1wbGVJRCwgY29kZSwgb3V0SUQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRJdGVtLnR5cGUgIT09IFwicGxheWdyb3VuZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCg8YW55PkFzeW5jLm9ic2VydmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gYy5vdXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dEVsdC5wYXJlbnROb2RlIS5yZXBsYWNlQ2hpbGQob3V0LmVsZW1lbnQsIG91dEVsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRFbHQgPSBvdXQuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIC8vIGZvciBwbGF5Z3JvdW5kIFwiZXhhbXBsZVwiLCBzaG93IGEgc2VwYXJhdGUgYnV0dG9uIHRvIG9wZW4gdGhlIGVkaXRvclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0SXRlbS50eXBlID09PSBcInBsYXlncm91bmRcIikge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RWx0LmNsYXNzTmFtZSArPSBcIiBkb2MtdGV4dC10eXBlLWV4YW1wbGVcIlxuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gbmV3IChVSS5Sb3cud2l0aChcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdmVydGljYWxTcGFjaW5nOiBcIjFyZW1cIiwgc3BhY2luZzogXCIwXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFVJLlByaW1hcnlCdXR0b24ud2l0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiBBc3luYy5vYnNlcnZlKCgpID0+IFVJLlNjcmVlbi5kaW1lbnNpb25zLmlzU21hbGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb246IFwiZmEtcGVuY2lsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtR3V0dGVyOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBVSS50bGBPcGVuIGNvZGUgZWRpdG9yYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDbGlja2VkOiBuZXcgVUkuQWN0aW9uSGFuZGxlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc2hvd0VkaXRvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlbHQgb2YgPGFueT50ZXh0RWx0LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwcmVcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RWx0LnJlbW92ZUNoaWxkKGVsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rd3JhcDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgVUkuTGFiZWwud2l0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiBBc3luYy5vYnNlcnZlKCgpID0+ICFVSS5TY3JlZW4uZGltZW5zaW9ucy5pc1NtYWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIihOb3QgYXZhaWxhYmxlIG9uIG1vYmlsZSBkZXZpY2VzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNocmlua3dyYXA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYXlncm91bmRCdXR0b25Sb3dFbHQ6IE5vZGUgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RWx0Lmluc2VydEJlZm9yZShwbGF5Z3JvdW5kQnV0dG9uUm93RWx0LCB0ZXh0RWx0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCg8YW55PkFzeW5jLm9ic2VydmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IHJvdy5vdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxheWdyb3VuZEJ1dHRvblJvd0VsdC5wYXJlbnROb2RlIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZUNoaWxkKG91dC5lbGVtZW50LCBwbGF5Z3JvdW5kQnV0dG9uUm93RWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGF5Z3JvdW5kQnV0dG9uUm93RWx0ID0gb3V0LmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzaG93IHRpdGxlLCBjb2xsYXBzZWQgb3Igbm9ybWFsXG4gICAgICAgICAgICBpZiAodGV4dEl0ZW0udGl0bGUgJiYgdGV4dEl0ZW0udGl0bGVbMF0gIT09IFwiX1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRpbmdFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICB0ZXh0SXRlbS5zdWJIZWFkaW5nID8gXCJoNFwiIDogXCJoM1wiKTtcbiAgICAgICAgICAgICAgICBoZWFkaW5nRWx0LmNsYXNzTmFtZSA9IFwiZG9jLWhlYWRpbmcgZG9jLWhlYWRpbmctXCIgK1xuICAgICAgICAgICAgICAgICAgICAodGV4dEl0ZW0udHlwZSA/IHRleHRJdGVtLnR5cGUgOiBcInNlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgaGVhZGluZ0VsdC50ZXh0Q29udGVudCA9IHRleHRJdGVtLnRpdGxlO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0SXRlbS50eXBlID09PSBcInRhc2tcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgXCJ0YXNrXCIgaWNvbiBpbiBoZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBpY29uRWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlcIik7XG4gICAgICAgICAgICAgICAgICAgIGljb25FbHQuY2xhc3NOYW1lID0gXCJmYSBmYS1hcnJvdy1jaXJjbGUtcmlnaHRcIjtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZ0VsdC5pbnNlcnRCZWZvcmUoaWNvbkVsdCwgaGVhZGluZ0VsdC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHRJdGVtLmNvbGxhcHNlID09PSBcImhlYWRpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgaWNvbiBpbiBoZWFkaW5nLCBhbmQgc2V0IGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGljb25FbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZ0VsdC5pbnNlcnRCZWZvcmUoaWNvbkVsdCwgaGVhZGluZ0VsdC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGluZ0VsdC5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNldEljb25DbGFzcyA9IChvcGVuPzogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbkVsdC5jbGFzc05hbWUgPSBvcGVuID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZhIGZhLWNoZXZyb24tZG93biBmYS1md1wiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZhIGZhLWNoZXZyb24tcmlnaHQgZmEtZndcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRJY29uQ2xhc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGV4dEVsdC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0ZXh0RWx0LnJlbW92ZUNoaWxkKHRleHRFbHQuZmlyc3RDaGlsZCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoZWFkaW5nRWx0Lm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuID0gIW9wZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJY29uQ2xhc3Mob3Blbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlbikgdGV4dEVsdC5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdGV4dEVsdC5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dEVsdC5pbnNlcnRCZWZvcmUoaGVhZGluZ0VsdCwgdGV4dEVsdC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZCh0ZXh0RWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmcmFnLmZpcnN0Q2hpbGQgfHwgaXRlbS5kb2MgfHwgaXRlbS5jb2RlKSB7XG4gICAgICAgICAgICB2YXIgdGV4dEJsb2NrID0gbmV3IFVJLkRPTS5ET01CbG9jayhmcmFnKTtcbiAgICAgICAgICAgIHRleHRCbG9jay5zdHlsZS5hZGRDbGFzcyhcImRvYy10ZXh0LWFydGljbGVcIik7XG4gICAgICAgICAgICB0ZXh0QmxvY2suc3R5bGUuc2V0KHsgbWFyZ2luOiBcIjFyZW0gMXJlbSAycmVtXCIgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh0ZXh0QmxvY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwZW5kIGxpc3RzIG9mIHN1YiBpdGVtcywgaWYgYW55LCBpbmNsdWRpbmcgaW5oZXJpdGVkIG9uZXNcbiAgICAgICAgaWYgKGl0ZW0udG9jICYmICFpdGVtLnRleHRTa2lwVE9DKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaChuZXcgVUkuUm93KFtuZXcgVUkuSGVhZGluZzMoXCJJbiB0aGlzIHNlY3Rpb25cIildKSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaChuZXcgSXRlbUxpc3RQYW5lbChcIlwiLCBpdGVtLnRvYy5tYXAoaWQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50U2VydmljZS5nZXRJdGVtQnlJZChpZCk7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLml0ZW1zICYmIGl0ZW0uaXRlbXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBpdGVtLmV4dGVuZHMgJiYgaXRlbS5leHRlbmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHN0YXRpY1BhbmVsID0gbmV3IEl0ZW1MaXN0UGFuZWwoXG4gICAgICAgICAgICAgICAgaXRlbS5pc0VudW0gPyBcIkVudW0gbWVtYmVyc1wiIDogXCJTdGF0aWMgbWVtYmVyc1wiLFxuICAgICAgICAgICAgICAgIGl0ZW0uaXRlbXMgJiYgaXRlbS5pdGVtcy5maWx0ZXIoeiA9PiB6LmlzU3RhdGljKSxcbiAgICAgICAgICAgICAgICBpdGVtLmluaGVyaXRzICYmIGl0ZW0uaW5oZXJpdHMuZmlsdGVyKGlkID0+XG4gICAgICAgICAgICAgICAgICAgIC9cXC5bXlxcL10rJC8udGVzdChpZCkgJiYgIS9cXC5jb25zdHJ1Y3Rvci8udGVzdChpZCkpKTtcbiAgICAgICAgICAgIHZhciBjb25zdHJQYW5lbCA9IG5ldyBJdGVtTGlzdFBhbmVsKFwiQ29uc3RydWN0b3JzXCIsXG4gICAgICAgICAgICAgICAgaXRlbS5pdGVtcyAmJiBpdGVtLml0ZW1zLmZpbHRlcih6ID0+IHouaXNDdG9yKSxcbiAgICAgICAgICAgICAgICBpdGVtLmluaGVyaXRzICYmIGl0ZW0uaW5oZXJpdHMuZmlsdGVyKGlkID0+XG4gICAgICAgICAgICAgICAgICAgIC9cXC5jb25zdHJ1Y3Rvci8udGVzdChpZCkpKTtcbiAgICAgICAgICAgIHZhciBtZW1iZXJzUGFuZWwgPSBuZXcgSXRlbUxpc3RQYW5lbChcIkluc3RhbmNlIG1lbWJlcnNcIixcbiAgICAgICAgICAgICAgICBpdGVtLml0ZW1zICYmIGl0ZW0uaXRlbXMuZmlsdGVyKHogPT4gIXouaXNDdG9yICYmICF6LmlzU3RhdGljKSxcbiAgICAgICAgICAgICAgICBpdGVtLmluaGVyaXRzICYmIGl0ZW0uaW5oZXJpdHMuZmlsdGVyKGlkID0+XG4gICAgICAgICAgICAgICAgICAgICEvXFwuW15cXC9dKyQvLnRlc3QoaWQpKSk7XG4gICAgICAgICAgICBpZiAoc3RhdGljUGFuZWwuZG9jSXRlbXMubGVuZ3RoIHx8IGNvbnN0clBhbmVsLmRvY0l0ZW1zLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIG1lbWJlcnNQYW5lbC5kb2NJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaChuZXcgVUkuUm93KFtuZXcgVUkuSGVhZGluZzMoXCJNZW1iZXJzXCIpXSksXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1BhbmVsLCBjb25zdHJQYW5lbCwgbWVtYmVyc1BhbmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5kZWNsVHlwZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlVHlwZXM6IERvY0l0ZW1bXSA9IFtdO1xuICAgICAgICAgICAgaXRlbS5kZWNsVHlwZS5zcGxpdCgvXFxzKlsmfCxcXDxcXD5dXFxzKi8pLmZvckVhY2godHlwZU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWUucmVwbGFjZSgvXlxccyp0eXBlb2YgLywgXCJcIikudHJpbSgpO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlSWQgPSB0aGlzLmRvY3VtZW50U2VydmljZS5maW5kKHR5cGVOYW1lLCBpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlSXRlbSA9IHRoaXMuZG9jdW1lbnRTZXJ2aWNlLmdldEl0ZW1CeUlkKHR5cGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWVUeXBlcy5zb21lKHogPT4gei5pZCA9PT0gdHlwZUl0ZW0uaWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVUeXBlcy5wdXNoKHR5cGVJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGxpbmsgKHJldHVybikgdHlwZShzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKG5ldyBVSS5Sb3coW25ldyBVSS5IZWFkaW5nMyhcbiAgICAgICAgICAgICAgICAgICAgKGl0ZW0uaXNGdW5jdGlvbiB8fCBpdGVtLmlzTWV0aG9kKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlJldHVybiB0eXBlXCIgOiBcIlZhbHVlIHR5cGVcIildKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2gobmV3IEl0ZW1MaXN0UGFuZWwoXCJcIiwgdmFsdWVUeXBlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLnRleHRTZWVBbHNvKSB7XG4gICAgICAgICAgICAvLyBzaG93IGEgXCJTZWUgYWxzb1wiIHNlY3Rpb25cbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKG5ldyBVSS5Sb3coW25ldyBVSS5IZWFkaW5nMyhcIlNlZSBhbHNvXCIpXSkpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2gobmV3IEl0ZW1MaXN0UGFuZWwoXCJSZWZlcmVuY2VzXCIsXG4gICAgICAgICAgICAgICAgaXRlbS50ZXh0U2VlQWxzby5zcGxpdCgvLHw7fFxcfC8pLm1hcCgoaWQpOiBEb2NJdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSB0aGlzLmRvY3VtZW50U2VydmljZS5maW5kKGlkLnRyaW0oKSwgaXRlbSkhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQgPyB0aGlzLmRvY3VtZW50U2VydmljZS5nZXRJdGVtQnlJZChpZCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgPGFueT51bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKHogPT4gISF6KSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLnBhcmVudEl0ZW0gJiYgaXRlbS5wYXJlbnRJdGVtLml0ZW1zKSB7XG4gICAgICAgICAgICAvLyBsaW5rIHBhcmVudCBpdGVtXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaChuZXcgVUkuUm93KFtuZXcgVUkuSGVhZGluZzMoXCJEZWNsYXJlZCBvblwiKV0pKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKG5ldyBJdGVtTGlzdFBhbmVsKFwiXCIsIFtpdGVtLnBhcmVudEl0ZW1dKSk7XG5cbiAgICAgICAgICAgIC8vIHNob3cgYSBsaXN0IG9mIHJlbGF0ZWQvc2libGluZy9pbnN0YW5jZSBpdGVtc1xuICAgICAgICAgICAgaWYgKGl0ZW0uaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVhZGluZyA9IG5ldyBVSS5Sb3coXG4gICAgICAgICAgICAgICAgICAgIFtuZXcgVUkuSGVhZGluZzMoXCJSZWxhdGVkIG1lbWJlcnNcIildKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFuZWwgPSBuZXcgSXRlbUxpc3RQYW5lbChcIk1lbWJlcnMgKHN0YXRpYylcIixcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wYXJlbnRJdGVtLml0ZW1zLmZpbHRlcih6ID0+XG4gICAgICAgICAgICAgICAgICAgICAgICB6LmlzU3RhdGljICYmIHouaWQgIT09IGl0ZW0uaWQpLFxuICAgICAgICAgICAgICAgICAgICBpdGVtLnBhcmVudEl0ZW0uaW5oZXJpdHMgJiZcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wYXJlbnRJdGVtLmluaGVyaXRzLmZpbHRlcihpZCA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgL1xcLlteXFwvXSskLy50ZXN0KGlkKSAmJiAhL1xcLmNvbnN0cnVjdG9yLy50ZXN0KGlkKSkpO1xuICAgICAgICAgICAgICAgIGlmIChwYW5lbC5pdGVtUm93cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKGhlYWRpbmcsIHBhbmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBoZWFkaW5nID0gbmV3IFVJLlJvdyhcbiAgICAgICAgICAgICAgICAgICAgW25ldyBVSS5IZWFkaW5nMyhpdGVtLmlzQ3RvciA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcIkluc3RhbmNlIG1lbWJlcnNcIiA6IFwiUmVsYXRlZCBtZW1iZXJzXCIpXSk7XG4gICAgICAgICAgICAgICAgbGV0IHBhbmVsID0gbmV3IEl0ZW1MaXN0UGFuZWwoXCJJbnN0YW5jZSBtZW1iZXJzXCIsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucGFyZW50SXRlbS5pdGVtcy5maWx0ZXIoeiA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgIXouaXNDdG9yICYmICF6LmlzU3RhdGljICYmIHouaWQgIT09IGl0ZW0uaWQpLFxuICAgICAgICAgICAgICAgICAgICBpdGVtLnBhcmVudEl0ZW0uaW5oZXJpdHMgJiYgaXRlbS5wYXJlbnRJdGVtLmluaGVyaXRzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0+ICEvXFwuW15cXC9dKyQvLnRlc3QoaWQpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhbmVsLml0ZW1Sb3dzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2goaGVhZGluZywgcGFuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGZpbmFsIHNwYWNlIGJlbG93IGFsbCBjb250ZW50XG4gICAgICAgIHZhciBib3R0b21TcGFjZXIgPSBuZXcgVUkuQmxvY2soKTtcbiAgICAgICAgYm90dG9tU3BhY2VyLmhlaWdodCA9IFwiNXJlbVwiO1xuICAgICAgICB0aGlzLmNvbnRlbnQucHVzaChib3R0b21TcGFjZXIpO1xuICAgIH1cblxuICAgIEBBcHAuaW5qZWN0U2VydmljZVxuICAgIHB1YmxpYyBkb2N1bWVudFNlcnZpY2U6IERvY3VtZW50U2VydmljZTtcbn1cblxuLyoqIFNwYWNlciB0aGF0IGlzIGFsd2F5cyBleGFjdGx5IC41cmVtIHdpZGUgKi9cbmNsYXNzIEhhbGZTcGFjZXIgZXh0ZW5kcyBVSS5TcGFjZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZHRoID0gXCIuNXJlbVwiO1xuICAgICAgICB0aGlzLnNocmlua3dyYXAgPSB0cnVlO1xuICAgIH1cbn1cblxuLyoqIEEgcm93IHdpdGggbGFiZWxzIHRoYXQgZGVzY3JpYmUgYSBjb2RlIGRvY3VtZW50YXRpb24gaXRlbSAqL1xuZXhwb3J0IGNsYXNzIFRhZ0xhYmVsUm93IGV4dGVuZHMgVUkuQ2xvc2VSb3cge1xuICAgIGNvbnN0cnVjdG9yKGl0ZW06IERvY0l0ZW0sIGlzSW5oZXJpdGVkPzogYm9vbGVhbiwgb21pdEljb24/OiBib29sZWFuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaWNvbiA9IGl0ZW0uaWNvbjtcblxuICAgICAgICBpZiAoaXNJbmhlcml0ZWQpIHtcbiAgICAgICAgICAgIC8vIGRpbSBhbGwgdGFnc1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQoeyBvcGFjaXR5OiBcIi41XCIgfSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBhbiBpY29uIGFuZCB0aGUgaW5oZXJpdGVkIGxhYmVsXG4gICAgICAgICAgICB2YXIgaW5oZXJpdGVkSWNvbiA9IG5ldyBVSS5JY29uKCk7XG4gICAgICAgICAgICBpbmhlcml0ZWRJY29uLmljb24gPSBcImZhLWNsb25lXCI7XG4gICAgICAgICAgICBpbmhlcml0ZWRJY29uLnRvb2x0aXBUZXh0ID0gXCJJbmhlcml0ZWRcIjtcbiAgICAgICAgICAgIGluaGVyaXRlZEljb24uc3R5bGUuc2V0KHtcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjODg4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2goaW5oZXJpdGVkSWNvbiwgbmV3IEhhbGZTcGFjZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0uY29kZSkge1xuICAgICAgICAgICAgLy8gYWRkIHRoZSBpY29uIGFuZCBhIHNtYWxsIHNwYWNlXG4gICAgICAgICAgICBpZiAoIW9taXRJY29uKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKG5ldyBVSS5JY29uKHRoaXMuaWNvbiksIG5ldyBIYWxmU3BhY2VyKCkpO1xuXG4gICAgICAgICAgICAvLyBhZGQgYWxsIGFwcHJvcHJpYXRlIHRhZ3NcbiAgICAgICAgICAgIGxldCBhZGQgPSAodGV4dDogc3RyaW5nLCBiZzogc3RyaW5nLCBpdGFsaWM/OiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gbmV3IFVJLkxhYmVsKHRleHQpO1xuICAgICAgICAgICAgICAgIGxhYmVsLnN0eWxlLnNldCh7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGJnLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCIuNXJlbVwiLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjAgLjVyZW1cIixcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogXCIxLjVlbVwiLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIuNzVyZW1cIixcbiAgICAgICAgICAgICAgICAgICAgZm9udFN0eWxlOiBpdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKGxhYmVsLCBuZXcgSGFsZlNwYWNlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLmlzQ2xhc3MpIGFkZChcImNsYXNzXCIsIFRBR19CR19DTEFTU1RZUEUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5pc05hbWVzcGFjZSkgYWRkKFwibmFtZXNwYWNlXCIsIFRBR19CR19DTEFTU1RZUEUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5pc0ludGVyZmFjZSkgYWRkKFwiaW50ZXJmYWNlXCIsIFRBR19CR19JTlRGVFlQRSk7XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmlzQ3RvcikgYWRkKFwiY29uc3RydWN0b3JcIiwgVEFHX0JHX0NUT1IpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5pc01ldGhvZCkgYWRkKFwibWV0aG9kXCIsIFRBR19CR19NRU1CRVJUWVBFKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uaXNTaWduYWwpIGFkZChcInNpZ25hbFwiLCBUQUdfQkdfQVNZTkMpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5pc1Byb3BlcnR5KSBhZGQoXCJwcm9wZXJ0eVwiLCBUQUdfQkdfTUVNQkVSVFlQRSk7XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmlzRGVjb3JhdG9yKSBhZGQoXCJkZWNvcmF0b3JcIiwgVEFHX0JHX0RFQ09SQVRPUik7XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmlzRnVuY3Rpb24pIGFkZChcImZ1bmN0aW9uXCIsIFRBR19CR19PVEhSVFlQRSk7XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmlzQ29uc3QpIGFkZChcImNvbnN0XCIsIFRBR19CR19PVEhSVFlQRSk7XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmlzVmFyKSBhZGQoXCJ2YXJcIiwgVEFHX0JHX09USFJUWVBFKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uaXNFbnVtKSBhZGQoXCJlbnVtXCIsIFRBR19CR19PVEhSVFlQRSk7XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLmlzVHlwZSkgYWRkKFwidHlwZVwiLCBUQUdfQkdfT1RIUlRZUEUpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uaXNQcm90ZWN0ZWQpIGFkZChcInByb3RlY3RlZFwiLCBUQUdfQkdfQUNDRVNTLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmlzUmVhZE9ubHkpIGFkZChcInJlYWQtb25seVwiLCBUQUdfQkdfQUNDRVNTLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmlzU3RhdGljKSBhZGQoXCJzdGF0aWNcIiwgVEFHX0JHX1NUQVRJQywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXRlbS5pc0FzeW5jKSBhZGQoXCJhc3luY1wiLCBUQUdfQkdfQVNZTkMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGljb246IHN0cmluZztcbn1cblxuLyoqIEEgbGlzdCBvZiBhbm5vdGF0ZWQgaXRlbSBsaW5rcyAqL1xuY2xhc3MgSXRlbUxpc3RQYW5lbCBleHRlbmRzIFVJLkNvbnRhaW5lckJsb2NrLndpdGgoXG4gICAge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgbWFyZ2luOiBcIjAgMCAxLjVyZW1cIixcbiAgICAgICAgICAgIGJvcmRlclRvcDogXCIycHggc29saWQgXCIgKyBVSS5ET00uU3R5bGVzLmNvbG9yLmRpdmlkZXIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIFwiICsgVUkuRE9NLlN0eWxlcy5jb2xvci5kaXZpZGVyXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFVJLkNvbnRhaW5lci53aXRoKFxuICAgICAgICB7IGhpZGRlbjogVUkuYmluZChcIiFpdGVtUm93cy5sZW5ndGhcIikgfSxcbiAgICAgICAgVUkuUm93LndpdGgoe1xuICAgICAgICAgICAgaGlkZGVuOiBVSS5iaW5kKFwiIXRpdGxlXCIpLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjEuNzVyZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtVSS5IZWFkaW5nNS53aXRoVGV4dChVSS5iaW5kKFwidGl0bGVcIikpXSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogXCIjZWVlXCIsXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiIzMzM1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBVSS5MaXN0LndpdGgoe1xuICAgICAgICAgICAgaXRlbXM6IFVJLmJpbmQoXCJpdGVtUm93c1wiKSxcbiAgICAgICAgICAgIGRpdmlkZXI6IHsgbWFyZ2luOiBcIjBcIiB9XG4gICAgICAgIH0pXG4gICAgKSxcbikge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0aXRsZTogc3RyaW5nLCBwdWJsaWMgaXRlbXM6IERvY0l0ZW1bXSA9IFtdLFxuICAgICAgICBwdWJsaWMgaW5oZXJpdGVkPzogc3RyaW5nW10pIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBjb25jYXRlbmF0ZSBhbGwgZ2l2ZW4gaXRlbXNcbiAgICAgICAgdmFyIGFsbEl0ZW1zID0gaXRlbXMuc2xpY2UoKTtcbiAgICAgICAgaWYgKGluaGVyaXRlZCkge1xuICAgICAgICAgICAgaW5oZXJpdGVkLmZvckVhY2gocyA9PiB7XG4gICAgICAgICAgICAgICAgYWxsSXRlbXMucHVzaCh0aGlzLmRvY3VtZW50U2VydmljZS5nZXRJdGVtQnlJZChzKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jSXRlbXMgPSBhbGxJdGVtcyA9IGFsbEl0ZW1zLmZpbHRlcihpdGVtID0+ICEhaXRlbSk7XG4gICAgICAgIGlmICghYWxsSXRlbXMubGVuZ3RoKSB0aGlzLmhpZGRlbiA9IHRydWU7XG5cbiAgICAgICAgLy8gcG9wdWxhdGUgaXRlbSByb3dzXG4gICAgICAgIHZhciBwID0gQXN5bmMuUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICBhbGxJdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSAlIDQgPT09IDApIHAgPSBwLnRoZW4oKCkgPT4gQXN5bmMuc2xlZXAoMCkpO1xuICAgICAgICAgICAgcC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICB2YXIgaXNJbmhlcml0ZWQgPSAhaXRlbXMuc29tZSh6ID0+IHouaWQgPT09IGl0ZW0uaWQpO1xuICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHRoaXMuZG9jdW1lbnRTZXJ2aWNlLmdldERpc3BsYXlOYW1lRm9yKGl0ZW0uaWQpO1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbFJvdyA9IG5ldyBUYWdMYWJlbFJvdyhpdGVtLCBpc0luaGVyaXRlZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBwdWxsIEpTRG9jIGFzIHRleHQgZnJvbSBhIGxpdmUgRE9NIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgZG9jVGV4dCA9IGl0ZW0udGV4dFN1bW1hcnkgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoIWRvY1RleHQgJiYgaXRlbS5kb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IGl0ZW0uZG9jO1xuICAgICAgICAgICAgICAgICAgICBkb2NUZXh0ID0gdGVtcERpdi5pbm5lclRleHQucmVwbGFjZSgvXFxyfFxcbi9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHJvdyBmYWN0b3J5IGZvciB0aGlzIGl0ZW1cbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1Sb3dzLnB1c2goVUkuUm93LndpdGgoe1xuICAgICAgICAgICAgICAgICAgICBzcGFjaW5nOiBcIi41cmVtXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCBsZWZ0IGFsaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgVUkuU3BhY2VyLndpdGgoeyB3aWR0aDogXCIwXCIsIHNocmlua3dyYXA6IHRydWUgfSksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhYmVsIHdpdGggaWNvbiBpbiBmcm9udFxuICAgICAgICAgICAgICAgICAgICAgICAgVUkuTGFiZWwud2l0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogbGFiZWxSb3cuaWNvbiArIFwiIGZhLWZ3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHsgZm9udFdlaWdodDogaXNJbmhlcml0ZWQgPyBcIjQwMFwiIDogXCI2MDBcIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGFiZWwgcm93IChzaHJpbmt3cmFwcGVkKSBhbmQgSlNEb2Mgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIFVJLkJsb2NrQ29udHJvbC53aXRoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jazogbGFiZWxSb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rd3JhcDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBVSS50bGB7d3wjYWFhfDMwMH0ke2RvY1RleHR9YFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMXJlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBDbGljazogbmV3IFVJLkFjdGlvbkhhbmRsZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXBwLnN0YXJ0QWN0aXZpdHlBc3luYyhcIi9kb2MvXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpdGVtLnRleHRTbHVnIHx8IGl0ZW0uaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgQEFwcC5pbmplY3RTZXJ2aWNlXG4gICAgcHVibGljIGRvY3VtZW50U2VydmljZTogRG9jdW1lbnRTZXJ2aWNlO1xuXG4gICAgLyoqIERvY3VtZW50IGl0ZW1zIGluY2x1ZGVkIGluIHRoaXMgYmxvY2sgKi9cbiAgICBwdWJsaWMgZG9jSXRlbXM6IERvY0l0ZW1bXTtcblxuICAgIC8qKiBGYWN0b3JpZXMgdXNlZCB0byBwb3B1bGF0ZSB0aGlzIGJsb2NrICovXG4gICAgQEFzeW5jLm9ic2VydmFibGVcbiAgICBwdWJsaWMgaXRlbVJvd3M6IFVJLkNvbXBvbmVudEZhY3Rvcnk8VUkuUm93PltdID0gW107XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RvY3Mtdmlld2VyL0RvY0FydGljbGUudHMiLCJpbXBvcnQgeyBBcHAsIEFzeW5jLCBVSSB9IGZyb20gXCJAdHlwZXNjZW5lL2RvbVwiO1xuaW1wb3J0IHsgRG9jSXRlbSB9IGZyb20gXCIuL0RvY3VtZW50U2VydmljZVwiO1xuaW1wb3J0IHsgRG9jQWN0aXZpdHkgfSBmcm9tIFwiLi9Eb2NBY3Rpdml0eVwiO1xuaW1wb3J0IHsgTWFpblZpZXcgfSBmcm9tIFwiLi9NYWluVmlld1wiO1xuaW1wb3J0IHsgRG9jQXJ0aWNsZSwgVGFnTGFiZWxSb3cgfSBmcm9tIFwiLi9Eb2NBcnRpY2xlXCI7XG5cbkBBcHAubWFwVmlld0FjdGl2aXR5KERvY0FjdGl2aXR5KVxuY2xhc3MgRG9jVmlldyBleHRlbmRzIE1haW5WaWV3LkRvY1ZpZXcud2l0aChcbiAgICB7XG4gICAgICAgIHN0eWxlOiBBc3luYy5vYnNlcnZlKCgpID0+IFVJLlNjcmVlbi5kaW1lbnNpb25zLmlzU21hbGwgP1xuICAgICAgICAgICAgeyBwYWRkaW5nOiBcIjBcIiB9IDpcbiAgICAgICAgICAgIHsgcGFkZGluZzogXCIwIDIuNXJlbSAwIDIuNXJlbVwiIH0pXG4gICAgfSxcblxuICAgIC8vIHJvdyB0aGF0IGRlc2NyaWJlcyB0aGUgKGNvZGUpIGl0ZW0sIGFuZCBhIGxpbmsgdG8gcGFyZW50XG4gICAgVUkuUm93LndpdGgoXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlaWdodDogQXN5bmMub2JzZXJ2ZSgoKSA9PlxuICAgICAgICAgICAgICAgIFVJLlNjcmVlbi5kaW1lbnNpb25zLmlzU21hbGwgPyBcImF1dG9cIiA6IFwiNHJlbVwiKSxcbiAgICAgICAgICAgIHNwYWNpbmc6IFwiLjVyZW1cIixcbiAgICAgICAgICAgIHZlcnRpY2FsU3BhY2luZzogXCIxcmVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgVUkuU3BhY2VyLndpdGgoeyB3aWR0aDogXCIwXCIsIHNocmlua3dyYXA6IHRydWUgfSksXG4gICAgICAgIFVJLlRleHRCdXR0b24ud2l0aCh7XG4gICAgICAgICAgICBoaWRkZW46IFVJLmJpbmQoXCIhcGFyZW50SXRlbVwiKSxcbiAgICAgICAgICAgIGxhYmVsOiBVSS5iaW5kKFwicGFyZW50SXRlbVwiLCAocGFyZW50OiBEb2NJdGVtKSA9PlxuICAgICAgICAgICAgICAgIChwYXJlbnQgJiYgKHBhcmVudC50ZXh0VG9waWMgfHwgcGFyZW50Lm5hbWUpIHx8IFwiXCIpKSxcbiAgICAgICAgICAgIGljb25BZnRlcjogXCJmYS1jYXJldC1yaWdodFwiLFxuICAgICAgICAgICAgcmVtR3V0dGVyOiAxLjc1LFxuICAgICAgICAgICAgdGFyZ2V0OiBVSS5iaW5kKFwicGFyZW50SXRlbS5pZFwiLCBpZCA9PiBcIi9kb2MvXCIgKyBpZCksXG4gICAgICAgICAgICBzdHlsZV9idXR0b246IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjNjY2XCIsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogXCI2MDBcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgVUkuYmluZChcIml0ZW1cIiwgaXRlbSA9PiBpdGVtICYmIG5ldyBUYWdMYWJlbFJvdyhpdGVtKSlcbiAgICApLFxuXG4gICAgLy8gbG9hZGluZyBpbmRpY2F0b3JcbiAgICBBc3luYy5zbGVlcCg1MCkudGhlbigoKSA9PiBVSS5DZW50ZXJSb3cud2l0aCh7XG4gICAgICAgIGhpZGRlbjogVUkuYmluZChcIml0ZW1cIiksXG4gICAgICAgIGhlaWdodDogXCIxMHJlbVwiLFxuICAgICAgICBjb250ZW50OiBbIFVJLnRsYExvYWRpbmcgZG9jdW1lbnRhdGlvbi4uLmAgXVxuICAgIH0pKSxcblxuICAgIC8vIGNvbnRhaW5lciB3aXRoIHRoZSBhcnRpY2xlIGl0c2VsZlxuICAgIFVJLmJpbmQoXCJpdGVtXCIsIGl0ZW0gPT4gaXRlbSAmJiBuZXcgRG9jQXJ0aWNsZShpdGVtKSlcbikge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBhY3Rpdml0eTogRG9jQWN0aXZpdHkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBAQXN5bmMub2JzZXJ2YWJsZVxuICAgIHB1YmxpYyBnZXQgaXRlbSgpIHsgcmV0dXJuIHRoaXMuYWN0aXZpdHkuaXRlbSB9XG5cbiAgICBAQXN5bmMub2JzZXJ2YWJsZVxuICAgIHB1YmxpYyBnZXQgcGFyZW50SXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbSAmJiB0aGlzLml0ZW0ucGFyZW50SXRlbTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RvY3Mtdmlld2VyL0RvY1ZpZXcudHMiLCJpbXBvcnQgeyBBcHAsIEFzeW5jLCBVSSB9IGZyb20gXCJAdHlwZXNjZW5lL2RvbVwiO1xuaW1wb3J0IHsgRG9jdW1lbnRTZXJ2aWNlLCBEb2NJdGVtIH0gZnJvbSBcIi4vRG9jdW1lbnRTZXJ2aWNlXCI7XG5pbXBvcnQgeyBNYWluQWN0aXZpdHkgfSBmcm9tIFwiLi9NYWluQWN0aXZpdHlcIjtcbmltcG9ydCB7IE1haW5WaWV3IH0gZnJvbSBcIi4vTWFpblZpZXdcIjtcbmltcG9ydCB7IERvY0FjdGl2aXR5IH0gZnJvbSBcIi4vRG9jQWN0aXZpdHlcIjtcblxuQEFwcC5tYXBWaWV3QWN0aXZpdHkoTWFpbkFjdGl2aXR5KVxuZXhwb3J0IGNsYXNzIFRPQ1ZpZXcgZXh0ZW5kcyBNYWluVmlldy5UT0NWaWV3LndpdGgoXG4gICAgLy8gYWRkIGhlYWRlciB3aXRoIHNlYXJjaCBmaWVsZFxuICAgIE1haW5WaWV3LlRPQ1ZpZXcuSGVhZGVyLndpdGgoXG4gICAgICAgIHtcbiAgICAgICAgICAgIGhlaWdodDogXCI0LjVyZW1cIixcbiAgICAgICAgICAgIHZlcnRBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgICAgIHN0eWxlOiB7IHBhZGRpbmc6IFwiMCAuNXJlbVwiIH0sXG4gICAgICAgICAgICBzaGFkb3dFZmZlY3Q6IFVJLmJpbmQoXCJzY3JvbGxlZFRvVG9wXCIsIGF0VG9wID0+XG4gICAgICAgICAgICAgICAgYXRUb3AgPyAwIDogLjM1KVxuICAgICAgICB9LFxuICAgICAgICBVSS5DbG9zZVJvdy53aXRoKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiI2ZmZlwiLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6IFwiMnB4IHNvbGlkICNlZWVcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBVSS5UZXh0RmllbGQud2l0aCh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJmaWx0ZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogVUkuYmluZDIoXCJmaWx0ZXJUZXh0XCIpLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyVGV4dDogXCJGaWx0ZXJcIixcbiAgICAgICAgICAgICAgICBzdHlsZV9pbnB1dDoge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXI6IFwiMFwiLFxuICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICBvdXRsaW5lOiBcIjBcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW1tZWRpYXRlVmFsdWVVcGRhdGU6IHRydWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgVUkuVGV4dEJ1dHRvbi53aXRoSWNvbihcImZhLXRpbWVzXCIsIFwicmVzZXRGaWx0ZXJcIiksXG4gICAgICAgICAgICBVSS5TcGFjZXIud2l0aCh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiLjVyZW1cIixcbiAgICAgICAgICAgICAgICBzaHJpbmt3cmFwOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgKSxcblxuICAgIC8vIGFkZCBhIGxhYmVsIGZvciB0aGlzIGRvY3VtZW50YXRpb24gZmlsZVxuICAgIFVJLkNsb3NlUm93LndpdGgoXG4gICAgICAgIHsgaGVpZ2h0OiBcIjJyZW1cIiwgc3R5bGU6IHsgbWFyZ2luVG9wOiBcIjFyZW1cIiB9IH0sXG4gICAgICAgIFVJLkljb24ud2l0aCh7XG4gICAgICAgICAgICBpY29uOiBcImZhLWNoZXZyb24tZG93blwiLFxuICAgICAgICAgICAgd2lkdGg6IFwiMnJlbVwiLFxuICAgICAgICAgICAgc3R5bGU6IHsgcGFkZGluZ0xlZnQ6IFwiLjc1cmVtXCIgfVxuICAgICAgICB9KSxcbiAgICAgICAgVUkuTGFiZWwud2l0aCh7XG4gICAgICAgICAgICB0ZXh0OiBVSS5iaW5kKFwiYWN0aXZpdHkudGl0bGVcIiksXG4gICAgICAgICAgICBpY29uOiBcImZhLWJvb2tcIixcbiAgICAgICAgICAgIHJlbUd1dHRlcjogMS41LFxuICAgICAgICAgICAgc3R5bGU6IHsgZm9udFdlaWdodDogXCI2MDBcIiB9XG4gICAgICAgIH0pXG4gICAgKSxcbiAgICBVSS5EaXZpZGVyLndpdGgoeyBtYXJnaW46IFwiLjI1cmVtXCIgfSksXG5cbiAgICAvLyBhZGQgdGhlIGFjdHVhbCBUT0MgdHJlZSBsaXN0XG4gICAgVUkuVHJlZUxpc3Qud2l0aCh7XG4gICAgICAgIGlkOiBcInRvY1RyZWVMaXN0XCIsXG4gICAgICAgIGl0ZW1zOiBVSS5UcmVlTGlzdFJvdy5hcnJheUZyb21CaW5kaW5nKFwiZ2V0VHJlZUl0ZW1zKClcIiwgXCJmYS1jaGV2cm9uLWRvd25cIiwgXCJmYS1jaGV2cm9uLXJpZ2h0XCIsXG4gICAgICAgICAgICAxLjUsIFwiMnJlbVwiLCAxMCksXG4gICAgICAgIGZvY3VzTW9kZTogVUkuQ29tcG9uZW50LkZvY3VzTW9kZS5JdGVtcyxcbiAgICAgICAgc2VsZWN0aW9uTW9kZTogVUkuQ29tcG9uZW50LlNlbGVjdGlvbk1vZGUuSXRlbUZvY3VzLFxuICAgICAgICBzdHlsZTogVUkuU3R5bGUud2l0aENsYXNzKFwidG9jX3RyZWVcIiksXG4gICAgICAgIEVudGVyS2V5UHJlc3NlZDogXCJzaG93VG9jVG9waWNcIixcbiAgICAgICAgQ2xpY2s6IFwic2hvd1RvY1RvcGljXCIsXG4gICAgfSlcbikge1xuICAgIEBBcHAuaW5qZWN0U2VydmljZVxuICAgIHB1YmxpYyBkb2N1bWVudFNlcnZpY2U6IERvY3VtZW50U2VydmljZTtcblxuICAgIEBBc3luYy5vYnNlcnZhYmxlXG4gICAgcHVibGljIHRvY1RyZWVMaXN0PzogVUkuVHJlZUxpc3Q8VUkuVHJlZUxpc3RSb3c+O1xuXG4gICAgQEFzeW5jLm9ic2VydmFibGVcbiAgICBwdWJsaWMgZmlsdGVyVGV4dCA9IFwiXCI7XG5cbiAgICBAQXN5bmMub2JzZXJ2YWJsZV9zaGFsbG93XG4gICAgcHVibGljIGZpbHRlclRlcm1zPzogc3RyaW5nW107XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgYWN0aXZpdHk6IE1haW5BY3Rpdml0eSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIG9ic2VydmUgdG9wIGRvYyBhY3Rpdml0eVxuICAgICAgICB0aGlzLlJlbmRlcmVkLmNvbm5lY3RPbmNlKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICBBc3luYy5vYnNlcnZlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b2NUcmVlTGlzdCAmJiB0aGlzLnRvY1RyZWVMaXN0Lml0ZW1zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5maWx0ZXJUZXJtcyAmJiAhYWN0aXZpdHkubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jQWN0aXZpdHkgPSBBcHAuZmluZEFjdGl2aXR5KERvY0FjdGl2aXR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY0FjdGl2aXR5KSByZXR1cm4gZG9jQWN0aXZpdHkuaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pLnN1YnNjcmliZShpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3QgdGhlIGN1cnJlbnRseSBzaG93biBkb2N1bWVudCB1c2luZyB0aGUgaXRlbSBJRFxuICAgICAgICAgICAgICAgICAgICBBc3luYy5zbGVlcCgxMCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvY1RyZWVMaXN0IS5zZWxlY3RlZEtleSA9IGl0ZW0uaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhdXRvIGZvY3VzIHNlbGVjdGVkIGl0ZW1zIHRvIGJyaW5nIHRoZW0gaW50byB2aWV3XG4gICAgICAgICAgICB0aGlzLnRvY1RyZWVMaXN0IS5TZWxlY3Rpb25DaGFuZ2UuY29ubmVjdChkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNGb2N1cykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLml0ZW0gJiYgIXRoaXMuZmlsdGVyVGVybXMpXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuaXRlbS5oYXNGb2N1cyA9IHRydWU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gb2JzZXJ2ZSBzZWFyY2ggZmlsdGVyIGFuZCB1cGRhdGUgdGVybXMgYWZ0ZXIgYSBkZWxheVxuICAgICAgICAgICAgdmFyIHRpbWVyOiBudW1iZXI7XG4gICAgICAgICAgICBBc3luYy5vYnNlcnZlKCgpID0+IHRoaXMuZmlsdGVyVGV4dCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXIpIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVGaWx0ZXIoKTtcbiAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgYSBsaXN0IG9mIGl0ZW1zIGZvciB0aGUgVE9DIHRyZWUgbGlzdCAqL1xuICAgIHB1YmxpYyBnZXRUcmVlSXRlbXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kb2N1bWVudFNlcnZpY2UgfHwgIXRoaXMuZG9jdW1lbnRTZXJ2aWNlLmlzTG9hZGVkKSByZXR1cm4gW107XG4gICAgICAgIGxldCBtYWtlSXRlbURhdGEgPSAodG9jSXRlbTogRG9jSXRlbSk6IFVJLlRyZWVMaXN0Um93Lkl0ZW1EYXRhID0+IHtcbiAgICAgICAgICAgIHZhciBzdWJJdGVtcyA9IHRoaXMuZG9jdW1lbnRTZXJ2aWNlLmdldFRPQ0l0ZW1zKHRvY0l0ZW0uaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0b2NJdGVtLnRleHRUb3BpYyB8fCB0b2NJdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAga2V5OiB0b2NJdGVtLmlkLFxuICAgICAgICAgICAgICAgIGljb246IHRvY0l0ZW0uaWNvbixcbiAgICAgICAgICAgICAgICBhdXRvRXhwYW5kOiAhIXRvY0l0ZW0udGV4dEF1dG9PcGVuLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBzdWJJdGVtcy5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICBzdWJJdGVtcy5tYXAobWFrZUl0ZW1EYXRhKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRvY3VtZW50U2VydmljZS5nZXRUT0NJdGVtcygpLm1hcChtYWtlSXRlbURhdGEpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJUZXJtcyAmJiB0aGlzLmZpbHRlclRlcm1zLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHRlcm1zID0gdGhpcy5maWx0ZXJUZXJtcy5tYXAocyA9PiBzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgbGV0IGYgPSAoaXRlbTogVUkuVHJlZUxpc3RSb3cuSXRlbURhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRlcm1zLnNvbWUocyA9PlxuICAgICAgICAgICAgICAgICAgICAoaXRlbS5uYW1lIS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocykgPCAwKSAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmtleSEudG9Mb3dlckNhc2UoKS5pbmRleE9mKHMpICE9PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5pdGVtcyA9IGl0ZW0uaXRlbXMuZmlsdGVyKGYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXV0b0V4cGFuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqIFNob3cgbmV3bHkgc2VsZWN0ZWQgVE9DIHRvcGljICovXG4gICAgcHVibGljIHNob3dUb2NUb3BpYygpIHtcbiAgICAgICAgQXN5bmMuc2xlZXAoMTApLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy50b2NUcmVlTGlzdCEuc2VsZWN0ZWRLZXk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGlkICYmIHRoaXMuZG9jdW1lbnRTZXJ2aWNlLmdldEl0ZW1CeUlkKGlkKTtcbiAgICAgICAgICAgIGlmIChkYXRhKSBBcHAuc3RhcnRBY3Rpdml0eUFzeW5jKFwiL2RvYy9cIlxuICAgICAgICAgICAgICAgICsgKGRhdGEudGV4dFNsdWcgfHwgZGF0YS5pZCkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogUmVzZXQgdGhlIHNlYXJjaCBmaWx0ZXIgKi9cbiAgICBwdWJsaWMgcmVzZXRGaWx0ZXIoKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyVGV4dCA9IFwiXCI7XG4gICAgfVxuXG4gICAgLyoqIFRha2UgdGhlIGN1cnJlbnQgZmlsdGVyIGlucHV0IHZhbHVlIGFuZCBhcHBseSB0aGUgZmlsdGVyICovXG4gICAgcHJpdmF0ZSBfdXBkYXRlRmlsdGVyKCkge1xuICAgICAgICB2YXIgdGVybXMgPSB0aGlzLmZpbHRlclRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXlxcd1xcc1xcLl0rLywgXCIgXCIpLnRyaW0oKVxuICAgICAgICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgICAgICAgIC5maWx0ZXIocyA9PiAhIXMpO1xuXG4gICAgICAgIC8vIHNldCB0ZXJtcyBvbmx5IGlmIGFueSBmb3VuZFxuICAgICAgICB0aGlzLmZpbHRlclRlcm1zID0gdGVybXMuc29tZShzID0+IHMubGVuZ3RoID4gMikgP1xuICAgICAgICAgICAgdGVybXMgOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5VSS5ET00uYXBwbHlTdHlsZXNoZWV0KHtcbiAgICBcIi50b2NfdHJlZSA+IC5VSS1Sb3dcIjoge1xuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfSxcbiAgICBcIi50b2NfdHJlZSBbc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgY3Vyc29yOiBcImRlZmF1bHRcIlxuICAgIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9kb2NzLXZpZXdlci9UT0NWaWV3LnRzIiwiaW1wb3J0IHsgVUkgfSBmcm9tIFwiQHR5cGVzY2VuZS9kb21cIjtcblxuLy8gYXBwbHkgc3R5bGUgZGlyZWN0bHkgdG8gdGhlIGJvZHkgZWxlbWVudFxuVUkuU2NyZWVuLnJlYWR5LnRoZW4oKCkgPT4ge1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuYmFja2dyb3VuZCA9IFwiI2ZmZlwiO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tYXJnaW4gPSBcIjBcIjtcbn0pOyAgICBcblxuLy8gQXBwbHkgc3R5bGUgc2hlZXQgKGNvcGllZCBmcm9tIENTUy4uLiBUT0RPOiBtYWtlIHRoaXMgbGVzcyBtZXNzeSlcblVJLkRPTS5hcHBseVN0eWxlc2hlZXQoe1xuICAgIFwiaDFcIjoge1xuICAgICAgICBmb250U2l6ZTogXCIzLjhyZW1cIixcbiAgICAgICAgZm9udFdlaWdodDogXCI2MDBcIlxuICAgIH0sXG4gICAgXCJoMlwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjIuMjVyZW1cIixcbiAgICAgICAgZm9udFdlaWdodDogXCI2MDBcIlxuICAgIH0sXG4gICAgXCJoM1wiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjEuNXJlbVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcIjYwMFwiLFxuICAgICAgICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiLFxuICAgICAgICBtYXJnaW46IFwiMi41cmVtIDAgMXJlbVwiXG4gICAgfSxcbiAgICBcImg0XCI6IHtcbiAgICAgICAgZm9udFNpemU6IFwiMS4xMjVyZW1cIixcbiAgICAgICAgZm9udFdlaWdodDogXCI2MDBcIixcbiAgICAgICAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgICBwYWRkaW5nOiBcIjBcIixcbiAgICAgICAgbWFyZ2luOiBcIjEuNXJlbSAwIC41cmVtXCJcbiAgICB9LFxuICAgIFwiaDVcIjoge1xuICAgICAgICBmb250U2l6ZTogXCIuODVyZW1cIixcbiAgICAgICAgZm9udFdlaWdodDogXCI2MDBcIixcbiAgICAgICAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgICB0ZXh0VHJhbnNmb3JtOiBcInVwcGVyY2FzZVwiLFxuICAgICAgICBtYXJnaW46IFwiMS43NXJlbSAwIC43NXJlbVwiXG4gICAgfSxcbiAgICBcIi5mYVwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIi44NzVlbVwiICAvLyAxNnB4ICgxcmVtKSA9PiAxNHB4IG5hdGl2ZSBzaXplXG4gICAgfSxcbiAgICBcImNvZGVcIjoge1xuICAgICAgICBmb250RmFtaWx5OiBcIk1lbmxvLE1vbmFjbyxDb25zb2xhcyxcXFwiTGliZXJhdGlvbiBNb25vXFxcIixcXFwiQ291cmllciBOZXdcXFwiLG1vbm9zcGFjZVwiLFxuICAgICAgICBmb250U2l6ZTogXCIuOGVtXCJcbiAgICB9LFxuICAgIFwiLmRvYy1jb2RlXCI6IHtcbiAgICAgICAgY29sb3I6IFwiIzYzZVwiXG4gICAgfSxcbiAgICBcIi5kb2MtY29kZSA+IGNvZGVcIjoge1xuICAgICAgICBsaW5lSGVpZ2h0OiBcIjEuNWVtXCIsXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC1hcnRpY2xlIC5mYTpmaXJzdC1jaGlsZFwiOiB7XG4gICAgICAgIHBhZGRpbmdSaWdodDogXCIuNXJlbVwiXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC1hcnRpY2xlIGEsIC5kb2MtdGV4dC1hcnRpY2xlIGE6dmlzaXRlZFwiOiB7XG4gICAgICAgIGNvbG9yOiBcIiMzOWVcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtYXJ0aWNsZSBhID4gLmZhXCI6IHtcbiAgICAgICAgY29sb3I6IFwiIzMzMyAhaW1wb3J0YW50XCIsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtYXJ0aWNsZSBjb2RlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCJyZ2JhKDAsNjQsMTI4LC4wNSlcIixcbiAgICAgICAgcGFkZGluZzogXCIuMTI1cmVtXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIycHhcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtYXJ0aWNsZSBwcmVcIjoge1xuICAgICAgICBmb250U2l6ZTogXCIxcmVtXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwicmdiYSgwLDY0LDEyOCwuMDUpXCIsXG4gICAgICAgIGJvcmRlclRvcDogXCIycHggc29saWQgcmdiYSgwLDY0LDEyOCwuMilcIixcbiAgICAgICAgcGFkZGluZzogXCIuNzVyZW0gLjVyZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjFyZW0gMFwiLFxuICAgICAgICBjb2xvcjogXCIjNTU1XCIsXG4gICAgICAgIG92ZXJmbG93OiBcImF1dG9cIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtYXJ0aWNsZSBwcmUgPiBjb2RlXCI6IHtcbiAgICAgICAgbGluZUhlaWdodDogXCIxLjVlbVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlICFpbXBvcnRhbnRcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtYXJ0aWNsZSBibG9ja3F1b3RlXCI6IHtcbiAgICAgICAgZm9udFNpemU6IFwiaW5oZXJpdFwiLFxuICAgICAgICBib3JkZXJDb2xvcjogXCIjZTgwXCJcbiAgICB9LFxuICAgIFwiLmRvYy10ZXh0LWFydGljbGUgcCwgLmRvYy10ZXh0LWFydGljbGUgbGksIC5kb2MtdGV4dC1hcnRpY2xlIGRsXCI6IHtcbiAgICAgICAgbGluZUhlaWdodDogXCIxLjY1ZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjAgMCAxcmVtXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC1hcnRpY2xlIGR0XCI6IHtcbiAgICAgICAgbWFyZ2luOiBcIjFyZW0gMCAwXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiLFxuICAgICAgICBmb250U2l6ZTogXCIxLjJyZW1cIixcbiAgICAgICAgZm9udFdlaWdodDogXCIzMDBcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtYXJ0aWNsZSBkdCBjb2RlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC1hcnRpY2xlIGR0IC5mYVwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjE0cHhcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtYXJ0aWNsZSBkZFwiOiB7XG4gICAgICAgIG1hcmdpbjogXCIuMjVyZW0gMCAuNzVyZW1cIixcbiAgICAgICAgcGFkZGluZzogXCIwIDAgLjVyZW0gMi44cmVtXCJcbiAgICB9LFxuICAgIFwiLmRvYy10ZXh0LWFydGljbGUgbGlcIjoge1xuICAgICAgICBtYXJnaW46IFwiLjI1cmVtIDBcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtYXJ0aWNsZSBoMy5kb2MtaGVhZGluZy1zZWN0aW9uXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIuNzVyZW0gMFwiLFxuICAgICAgICBib3JkZXJUb3A6IFwiMXB4IHNvbGlkIHJnYmEoMCwwLDAsLjE1KVwiXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC1hcnRpY2xlIGhyXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIjBcIixcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCByZ2JhKDAsMCwwLC4yKVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjBcIixcbiAgICAgICAgbWFyZ2luOiBcIjJyZW0gLTFyZW1cIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtdHlwZS1pbnRyb1wiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjEuMjVyZW1cIixcbiAgICAgICAgZm9udFdlaWdodDogXCIzMDBcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtdHlwZS1ub3RlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCJyZ2JhKDIyMCwxNjAsNjQsLjA4KVwiLFxuICAgICAgICBib3JkZXJUb3A6IFwiMnB4IHNvbGlkIHJnYmEoMCwwLDAsLjIpXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiLjVyZW0gMXJlbVwiLFxuICAgICAgICBtYXJnaW46IFwiMS41cmVtIDBcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtdHlwZS1ub3RlID4gOmZpcnN0LWNoaWxkXCI6IHtcbiAgICAgICAgbWFyZ2luVG9wOiBcIi41cmVtXCJcbiAgICB9LFxuICAgIFwiLmRvYy10ZXh0LXR5cGUtbm90ZSBwcmVcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgIGJvcmRlcjogXCIwXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMFwiXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC10eXBlLWV4YW1wbGVcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcInJnYmEoMCw2NCwxMjgsLjA1KVwiLFxuICAgICAgICBwYWRkaW5nOiBcIi41cmVtIDFyZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjEuNXJlbSAwXCJcbiAgICB9LFxuICAgIFwiLmRvYy10ZXh0LXR5cGUtZXhhbXBsZSBwcmVcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgIGJvcmRlcjogXCIwXCJcbiAgICB9LFxuICAgIFwiLmRvYy10ZXh0LXR5cGUtZXhhbXBsZSA+IGgzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNjY2XCIsXG4gICAgICAgIGNvbG9yOiBcIiNmZmZcIixcbiAgICAgICAgdGV4dFRyYW5zZm9ybTogXCJ1cHBlcmNhc2VcIixcbiAgICAgICAgZm9udFNpemU6IFwiLjhlbVwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiBcIjEuNzVlbVwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yNXJlbSAxcmVtXCIsXG4gICAgICAgIG1hcmdpbjogXCItLjVyZW0gLTFyZW0gMXJlbSAtMXJlbVwiXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC10eXBlLWV4YW1wbGUgPiBoMzpsYXN0LWNoaWxkXCI6IHtcbiAgICAgICAgbWFyZ2luQm90dG9tOiBcIi0uNXJlbVwiXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC10eXBlLWV4YW1wbGUgPiBwcmVcIjoge1xuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0uNjVyZW1cIixcbiAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLS42NXJlbVwiXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC10eXBlLWV4YW1wbGUgPiBoMyArIHByZVwiOiB7XG4gICAgICAgIG1hcmdpbjogXCItMXJlbSAtMXJlbSAxcmVtXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIwXCIsXG4gICAgICAgIHBhZGRpbmdMZWZ0OiBcIi43NXJlbVwiXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC10eXBlLWV4YW1wbGUgPiBwcmU6Zmlyc3QtY2hpbGRcIjoge1xuICAgICAgICBib3JkZXJUb3A6IFwiMnB4IHNvbGlkIHJnYmEoMCw2NCwxMjgsLjIpXCIsXG4gICAgICAgIG1hcmdpbjogXCItLjVyZW0gLTFyZW0gMXJlbVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiMFwiLFxuICAgICAgICBwYWRkaW5nTGVmdDogXCIuNzVyZW1cIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtdHlwZS1leGFtcGxlID4gcHJlOmZpcnN0LWNoaWxkICsgLmRvYy10ZXh0LWV4YW1wbGUtb3V0cHV0XCI6IHtcbiAgICAgICAgbWFyZ2luVG9wOiBcIi0xcmVtICFpbXBvcnRhbnRcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtZXhhbXBsZS1vdXRwdXRcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrICFpbXBvcnRhbnRcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiYXV0byAhaW1wb3J0YW50XCIsXG4gICAgICAgIHdpZHRoOiBcImF1dG8gIWltcG9ydGFudFwiLFxuICAgICAgICBtYXJnaW46IFwiMCAtMXJlbSAtLjVyZW0gIWltcG9ydGFudFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNmZmZcIlxuICAgIH0sXG4gICAgXCIuZG9jLXRleHQtdHlwZS1leGFtcGxlID4gaDMgKyBwcmUgKyAuZG9jLXRleHQtZXhhbXBsZS1vdXRwdXRcIjoge1xuICAgICAgICBtYXJnaW5Ub3A6IFwiLTFyZW0gIWltcG9ydGFudFwiXG4gICAgfSxcbiAgICBcIi5kb2MtdGV4dC1leGFtcGxlLWJ5bGluZSwgLmRvYy10ZXh0LWV4YW1wbGUtYnlsaW5lIGJ1dHRvblwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIi43NXJlbVwiLFxuICAgICAgICB0ZXh0VHJhbnNmb3JtOiBcInVwcGVyY2FzZSAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiNjAwXCIsXG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggZG90dGVkICNjY2NcIlxuICAgIH0sXG4gICAgXCIudG9jX3RyZWVcIjoge1xuICAgICAgICBjb2xvcjogXCIjNDQ0XCJcbiAgICB9LFxuICAgIFwiLnRvY190cmVlIGRpdlwiOiB7XG4gICAgICAgIG91dGxpbmU6IFwiMFwiXG4gICAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2RvY3Mtdmlld2VyL3N0eWxlLnRzIiwiLy8gU2ltcGxlIHZpZXdlciBmb3IgVHlwZXNjZW5lIEFQSSBkb2N1bWVudGF0aW9uXG5cbmltcG9ydCB7IEFwcCwgQXN5bmMsIFVJIH0gZnJvbSBcIkB0eXBlc2NlbmUvZG9tXCI7XG5pbXBvcnQgXCIuL0RvY3VtZW50U2VydmljZVwiO1xuaW1wb3J0IFwiLi9NYWluQWN0aXZpdHlcIjtcbmltcG9ydCBcIi4vTWFpblZpZXdcIjtcbmltcG9ydCBcIi4vRG9jQWN0aXZpdHlcIjtcbmltcG9ydCBcIi4vRG9jVmlld1wiO1xuaW1wb3J0IFwiLi9UT0NWaWV3XCI7XG5cbm5ldyBBcHAuRE9NQXBwbGljYXRpb24oXCJEb2N1bWVudGF0aW9uXCIpO1xuVUkuRE9NLlN0eWxlcy5mb250LmZhbWlseSA9IFwiXFxcIlNvdXJjZSBTYW5zIFByb1xcXCIsIHNhbnMtc2VyaWZcIjtcblxuLy8gRG8gbm90IHVzZSBwcmVkZWZpbmVkIGhlYWRpbmcgc3R5bGVzIGJ1dCB0YWtlIHRoZW0gZnJvbSBDU1NcblVJLkRPTS5TdHlsZXMucmVib290U3R5bGVzLnJlbW92ZShcImgxLGgyLGgzLGg0LGg1LGg2XCIpO1xuVUkuRE9NLlN0eWxlcy5yZWJvb3RTdHlsZXMucmVtb3ZlKC9eaFxcZCQvKTtcbmltcG9ydCBcIi4vc3R5bGVcIjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZG9jcy12aWV3ZXIvbWFpbi50cyJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDelNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcmhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDellBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BHQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvR0E7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pWQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0NBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNYQTtBQXVGQTtBQUdBO0FBQUE7QUFEQTtBQUFBO0FBaUJBO0FBRUE7QUFFQTtBQUNBO0FBeUlBO0FBQ0E7O0FBQ0E7QUFoS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBOUhBO0FBREE7QUFDQTtBQWxCQTtBQURBO0FBQ0E7QUFnS0E7O0FBQUE7QUFoS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRkE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBaUJBO0FBRUE7QUFFQTtBQUVBO0FBckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFEQTtBQUNBO0FBSUE7QUFEQTtBQUNBO0FBSUE7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQXpCQTtBQTJCQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFHQTtBQURBO0FBQ0E7QUFkQTtBQUhBO0FBQ0E7QUFDQTtBQUNBO0FBZUE7QUFBQTtBQWZBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFHQTtBQUFBO0FBdURBO0FBQUE7QUFBQTs7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUdBO0FBSEE7QUFEQTtBQUNBO0FBR0E7QUFEQTtBQUNBO0FBckRBO0FBREE7QUFDQTtBQWtFQTtBQUFBO0FBN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0pBO0FBRUE7QUFHQTtBQUFBO0FBQUE7O0FBRUE7QUFGQTtBQURBO0FBQ0E7QUFFQTtBQUFBO0FBSUE7QUFBQTtBQUZBO0FBQUE7QUE2REE7O0FBQ0E7QUEzREE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBREE7QUFDQTtBQWVBO0FBREE7QUFDQTtBQXpEQTtBQUZBO0FBQ0E7QUFDQTtBQTREQTtBQUFBO0FBNURBOzs7Ozs7Ozs7QUNYQTtBQUNBO0FBSUE7QUFLQTtBQUNBO0FBK0JBO0FBQ0E7QUFBQTtBQUFBO0FBNkJBO0FBRUE7QUE5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXhCQTtBQURBO0FBQ0E7QUEyQkE7QUFBQTtBQTFGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFKQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQXdCQTtBQUNBO0FBdkJBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUFBO0FBOEVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQURBO0FBQ0E7QUFVQTtBQUFBO0FBcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2UkE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTs7QUFZQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFWQTs7QUF3QkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBL1FBO0FBaVJBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFHQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTtBQXlCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUF1RUE7QUFFQTtBQXRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFEQTtBQUNBO0FBT0E7QUFEQTtBQUNBO0FBQ0E7QUFBQTtBQWxHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdGJBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQXlDQTtBQUFBO0FBQUE7O0FBRUE7QUFHQTtBQUFBOzs7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBOzs7QUFBQTtBQUxBO0FBREE7QUFDQTtBQUdBO0FBREE7QUFHQTtBQW5EQTtBQURBO0FBQ0E7QUFvREE7QUFBQTtBQWxEQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFKQTtBQU1BO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5Q0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBNkVBO0FBQUE7QUFBQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFqSEE7QUFEQTtBQUNBO0FBR0E7QUFEQTtBQUNBO0FBR0E7QUFEQTtBQUNBO0FBR0E7QUFEQTtBQUNBO0FBM0VBO0FBREE7QUFDQTtBQW9MQTtBQUFBO0FBbkxBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9EQTtBQXNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2TUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ })
/******/ ]);